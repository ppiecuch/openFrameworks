/* Thu Sep 13 21:25:26 CEST 2018 */
#pragma once
#define TARGET_QT

#line 0 "ext/utf8.h"
// Copyright 2006 Nemanja Trifunovic

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


#ifndef UTF8_FOR_CPP_CORE_H_2675DCD0_9480_4c0c_B92A_CC14C027B731
#define UTF8_FOR_CPP_CORE_H_2675DCD0_9480_4c0c_B92A_CC14C027B731

#include <iterator>

namespace utf8
{
    // The typedefs for 8-bit, 16-bit and 32-bit unsigned integers
    // You may need to change them to match your system.
    // These typedefs have the same names as ones from cstdint, or boost/cstdint
    typedef unsigned char   uint8_t;
    typedef unsigned short  uint16_t;
    typedef unsigned int    uint32_t;

// Helper code - not intended to be directly called by the library users. May be changed at any time
namespace internal
{
    // Unicode constants
    // Leading (high) surrogates: 0xd800 - 0xdbff
    // Trailing (low) surrogates: 0xdc00 - 0xdfff
    const uint16_t LEAD_SURROGATE_MIN  = 0xd800u;
    const uint16_t LEAD_SURROGATE_MAX  = 0xdbffu;
    const uint16_t TRAIL_SURROGATE_MIN = 0xdc00u;
    const uint16_t TRAIL_SURROGATE_MAX = 0xdfffu;
    const uint16_t LEAD_OFFSET         = LEAD_SURROGATE_MIN - (0x10000 >> 10);
    const uint32_t SURROGATE_OFFSET    = 0x10000u - (LEAD_SURROGATE_MIN << 10) - TRAIL_SURROGATE_MIN;

    // Maximum valid value for a Unicode code point
    const uint32_t CODE_POINT_MAX      = 0x0010ffffu;

    template<typename octet_type>
    inline uint8_t mask8(octet_type oc)
    {
        return static_cast<uint8_t>(0xff & oc);
    }
    template<typename u16_type>
    inline uint16_t mask16(u16_type oc)
    {
        return static_cast<uint16_t>(0xffff & oc);
    }
    template<typename octet_type>
    inline bool is_trail(octet_type oc)
    {
        return ((utf8::internal::mask8(oc) >> 6) == 0x2);
    }

    template <typename u16>
    inline bool is_lead_surrogate(u16 cp)
    {
        return (cp >= LEAD_SURROGATE_MIN && cp <= LEAD_SURROGATE_MAX);
    }

    template <typename u16>
    inline bool is_trail_surrogate(u16 cp)
    {
        return (cp >= TRAIL_SURROGATE_MIN && cp <= TRAIL_SURROGATE_MAX);
    }

    template <typename u16>
    inline bool is_surrogate(u16 cp)
    {
        return (cp >= LEAD_SURROGATE_MIN && cp <= TRAIL_SURROGATE_MAX);
    }

    template <typename u32>
    inline bool is_code_point_valid(u32 cp)
    {
        return (cp <= CODE_POINT_MAX && !utf8::internal::is_surrogate(cp));
    }

    template <typename octet_iterator>
    inline typename std::iterator_traits<octet_iterator>::difference_type
    sequence_length(octet_iterator lead_it)
    {
        uint8_t lead = utf8::internal::mask8(*lead_it);
        if (lead < 0x80)
            return 1;
        else if ((lead >> 5) == 0x6)
            return 2;
        else if ((lead >> 4) == 0xe)
            return 3;
        else if ((lead >> 3) == 0x1e)
            return 4;
        else
            return 0;
    }

    template <typename octet_difference_type>
    inline bool is_overlong_sequence(uint32_t cp, octet_difference_type length)
    {
        if (cp < 0x80) {
            if (length != 1) 
                return true;
        }
        else if (cp < 0x800) {
            if (length != 2) 
                return true;
        }
        else if (cp < 0x10000) {
            if (length != 3) 
                return true;
        }

        return false;
    }

    enum utf_error {UTF8_OK, NOT_ENOUGH_ROOM, INVALID_LEAD, INCOMPLETE_SEQUENCE, OVERLONG_SEQUENCE, INVALID_CODE_POINT};

    /// Helper for get_sequence_x
    template <typename octet_iterator>
    utf_error increase_safely(octet_iterator& it, octet_iterator end)
    {
        if (++it == end)
            return NOT_ENOUGH_ROOM;

        if (!utf8::internal::is_trail(*it))
            return INCOMPLETE_SEQUENCE;
        
        return UTF8_OK;
    }

    #define UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(IT, END) {utf_error ret = increase_safely(IT, END); if (ret != UTF8_OK) return ret;}    

    /// get_sequence_x functions decode utf-8 sequences of the length x
    template <typename octet_iterator>
    utf_error get_sequence_1(octet_iterator& it, octet_iterator end, uint32_t& code_point)
    {
        if (it == end)
            return NOT_ENOUGH_ROOM;

        code_point = utf8::internal::mask8(*it);

        return UTF8_OK;
    }

    template <typename octet_iterator>
    utf_error get_sequence_2(octet_iterator& it, octet_iterator end, uint32_t& code_point)
    {
        if (it == end) 
            return NOT_ENOUGH_ROOM;
        
        code_point = utf8::internal::mask8(*it);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

        code_point = ((code_point << 6) & 0x7ff) + ((*it) & 0x3f);

        return UTF8_OK;
    }

    template <typename octet_iterator>
    utf_error get_sequence_3(octet_iterator& it, octet_iterator end, uint32_t& code_point)
    {
        if (it == end)
            return NOT_ENOUGH_ROOM;
            
        code_point = utf8::internal::mask8(*it);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

        code_point = ((code_point << 12) & 0xffff) + ((utf8::internal::mask8(*it) << 6) & 0xfff);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

        code_point += (*it) & 0x3f;

        return UTF8_OK;
    }

    template <typename octet_iterator>
    utf_error get_sequence_4(octet_iterator& it, octet_iterator end, uint32_t& code_point)
    {
        if (it == end)
           return NOT_ENOUGH_ROOM;

        code_point = utf8::internal::mask8(*it);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

        code_point = ((code_point << 18) & 0x1fffff) + ((utf8::internal::mask8(*it) << 12) & 0x3ffff);

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

        code_point += (utf8::internal::mask8(*it) << 6) & 0xfff;

        UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

        code_point += (*it) & 0x3f;

        return UTF8_OK;
    }

    #undef UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR

    template <typename octet_iterator>
    utf_error validate_next(octet_iterator& it, octet_iterator end, uint32_t& code_point)
    {
        // Save the original value of it so we can go back in case of failure
        // Of course, it does not make much sense with i.e. stream iterators
        octet_iterator original_it = it;

        uint32_t cp = 0;
        // Determine the sequence length based on the lead octet
        typedef typename std::iterator_traits<octet_iterator>::difference_type octet_difference_type;
        const octet_difference_type length = utf8::internal::sequence_length(it);

        // Get trail octets and calculate the code point
        utf_error err = UTF8_OK;
        switch (length) {
            case 0: 
                return INVALID_LEAD;
            case 1:
                err = utf8::internal::get_sequence_1(it, end, cp);
                break;
            case 2:
                err = utf8::internal::get_sequence_2(it, end, cp);
            break;
            case 3:
                err = utf8::internal::get_sequence_3(it, end, cp);
            break;
            case 4:
                err = utf8::internal::get_sequence_4(it, end, cp);
            break;
        }

        if (err == UTF8_OK) {
            // Decoding succeeded. Now, security checks...
            if (utf8::internal::is_code_point_valid(cp)) {
                if (!utf8::internal::is_overlong_sequence(cp, length)){
                    // Passed! Return here.
                    code_point = cp;
                    ++it;
                    return UTF8_OK;
                }
                else
                    err = OVERLONG_SEQUENCE;
            }
            else 
                err = INVALID_CODE_POINT;
        }

        // Failure branch - restore the original value of the iterator
        it = original_it;
        return err;
    }

    template <typename octet_iterator>
    inline utf_error validate_next(octet_iterator& it, octet_iterator end) {
        uint32_t ignored;
        return utf8::internal::validate_next(it, end, ignored);
    }

} // namespace internal

    /// The library API - functions intended to be called by the users

    // Byte order mark
    const uint8_t bom[] = {0xef, 0xbb, 0xbf};

    template <typename octet_iterator>
    octet_iterator find_invalid(octet_iterator start, octet_iterator end)
    {
        octet_iterator result = start;
        while (result != end) {
            utf8::internal::utf_error err_code = utf8::internal::validate_next(result, end);
            if (err_code != internal::UTF8_OK)
                return result;
        }
        return result;
    }

    template <typename octet_iterator>
    inline bool is_valid(octet_iterator start, octet_iterator end)
    {
        return (utf8::find_invalid(start, end) == end);
    }

    template <typename octet_iterator>
    inline bool starts_with_bom (octet_iterator it, octet_iterator end)
    {
        return (
            ((it != end) && (utf8::internal::mask8(*it++)) == bom[0]) &&
            ((it != end) && (utf8::internal::mask8(*it++)) == bom[1]) &&
            ((it != end) && (utf8::internal::mask8(*it))   == bom[2])
           );
    }
	
    //Deprecated in release 2.3 
    template <typename octet_iterator>
    inline bool is_bom (octet_iterator it)
    {
        return (
            (utf8::internal::mask8(*it++)) == bom[0] &&
            (utf8::internal::mask8(*it++)) == bom[1] &&
            (utf8::internal::mask8(*it))   == bom[2]
           );
    }
} // namespace utf8

#endif // header guard


// Copyright 2006 Nemanja Trifunovic

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


#ifndef UTF8_FOR_CPP_CHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731
#define UTF8_FOR_CPP_CHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731

#include <stdexcept>

namespace utf8
{
    // Base for the exceptions that may be thrown from the library
    class exception : public ::std::exception {
    };

    // Exceptions that may be thrown from the library functions.
    class invalid_code_point : public exception {
        uint32_t cp;
    public:
        invalid_code_point(uint32_t cp) : cp(cp) {}
        virtual const char* what() const throw() { return "Invalid code point"; }
        uint32_t code_point() const {return cp;}
    };

    class invalid_utf8 : public exception {
        uint8_t u8;
    public:
        invalid_utf8 (uint8_t u) : u8(u) {}
        virtual const char* what() const throw() { return "Invalid UTF-8"; }
        uint8_t utf8_octet() const {return u8;}
    };

    class invalid_utf16 : public exception {
        uint16_t u16;
    public:
        invalid_utf16 (uint16_t u) : u16(u) {}
        virtual const char* what() const throw() { return "Invalid UTF-16"; }
        uint16_t utf16_word() const {return u16;}
    };

    class not_enough_room : public exception {
    public:
        virtual const char* what() const throw() { return "Not enough space"; }
    };

    /// The library API - functions intended to be called by the users

    template <typename octet_iterator>
    octet_iterator append(uint32_t cp, octet_iterator result)
    {
        if (!utf8::internal::is_code_point_valid(cp))
            throw invalid_code_point(cp);

        if (cp < 0x80)                        // one octet
            *(result++) = static_cast<uint8_t>(cp);
        else if (cp < 0x800) {                // two octets
            *(result++) = static_cast<uint8_t>((cp >> 6)            | 0xc0);
            *(result++) = static_cast<uint8_t>((cp & 0x3f)          | 0x80);
        }
        else if (cp < 0x10000) {              // three octets
            *(result++) = static_cast<uint8_t>((cp >> 12)           | 0xe0);
            *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f)   | 0x80);
            *(result++) = static_cast<uint8_t>((cp & 0x3f)          | 0x80);
        }
        else {                                // four octets
            *(result++) = static_cast<uint8_t>((cp >> 18)           | 0xf0);
            *(result++) = static_cast<uint8_t>(((cp >> 12) & 0x3f)  | 0x80);
            *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f)   | 0x80);
            *(result++) = static_cast<uint8_t>((cp & 0x3f)          | 0x80);
        }
        return result;
    }

    template <typename octet_iterator, typename output_iterator>
    output_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out, uint32_t replacement)
    {
        while (start != end) {
            octet_iterator sequence_start = start;
            internal::utf_error err_code = utf8::internal::validate_next(start, end);
            switch (err_code) {
                case internal::UTF8_OK :
                    for (octet_iterator it = sequence_start; it != start; ++it)
                        *out++ = *it;
                    break;
                case internal::NOT_ENOUGH_ROOM:
                    throw not_enough_room();
                case internal::INVALID_LEAD:
                    out = utf8::append (replacement, out);
                    ++start;
                    break;
                case internal::INCOMPLETE_SEQUENCE:
                case internal::OVERLONG_SEQUENCE:
                case internal::INVALID_CODE_POINT:
                    out = utf8::append (replacement, out);
                    ++start;
                    // just one replacement mark for the sequence
                    while (start != end && utf8::internal::is_trail(*start))
                        ++start;
                    break;
            }
        }
        return out;
    }

    template <typename octet_iterator, typename output_iterator>
    inline output_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out)
    {
        static const uint32_t replacement_marker = utf8::internal::mask16(0xfffd);
        return utf8::replace_invalid(start, end, out, replacement_marker);
    }

    template <typename octet_iterator>
    uint32_t next(octet_iterator& it, octet_iterator end)
    {
        uint32_t cp = 0;
        internal::utf_error err_code = utf8::internal::validate_next(it, end, cp);
        switch (err_code) {
            case internal::UTF8_OK :
                break;
            case internal::NOT_ENOUGH_ROOM :
                throw not_enough_room();
            case internal::INVALID_LEAD :
            case internal::INCOMPLETE_SEQUENCE :
            case internal::OVERLONG_SEQUENCE :
                throw invalid_utf8(*it);
            case internal::INVALID_CODE_POINT :
                throw invalid_code_point(cp);
        }
        return cp;
    }

    template <typename octet_iterator>
    uint32_t peek_next(octet_iterator it, octet_iterator end)
    {
        return utf8::next(it, end);
    }

    template <typename octet_iterator>
    uint32_t prior(octet_iterator& it, octet_iterator start)
    {
        // can't do much if it == start
        if (it == start)
            throw not_enough_room();

        octet_iterator end = it;
        // Go back until we hit either a lead octet or start
        while (utf8::internal::is_trail(*(--it)))
            if (it == start)
                throw invalid_utf8(*it); // error - no lead byte in the sequence
        return utf8::peek_next(it, end);
    }

    /// Deprecated in versions that include "prior"
    template <typename octet_iterator>
    uint32_t previous(octet_iterator& it, octet_iterator pass_start)
    {
        octet_iterator end = it;
        while (utf8::internal::is_trail(*(--it)))
            if (it == pass_start)
                throw invalid_utf8(*it); // error - no lead byte in the sequence
        octet_iterator temp = it;
        return utf8::next(temp, end);
    }

    template <typename octet_iterator, typename distance_type>
    void advance (octet_iterator& it, distance_type n, octet_iterator end)
    {
        for (distance_type i = 0; i < n; ++i)
            utf8::next(it, end);
    }

    template <typename octet_iterator>
    typename std::iterator_traits<octet_iterator>::difference_type
    distance (octet_iterator first, octet_iterator last)
    {
        typename std::iterator_traits<octet_iterator>::difference_type dist;
        for (dist = 0; first < last; ++dist)
            utf8::next(first, last);
        return dist;
    }

    template <typename u16bit_iterator, typename octet_iterator>
    octet_iterator utf16to8 (u16bit_iterator start, u16bit_iterator end, octet_iterator result)
    {
        while (start != end) {
            uint32_t cp = utf8::internal::mask16(*start++);
            // Take care of surrogate pairs first
            if (utf8::internal::is_lead_surrogate(cp)) {
                if (start != end) {
                    uint32_t trail_surrogate = utf8::internal::mask16(*start++);
                    if (utf8::internal::is_trail_surrogate(trail_surrogate))
                        cp = (cp << 10) + trail_surrogate + internal::SURROGATE_OFFSET;
                    else
                        throw invalid_utf16(static_cast<uint16_t>(trail_surrogate));
                }
                else
                    throw invalid_utf16(static_cast<uint16_t>(cp));

            }
            // Lone trail surrogate
            else if (utf8::internal::is_trail_surrogate(cp))
                throw invalid_utf16(static_cast<uint16_t>(cp));

            result = utf8::append(cp, result);
        }
        return result;
    }

    template <typename u16bit_iterator, typename octet_iterator>
    u16bit_iterator utf8to16 (octet_iterator start, octet_iterator end, u16bit_iterator result)
    {
        while (start != end) {
            uint32_t cp = utf8::next(start, end);
            if (cp > 0xffff) { //make a surrogate pair
                *result++ = static_cast<uint16_t>((cp >> 10)   + internal::LEAD_OFFSET);
                *result++ = static_cast<uint16_t>((cp & 0x3ff) + internal::TRAIL_SURROGATE_MIN);
            }
            else
                *result++ = static_cast<uint16_t>(cp);
        }
        return result;
    }

    template <typename octet_iterator, typename u32bit_iterator>
    octet_iterator utf32to8 (u32bit_iterator start, u32bit_iterator end, octet_iterator result)
    {
        while (start != end)
            result = utf8::append(*(start++), result);

        return result;
    }

    template <typename octet_iterator, typename u32bit_iterator>
    u32bit_iterator utf8to32 (octet_iterator start, octet_iterator end, u32bit_iterator result)
    {
        while (start != end)
            (*result++) = utf8::next(start, end);

        return result;
    }

    // The iterator class
    template <typename octet_iterator>
    class iterator : public std::iterator <std::bidirectional_iterator_tag, uint32_t> {
      octet_iterator it;
      octet_iterator range_start;
      octet_iterator range_end;
      public:
      iterator () {}
      explicit iterator (const octet_iterator& octet_it,
                         const octet_iterator& range_start,
                         const octet_iterator& range_end) :
               it(octet_it), range_start(range_start), range_end(range_end)
      {
          if (it < range_start || it > range_end)
              throw std::out_of_range("Invalid utf-8 iterator position");
      }
      // the default "big three" are OK
      octet_iterator base () const { return it; }
      uint32_t operator * () const
      {
          octet_iterator temp = it;
          return utf8::next(temp, range_end);
      }
      bool operator == (const iterator& rhs) const
      {
          if (range_start != rhs.range_start || range_end != rhs.range_end)
              throw std::logic_error("Comparing utf-8 iterators defined with different ranges");
          return (it == rhs.it);
      }
      bool operator != (const iterator& rhs) const
      {
          return !(operator == (rhs));
      }
      iterator& operator ++ ()
      {
          utf8::next(it, range_end);
          return *this;
      }
      iterator operator ++ (int)
      {
          iterator temp = *this;
          utf8::next(it, range_end);
          return temp;
      }
      iterator& operator -- ()
      {
          utf8::prior(it, range_start);
          return *this;
      }
      iterator operator -- (int)
      {
          iterator temp = *this;
          utf8::prior(it, range_start);
          return temp;
      }
    }; // class iterator

} // namespace utf8

#endif //header guard


// Copyright 2006 Nemanja Trifunovic

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


#ifndef UTF8_FOR_CPP_UNCHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731
#define UTF8_FOR_CPP_UNCHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731

namespace utf8
{
    namespace unchecked 
    {
        template <typename octet_iterator>
        octet_iterator append(uint32_t cp, octet_iterator result)
        {
            if (cp < 0x80)                        // one octet
                *(result++) = static_cast<uint8_t>(cp);  
            else if (cp < 0x800) {                // two octets
                *(result++) = static_cast<uint8_t>((cp >> 6)          | 0xc0);
                *(result++) = static_cast<uint8_t>((cp & 0x3f)        | 0x80);
            }
            else if (cp < 0x10000) {              // three octets
                *(result++) = static_cast<uint8_t>((cp >> 12)         | 0xe0);
                *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
                *(result++) = static_cast<uint8_t>((cp & 0x3f)        | 0x80);
            }
            else {                                // four octets
                *(result++) = static_cast<uint8_t>((cp >> 18)         | 0xf0);
                *(result++) = static_cast<uint8_t>(((cp >> 12) & 0x3f)| 0x80);
                *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
                *(result++) = static_cast<uint8_t>((cp & 0x3f)        | 0x80);
            }
            return result;
        }

        template <typename octet_iterator>
        uint32_t next(octet_iterator& it)
        {
            uint32_t cp = utf8::internal::mask8(*it);
            typename std::iterator_traits<octet_iterator>::difference_type length = utf8::internal::sequence_length(it);
            switch (length) {
                case 1:
                    break;
                case 2:
                    it++;
                    cp = ((cp << 6) & 0x7ff) + ((*it) & 0x3f);
                    break;
                case 3:
                    ++it; 
                    cp = ((cp << 12) & 0xffff) + ((utf8::internal::mask8(*it) << 6) & 0xfff);
                    ++it;
                    cp += (*it) & 0x3f;
                    break;
                case 4:
                    ++it;
                    cp = ((cp << 18) & 0x1fffff) + ((utf8::internal::mask8(*it) << 12) & 0x3ffff);                
                    ++it;
                    cp += (utf8::internal::mask8(*it) << 6) & 0xfff;
                    ++it;
                    cp += (*it) & 0x3f; 
                    break;
            }
            ++it;
            return cp;        
        }

        template <typename octet_iterator>
        uint32_t peek_next(octet_iterator it)
        {
            return utf8::unchecked::next(it);    
        }

        template <typename octet_iterator>
        uint32_t prior(octet_iterator& it)
        {
            while (utf8::internal::is_trail(*(--it))) ;
            octet_iterator temp = it;
            return utf8::unchecked::next(temp);
        }

        // Deprecated in versions that include prior, but only for the sake of consistency (see utf8::previous)
        template <typename octet_iterator>
        inline uint32_t previous(octet_iterator& it)
        {
            return utf8::unchecked::prior(it);
        }

        template <typename octet_iterator, typename distance_type>
        void advance (octet_iterator& it, distance_type n)
        {
            for (distance_type i = 0; i < n; ++i)
                utf8::unchecked::next(it);
        }

        template <typename octet_iterator>
        typename std::iterator_traits<octet_iterator>::difference_type
        distance (octet_iterator first, octet_iterator last)
        {
            typename std::iterator_traits<octet_iterator>::difference_type dist;
            for (dist = 0; first < last; ++dist) 
                utf8::unchecked::next(first);
            return dist;
        }

        template <typename u16bit_iterator, typename octet_iterator>
        octet_iterator utf16to8 (u16bit_iterator start, u16bit_iterator end, octet_iterator result)
        {       
            while (start != end) {
                uint32_t cp = utf8::internal::mask16(*start++);
            // Take care of surrogate pairs first
                if (utf8::internal::is_lead_surrogate(cp)) {
                    uint32_t trail_surrogate = utf8::internal::mask16(*start++);
                    cp = (cp << 10) + trail_surrogate + internal::SURROGATE_OFFSET;
                }
                result = utf8::unchecked::append(cp, result);
            }
            return result;         
        }

        template <typename u16bit_iterator, typename octet_iterator>
        u16bit_iterator utf8to16 (octet_iterator start, octet_iterator end, u16bit_iterator result)
        {
            while (start < end) {
                uint32_t cp = utf8::unchecked::next(start);
                if (cp > 0xffff) { //make a surrogate pair
                    *result++ = static_cast<uint16_t>((cp >> 10)   + internal::LEAD_OFFSET);
                    *result++ = static_cast<uint16_t>((cp & 0x3ff) + internal::TRAIL_SURROGATE_MIN);
                }
                else
                    *result++ = static_cast<uint16_t>(cp);
            }
            return result;
        }

        template <typename octet_iterator, typename u32bit_iterator>
        octet_iterator utf32to8 (u32bit_iterator start, u32bit_iterator end, octet_iterator result)
        {
            while (start != end)
                result = utf8::unchecked::append(*(start++), result);

            return result;
        }

        template <typename octet_iterator, typename u32bit_iterator>
        u32bit_iterator utf8to32 (octet_iterator start, octet_iterator end, u32bit_iterator result)
        {
            while (start < end)
                (*result++) = utf8::unchecked::next(start);

            return result;
        }

        // The iterator class
        template <typename octet_iterator>
          class iterator : public std::iterator <std::bidirectional_iterator_tag, uint32_t> { 
            octet_iterator it;
            public:
            iterator () {}
            explicit iterator (const octet_iterator& octet_it): it(octet_it) {}
            // the default "big three" are OK
            octet_iterator base () const { return it; }
            uint32_t operator * () const
            {
                octet_iterator temp = it;
                return utf8::unchecked::next(temp);
            }
            bool operator == (const iterator& rhs) const 
            { 
                return (it == rhs.it);
            }
            bool operator != (const iterator& rhs) const
            {
                return !(operator == (rhs));
            }
            iterator& operator ++ () 
            {
                ::std::advance(it, utf8::internal::sequence_length(it));
                return *this;
            }
            iterator operator ++ (int)
            {
                iterator temp = *this;
                ::std::advance(it, utf8::internal::sequence_length(it));
                return temp;
            }  
            iterator& operator -- ()
            {
                utf8::unchecked::prior(it);
                return *this;
            }
            iterator operator -- (int)
            {
                iterator temp = *this;
                utf8::unchecked::prior(it);
                return temp;
            }
          }; // class iterator

    } // namespace utf8::unchecked
} // namespace utf8 


#endif // header guard


#line 0 "ext/json.hpp"
/*
    __ _____ _____ _____
 __|  |   __|     |   | |  JSON for Modern C++
|  |  |__   |  |  | | | |  version 2.1.1
|_____|_____|_____|_|___|  https://github.com/nlohmann/json

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
Copyright (c) 2013-2017 Niels Lohmann <http://nlohmann.me>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef NLOHMANN_JSON_HPP
#define NLOHMANN_JSON_HPP

#include <algorithm> // all_of, copy, fill, find, for_each, generate_n, none_of, remove, reverse, transform
#include <array> // array
#include <cassert> // assert
#include <ciso646> // and, not, or
#include <clocale> // lconv, localeconv
#include <cmath> // isfinite, labs, ldexp, signbit
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <cstdint> // int64_t, uint64_t
#include <cstdlib> // abort, strtod, strtof, strtold, strtoul, strtoll, strtoull
#include <cstring> // memcpy, strlen
#include <forward_list> // forward_list
#include <functional> // function, hash, less
#include <initializer_list> // initializer_list
#include <iomanip> // hex
#include <iosfwd>   // istream, ostream
#include <iterator> // advance, begin, back_inserter, bidirectional_iterator_tag, distance, end, inserter, iterator, iterator_traits, next, random_access_iterator_tag, reverse_iterator
#include <limits> // numeric_limits
#include <locale> // locale
#include <map> // map
#include <memory> // addressof, allocator, allocator_traits, unique_ptr
#include <numeric> // accumulate
#include <sstream> // stringstream
#include <string> // getline, stoi, string, to_string
#include <type_traits> // add_pointer, conditional, decay, enable_if, false_type, integral_constant, is_arithmetic, is_base_of, is_const, is_constructible, is_convertible, is_default_constructible, is_enum, is_floating_point, is_integral, is_nothrow_move_assignable, is_nothrow_move_constructible, is_pointer, is_reference, is_same, is_scalar, is_signed, remove_const, remove_cv, remove_pointer, remove_reference, true_type, underlying_type
#include <utility> // declval, forward, make_pair, move, pair, swap
#include <valarray> // valarray
#include <vector> // vector

// exclude unsupported compilers
#if defined(__clang__)
    #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
        #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
    #endif
#elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
    #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40900
        #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
    #endif
#endif

// disable float-equal warnings on GCC/clang
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wfloat-equal"
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wdocumentation"
#endif

// allow for portable deprecation warnings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #define JSON_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
    #define JSON_DEPRECATED __declspec(deprecated)
#else
    #define JSON_DEPRECATED
#endif

// allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && not defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
#else
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
#endif

// manual branch prediction
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #define JSON_LIKELY(x)      __builtin_expect(!!(x), 1)
    #define JSON_UNLIKELY(x)    __builtin_expect(!!(x), 0)
#else
    #define JSON_LIKELY(x)      x
    #define JSON_UNLIKELY(x)    x
#endif

// C++ language standard detection
#if (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
    #define JSON_HAS_CPP_17
    #define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
    #define JSON_HAS_CPP_14
#endif

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{
template<typename = void, typename = void>
struct adl_serializer;

// forward declaration of basic_json (required to split the class)
template<template<typename, typename, typename...> class ObjectType = std::map,
         template<typename, typename...> class ArrayType = std::vector,
         class StringType = std::string, class BooleanType = bool,
         class NumberIntegerType = std::int64_t,
         class NumberUnsignedType = std::uint64_t,
         class NumberFloatType = double,
         template<typename> class AllocatorType = std::allocator,
         template<typename, typename = void> class JSONSerializer = adl_serializer>
class basic_json;

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer>


/*!
@brief unnamed namespace with internal helper functions

This namespace collects some functions that could not be defined inside the
@ref basic_json class.

@since version 2.1.0
*/
namespace detail
{
////////////////
// exceptions //
////////////////

/*!
@brief general exception of the @ref basic_json class

This class is an extension of `std::exception` objects with a member @a id for
exception ids. It is used as the base class for all exceptions thrown by the
@ref basic_json class. This class can hence be used as "wildcard" to catch
exceptions.

Subclasses:
- @ref parse_error for exceptions indicating a parse error
- @ref invalid_iterator for exceptions indicating errors with iterators
- @ref type_error for exceptions indicating executing a member function with
                  a wrong type
- @ref out_of_range for exceptions indicating access out of the defined range
- @ref other_error for exceptions indicating other library errors

@internal
@note To have nothrow-copy-constructible exceptions, we internally use
      `std::runtime_error` which can cope with arbitrary-length error messages.
      Intermediate strings are built with static functions and then passed to
      the actual constructor.
@endinternal

@liveexample{The following code shows how arbitrary library exceptions can be
caught.,exception}

@since version 3.0.0
*/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id;

  protected:
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}

    static std::string name(const std::string& ename, int id_)
    {
        return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
};

/*!
@brief exception indicating a parse error

This exception is thrown by the library when a parse error occurs. Parse errors
can occur during the deserialization of JSON text, CBOR, MessagePack, as well
as when using JSON Patch.

Member @a byte holds the byte index of the last read character in the input
file.

Exceptions have ids 1xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.
json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.

@note For an input with n bytes, 1 is the index of the first character and n+1
      is the index of the terminating null byte or the end of file. This also
      holds true when reading a byte vector (CBOR or MessagePack).

@liveexample{The following code shows how a `parse_error` exception can be
caught.,parse_error}

@sa @ref exception for the base class of the library exceptions
@sa @ref invalid_iterator for exceptions indicating errors with iterators
@sa @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa @ref out_of_range for exceptions indicating access out of the defined range
@sa @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] byte_     the byte index where the error occurred (or 0 if the
                         position cannot be determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        (byte_ != 0 ? (" at " + std::to_string(byte_)) : "") +
                        ": " + what_arg;
        return parse_error(id_, byte_, w.c_str());
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}
};

/*!
@brief exception indicating errors with iterators

This exception is thrown if iterators passed to a library function do not match
the expected semantics.

Exceptions have ids 2xx.

name / id                           | example message | description
----------------------------------- | --------------- | -------------------------
json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().

@liveexample{The following code shows how an `invalid_iterator` exception can be
caught.,invalid_iterator}

@sa @ref exception for the base class of the library exceptions
@sa @ref parse_error for exceptions indicating a parse error
@sa @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa @ref out_of_range for exceptions indicating access out of the defined range
@sa @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class invalid_iterator : public exception
{
  public:
    static invalid_iterator create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("invalid_iterator", id_) + what_arg;
        return invalid_iterator(id_, w.c_str());
    }

  private:
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/*!
@brief exception indicating executing a member function with a wrong type

This exception is thrown in case of a type error; that is, a library function is
executed on a JSON value whose type does not match the expected semantics.

Exceptions have ids 3xx.

name / id                     | example message | description
----------------------------- | --------------- | -------------------------
json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t&.
json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |

@liveexample{The following code shows how a `type_error` exception can be
caught.,type_error}

@sa @ref exception for the base class of the library exceptions
@sa @ref parse_error for exceptions indicating a parse error
@sa @ref invalid_iterator for exceptions indicating errors with iterators
@sa @ref out_of_range for exceptions indicating access out of the defined range
@sa @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class type_error : public exception
{
  public:
    static type_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("type_error", id_) + what_arg;
        return type_error(id_, w.c_str());
    }

  private:
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating access out of the defined range

This exception is thrown in case a library function is called on an input
parameter that exceeds the expected range, for instance in case of array
indices or nonexisting object keys.

Exceptions have ids 4xx.

name / id                       | example message | description
------------------------------- | --------------- | -------------------------
json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.

@liveexample{The following code shows how an `out_of_range` exception can be
caught.,out_of_range}

@sa @ref exception for the base class of the library exceptions
@sa @ref parse_error for exceptions indicating a parse error
@sa @ref invalid_iterator for exceptions indicating errors with iterators
@sa @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class out_of_range : public exception
{
  public:
    static out_of_range create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("out_of_range", id_) + what_arg;
        return out_of_range(id_, w.c_str());
    }

  private:
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating other library errors

This exception is thrown in case of errors that cannot be classified with the
other exception types.

Exceptions have ids 5xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.other_error.501 | unsuccessful: {"op":"test","path":"/baz", "value":"bar"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.
json.exception.other_error.502 | invalid object size for conversion | Some conversions to user-defined types impose constraints on the object size (e.g. std::pair)

@sa @ref exception for the base class of the library exceptions
@sa @ref parse_error for exceptions indicating a parse error
@sa @ref invalid_iterator for exceptions indicating errors with iterators
@sa @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa @ref out_of_range for exceptions indicating access out of the defined range

@liveexample{The following code shows how an `other_error` exception can be
caught.,other_error}

@since version 3.0.0
*/
class other_error : public exception
{
  public:
    static other_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("other_error", id_) + what_arg;
        return other_error(id_, w.c_str());
    }

  private:
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};



///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    discarded         ///< discarded by the the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string
- furthermore, each type is not smaller than itself
- discarded values are not comparable

@since version 1.0.0
*/
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    static constexpr std::array<uint8_t, 8> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
    return l_index < order.size() and r_index < order.size() and order[l_index] < order[r_index];
}


/////////////
// helpers //
/////////////

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

// implementation of C++14 index_sequence and affiliates
// source: https://stackoverflow.com/a/32223343
template<std::size_t... Ints>
struct index_sequence
{
    using type = index_sequence;
    using value_type = std::size_t;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

template<class Sequence1, class Sequence2>
struct merge_and_renumber;

template<std::size_t... I1, std::size_t... I2>
struct merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
        : index_sequence < I1..., (sizeof...(I1) + I2)... > {};

template<std::size_t N>
struct make_index_sequence
    : merge_and_renumber < typename make_index_sequence < N / 2 >::type,
      typename make_index_sequence < N - N / 2 >::type > {};

template<> struct make_index_sequence<0> : index_sequence<> {};
template<> struct make_index_sequence<1> : index_sequence<0> {};

template<typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

/*
Implementation of two C++17 constructs: conjunction, negation. This is needed
to avoid evaluating all the traits in a condition

For example: not std::is_same<void, T>::value and has_value_type<T>::value
will not compile when T = void (on MSVC at least). Whereas
conjunction<negation<std::is_same<void, T>>, has_value_type<T>>::value will
stop evaluating if negation<...>::value == false

Please note that those constructs must be used with caution, since symbols can
become very long quickly (which can slow down compilation and cause MSVC
internal compiler errors). Only use it when you have to (see example ahead).
*/
template<class...> struct conjunction : std::true_type {};
template<class B1> struct conjunction<B1> : B1 {};
template<class B1, class... Bn>
struct conjunction<B1, Bn...> : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};

template<class B> struct negation : std::integral_constant<bool, not B::value> {};

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};


//////////////////
// constructors //
//////////////////

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_type = value_t::boolean;
        j.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_type = value_t::string;
        j.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_type = value_t::string;
        j.m_value = std::move(s);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_type = value_t::number_float;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_type = value_t::number_unsigned;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_type = value_t::number_integer;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_type = value_t::array;
        j.m_value = arr;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_type = value_t::array;
        j.m_value = std::move(arr);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleArrayType,
             enable_if_t<not std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                         int> = 0>
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;
        j.m_type = value_t::array;
        j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->reserve(arr.size());
        for (bool x : arr)
        {
            j.m_value.array->push_back(x);
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->resize(arr.size());
        std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_type = value_t::object;
        j.m_value = obj;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_type = value_t::object;
        j.m_value = std::move(obj);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleObjectType,
             enable_if_t<not std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int> = 0>
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_type = value_t::object;
        j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.assert_invariant();
    }
};


////////////////////////
// has_/is_ functions //
////////////////////////

/*!
@brief Helper to determine whether there's a key_type for T.

This helper is used to tell associative containers apart from other containers
such as sequence containers. For instance, `std::map` passes the test as it
contains a `mapped_type`, whereas `std::vector` fails the test.

@sa http://stackoverflow.com/a/7728728/266378
@since version 1.0.0, overworked in version 2.0.6
*/
#define NLOHMANN_JSON_HAS_HELPER(type)                                        \
    template<typename T> struct has_##type {                                  \
    private:                                                                  \
        template<typename U, typename = typename U::type>                     \
        static int detect(U &&);                                              \
        static void detect(...);                                              \
    public:                                                                   \
        static constexpr bool value =                                         \
                std::is_integral<decltype(detect(std::declval<T>()))>::value; \
    }

NLOHMANN_JSON_HAS_HELPER(mapped_type);
NLOHMANN_JSON_HAS_HELPER(key_type);
NLOHMANN_JSON_HAS_HELPER(value_type);
NLOHMANN_JSON_HAS_HELPER(iterator);

#undef NLOHMANN_JSON_HAS_HELPER


template<bool B, class RealType, class CompatibleObjectType>
struct is_compatible_object_type_impl : std::false_type {};

template<class RealType, class CompatibleObjectType>
struct is_compatible_object_type_impl<true, RealType, CompatibleObjectType>
{
    static constexpr auto value =
        std::is_constructible<typename RealType::key_type, typename CompatibleObjectType::key_type>::value and
        std::is_constructible<typename RealType::mapped_type, typename CompatibleObjectType::mapped_type>::value;
};

template<class BasicJsonType, class CompatibleObjectType>
struct is_compatible_object_type
{
    static auto constexpr value = is_compatible_object_type_impl <
                                  conjunction<negation<std::is_same<void, CompatibleObjectType>>,
                                  has_mapped_type<CompatibleObjectType>,
                                  has_key_type<CompatibleObjectType>>::value,
                                  typename BasicJsonType::object_t, CompatibleObjectType >::value;
};

template<typename BasicJsonType, typename T>
struct is_basic_json_nested_type
{
    static auto constexpr value = std::is_same<T, typename BasicJsonType::iterator>::value or
                                  std::is_same<T, typename BasicJsonType::const_iterator>::value or
                                  std::is_same<T, typename BasicJsonType::reverse_iterator>::value or
                                  std::is_same<T, typename BasicJsonType::const_reverse_iterator>::value;
};

template<class BasicJsonType, class CompatibleArrayType>
struct is_compatible_array_type
{
    static auto constexpr value =
        conjunction<negation<std::is_same<void, CompatibleArrayType>>,
        negation<is_compatible_object_type<
        BasicJsonType, CompatibleArrayType>>,
        negation<std::is_constructible<typename BasicJsonType::string_t,
        CompatibleArrayType>>,
        negation<is_basic_json_nested_type<BasicJsonType, CompatibleArrayType>>,
        has_value_type<CompatibleArrayType>,
        has_iterator<CompatibleArrayType>>::value;
};

template<bool, typename, typename>
struct is_compatible_integer_type_impl : std::false_type {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl<true, RealIntegerType, CompatibleNumberIntegerType>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        std::is_constructible<RealIntegerType, CompatibleNumberIntegerType>::value and
        CompatibleLimits::is_integer and
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
{
    static constexpr auto value =
        is_compatible_integer_type_impl <
        std::is_integral<CompatibleNumberIntegerType>::value and
        not std::is_same<bool, CompatibleNumberIntegerType>::value,
        RealIntegerType, CompatibleNumberIntegerType >::value;
};


// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template<typename BasicJsonType, typename T>
struct has_from_json
{
  private:
    // also check the return type of from_json
    template<typename U, typename = enable_if_t<std::is_same<void, decltype(uncvref_t<U>::from_json(
                 std::declval<BasicJsonType>(), std::declval<T&>()))>::value>>
    static int detect(U&&);
    static void detect(...);

  public:
    static constexpr bool value = std::is_integral<decltype(
                                      detect(std::declval<typename BasicJsonType::template json_serializer<T, void>>()))>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template<typename BasicJsonType, typename T>
struct has_non_default_from_json
{
  private:
    template<typename U, typename =
             enable_if_t<std::is_same<T, decltype(uncvref_t<U>::from_json(std::declval<BasicJsonType>()))>::value>>
    static int detect(U&&);
    static void detect(...);

  public:
    static constexpr bool value = std::is_integral<decltype(detect(
                                      std::declval<typename BasicJsonType::template json_serializer<T, void>>()))>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
template<typename BasicJsonType, typename T>
struct has_to_json
{
  private:
    template<typename U, typename = decltype(uncvref_t<U>::to_json(
                 std::declval<BasicJsonType&>(), std::declval<T>()))>
    static int detect(U&&);
    static void detect(...);

  public:
    static constexpr bool value = std::is_integral<decltype(detect(
                                      std::declval<typename BasicJsonType::template json_serializer<T, void>>()))>::value;
};


/////////////
// to_json //
/////////////

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template<typename BasicJsonType, typename CompatibleArrayType,
         enable_if_t<is_compatible_array_type<BasicJsonType, CompatibleArrayType>::value or
                     std::is_same<typename BasicJsonType::array_t, CompatibleArrayType>::value,
                     int> = 0>
void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
void to_json(BasicJsonType& j, std::valarray<T> arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType, typename CompatibleObjectType,
         enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template<typename BasicJsonType, typename T, std::size_t N,
         enable_if_t<not std::is_constructible<typename BasicJsonType::string_t, T (&)[N]>::value, int> = 0>
void to_json(BasicJsonType& j, T (&arr)[N])
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType, typename... Args>
void to_json(BasicJsonType& j, const std::pair<Args...>& p)
{
    j = {p.first, p.second};
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...>)
{
    j = {std::get<Idx>(t)...};
}

template<typename BasicJsonType, typename... Args>
void to_json(BasicJsonType& j, const std::tuple<Args...>& t)
{
    to_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

///////////////
// from_json //
///////////////

// overloads for basic_json template parameters
template<typename BasicJsonType, typename ArithmeticType,
         enable_if_t<std::is_arithmetic<ArithmeticType>::value and
                     not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                     int> = 0>
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_UNLIKELY(not j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name())));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_UNLIKELY(not j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::array_t& arr)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.resize(j.size());
    std::copy(j.m_value.array->begin(), j.m_value.array->end(), std::begin(l));
}

template<typename BasicJsonType, typename CompatibleArrayType>
void from_json_array_impl(const BasicJsonType& j, CompatibleArrayType& arr, priority_tag<0> /*unused*/)
{
    using std::end;

    std::transform(j.begin(), j.end(),
                   std::inserter(arr, end(arr)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename CompatibleArrayType::value_type>();
    });
}

template<typename BasicJsonType, typename CompatibleArrayType>
auto from_json_array_impl(const BasicJsonType& j, CompatibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename CompatibleArrayType::size_type>()),
    void())
{
    using std::end;

    arr.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(arr, end(arr)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename CompatibleArrayType::value_type>();
    });
}

template<typename BasicJsonType, typename T, std::size_t N>
void from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr, priority_tag<2> /*unused*/)
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename CompatibleArrayType,
         enable_if_t<is_compatible_array_type<BasicJsonType, CompatibleArrayType>::value and
                     std::is_convertible<BasicJsonType, typename CompatibleArrayType::value_type>::value and
                     not std::is_same<typename BasicJsonType::array_t, CompatibleArrayType>::value, int> = 0>
void from_json(const BasicJsonType& j, CompatibleArrayType& arr)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }

    from_json_array_impl(j, arr, priority_tag<2> {});
}

template<typename BasicJsonType, typename CompatibleObjectType,
         enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value, int> = 0>
void from_json(const BasicJsonType& j, CompatibleObjectType& obj)
{
    if (JSON_UNLIKELY(not j.is_object()))
    {
        JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name())));
    }

    auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename CompatibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(obj, obj.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename CompatibleObjectType::mapped_type>());
    });
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc..); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template<typename BasicJsonType, typename ArithmeticType,
         enable_if_t <
             std::is_arithmetic<ArithmeticType>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
             int> = 0>
void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType, typename A1, typename A2>
void from_json(const BasicJsonType& j, std::pair<A1, A2>& p)
{
    p = {j.at(0).template get<A1>(), j.at(1).template get<A2>()};
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void from_json_tuple_impl(const BasicJsonType& j, Tuple& t, index_sequence<Idx...>)
{
    t = std::make_tuple(j.at(Idx).template get<typename std::tuple_element<Idx, Tuple>::type>()...);
}

template<typename BasicJsonType, typename... Args>
void from_json(const BasicJsonType& j, std::tuple<Args...>& t)
{
    from_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

struct to_json_fn
{
  private:
    template<typename BasicJsonType, typename T>
    auto call(BasicJsonType& j, T&& val, priority_tag<1> /*unused*/) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }

    template<typename BasicJsonType, typename T>
    void call(BasicJsonType& /*unused*/, T&& /*unused*/, priority_tag<0> /*unused*/) const noexcept
    {
        static_assert(sizeof(BasicJsonType) == 0,
                      "could not find to_json() method in T's namespace");

#ifdef _MSC_VER
        // MSVC does not show a stacktrace for the above assert
        using decayed = uncvref_t<T>;
        static_assert(sizeof(typename decayed::force_msvc_stacktrace) == 0,
                      "forcing MSVC stacktrace to show which T we're talking about.");
#endif
    }

  public:
    template<typename BasicJsonType, typename T>
    void operator()(BasicJsonType& j, T&& val) const
    noexcept(noexcept(std::declval<to_json_fn>().call(j, std::forward<T>(val), priority_tag<1> {})))
    {
        return call(j, std::forward<T>(val), priority_tag<1> {});
    }
};

struct from_json_fn
{
  private:
    template<typename BasicJsonType, typename T>
    auto call(const BasicJsonType& j, T& val, priority_tag<1> /*unused*/) const
    noexcept(noexcept(from_json(j, val)))
    -> decltype(from_json(j, val), void())
    {
        return from_json(j, val);
    }

    template<typename BasicJsonType, typename T>
    void call(const BasicJsonType& /*unused*/, T& /*unused*/, priority_tag<0> /*unused*/) const noexcept
    {
        static_assert(sizeof(BasicJsonType) == 0,
                      "could not find from_json() method in T's namespace");
#ifdef _MSC_VER
        // MSVC does not show a stacktrace for the above assert
        using decayed = uncvref_t<T>;
        static_assert(sizeof(typename decayed::force_msvc_stacktrace) == 0,
                      "forcing MSVC stacktrace to show which T we're talking about.");
#endif
    }

  public:
    template<typename BasicJsonType, typename T>
    void operator()(const BasicJsonType& j, T& val) const
    noexcept(noexcept(std::declval<from_json_fn>().call(j, val, priority_tag<1> {})))
    {
        return call(j, val, priority_tag<1> {});
    }
};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static constexpr T value{};
};

template<typename T>
constexpr T static_const<T>::value;

////////////////////
// input adapters //
////////////////////

/*!
@brief abstract input adapter interface

Produces a stream of std::char_traits<char>::int_type characters from a
std::istream, a buffer, or some other input type.  Accepts the return of exactly
one non-EOF character for future input.  The int_type characters returned
consist of all valid char values as positive values (typically unsigned char),
plus an EOF value outside that range, specified by the value of the function
std::char_traits<char>::eof().  This value is typically -1, but could be any
arbitrary value which is not a valid char value.
*/
struct input_adapter_protocol
{
    /// get a character [0,255] or std::char_traits<char>::eof().
    virtual std::char_traits<char>::int_type get_character() = 0;
    /// restore the last non-eof() character to input
    virtual void unget_character() = 0;
    virtual ~input_adapter_protocol() = default;
};

/// a type to simplify interfaces
using input_adapter_t = std::shared_ptr<input_adapter_protocol>;

/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter : public input_adapter_protocol
{
  public:
    ~input_stream_adapter() override
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags
        is.clear();
    }

    explicit input_stream_adapter(std::istream& i)
        : is(i), sb(*i.rdbuf())
    {
        // skip byte order mark
        std::char_traits<char>::int_type c;
        if ((c = get_character()) == 0xEF)
        {
            if ((c = get_character()) == 0xBB)
            {
                if ((c = get_character()) == 0xBF)
                {
                    return; // Ignore BOM
                }
                else if (c != std::char_traits<char>::eof())
                {
                    is.unget();
                }
                is.putback('\xBB');
            }
            else if (c != std::char_traits<char>::eof())
            {
                is.unget();
            }
            is.putback('\xEF');
        }
        else if (c != std::char_traits<char>::eof())
        {
            is.unget(); // no byte order mark; process as usual
        }
    }

    // delete because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, eg. 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character() override
    {
        return sb.sbumpc();
    }

    void unget_character() override
    {
        sb.sungetc();  // is.unget() avoided for performance
    }

  private:
    /// the associated input stream
    std::istream& is;
    std::streambuf& sb;
};

/// input adapter for buffer input
class input_buffer_adapter : public input_adapter_protocol
{
  public:
    input_buffer_adapter(const char* b, const std::size_t l)
        : cursor(b), limit(b + l), start(b)
    {
        // skip byte order mark
        if (l >= 3 and b[0] == '\xEF' and b[1] == '\xBB' and b[2] == '\xBF')
        {
            cursor += 3;
        }
    }

    // delete because of pointer members
    input_buffer_adapter(const input_buffer_adapter&) = delete;
    input_buffer_adapter& operator=(input_buffer_adapter&) = delete;

    std::char_traits<char>::int_type get_character() noexcept override
    {
        if (JSON_LIKELY(cursor < limit))
        {
            return std::char_traits<char>::to_int_type(*(cursor++));
        }

        return std::char_traits<char>::eof();
    }

    void unget_character() noexcept override
    {
        if (JSON_LIKELY(cursor > start))
        {
            --cursor;
        }
    }

  private:
    /// pointer to the current character
    const char* cursor;
    /// pointer past the last character
    const char* limit;
    /// pointer to the first character
    const char* start;
};

class input_adapter
{
  public:
    // native support

    /// input adapter for input stream
    input_adapter(std::istream& i)
        : ia(std::make_shared<input_stream_adapter>(i)) {}

    /// input adapter for input stream
    input_adapter(std::istream&& i)
        : ia(std::make_shared<input_stream_adapter>(i)) {}

    /// input adapter for buffer
    template<typename CharT,
             typename std::enable_if<
                 std::is_pointer<CharT>::value and
                 std::is_integral<typename std::remove_pointer<CharT>::type>::value and
                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
                 int>::type = 0>
    input_adapter(CharT b, std::size_t l)
        : ia(std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(b), l)) {}

    // derived support

    /// input adapter for string literal
    template<typename CharT,
             typename std::enable_if<
                 std::is_pointer<CharT>::value and
                 std::is_integral<typename std::remove_pointer<CharT>::type>::value and
                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
                 int>::type = 0>
    input_adapter(CharT b)
        : input_adapter(reinterpret_cast<const char*>(b),
                        std::strlen(reinterpret_cast<const char*>(b))) {}

    /// input adapter for iterator range with contiguous storage
    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename std::iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    input_adapter(IteratorType first, IteratorType last)
    {
        // assertion to check that the iterator range is indeed contiguous,
        // see http://stackoverflow.com/a/35008842/266378 for more discussion
        assert(std::accumulate(
                   first, last, std::pair<bool, int>(true, 0),
                   [&first](std::pair<bool, int> res, decltype(*first) val)
        {
            res.first &= (val == *(std::next(std::addressof(*first), res.second++)));
            return res;
        }).first);

        // assertion to check that each element is 1 byte long
        static_assert(
            sizeof(typename std::iterator_traits<IteratorType>::value_type) == 1,
            "each element in the iterator range must have the size of 1 byte");

        const auto len = static_cast<size_t>(std::distance(first, last));
        if (JSON_LIKELY(len > 0))
        {
            // there is at least one element: use the address of first
            ia = std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(&(*first)), len);
        }
        else
        {
            // the address of first cannot be used: use nullptr
            ia = std::make_shared<input_buffer_adapter>(nullptr, len);
        }
    }

    /// input adapter for array
    template<class T, std::size_t N>
    input_adapter(T (&array)[N])
        : input_adapter(std::begin(array), std::end(array)) {}

    /// input adapter for contiguous container
    template<class ContiguousContainer, typename
             std::enable_if<not std::is_pointer<ContiguousContainer>::value and
                            std::is_base_of<std::random_access_iterator_tag, typename std::iterator_traits<decltype(std::begin(std::declval<ContiguousContainer const>()))>::iterator_category>::value,
                            int>::type = 0>
    input_adapter(const ContiguousContainer& c)
        : input_adapter(std::begin(c), std::end(c)) {}

    operator input_adapter_t()
    {
        return ia;
    }

  private:
    /// the actual adapter
    input_adapter_t ia = nullptr;
};

//////////////////////
// lexer and parser //
//////////////////////

/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType>
class lexer
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;

  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case lexer::token_type::value_unsigned:
            case lexer::token_type::value_integer:
            case lexer::token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            default: // catch non-enum values
                return "unknown token"; // LCOV_EXCL_LINE
        }
    }

    explicit lexer(detail::input_adapter_t adapter)
        : ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}

    // delete because of pointer members
    lexer(const lexer&) = delete;
    lexer& operator=(lexer&) = delete;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    static char get_decimal_point() noexcept
    {
        const auto loc = localeconv();
        assert(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        assert(current == 'u');
        int codepoint = 0;

        const auto factors = { 12, 8, 4, 0 };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' and current <= '9')
            {
                codepoint += ((current - 0x30) << factor);
            }
            else if (current >= 'A' and current <= 'F')
            {
                codepoint += ((current - 0x37) << factor);
            }
            else if (current >= 'a' and current <= 'f')
            {
                codepoint += ((current - 0x57) << factor);
            }
            else
            {
                return -1;
            }
        }

        assert(0x0000 <= codepoint and codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<int> ranges)
    {
        assert(ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_LIKELY(*range <= current and current <= *(++range)))
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 7159. While
    scanning, bytes are escaped and copied into buffer yytext. Then the function
    returns successfully, yytext is *not* null-terminated (as it may contain \0
    bytes), and yytext.size() is the number of bytes in the string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset yytext (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        assert(current == '\"');

        while (true)
        {
            // get next character
            switch (get())
            {
                // end of file while parsing string
                case std::char_traits<char>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 and codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_LIKELY(get() == '\\' and get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_LIKELY(0xDC00 <= codepoint2 and codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint =
                                            // high surrogate occupies the most significant 22 bits
                                            (codepoint1 << 10)
                                            // low surrogate occupies the least significant 15 bits
                                            + codepoint2
                                            // there is still the 0xD800, 0xDC00 and 0x10000 noise
                                            // in the result so we have to subtract with:
                                            // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                            - 0x35FDC00;
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_UNLIKELY(0xDC00 <= codepoint1 and codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // result of the above calculation yields a proper codepoint
                            assert(0x00 <= codepoint and codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(codepoint);
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(0xC0 | (codepoint >> 6));
                                add(0x80 | (codepoint & 0x3F));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(0xE0 | (codepoint >> 12));
                                add(0x80 | ((codepoint >> 6) & 0x3F));
                                add(0x80 | (codepoint & 0x3F));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(0xF0 | (codepoint >> 18));
                                add(0x80 | ((codepoint >> 12) & 0x3F));
                                add(0x80 | ((codepoint >> 6) & 0x3F));
                                add(0x80 | (codepoint & 0x3F));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                case 0x01:
                case 0x02:
                case 0x03:
                case 0x04:
                case 0x05:
                case 0x06:
                case 0x07:
                case 0x08:
                case 0x09:
                case 0x0A:
                case 0x0B:
                case 0x0C:
                case 0x0D:
                case 0x0E:
                case 0x0F:
                case 0x10:
                case 0x11:
                case 0x12:
                case 0x13:
                case 0x14:
                case 0x15:
                case 0x16:
                case 0x17:
                case 0x18:
                case 0x19:
                case 0x1A:
                case 0x1B:
                case 0x1C:
                case 0x1D:
                case 0x1E:
                case 0x1F:
                {
                    error_message = "invalid string: control character must be escaped";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_UNLIKELY(not next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 7159.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 7159. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | [error]  | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in yytext. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()
    {
        // reset yytext to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                // all other characters are rejected outside scan_number()
                assert(false); // LCOV_EXCL_LINE
            }
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr;
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
            const auto x = std::strtoull(yytext.data(), &endptr, 10);

            // we checked the number format before
            assert(endptr == yytext.data() + yytext.size());

            if (errno == 0)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
            const auto x = std::strtoll(yytext.data(), &endptr, 10);

            // we checked the number format before
            assert(endptr == yytext.data() + yytext.size());

            if (errno == 0)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, yytext.data(), &endptr);

        // we checked the number format before
        assert(endptr == yytext.data() + yytext.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    token_type scan_literal(const char* literal_text, const std::size_t length,
                            token_type return_type)
    {
        assert(current == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_UNLIKELY(get() != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset yytext; current character is beginning of token
    void reset() noexcept
    {
        yytext.clear();
        token_string.clear();
        token_string.push_back(std::char_traits<char>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `std::char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    std::char_traits<char>::int_type get()
    {
        ++chars_read;
        current = ia->get_character();
        if (JSON_LIKELY(current != std::char_traits<char>::eof()))
        {
            token_string.push_back(std::char_traits<char>::to_char_type(current));
        }
        return current;
    }

    /// unget current character (return it again on next get)
    void unget()
    {
        --chars_read;
        if (JSON_LIKELY(current != std::char_traits<char>::eof()))
        {
            ia->unget_character();
            assert(token_string.size() != 0);
            token_string.pop_back();
        }
    }

    /// add a character to yytext
    void add(int c)
    {
        yytext.push_back(std::char_traits<char>::to_char_type(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    std::string move_string()
    {
        return std::move(yytext);
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr std::size_t get_position() const noexcept
    {
        return chars_read;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (auto c : token_string)
        {
            if ('\x00' <= c and c <= '\x1F')
            {
                // escape control characters
                std::stringstream ss;
                ss << "<U+" << std::setw(4) << std::uppercase << std::setfill('0')
                   << std::hex << static_cast<int>(c) << ">";
                result += ss.str();
            }
            else
            {
                // add character as is
                result.push_back(c);
            }
        }

        return result;
    }

    /// return syntax error message
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    token_type scan()
    {
        // read next character and ignore whitespace
        do
        {
            get();
        }
        while (current == ' ' or current == '\t' or current == '\n' or current == '\r');

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
                return scan_literal("true", 4, token_type::literal_true);
            case 'f':
                return scan_literal("false", 5, token_type::literal_false);
            case 'n':
                return scan_literal("null", 4, token_type::literal_null);

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case std::char_traits<char>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    detail::input_adapter_t ia = nullptr;

    /// the current character
    std::char_traits<char>::int_type current = std::char_traits<char>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// raw input token string (for error messages)
    std::vector<char> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    std::string yytext {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char decimal_point_char = '.';
};

/*!
@brief syntax analysis

This class implements a recursive decent parser.
*/
template<typename BasicJsonType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using lexer_t = lexer<BasicJsonType>;
    using token_type = typename lexer_t::token_type;

  public:
    enum class parse_event_t : uint8_t
    {
        /// the parser read `{` and started to process a JSON object
        object_start,
        /// the parser read `}` and finished processing a JSON object
        object_end,
        /// the parser read `[` and started to process a JSON array
        array_start,
        /// the parser read `]` and finished processing a JSON array
        array_end,
        /// the parser read a key of a value in an object
        key,
        /// the parser finished reading a JSON value
        value
    };

    using parser_callback_t =
        std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;

    /// a parser reading from an input adapter
    explicit parser(detail::input_adapter_t adapter,
                    const parser_callback_t cb = nullptr,
                    const bool allow_exceptions_ = true)
        : callback(cb), m_lexer(adapter), allow_exceptions(allow_exceptions_)
    {}

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        // read first token
        get_token();

        parse_internal(true, result);
        result.assert_invariant();

        // in strict mode, input must be completely read
        if (strict)
        {
            get_token();
            expect(token_type::end_of_input);
        }

        // in case of an error, return discarded value
        if (errored)
        {
            result = value_t::discarded;
            return;
        }

        // set top-level value to null if it was discarded by the callback
        // function
        if (result.is_discarded())
        {
            result = nullptr;
        }
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        // read first token
        get_token();

        if (not accept_internal())
        {
            return false;
        }

        // strict => last token must be EOF
        return not strict or (get_token() == token_type::end_of_input);
    }

  private:
    /*!
    @brief the actual parser
    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse_internal(bool keep, BasicJsonType& result)
    {
        // never parse after a parse error was detected
        assert(not errored);

        // start with a discarded value
        if (not result.is_discarded())
        {
            result.m_value.destroy(result.m_type);
            result.m_type = value_t::discarded;
        }

        switch (last_token)
        {
            case token_type::begin_object:
            {
                if (keep)
                {
                    if (callback)
                    {
                        keep = callback(depth++, parse_event_t::object_start, result);
                    }

                    if (not callback or keep)
                    {
                        // explicitly set result to object to cope with {}
                        result.m_type = value_t::object;
                        result.m_value = value_t::object;
                    }
                }

                // read next token
                get_token();

                // closing } -> we are done
                if (last_token == token_type::end_object)
                {
                    if (keep and callback and not callback(--depth, parse_event_t::object_end, result))
                    {
                        result.m_value.destroy(result.m_type);
                        result.m_type = value_t::discarded;
                    }
                    break;
                }

                // parse values
                std::string key;
                BasicJsonType value;
                while (true)
                {
                    // store key
                    if (not expect(token_type::value_string))
                    {
                        return;
                    }
                    key = m_lexer.move_string();

                    bool keep_tag = false;
                    if (keep)
                    {
                        if (callback)
                        {
                            BasicJsonType k(key);
                            keep_tag = callback(depth, parse_event_t::key, k);
                        }
                        else
                        {
                            keep_tag = true;
                        }
                    }

                    // parse separator (:)
                    get_token();
                    if (not expect(token_type::name_separator))
                    {
                        return;
                    }

                    // parse and add value
                    get_token();
                    value.m_value.destroy(value.m_type);
                    value.m_type = value_t::discarded;
                    parse_internal(keep, value);

                    if (JSON_UNLIKELY(errored))
                    {
                        return;
                    }

                    if (keep and keep_tag and not value.is_discarded())
                    {
                        result.m_value.object->emplace(std::move(key), std::move(value));
                    }

                    // comma -> next value
                    get_token();
                    if (last_token == token_type::value_separator)
                    {
                        get_token();
                        continue;
                    }

                    // closing }
                    if (not expect(token_type::end_object))
                    {
                        return;
                    }
                    break;
                }

                if (keep and callback and not callback(--depth, parse_event_t::object_end, result))
                {
                    result.m_value.destroy(result.m_type);
                    result.m_type = value_t::discarded;
                }
                break;
            }

            case token_type::begin_array:
            {
                if (keep)
                {
                    if (callback)
                    {
                        keep = callback(depth++, parse_event_t::array_start, result);
                    }

                    if (not callback or keep)
                    {
                        // explicitly set result to array to cope with []
                        result.m_type = value_t::array;
                        result.m_value = value_t::array;
                    }
                }

                // read next token
                get_token();

                // closing ] -> we are done
                if (last_token == token_type::end_array)
                {
                    if (callback and not callback(--depth, parse_event_t::array_end, result))
                    {
                        result.m_value.destroy(result.m_type);
                        result.m_type = value_t::discarded;
                    }
                    break;
                }

                // parse values
                BasicJsonType value;
                while (true)
                {
                    // parse value
                    value.m_value.destroy(value.m_type);
                    value.m_type = value_t::discarded;
                    parse_internal(keep, value);

                    if (JSON_UNLIKELY(errored))
                    {
                        return;
                    }

                    if (keep and not value.is_discarded())
                    {
                        result.m_value.array->push_back(std::move(value));
                    }

                    // comma -> next value
                    get_token();
                    if (last_token == token_type::value_separator)
                    {
                        get_token();
                        continue;
                    }

                    // closing ]
                    if (not expect(token_type::end_array))
                    {
                        return;
                    }
                    break;
                }

                if (keep and callback and not callback(--depth, parse_event_t::array_end, result))
                {
                    result.m_value.destroy(result.m_type);
                    result.m_type = value_t::discarded;
                }
                break;
            }

            case token_type::literal_null:
            {
                result.m_type = value_t::null;
                break;
            }

            case token_type::value_string:
            {
                result.m_type = value_t::string;
                result.m_value = m_lexer.move_string();
                break;
            }

            case token_type::literal_true:
            {
                result.m_type = value_t::boolean;
                result.m_value = true;
                break;
            }

            case token_type::literal_false:
            {
                result.m_type = value_t::boolean;
                result.m_value = false;
                break;
            }

            case token_type::value_unsigned:
            {
                result.m_type = value_t::number_unsigned;
                result.m_value = m_lexer.get_number_unsigned();
                break;
            }

            case token_type::value_integer:
            {
                result.m_type = value_t::number_integer;
                result.m_value = m_lexer.get_number_integer();
                break;
            }

            case token_type::value_float:
            {
                result.m_type = value_t::number_float;
                result.m_value = m_lexer.get_number_float();

                // throw in case of infinity or NAN
                if (JSON_UNLIKELY(not std::isfinite(result.m_value.number_float)))
                {
                    if (allow_exceptions)
                    {
                        JSON_THROW(out_of_range::create(406, "number overflow parsing '" +
                                                        m_lexer.get_token_string() + "'"));
                    }
                    expect(token_type::uninitialized);
                }
                break;
            }

            case token_type::parse_error:
            {
                // using "uninitialized" to avoid "expected" message
                if (not expect(token_type::uninitialized))
                {
                    return;
                }
                break; // LCOV_EXCL_LINE
            }

            default:
            {
                // the last token was unexpected; we expected a value
                if (not expect(token_type::literal_or_value))
                {
                    return;
                }
                break; // LCOV_EXCL_LINE
            }
        }

        if (keep and callback and not callback(depth, parse_event_t::value, result))
        {
            result.m_type = value_t::discarded;
        }
    }

    /*!
    @brief the actual acceptor

    @invariant 1. The last token is not yet processed. Therefore, the caller
                  of this function must make sure a token has been read.
               2. When this function returns, the last token is processed.
                  That is, the last read character was already considered.

    This invariant makes sure that no token needs to be "unput".
    */
    bool accept_internal()
    {
        switch (last_token)
        {
            case token_type::begin_object:
            {
                // read next token
                get_token();

                // closing } -> we are done
                if (last_token == token_type::end_object)
                {
                    return true;
                }

                // parse values
                while (true)
                {
                    // parse key
                    if (last_token != token_type::value_string)
                    {
                        return false;
                    }

                    // parse separator (:)
                    get_token();
                    if (last_token != token_type::name_separator)
                    {
                        return false;
                    }

                    // parse value
                    get_token();
                    if (not accept_internal())
                    {
                        return false;
                    }

                    // comma -> next value
                    get_token();
                    if (last_token == token_type::value_separator)
                    {
                        get_token();
                        continue;
                    }

                    // closing }
                    return (last_token == token_type::end_object);
                }
            }

            case token_type::begin_array:
            {
                // read next token
                get_token();

                // closing ] -> we are done
                if (last_token == token_type::end_array)
                {
                    return true;
                }

                // parse values
                while (true)
                {
                    // parse value
                    if (not accept_internal())
                    {
                        return false;
                    }

                    // comma -> next value
                    get_token();
                    if (last_token == token_type::value_separator)
                    {
                        get_token();
                        continue;
                    }

                    // closing ]
                    return (last_token == token_type::end_array);
                }
            }

            case token_type::value_float:
            {
                // reject infinity or NAN
                return std::isfinite(m_lexer.get_number_float());
            }

            case token_type::literal_false:
            case token_type::literal_null:
            case token_type::literal_true:
            case token_type::value_integer:
            case token_type::value_string:
            case token_type::value_unsigned:
                return true;

            default: // the last token was unexpected
                return false;
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return (last_token = m_lexer.scan());
    }

    /*!
    @throw parse_error.101 if expected token did not occur
    */
    bool expect(token_type t)
    {
        if (JSON_UNLIKELY(t != last_token))
        {
            errored = true;
            expected = t;
            if (allow_exceptions)
            {
                throw_exception();
            }
            else
            {
                return false;
            }
        }

        return true;
    }

    [[noreturn]] void throw_exception() const
    {
        std::string error_msg = "syntax error - ";
        if (last_token == token_type::parse_error)
        {
            error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
                         m_lexer.get_token_string() + "'";
        }
        else
        {
            error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
        }

        JSON_THROW(parse_error::create(101, m_lexer.get_position(), error_msg));
    }

  private:
    /// current level of recursion
    int depth = 0;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether a syntax error occurred
    bool errored = false;
    /// possible reason for the syntax error
    token_type expected = token_type::uninitialized;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

///////////////
// iterators //
///////////////

/*!
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). It's only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin,
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  public:
    using difference_type = std::ptrdiff_t;

    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type i)
    {
        auto result = *this;
        result += i;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    friend std::ostream& operator<<(std::ostream& os, primitive_iterator_t it)
    {
        return os << it.m_it;
    }

    primitive_iterator_t& operator++()
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t operator++(int)
    {
        auto result = *this;
        m_it++;
        return result;
    }

    primitive_iterator_t& operator--()
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t operator--(int)
    {
        auto result = *this;
        m_it--;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n)
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n)
    {
        m_it -= n;
        return *this;
    }

  private:
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();
};

/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};

template<typename IteratorType> class iteration_proxy;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class

This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.

@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).

@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl
{
    /// allow basic_json to access private members
    friend iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");

  public:

    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    /// default constructor
    iter_impl() = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it) {}

    /*!
    @brief converting assignment
    @param[in,out] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  private:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                assert(m_it.object_iterator != m_object->m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                assert(m_it.array_iterator != m_object->m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                assert(m_it.object_iterator != m_object->m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                assert(m_it.array_iterator != m_object->m_value.array->end());
                return &*m_it.array_iterator;
            }

            default:
            {
                if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator++(int)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator--(int)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  comparison: equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator==(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: not equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator!=(const iter_impl& other) const
    {
        return not operator==(other);
    }

    /*!
    @brief  comparison: smaller
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators"));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: less than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<=(const iter_impl& other) const
    {
        return not other.operator < (*this);
    }

    /*!
    @brief  comparison: greater than
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>(const iter_impl& other) const
    {
        return not operator<=(other);
    }

    /*!
    @brief  comparison: greater than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>=(const iter_impl& other) const
    {
        return not operator<(other);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief  addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief  return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief  access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators"));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief  return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    typename object_t::key_type key() const
    {
        assert(m_object != nullptr);

        if (JSON_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
    }

    /*!
    @brief  return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  private:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it = {};
};

/// proxy class for the iterator_wrapper functions
template<typename IteratorType> class iteration_proxy
{
  private:
    /// helper class for iteration
    class iteration_proxy_internal
    {
      private:
        /// the iterator
        IteratorType anchor;
        /// an index for arrays (used to create key names)
        std::size_t array_index = 0;

      public:
        explicit iteration_proxy_internal(IteratorType it) noexcept : anchor(it) {}

        /// dereference operator (needed for range-based for)
        iteration_proxy_internal& operator*()
        {
            return *this;
        }

        /// increment operator (needed for range-based for)
        iteration_proxy_internal& operator++()
        {
            ++anchor;
            ++array_index;

            return *this;
        }

        /// inequality operator (needed for range-based for)
        bool operator!=(const iteration_proxy_internal& o) const noexcept
        {
            return anchor != o.anchor;
        }

        /// return key of the iterator
        std::string key() const
        {
            assert(anchor.m_object != nullptr);

            switch (anchor.m_object->type())
            {
                // use integer array index as key
                case value_t::array:
                    return std::to_string(array_index);

                // use key from the object
                case value_t::object:
                    return anchor.key();

                // use an empty key for all primitive types
                default:
                    return "";
            }
        }

        /// return value of the iterator
        typename IteratorType::reference value() const
        {
            return anchor.value();
        }
    };

    /// the container to iterate
    typename IteratorType::reference container;

  public:
    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont)
        : container(cont) {}

    /// return iterator begin (needed for range-based for)
    iteration_proxy_internal begin() noexcept
    {
        return iteration_proxy_internal(container.begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_internal end() noexcept
    {
        return iteration_proxy_internal(container.end());
    }
};

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](http://en.cppreference.com/w/cpp/concept/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator operator++(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator operator--(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};

/////////////////////
// output adapters //
/////////////////////

/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType>& vec) : v(vec) {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    void write_characters(const CharType* s, std::size_t length) override
    {
        std::copy(s, s + length, std::back_inserter(v));
    }

  private:
    std::vector<CharType>& v;
};

/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) : stream(s) {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};

/// output adapter for basic_string
template<typename CharType>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(std::basic_string<CharType>& s) : str(s) {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    std::basic_string<CharType>& str;
};

template<typename CharType>
class output_adapter
{
  public:
    output_adapter(std::vector<CharType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}

    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}

    output_adapter(std::basic_string<CharType>& s)
        : oa(std::make_shared<output_string_adapter<CharType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};

//////////////////////////////
// binary reader and writer //
//////////////////////////////

/*!
@brief deserialization of CBOR and MessagePack values
*/
template<typename BasicJsonType>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(input_adapter_t adapter) : ia(std::move(adapter))
    {
        assert(ia);
    }

    /*!
    @brief create a JSON value from CBOR input

    @param[in] strict  whether to expect the input to be consumed completed
    @return JSON value created from CBOR input

    @throw parse_error.110 if input ended unexpectedly or the end of file was
                           not reached when @a strict was set to true
    @throw parse_error.112 if unsupported byte was read
    */
    BasicJsonType parse_cbor(const bool strict)
    {
        const auto res = parse_cbor_internal();
        if (strict)
        {
            get();
            check_eof(true);
        }
        return res;
    }

    /*!
    @brief create a JSON value from MessagePack input

    @param[in] strict  whether to expect the input to be consumed completed
    @return JSON value created from MessagePack input

    @throw parse_error.110 if input ended unexpectedly or the end of file was
                           not reached when @a strict was set to true
    @throw parse_error.112 if unsupported byte was read
    */
    BasicJsonType parse_msgpack(const bool strict)
    {
        const auto res = parse_msgpack_internal();
        if (strict)
        {
            get();
            check_eof(true);
        }
        return res;
    }

    /*!
    @brief determine system byte order

    @return true if and only if system's byte order is little endian

    @note from http://stackoverflow.com/a/1001328/266378
    */
    static constexpr bool little_endianess(int num = 1) noexcept
    {
        return (*reinterpret_cast<char*>(&num) == 1);
    }

  private:
    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead
    */
    BasicJsonType parse_cbor_internal(const bool get_char = true)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case std::char_traits<char>::eof():
                JSON_THROW(parse_error::create(110, chars_read, "unexpected end of input"));

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return static_cast<number_unsigned_t>(current);

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
                return get_number<uint8_t>();

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
                return get_number<uint16_t>();

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
                return get_number<uint32_t>();

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
                return get_number<uint64_t>();

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return static_cast<int8_t>(0x20 - 1 - current);

            case 0x38: // Negative integer (one-byte uint8_t follows)
            {
                // must be uint8_t !
                return static_cast<number_integer_t>(-1) - get_number<uint8_t>();
            }

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
            {
                return static_cast<number_integer_t>(-1) - get_number<uint16_t>();
            }

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
            {
                return static_cast<number_integer_t>(-1) - get_number<uint32_t>();
            }

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
            {
                return static_cast<number_integer_t>(-1) -
                       static_cast<number_integer_t>(get_number<uint64_t>());
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                return get_cbor_string();
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            {
                return get_cbor_array(current & 0x1F);
            }

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                return get_cbor_array(get_number<uint8_t>());
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                return get_cbor_array(get_number<uint16_t>());
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                return get_cbor_array(get_number<uint32_t>());
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                return get_cbor_array(get_number<uint64_t>());
            }

            case 0x9F: // array (indefinite length)
            {
                BasicJsonType result = value_t::array;
                while (get() != 0xFF)
                {
                    result.push_back(parse_cbor_internal(false));
                }
                return result;
            }

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            {
                return get_cbor_object(current & 0x1F);
            }

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                return get_cbor_object(get_number<uint8_t>());
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                return get_cbor_object(get_number<uint16_t>());
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                return get_cbor_object(get_number<uint32_t>());
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                return get_cbor_object(get_number<uint64_t>());
            }

            case 0xBF: // map (indefinite length)
            {
                BasicJsonType result = value_t::object;
                while (get() != 0xFF)
                {
                    auto key = get_cbor_string();
                    result[key] = parse_cbor_internal();
                }
                return result;
            }

            case 0xF4: // false
            {
                return false;
            }

            case 0xF5: // true
            {
                return true;
            }

            case 0xF6: // null
            {
                return value_t::null;
            }

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const int byte1 = get();
                check_eof();
                const int byte2 = get();
                check_eof();

                // code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const int half = (byte1 << 8) + byte2;
                const int exp = (half >> 10) & 0x1F;
                const int mant = half & 0x3FF;
                double val;
                if (exp == 0)
                {
                    val = std::ldexp(mant, -24);
                }
                else if (exp != 31)
                {
                    val = std::ldexp(mant + 1024, exp - 25);
                }
                else
                {
                    val = (mant == 0) ? std::numeric_limits<double>::infinity()
                          : std::numeric_limits<double>::quiet_NaN();
                }
                return (half & 0x8000) != 0 ? -val : val;
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                return get_number<float>();
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                return get_number<double>();
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                std::stringstream ss;
                ss << std::setw(2) << std::uppercase << std::setfill('0') << std::hex << current;
                JSON_THROW(parse_error::create(112, chars_read, "error reading CBOR; last byte: 0x" + ss.str()));
            }
        }
    }

    BasicJsonType parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case std::char_traits<char>::eof():
                JSON_THROW(parse_error::create(110, chars_read, "unexpected end of input"));

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return static_cast<number_unsigned_t>(current);

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            {
                return get_msgpack_object(current & 0x0F);
            }

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
            {
                return get_msgpack_array(current & 0x0F);
            }

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
                return get_msgpack_string();

            case 0xC0: // nil
                return value_t::null;

            case 0xC2: // false
                return false;

            case 0xC3: // true
                return true;

            case 0xCA: // float 32
                return get_number<float>();

            case 0xCB: // float 64
                return get_number<double>();

            case 0xCC: // uint 8
                return get_number<uint8_t>();

            case 0xCD: // uint 16
                return get_number<uint16_t>();

            case 0xCE: // uint 32
                return get_number<uint32_t>();

            case 0xCF: // uint 64
                return get_number<uint64_t>();

            case 0xD0: // int 8
                return get_number<int8_t>();

            case 0xD1: // int 16
                return get_number<int16_t>();

            case 0xD2: // int 32
                return get_number<int32_t>();

            case 0xD3: // int 64
                return get_number<int64_t>();

            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
                return get_msgpack_string();

            case 0xDC: // array 16
            {
                return get_msgpack_array(get_number<uint16_t>());
            }

            case 0xDD: // array 32
            {
                return get_msgpack_array(get_number<uint32_t>());
            }

            case 0xDE: // map 16
            {
                return get_msgpack_object(get_number<uint16_t>());
            }

            case 0xDF: // map 32
            {
                return get_msgpack_object(get_number<uint32_t>());
            }

            // positive fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return static_cast<int8_t>(current);

            default: // anything else
            {
                std::stringstream ss;
                ss << std::setw(2) << std::uppercase << std::setfill('0') << std::hex << current;
                JSON_THROW(parse_error::create(112, chars_read,
                                               "error reading MessagePack; last byte: 0x" + ss.str()));
            }
        }
    }

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `std::char_traits<char>::eof()` in that case.

    @return character read from the input
    */
    int get()
    {
        ++chars_read;
        return (current = ia->get_character());
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number

    @return number of type @a NumberType

    @note This function needs to respect the system's endianess, because
          bytes in CBOR and MessagePack are stored in network order (big
          endian) and therefore need reordering on little endian systems.

    @throw parse_error.110 if input has less than `sizeof(NumberType)` bytes
    */
    template<typename NumberType> NumberType get_number()
    {
        // step 1: read input into array with system's byte order
        std::array<uint8_t, sizeof(NumberType)> vec;
        for (std::size_t i = 0; i < sizeof(NumberType); ++i)
        {
            get();
            check_eof();

            // reverse byte order prior to conversion if necessary
            if (is_little_endian)
            {
                vec[sizeof(NumberType) - i - 1] = static_cast<uint8_t>(current);
            }
            else
            {
                vec[i] = static_cast<uint8_t>(current); // LCOV_EXCL_LINE
            }
        }

        // step 2: convert array into number of type T and return
        NumberType result;
        std::memcpy(&result, vec.data(), sizeof(NumberType));
        return result;
    }

    /*!
    @brief create a string by reading characters from the input

    @param[in] len number of bytes to read

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref check_eof() detects the end of
          the input before we run out of string memory.

    @return string created by reading @a len bytes

    @throw parse_error.110 if input has less than @a len bytes
    */
    template<typename NumberType>
    std::string get_string(const NumberType len)
    {
        std::string result;
        std::generate_n(std::back_inserter(result), len, [this]()
        {
            get();
            check_eof();
            return static_cast<char>(current);
        });
        return result;
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @return string

    @throw parse_error.110 if input ended
    @throw parse_error.113 if an unexpected byte is read
    */
    std::string get_cbor_string()
    {
        check_eof();

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(current & 0x1F);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                return get_string(get_number<uint8_t>());
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                return get_string(get_number<uint16_t>());
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                return get_string(get_number<uint32_t>());
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                return get_string(get_number<uint64_t>());
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                std::string result;
                while (get() != 0xFF)
                {
                    check_eof();
                    result.push_back(static_cast<char>(current));
                }
                return result;
            }

            default:
            {
                std::stringstream ss;
                ss << std::setw(2) << std::uppercase << std::setfill('0') << std::hex << current;
                JSON_THROW(parse_error::create(113, chars_read, "expected a CBOR string; last byte: 0x" + ss.str()));
            }
        }
    }

    template<typename NumberType>
    BasicJsonType get_cbor_array(const NumberType len)
    {
        BasicJsonType result = value_t::array;
        std::generate_n(std::back_inserter(*result.m_value.array), len, [this]()
        {
            return parse_cbor_internal();
        });
        return result;
    }

    template<typename NumberType>
    BasicJsonType get_cbor_object(const NumberType len)
    {
        BasicJsonType result = value_t::object;
        std::generate_n(std::inserter(*result.m_value.object,
                                      result.m_value.object->end()),
                        len, [this]()
        {
            get();
            auto key = get_cbor_string();
            auto val = parse_cbor_internal();
            return std::make_pair(std::move(key), std::move(val));
        });
        return result;
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @return string

    @throw parse_error.110 if input ended
    @throw parse_error.113 if an unexpected byte is read
    */
    std::string get_msgpack_string()
    {
        check_eof();

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(current & 0x1F);
            }

            case 0xD9: // str 8
            {
                return get_string(get_number<uint8_t>());
            }

            case 0xDA: // str 16
            {
                return get_string(get_number<uint16_t>());
            }

            case 0xDB: // str 32
            {
                return get_string(get_number<uint32_t>());
            }

            default:
            {
                std::stringstream ss;
                ss << std::setw(2) << std::uppercase << std::setfill('0') << std::hex << current;
                JSON_THROW(parse_error::create(113, chars_read,
                                               "expected a MessagePack string; last byte: 0x" + ss.str()));
            }
        }
    }

    template<typename NumberType>
    BasicJsonType get_msgpack_array(const NumberType len)
    {
        BasicJsonType result = value_t::array;
        std::generate_n(std::back_inserter(*result.m_value.array), len, [this]()
        {
            return parse_msgpack_internal();
        });
        return result;
    }

    template<typename NumberType>
    BasicJsonType get_msgpack_object(const NumberType len)
    {
        BasicJsonType result = value_t::object;
        std::generate_n(std::inserter(*result.m_value.object,
                                      result.m_value.object->end()),
                        len, [this]()
        {
            get();
            auto key = get_msgpack_string();
            auto val = parse_msgpack_internal();
            return std::make_pair(std::move(key), std::move(val));
        });
        return result;
    }

    /*!
    @brief check if input ended
    @throw parse_error.110 if input ended
    */
    void check_eof(const bool expect_eof = false) const
    {
        if (expect_eof)
        {
            if (JSON_UNLIKELY(current != std::char_traits<char>::eof()))
            {
                JSON_THROW(parse_error::create(110, chars_read, "expected end of input"));
            }
        }
        else
        {
            if (JSON_UNLIKELY(current == std::char_traits<char>::eof()))
            {
                JSON_THROW(parse_error::create(110, chars_read, "unexpected end of input"));
            }
        }
    }

  private:
    /// input adapter
    input_adapter_t ia = nullptr;

    /// the current character
    int current = std::char_traits<char>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianess
    const bool is_little_endian = little_endianess();
};

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
    {
        assert(oa);
    }

    /*!
    @brief[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(static_cast<CharType>(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_value.boolean
                                    ? static_cast<CharType>(0xF5)
                                    : static_cast<CharType>(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<uint8_t>::max)())
                    {
                        oa->write_character(static_cast<CharType>(0x18));
                        write_number(static_cast<uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<uint16_t>::max)())
                    {
                        oa->write_character(static_cast<CharType>(0x19));
                        write_number(static_cast<uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<uint32_t>::max)())
                    {
                        oa->write_character(static_cast<CharType>(0x1A));
                        write_number(static_cast<uint32_t>(j.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(static_cast<CharType>(0x1B));
                        write_number(static_cast<uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_value.number_integer;
                    if (j.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<uint8_t>::max)())
                    {
                        oa->write_character(static_cast<CharType>(0x38));
                        write_number(static_cast<uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<uint16_t>::max)())
                    {
                        oa->write_character(static_cast<CharType>(0x39));
                        write_number(static_cast<uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<uint32_t>::max)())
                    {
                        oa->write_character(static_cast<CharType>(0x3A));
                        write_number(static_cast<uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(static_cast<CharType>(0x3B));
                        write_number(static_cast<uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
                {
                    oa->write_character(static_cast<CharType>(0x18));
                    write_number(static_cast<uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
                {
                    oa->write_character(static_cast<CharType>(0x19));
                    write_number(static_cast<uint16_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
                {
                    oa->write_character(static_cast<CharType>(0x1A));
                    write_number(static_cast<uint32_t>(j.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(static_cast<CharType>(0x1B));
                    write_number(static_cast<uint64_t>(j.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float: // Double-Precision Float
            {
                oa->write_character(static_cast<CharType>(0xFB));
                write_number(j.m_value.number_float);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<uint8_t>(0x60 + N));
                }
                else if (N <= 0xFF)
                {
                    oa->write_character(static_cast<CharType>(0x78));
                    write_number(static_cast<uint8_t>(N));
                }
                else if (N <= 0xFFFF)
                {
                    oa->write_character(static_cast<CharType>(0x79));
                    write_number(static_cast<uint16_t>(N));
                }
                else if (N <= 0xFFFFFFFF)
                {
                    oa->write_character(static_cast<CharType>(0x7A));
                    write_number(static_cast<uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= 0xFFFFFFFFFFFFFFFF)
                {
                    oa->write_character(static_cast<CharType>(0x7B));
                    write_number(static_cast<uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<uint8_t>(0x80 + N));
                }
                else if (N <= 0xFF)
                {
                    oa->write_character(static_cast<CharType>(0x98));
                    write_number(static_cast<uint8_t>(N));
                }
                else if (N <= 0xFFFF)
                {
                    oa->write_character(static_cast<CharType>(0x99));
                    write_number(static_cast<uint16_t>(N));
                }
                else if (N <= 0xFFFFFFFF)
                {
                    oa->write_character(static_cast<CharType>(0x9A));
                    write_number(static_cast<uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= 0xFFFFFFFFFFFFFFFF)
                {
                    oa->write_character(static_cast<CharType>(0x9B));
                    write_number(static_cast<uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<uint8_t>(0xA0 + N));
                }
                else if (N <= 0xFF)
                {
                    oa->write_character(static_cast<CharType>(0xB8));
                    write_number(static_cast<uint8_t>(N));
                }
                else if (N <= 0xFFFF)
                {
                    oa->write_character(static_cast<CharType>(0xB9));
                    write_number(static_cast<uint16_t>(N));
                }
                else if (N <= 0xFFFFFFFF)
                {
                    oa->write_character(static_cast<CharType>(0xBA));
                    write_number(static_cast<uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= 0xFFFFFFFFFFFFFFFF)
                {
                    oa->write_character(static_cast<CharType>(0xBB));
                    write_number(static_cast<uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @brief[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(static_cast<CharType>(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_value.boolean
                                    ? static_cast<CharType>(0xC3)
                                    : static_cast<CharType>(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(static_cast<CharType>(0xCC));
                        write_number(static_cast<uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(static_cast<CharType>(0xCD));
                        write_number(static_cast<uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(static_cast<CharType>(0xCE));
                        write_number(static_cast<uint32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(static_cast<CharType>(0xCF));
                        write_number(static_cast<uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<int8_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(static_cast<CharType>(0xD0));
                        write_number(static_cast<int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<int16_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(static_cast<CharType>(0xD1));
                        write_number(static_cast<int16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<int32_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(static_cast<CharType>(0xD2));
                        write_number(static_cast<int32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<int64_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(static_cast<CharType>(0xD3));
                        write_number(static_cast<int64_t>(j.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(static_cast<CharType>(0xCC));
                    write_number(static_cast<uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(static_cast<CharType>(0xCD));
                    write_number(static_cast<uint16_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(static_cast<CharType>(0xCE));
                    write_number(static_cast<uint32_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(static_cast<CharType>(0xCF));
                    write_number(static_cast<uint64_t>(j.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float: // float 64
            {
                oa->write_character(static_cast<CharType>(0xCB));
                write_number(j.m_value.number_float);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<uint8_t>(0xA0 | N));
                }
                else if (N <= 255)
                {
                    // str 8
                    oa->write_character(static_cast<CharType>(0xD9));
                    write_number(static_cast<uint8_t>(N));
                }
                else if (N <= 65535)
                {
                    // str 16
                    oa->write_character(static_cast<CharType>(0xDA));
                    write_number(static_cast<uint16_t>(N));
                }
                else if (N <= 4294967295)
                {
                    // str 32
                    oa->write_character(static_cast<CharType>(0xDB));
                    write_number(static_cast<uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<uint8_t>(0x90 | N));
                }
                else if (N <= 0xFFFF)
                {
                    // array 16
                    oa->write_character(static_cast<CharType>(0xDC));
                    write_number(static_cast<uint16_t>(N));
                }
                else if (N <= 0xFFFFFFFF)
                {
                    // array 32
                    oa->write_character(static_cast<CharType>(0xDD));
                    write_number(static_cast<uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= 65535)
                {
                    // map 16
                    oa->write_character(static_cast<CharType>(0xDE));
                    write_number(static_cast<uint16_t>(N));
                }
                else if (N <= 4294967295)
                {
                    // map 32
                    oa->write_character(static_cast<CharType>(0xDF));
                    write_number(static_cast<uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

  private:
    /*
    @brief write a number to output input

    @param[in] n number of type @a NumberType
    @tparam NumberType the type of the number

    @note This function needs to respect the system's endianess, because bytes
          in CBOR and MessagePack are stored in network order (big endian) and
          therefore need reordering on little endian systems.
    */
    template<typename NumberType> void write_number(NumberType n)
    {
        // step 1: write number to array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec;
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write array to output (with possible reordering)
        if (is_little_endian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

  private:
    /// whether we can assume little endianess
    const bool is_little_endian = binary_reader<BasicJsonType>::little_endianess();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};

///////////////////
// serialization //
///////////////////

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    */
    serializer(output_adapter_t<char> s, const char ichar)
        : o(std::move(s)), loc(std::localeconv()),
          thousands_sep(loc->thousands_sep == nullptr ? '\0' : * (loc->thousands_sep)),
          decimal_point(loc->decimal_point == nullptr ? '\0' : * (loc->decimal_point)),
          indent_char(ichar), indent_string(512, indent_char) {}

    // delete because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format

    @param[in] val             value to serialize
    @param[in] pretty_print    whether the output shall be pretty-printed
    @param[in] indent_step     the indent level
    @param[in] current_indent  the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val, const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_type)
        {
            case value_t::object:
            {
                if (val.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    assert(i != val.m_value.object->cend());
                    assert(std::next(i) == val.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    assert(i != val.m_value.object->cend());
                    assert(std::next(i) == val.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    assert(not val.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    assert(not val.m_value.array->empty());
                    dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::boolean:
            {
                if (val.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }
        }
    }

  private:
    /*!
    @brief returns the number of expected bytes following in UTF-8 string

    @param[in]  u  the first byte of a UTF-8 string
    @return  the number of expected bytes following
    */
    static constexpr std::size_t bytes_following(const uint8_t u)
    {
        return ((u <= 127) ? 0
                : ((192 <= u and u <= 223) ? 1
                   : ((224 <= u and u <= 239) ? 2
                      : ((240 <= u and u <= 247) ? 3 : std::string::npos))));
    }

    /*!
    @brief calculates the extra space to escape a JSON string

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences
    @return the number of characters required to escape string @a s

    @complexity Linear in the length of string @a s.
    */
    static std::size_t extra_space(const string_t& s,
                                   const bool ensure_ascii) noexcept
    {
        std::size_t res = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            switch (s[i])
            {
                // control characters that can be escaped with a backslash
                case '"':
                case '\\':
                case '\b':
                case '\f':
                case '\n':
                case '\r':
                case '\t':
                {
                    // from c (1 byte) to \x (2 bytes)
                    res += 1;
                    break;
                }

                // control characters that need \uxxxx escaping
                case 0x00:
                case 0x01:
                case 0x02:
                case 0x03:
                case 0x04:
                case 0x05:
                case 0x06:
                case 0x07:
                case 0x0B:
                case 0x0E:
                case 0x0F:
                case 0x10:
                case 0x11:
                case 0x12:
                case 0x13:
                case 0x14:
                case 0x15:
                case 0x16:
                case 0x17:
                case 0x18:
                case 0x19:
                case 0x1A:
                case 0x1B:
                case 0x1C:
                case 0x1D:
                case 0x1E:
                case 0x1F:
                {
                    // from c (1 byte) to \uxxxx (6 bytes)
                    res += 5;
                    break;
                }

                default:
                {
                    if (ensure_ascii and (s[i] & 0x80 or s[i] == 0x7F))
                    {
                        const auto bytes = bytes_following(static_cast<uint8_t>(s[i]));
                        // invalid characters will be detected by throw_if_invalid_utf8
                        assert (bytes != std::string::npos);

                        if (bytes == 3)
                        {
                            // codepoints that need 4 bytes (i.e., 3 additional
                            // bytes) in UTF-8 need a surrogate pair when \u
                            // escaping is used: from 4 bytes to \uxxxx\uxxxx
                            // (12 bytes)
                            res += (12 - bytes - 1);
                        }
                        else
                        {
                            // from x bytes to \uxxxx (6 bytes)
                            res += (6 - bytes - 1);
                        }

                        // skip the additional bytes
                        i += bytes;
                    }
                    break;
                }
            }
        }

        return res;
    }

    static void escape_codepoint(int codepoint, string_t& result, std::size_t& pos)
    {
        // expecting a proper codepoint
        assert(0x00 <= codepoint and codepoint <= 0x10FFFF);

        // the last written character was the backslash before the 'u'
        assert(result[pos] == '\\');

        // write the 'u'
        result[++pos] = 'u';

        // convert a number 0..15 to its hex representation (0..f)
        static const std::array<char, 16> hexify =
        {
            {
                '0', '1', '2', '3', '4', '5', '6', '7',
                '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
            }
        };

        if (codepoint < 0x10000)
        {
            // codepoints U+0000..U+FFFF can be represented as \uxxxx.
            result[++pos] = hexify[(codepoint >> 12) & 0x0F];
            result[++pos] = hexify[(codepoint >> 8) & 0x0F];
            result[++pos] = hexify[(codepoint >> 4) & 0x0F];
            result[++pos] = hexify[codepoint & 0x0F];
        }
        else
        {
            // codepoints U+10000..U+10FFFF need a surrogate pair to be
            // represented as \uxxxx\uxxxx.
            // http://www.unicode.org/faq/utf_bom.html#utf16-4
            codepoint -= 0x10000;
            const int high_surrogate = 0xD800 | ((codepoint >> 10) & 0x3FF);
            const int low_surrogate = 0xDC00 | (codepoint & 0x3FF);
            result[++pos] = hexify[(high_surrogate >> 12) & 0x0F];
            result[++pos] = hexify[(high_surrogate >> 8) & 0x0F];
            result[++pos] = hexify[(high_surrogate >> 4) & 0x0F];
            result[++pos] = hexify[high_surrogate & 0x0F];
            ++pos;  // backslash is already in output
            result[++pos] = 'u';
            result[++pos] = hexify[(low_surrogate >> 12) & 0x0F];
            result[++pos] = hexify[(low_surrogate >> 8) & 0x0F];
            result[++pos] = hexify[(low_surrogate >> 4) & 0x0F];
            result[++pos] = hexify[low_surrogate & 0x0F];
        }

        ++pos;
    }

    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii) const
    {
        throw_if_invalid_utf8(s);

        const auto space = extra_space(s, ensure_ascii);
        if (space == 0)
        {
            o->write_characters(s.c_str(), s.size());
            return;
        }

        // create a result string of necessary size
        string_t result(s.size() + space, '\\');
        std::size_t pos = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            switch (s[i])
            {
                case '"': // quotation mark (0x22)
                {
                    result[pos + 1] = '"';
                    pos += 2;
                    break;
                }

                case '\\': // reverse solidus (0x5C)
                {
                    // nothing to change
                    pos += 2;
                    break;
                }

                case '\b': // backspace (0x08)
                {
                    result[pos + 1] = 'b';
                    pos += 2;
                    break;
                }

                case '\f': // formfeed (0x0C)
                {
                    result[pos + 1] = 'f';
                    pos += 2;
                    break;
                }

                case '\n': // newline (0x0A)
                {
                    result[pos + 1] = 'n';
                    pos += 2;
                    break;
                }

                case '\r': // carriage return (0x0D)
                {
                    result[pos + 1] = 'r';
                    pos += 2;
                    break;
                }

                case '\t': // horizontal tab (0x09)
                {
                    result[pos + 1] = 't';
                    pos += 2;
                    break;
                }

                default:
                {
                    // escape control characters (0x00..0x1F) or, if
                    // ensure_ascii parameter is used, non-ASCII characters
                    if ((0x00 <= s[i] and s[i] <= 0x1F) or
                            (ensure_ascii and (s[i] & 0x80 or s[i] == 0x7F)))
                    {
                        const auto bytes = bytes_following(static_cast<uint8_t>(s[i]));
                        // invalid characters will be detected by throw_if_invalid_utf8
                        assert (bytes != std::string::npos);

                        // check that the additional bytes are present
                        assert(i + bytes < s.size());

                        // to use\uxxxx escaping, we first need to caluclate
                        // the codepoint from the UTF-8 bytes
                        int codepoint = 0;

                        assert(0 <= bytes and bytes <= 3);
                        switch (bytes)
                        {
                            case 0:
                            {
                                codepoint = s[i] & 0xFF;
                                break;
                            }

                            case 1:
                            {
                                codepoint = ((s[i] & 0x3F) << 6)
                                            + (s[i + 1] & 0x7F);
                                break;
                            }

                            case 2:
                            {
                                codepoint = ((s[i] & 0x1F) << 12)
                                            + ((s[i + 1] & 0x7F) << 6)
                                            + (s[i + 2] & 0x7F);
                                break;
                            }

                            case 3:
                            {
                                codepoint = ((s[i] & 0xF) << 18)
                                            + ((s[i + 1] & 0x7F) << 12)
                                            + ((s[i + 2] & 0x7F) << 6)
                                            + (s[i + 3] & 0x7F);
                                break;
                            }

                            default:
                                break;  // LCOV_EXCL_LINE
                        }

                        escape_codepoint(codepoint, result, pos);
                        i += bytes;
                    }
                    else
                    {
                        // all other characters are added as-is
                        result[pos++] = s[i];
                    }
                    break;
                }
            }
        }

        assert(pos == result.size());
        o->write_characters(result.c_str(), result.size());
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template<typename NumberType, detail::enable_if_t<
                 std::is_same<NumberType, number_unsigned_t>::value or
                 std::is_same<NumberType, number_integer_t>::value,
                 int> = 0>
    void dump_integer(NumberType x)
    {
        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        const bool is_negative = (x <= 0) and (x != 0);  // see issue #755
        std::size_t i = 0;

        while (x != 0)
        {
            // spare 1 byte for '\0'
            assert(i < number_buffer.size() - 1);

            const auto digit = std::labs(static_cast<long>(x % 10));
            number_buffer[i++] = static_cast<char>('0' + digit);
            x /= 10;
        }

        if (is_negative)
        {
            // make sure there is capacity for the '-'
            assert(i < number_buffer.size() - 2);
            number_buffer[i++] = '-';
        }

        std::reverse(number_buffer.begin(), number_buffer.begin() + i);
        o->write_characters(number_buffer.data(), i);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (not std::isfinite(x) or std::isnan(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // get number of digits for a text -> float -> text round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::digits10;

        // the actual conversion
        std::ptrdiff_t len = snprintf(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        assert(len > 0);
        // check if buffer was large enough
        assert(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separator
        if (thousands_sep != '\0')
        {
            const auto end = std::remove(number_buffer.begin(),
                                         number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            assert((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' and decimal_point != '.')
        {
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return (c == '.' or c == 'e');
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in] byte       next byte to decode

    @note The function has been edited: a std::array is used and the code
          point is not calculated.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static void decode(uint8_t& state, const uint8_t byte)
    {
        static const std::array<uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        const uint8_t type = utf8d[byte];
        state = utf8d[256u + state * 16u + type];
    }

    /*!
    @brief throw an exception if a string is not UTF-8 encoded

    @param[in] str  UTF-8 string to check
    @throw type_error.316 if passed string is not UTF-8 encoded

    @since version 3.0.0
    */
    static void throw_if_invalid_utf8(const std::string& str)
    {
        // start with state 0 (= accept)
        uint8_t state = 0;

        for (size_t i = 0; i < str.size(); ++i)
        {
            const auto byte = static_cast<uint8_t>(str[i]);
            decode(state, byte);
            if (state == 1)
            {
                // state 1 means reject
                std::stringstream ss;
                ss << std::setw(2) << std::uppercase << std::setfill('0') << std::hex << static_cast<int>(byte);
                JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + ss.str()));
            }
        }

        if (state != 0)
        {
            // we finish reading, but do not accept: string was incomplete
            std::stringstream ss;
            ss << std::setw(2) << std::uppercase << std::setfill('0') << std::hex << static_cast<int>(static_cast<uint8_t>(str.back()));
            JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + ss.str()));
        }
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// the indentation character
    const char indent_char;

    /// the indentation string
    string_t indent_string;
};

template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value)), value_ref(&owned_value), is_rvalue(true)
    {}

    json_ref(const value_type& value)
        : value_ref(const_cast<value_type*>(&value)), is_rvalue(false)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init), value_ref(&owned_value), is_rvalue(true)
    {}

    template<class... Args>
    json_ref(Args&& ... args)
        : owned_value(std::forward<Args>(args)...), value_ref(&owned_value), is_rvalue(true)
    {}

    // class should be movable only
    json_ref(json_ref&&) = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;

    value_type moved_or_copied() const
    {
        if (is_rvalue)
        {
            return std::move(*value_ref);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return *static_cast<value_type const*>(value_ref);
    }

    value_type const* operator->() const
    {
        return static_cast<value_type const*>(value_ref);
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type* value_ref = nullptr;
    const bool is_rvalue;
};

} // namespace detail

/// namespace to hold default `to_json` / `from_json` functions
namespace
{
constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value;
constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value;
}


/*!
@brief default JSONSerializer template argument

This serializer ignores the template arguments and uses ADL
([argument-dependent lookup](http://en.cppreference.com/w/cpp/language/adl))
for serialization.
*/
template<typename, typename>
struct adl_serializer
{
    /*!
    @brief convert a JSON value to any value type

    This function is usually called by the `get()` function of the
    @ref basic_json class (either explicit or via conversion operators).

    @param[in] j         JSON value to read from
    @param[in,out] val  value to write to
    */
    template<typename BasicJsonType, typename ValueType>
    static void from_json(BasicJsonType&& j, ValueType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /*!
    @brief convert any value type to a JSON value

    This function is usually called by the constructors of the @ref basic_json
    class.

    @param[in,out] j  JSON value to write to
    @param[in] val     value to read from
    */
    template<typename BasicJsonType, typename ValueType>
    static void to_json(BasicJsonType& j, ValueType&& val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<ValueType>(val))))
    {
        ::nlohmann::to_json(j, std::forward<ValueType>(val));
    }
};

/*!
@brief JSON Pointer

A JSON pointer defines a string syntax for identifying a specific value
within a JSON document. It can be used with functions `at` and
`operator[]`. Furthermore, JSON pointers are the base for JSON patches.

@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)

@since version 2.0.0
*/
class json_pointer
{
    /// allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

  public:
    /*!
    @brief create JSON pointer

    Create a JSON pointer according to the syntax described in
    [Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).

    @param[in] s  string representing the JSON pointer; if omitted, the empty
                  string is assumed which references the whole JSON value

    @throw parse_error.107 if the given JSON pointer @a s is nonempty and
    does not begin with a slash (`/`); see example below

    @throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s
    is not followed by `0` (representing `~`) or `1` (representing `/`);
    see example below

    @liveexample{The example shows the construction several valid JSON
    pointers as well as the exceptional behavior.,json_pointer}

    @since version 2.0.0
    */
    explicit json_pointer(const std::string& s = "") : reference_tokens(split(s)) {}

    /*!
    @brief return a string representation of the JSON pointer

    @invariant For each JSON pointer `ptr`, it holds:
    @code {.cpp}
    ptr == json_pointer(ptr.to_string());
    @endcode

    @return a string representation of the JSON pointer

    @liveexample{The example shows the result of `to_string`.,
    json_pointer__to_string}

    @since version 2.0.0
    */
    std::string to_string() const noexcept
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               std::string{},
                               [](const std::string & a, const std::string & b)
        {
            return a + "/" + escape(b);
        });
    }

    /// @copydoc to_string()
    operator std::string() const
    {
        return to_string();
    }

  private:
    /*!
    @brief remove and return last reference pointer
    @throw out_of_range.405 if JSON pointer has no parent
    */
    std::string pop_back()
    {
        if (JSON_UNLIKELY(is_root()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        auto last = reference_tokens.back();
        reference_tokens.pop_back();
        return last;
    }

    /// return whether pointer points to the root document
    bool is_root() const
    {
        return reference_tokens.empty();
    }

    json_pointer top() const
    {
        if (JSON_UNLIKELY(is_root()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }


    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    NLOHMANN_BASIC_JSON_TPL& get_and_create(NLOHMANN_BASIC_JSON_TPL& j) const;

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    NLOHMANN_BASIC_JSON_TPL& get_unchecked(NLOHMANN_BASIC_JSON_TPL* ptr) const;

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    NLOHMANN_BASIC_JSON_TPL& get_checked(NLOHMANN_BASIC_JSON_TPL* ptr) const;

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    const NLOHMANN_BASIC_JSON_TPL& get_unchecked(const NLOHMANN_BASIC_JSON_TPL* ptr) const;

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    const NLOHMANN_BASIC_JSON_TPL& get_checked(const NLOHMANN_BASIC_JSON_TPL* ptr) const;

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<std::string> split(const std::string& reference_string)
    {
        std::vector<std::string> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if nonempty reference string begins with slash
        if (JSON_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1,
                                                   "JSON pointer must be empty or begin with '/' - was: '" +
                                                   reference_string + "'"));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == string::npos+1 = 0
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == std::string::npos)
            start = slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != std::string::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                assert(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_UNLIKELY(pos == reference_token.size() - 1 or
                                  (reference_token[pos + 1] != '0' and
                                   reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'"));
                }
            }

            // finally, store the reference token
            unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

    /*!
    @brief replace all occurrences of a substring by another string

    @param[in,out] s  the string to manipulate; changed so that all
                   occurrences of @a f are replaced with @a t
    @param[in]     f  the substring to replace with @a t
    @param[in]     t  the string to replace @a f

    @pre The search string @a f must not be empty. **This precondition is
    enforced with an assertion.**

    @since version 2.0.0
    */
    static void replace_substring(std::string& s, const std::string& f,
                                  const std::string& t)
    {
        assert(not f.empty());
        for (auto pos = s.find(f);                // find first occurrence of f
                pos != std::string::npos;         // make sure f was found
                s.replace(pos, f.size(), t),      // replace with t, and
                pos = s.find(f, pos + t.size()))  // find next occurrence of f
        {}
    }

    /// escape "~"" to "~0" and "/" to "~1"
    static std::string escape(std::string s)
    {
        replace_substring(s, "~", "~0");
        replace_substring(s, "/", "~1");
        return s;
    }

    /// unescape "~1" to tilde and "~0" to slash (order is important!)
    static void unescape(std::string& s)
    {
        replace_substring(s, "~1", "/");
        replace_substring(s, "~0", "~");
    }

    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    static void flatten(const std::string& reference_string,
                        const NLOHMANN_BASIC_JSON_TPL& value,
                        NLOHMANN_BASIC_JSON_TPL& result);

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    static NLOHMANN_BASIC_JSON_TPL
    unflatten(const NLOHMANN_BASIC_JSON_TPL& value);

    friend bool operator==(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept;

    friend bool operator!=(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept;

    /// the reference tokens
    std::vector<std::string> reference_tokens;
};

/*!
@brief a class to store JSON values

@tparam ObjectType type for JSON objects (`std::map` by default; will be used
in @ref object_t)
@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
in @ref array_t)
@tparam StringType type for JSON strings and object keys (`std::string` by
default; will be used in @ref string_t)
@tparam BooleanType type for JSON booleans (`bool` by default; will be used
in @ref boolean_t)
@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
default; will be used in @ref number_integer_t)
@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
`uint64_t` by default; will be used in @ref number_unsigned_t)
@tparam NumberFloatType type for JSON floating-point numbers (`double` by
default; will be used in @ref number_float_t)
@tparam AllocatorType type of the allocator to use (`std::allocator` by
default)
@tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
and `from_json()` (@ref adl_serializer by default)

@requirement The class satisfies the following concept requirements:
- Basic
 - [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible):
   JSON values can be default constructed. The result will be a JSON null
   value.
 - [MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible):
   A JSON value can be constructed from an rvalue argument.
 - [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible):
   A JSON value can be copy-constructed from an lvalue expression.
 - [MoveAssignable](http://en.cppreference.com/w/cpp/concept/MoveAssignable):
   A JSON value van be assigned from an rvalue argument.
 - [CopyAssignable](http://en.cppreference.com/w/cpp/concept/CopyAssignable):
   A JSON value can be copy-assigned from an lvalue expression.
 - [Destructible](http://en.cppreference.com/w/cpp/concept/Destructible):
   JSON values can be destructed.
- Layout
 - [StandardLayoutType](http://en.cppreference.com/w/cpp/concept/StandardLayoutType):
   JSON values have
   [standard layout](http://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
   All non-static data members are private and standard layout types, the
   class has no virtual functions or (virtual) base classes.
- Library-wide
 - [EqualityComparable](http://en.cppreference.com/w/cpp/concept/EqualityComparable):
   JSON values can be compared with `==`, see @ref
   operator==(const_reference,const_reference).
 - [LessThanComparable](http://en.cppreference.com/w/cpp/concept/LessThanComparable):
   JSON values can be compared with `<`, see @ref
   operator<(const_reference,const_reference).
 - [Swappable](http://en.cppreference.com/w/cpp/concept/Swappable):
   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
   other compatible types, using unqualified function call @ref swap().
 - [NullablePointer](http://en.cppreference.com/w/cpp/concept/NullablePointer):
   JSON values can be compared against `std::nullptr_t` objects which are used
   to model the `null` value.
- Container
 - [Container](http://en.cppreference.com/w/cpp/concept/Container):
   JSON values can be used like STL containers and provide iterator access.
 - [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer);
   JSON values can be used like STL containers and provide reverse iterator
   access.

@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@internal
@note ObjectType trick from http://stackoverflow.com/a/9860911
@endinternal

@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
Format](http://rfc7159.net/rfc7159)

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;
    friend ::nlohmann::json_pointer;
    friend ::nlohmann::detail::parser<basic_json>;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::binary_reader;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;

    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer<basic_json>;
    using parser = ::nlohmann::detail::parser<basic_json>;

    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    using binary_reader = ::nlohmann::detail::binary_reader<basic_json>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// @copydoc nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    /// @copydoc detail::exception
    using exception = detail::exception;
    /// @copydoc detail::parse_error
    using parse_error = detail::parse_error;
    /// @copydoc detail::invalid_iterator
    using invalid_iterator = detail::invalid_iterator;
    /// @copydoc detail::type_error
    using type_error = detail::type_error;
    /// @copydoc detail::out_of_range
    using out_of_range = detail::out_of_range;
    /// @copydoc detail::other_error
    using other_error = detail::other_error;

    /// @}


    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}


    /*!
    @brief returns the allocator associated with the container
    */
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /*!
    @brief returns version information on the library

    This function returns a JSON object with information about the library,
    including the version number and information on the platform and compiler.

    @return JSON object holding version information
    key         | description
    ----------- | ---------------
    `compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
    `copyright` | The copyright line for the library as string.
    `name`      | The name of the library as string.
    `platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
    `url`       | The URL of the project as string.
    `version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).

    @liveexample{The following code shows an example output of the `meta()`
    function.,meta}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @complexity Constant.

    @since 2.1.0
    */
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2017 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"] =
        {
            {"string", "2.1.1"}, {"major", 2}, {"minor", 1}, {"patch", 1}
        };

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)}};
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#ifdef __cplusplus
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }


    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

#if defined(JSON_HAS_CPP_14)
    // Use transparent comparator if possible, combined with perfect forwarding
    // on find() and count() calls prevents unnecessary string construction.
    using object_comparator_t = std::less<>;
#else
    using object_comparator_t = std::less<StringType>;
#endif

    /*!
    @brief a type for an object

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
    > An object is an unordered collection of zero or more name/value pairs,
    > where a name is a string and a value is a string, number, boolean, null,
    > object, or array.

    To store objects in C++, a type is defined by the template parameters
    described below.

    @tparam ObjectType  the container to store objects (e.g., `std::map` or
    `std::unordered_map`)
    @tparam StringType the type of the keys or names (e.g., `std::string`).
    The comparison function `std::less<StringType>` is used to order elements
    inside the container.
    @tparam AllocatorType the allocator to use for objects (e.g.,
    `std::allocator`)

    #### Default type

    With the default values for @a ObjectType (`std::map`), @a StringType
    (`std::string`), and @a AllocatorType (`std::allocator`), the default
    value for @a object_t is:

    @code {.cpp}
    std::map<
      std::string, // key_type
      basic_json, // value_type
      std::less<std::string>, // key_compare
      std::allocator<std::pair<const std::string, basic_json>> // allocator_type
    >
    @endcode

    #### Behavior

    The choice of @a object_t influences the behavior of the JSON class. With
    the default type, objects have the following behavior:

    - When all names are unique, objects will be interoperable in the sense
      that all software implementations receiving that object will agree on
      the name-value mappings.
    - When the names within an object are not unique, later stored name/value
      pairs overwrite previously stored name/value pairs, leaving the used
      names unique. For instance, `{"key": 1}` and `{"key": 2, "key": 1}` will
      be treated as equal and both stored as `{"key": 1}`.
    - Internally, name/value pairs are stored in lexicographical order of the
      names. Objects will also be serialized (see @ref dump) in this order.
      For instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored
      and serialized as `{"a": 2, "b": 1}`.
    - When comparing objects, the order of the name/value pairs is irrelevant.
      This makes objects interoperable in the sense that they will not be
      affected by these differences. For instance, `{"b": 1, "a": 2}` and
      `{"a": 2, "b": 1}` will be treated as equal.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the object's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON object.

    #### Storage

    Objects are stored as pointers in a @ref basic_json type. That is, for any
    access to object values, a pointer of type `object_t*` must be
    dereferenced.

    @sa @ref array_t -- type for an array value

    @since version 1.0.0

    @note The order name/value pairs are added to the object is *not*
    preserved by the library. Therefore, iterating an object may return
    name/value pairs in a different order than they were originally stored. In
    fact, keys will be traversed in alphabetical order as `std::map` with
    `std::less` is used by default. Please note this behavior conforms to [RFC
    7159](http://rfc7159.net/rfc7159), because any order implements the
    specified "unordered" nature of JSON objects.
    */
    using object_t = ObjectType<StringType,
          basic_json,
          object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /*!
    @brief a type for an array

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
    > An array is an ordered sequence of zero or more values.

    To store objects in C++, a type is defined by the template parameters
    explained below.

    @tparam ArrayType  container type to store arrays (e.g., `std::vector` or
    `std::list`)
    @tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)

    #### Default type

    With the default values for @a ArrayType (`std::vector`) and @a
    AllocatorType (`std::allocator`), the default value for @a array_t is:

    @code {.cpp}
    std::vector<
      basic_json, // value_type
      std::allocator<basic_json> // allocator_type
    >
    @endcode

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the array's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON array.

    #### Storage

    Arrays are stored as pointers in a @ref basic_json type. That is, for any
    access to array values, a pointer of type `array_t*` must be dereferenced.

    @sa @ref object_t -- type for an object value

    @since version 1.0.0
    */
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /*!
    @brief a type for a string

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
    > A string is a sequence of zero or more Unicode characters.

    To store objects in C++, a type is defined by the template parameter
    described below. Unicode values are split by the JSON class into
    byte-sized characters during deserialization.

    @tparam StringType  the container to store strings (e.g., `std::string`).
    Note this container is used for keys/names in objects, see @ref object_t.

    #### Default type

    With the default values for @a StringType (`std::string`), the default
    value for @a string_t is:

    @code {.cpp}
    std::string
    @endcode

    #### Encoding

    Strings are stored in UTF-8 encoding. Therefore, functions like
    `std::string::size()` or `std::string::length()` return the number of
    bytes in the string rather than the number of characters or glyphs.

    #### String comparison

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > Software implementations are typically required to test names of object
    > members for equality. Implementations that transform the textual
    > representation into sequences of Unicode code units and then perform the
    > comparison numerically, code unit by code unit, are interoperable in the
    > sense that implementations will agree in all cases on equality or
    > inequality of two strings. For example, implementations that compare
    > strings with escaped characters unconverted may incorrectly find that
    > `"a\\b"` and `"a\u005Cb"` are not equal.

    This implementation is interoperable as it does compare strings code unit
    by code unit.

    #### Storage

    String values are stored as pointers in a @ref basic_json type. That is,
    for any access to string values, a pointer of type `string_t*` must be
    dereferenced.

    @since version 1.0.0
    */
    using string_t = StringType;

    /*!
    @brief a type for a boolean

    [RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
    type which differentiates the two literals `true` and `false`.

    To store objects in C++, a type is defined by the template parameter @a
    BooleanType which chooses the type to use.

    #### Default type

    With the default values for @a BooleanType (`bool`), the default value for
    @a boolean_t is:

    @code {.cpp}
    bool
    @endcode

    #### Storage

    Boolean values are stored directly inside a @ref basic_json type.

    @since version 1.0.0
    */
    using boolean_t = BooleanType;

    /*!
    @brief a type for a number (integer)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store integer numbers in C++, a type is defined by the template
    parameter @a NumberIntegerType which chooses the type to use.

    #### Default type

    With the default values for @a NumberIntegerType (`int64_t`), the default
    value for @a number_integer_t is:

    @code {.cpp}
    int64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
    that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
    that are out of range will yield over/underflow when used in a
    constructor. During deserialization, too large or small integer numbers
    will be automatically be stored as @ref number_unsigned_t or @ref
    number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange of the exactly supported range [INT64_MIN,
    INT64_MAX], this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_integer_t = NumberIntegerType;

    /*!
    @brief a type for a number (unsigned)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store unsigned integer numbers in C++, a type is defined by the
    template parameter @a NumberUnsignedType which chooses the type to use.

    #### Default type

    With the default values for @a NumberUnsignedType (`uint64_t`), the
    default value for @a number_unsigned_t is:

    @code {.cpp}
    uint64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
    number that can be stored is `0`. Integer numbers that are out of range
    will yield over/underflow when used in a constructor. During
    deserialization, too large or small integer numbers will be automatically
    be stored as @ref number_integer_t or @ref number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange (when considered in conjunction with the
    number_integer_t type) of the exactly supported range [0, UINT64_MAX],
    this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)
    @sa @ref number_integer_t -- type for number values (integer)

    @since version 2.0.0
    */
    using number_unsigned_t = NumberUnsignedType;

    /*!
    @brief a type for a number (floating-point)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store floating-point numbers in C++, a type is defined by the template
    parameter @a NumberFloatType which chooses the type to use.

    #### Default type

    With the default values for @a NumberFloatType (`double`), the default
    value for @a number_float_t is:

    @code {.cpp}
    double
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in floating-point literals will be ignored. Internally,
      the value will be stored as decimal number. For instance, the C++
      floating-point literal `01.2` will be serialized to `1.2`. During
      deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > This specification allows implementations to set limits on the range and
    > precision of numbers accepted. Since software that implements IEEE
    > 754-2008 binary64 (double precision) numbers is generally available and
    > widely used, good interoperability can be achieved by implementations
    > that expect no more precision or range than these provide, in the sense
    > that implementations will approximate JSON numbers within the expected
    > precision.

    This implementation does exactly follow this approach, as it uses double
    precision floating-point numbers. Note values smaller than
    `-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
    will be stored as NaN internally and be serialized to `null`.

    #### Storage

    Floating-point number values are stored directly inside a @ref basic_json
    type.

    @sa @ref number_integer_t -- type for number values (integer)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_float_t = NumberFloatType;

    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * object)
        {
            AllocatorTraits::deallocate(alloc, object, 1);
        };
        std::unique_ptr<T, decltype(deleter)> object(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, object.get(), std::forward<Args>(args)...);
        assert(object != nullptr);
        return object.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::boolean:
                {
                    boolean = boolean_t(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = number_integer_t(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = number_unsigned_t(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = number_float_t(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 2.1.1")); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value)
        {
            string = create<string_t>(value);
        }

        /// constructor for rvalue strings
        json_value(string_t&& value)
        {
            string = create<string_t>(std::move(value));
        }

        /// constructor for objects
        json_value(const object_t& value)
        {
            object = create<object_t>(value);
        }

        /// constructor for rvalue objects
        json_value(object_t&& value)
        {
            object = create<object_t>(std::move(value));
        }

        /// constructor for arrays
        json_value(const array_t& value)
        {
            array = create<array_t>(value);
        }

        /// constructor for rvalue arrays
        json_value(array_t&& value)
        {
            array = create<array_t>(std::move(value));
        }

        void destroy(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
    };

    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.
    */
    void assert_invariant() const
    {
        assert(m_type != value_t::object or m_value.object != nullptr);
        assert(m_type != value_t::array or m_value.array != nullptr);
        assert(m_type != value_t::string or m_value.string != nullptr);
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /*!
    @brief parser event types

    The parser callback distinguishes the following events:
    - `object_start`: the parser read `{` and started to process a JSON object
    - `key`: the parser read a key of a value in an object
    - `object_end`: the parser read `}` and finished processing a JSON object
    - `array_start`: the parser read `[` and started to process a JSON array
    - `array_end`: the parser read `]` and finished processing a JSON array
    - `value`: the parser finished reading a JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    @sa @ref parser_callback_t for more information and examples
    */
    using parse_event_t = typename parser::parse_event_t;

    /*!
    @brief per-element parser callback type

    With a parser callback function, the result of parsing a JSON text can be
    influenced. When passed to @ref parse, it is called on certain events
    (passed as @ref parse_event_t via parameter @a event) with a set recursion
    depth @a depth and context JSON value @a parsed. The return value of the
    callback function is a boolean indicating whether the element that emitted
    the callback shall be kept or not.

    We distinguish six scenarios (determined by the event type) in which the
    callback function can be called. The following table describes the values
    of the parameters @a depth, @a event, and @a parsed.

    parameter @a event | description | parameter @a depth | parameter @a parsed
    ------------------ | ----------- | ------------------ | -------------------
    parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
    parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
    parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
    parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
    parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
    parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    Discarding a value (i.e., returning `false`) has different effects
    depending on the context in which function was called:

    - Discarded values in structured types are skipped. That is, the parser
      will behave as if the discarded value was never read.
    - In case a value outside a structured type is skipped, it is replaced
      with `null`. This case happens if the top-level element is skipped.

    @param[in] depth  the depth of the recursion during parsing

    @param[in] event  an event of type parse_event_t indicating the context in
    the callback function has been called

    @param[in,out] parsed  the current intermediate parse result; note that
    writing to this value has no effect for parse_event_t::key events

    @return Whether the JSON value which called the function during parsing
    should be kept (`true`) or not (`false`). In the latter case, it is either
    skipped completely or replaced by an empty discarded object.

    @sa @ref parse for examples

    @since version 1.0.0
    */
    using parser_callback_t = typename parser::parser_callback_t;


    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /*!
    @brief create an empty value with a given type

    Create an empty JSON value with a given type. The value will be default
    initialized with an empty value which depends on the type:

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`

    @param[in] v  the type of the value to create

    @complexity Constant.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows the constructor for different @ref
    value_t values,basic_json__value_t}

    @sa @ref clear() -- restores the postcondition of this constructor

    @since version 1.0.0
    */
    basic_json(const value_t v)
        : m_type(v), m_value(v)
    {
        assert_invariant();
    }

    /*!
    @brief create a null object

    Create a `null` JSON value. It either takes a null pointer as parameter
    (explicitly creating `null`) or no parameter (implicitly creating `null`).
    The passed null pointer itself is not read -- it is only used to choose
    the right constructor.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @liveexample{The following code shows the constructor with and without a
    null pointer parameter.,basic_json__nullptr_t}

    @since version 1.0.0
    */
    basic_json(std::nullptr_t = nullptr) noexcept
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /*!
    @brief create a JSON value

    This is a "catch all" constructor for all compatible JSON types; that is,
    types for which a `to_json()` method exists. The constructor forwards the
    parameter @a val to that method (to `json_serializer<U>::to_json` method
    with `U = uncvref_t<CompatibleType>`, to be exact).

    Template type @a CompatibleType includes, but is not limited to, the
    following types:
    - **arrays**: @ref array_t and all kinds of compatible containers such as
      `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
      `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
      `std::multiset`, and `std::unordered_multiset` with a `value_type` from
      which a @ref basic_json value can be constructed.
    - **objects**: @ref object_t and all kinds of compatible associative
      containers such as `std::map`, `std::unordered_map`, `std::multimap`,
      and `std::unordered_multimap` with a `key_type` compatible to
      @ref string_t and a `value_type` from which a @ref basic_json value can
      be constructed.
    - **strings**: @ref string_t, string literals, and all compatible string
      containers can be used.
    - **numbers**: @ref number_integer_t, @ref number_unsigned_t,
      @ref number_float_t, and all convertible number types such as `int`,
      `size_t`, `int64_t`, `float` or `double` can be used.
    - **boolean**: @ref boolean_t / `bool` can be used.

    See the examples below.

    @tparam CompatibleType a type such that:
    - @a CompatibleType is not derived from `std::istream`,
    - @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
         constructors),
    - @a CompatibleType is not a @ref basic_json nested type (e.g.,
         @ref json_pointer, @ref iterator, etc ...)
    - @ref @ref json_serializer<U> has a
         `to_json(basic_json_t&, CompatibleType&&)` method

    @tparam U = `uncvref_t<CompatibleType>`

    @param[in] val the value to be forwarded to the respective constructor

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @liveexample{The following code shows the constructor with several
    compatible types.,basic_json__CompatibleType}

    @since version 2.1.0
    */
    template<typename CompatibleType, typename U = detail::uncvref_t<CompatibleType>,
             detail::enable_if_t<not std::is_base_of<std::istream, U>::value and
                                 not std::is_same<U, basic_json_t>::value and
                                 not detail::is_basic_json_nested_type<
                                     basic_json_t, U>::value and
                                 detail::has_to_json<basic_json, U>::value,
                                 int> = 0>
    basic_json(CompatibleType && val) noexcept(noexcept(JSONSerializer<U>::to_json(
                std::declval<basic_json_t&>(), std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        assert_invariant();
    }

    /*!
    @brief create a container (array or object) from an initializer list

    Creates a JSON value of type array or object from the passed initializer
    list @a init. In case @a type_deduction is `true` (default), the type of
    the JSON value to be created is deducted from the initializer list @a init
    according to the following rules:

    1. If the list is empty, an empty JSON object value `{}` is created.
    2. If the list consists of pairs whose first element is a string, a JSON
       object value is created where the first elements of the pairs are
       treated as keys and the second elements are as values.
    3. In all other cases, an array is created.

    The rules aim to create the best fit between a C++ initializer list and
    JSON values. The rationale is as follows:

    1. The empty initializer list is written as `{}` which is exactly an empty
       JSON object.
    2. C++ has no way of describing mapped types other than to list a list of
       pairs. As JSON requires that keys must be of type string, rule 2 is the
       weakest constraint one can pose on initializer lists to interpret them
       as an object.
    3. In all other cases, the initializer list could not be interpreted as
       JSON object type, so interpreting it as JSON array type is safe.

    With the rules described above, the following JSON values cannot be
    expressed by an initializer list:

    - the empty array (`[]`): use @ref array(initializer_list_t)
      with an empty initializer list in this case
    - arrays whose elements satisfy rule 2: use @ref
      array(initializer_list_t) with the same initializer list
      in this case

    @note When used without parentheses around an empty initializer list, @ref
    basic_json() is called instead of this function, yielding the JSON null
    value.

    @param[in] init  initializer list with JSON values

    @param[in] type_deduction internal parameter; when set to `true`, the type
    of the JSON value is deducted from the initializer list @a init; when set
    to `false`, the type provided via @a manual_type is forced. This mode is
    used by the functions @ref array(initializer_list_t) and
    @ref object(initializer_list_t).

    @param[in] manual_type internal parameter; when @a type_deduction is set
    to `false`, the created JSON value will use the provided type (only @ref
    value_t::array and @ref value_t::object are valid); when @a type_deduction
    is set to `true`, this parameter has no effect

    @throw type_error.301 if @a type_deduction is `false`, @a manual_type is
    `value_t::object`, but @a init contains an element which is not a pair
    whose first element is a string. In this case, the constructor could not
    create an object. If @a type_deduction would have be `true`, an array
    would have been created. See @ref object(initializer_list_t)
    for an example.

    @complexity Linear in the size of the initializer list @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows how JSON values are created from
    initializer lists.,basic_json__list_init_t}

    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            return (element_ref->is_array() and element_ref->size() == 2 and (*element_ref)[0].is_string());
        });

        // adjust type if type deduction is not wanted
        if (not type_deduction)
        {
            // if array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if object is wanted but impossible, throw an exception
            if (JSON_UNLIKELY(manual_type == value_t::object and not is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list"));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create object
            m_type = value_t::object;
            m_value = value_t::object;

            std::for_each(init.begin(), init.end(), [this](const detail::json_ref<basic_json>& element_ref)
            {
                auto element = element_ref.moved_or_copied();
                m_value.object->emplace(
                    std::move(*((*element.m_value.array)[0].m_value.string)),
                    std::move((*element.m_value.array)[1]));
            });
        }
        else
        {
            // the initializer list describes an array -> create array
            m_type = value_t::array;
            m_value.array = create<array_t>(init.begin(), init.end());
        }

        assert_invariant();
    }

    /*!
    @brief explicitly create an array from an initializer list

    Creates a JSON array value from a given initializer list. That is, given a
    list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
    initializer list is empty, the empty array `[]` is created.

    @note This function is only needed to express two edge cases that cannot
    be realized with the initializer list constructor (@ref
    basic_json(initializer_list_t, bool, value_t)). These cases
    are:
    1. creating an array whose elements are all pairs whose first element is a
    string -- in this case, the initializer list constructor would create an
    object, taking the first elements as keys
    2. creating an empty array -- passing the empty initializer list to the
    initializer list constructor yields an empty object

    @param[in] init  initializer list with JSON values to create an array from
    (optional)

    @return JSON array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `array`
    function.,array}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /*!
    @brief explicitly create an object from an initializer list

    Creates a JSON object value from a given initializer list. The initializer
    lists elements must be pairs, and their first elements must be strings. If
    the initializer list is empty, the empty object `{}` is created.

    @note This function is only added for symmetry reasons. In contrast to the
    related function @ref array(initializer_list_t), there are
    no cases which can only be expressed by this function. That is, any
    initializer list @a init can also be passed to the initializer list
    constructor @ref basic_json(initializer_list_t, bool, value_t).

    @param[in] init  initializer list to create an object from (optional)

    @return JSON object value

    @throw type_error.301 if @a init is not a list of pairs whose first
    elements are strings. In this case, no object can be created. When such a
    value is passed to @ref basic_json(initializer_list_t, bool, value_t),
    an array would have been created from the passed initializer list @a init.
    See example below.

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `object`
    function.,object}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list

    @since version 1.0.0
    */
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /*!
    @brief construct an array with count copies of given value

    Constructs a JSON array value by creating @a cnt copies of a passed value.
    In case @a cnt is `0`, an empty array is created.

    @param[in] cnt  the number of JSON copies of @a val to create
    @param[in] val  the JSON value to copy

    @post `std::distance(begin(),end()) == cnt` holds.

    @complexity Linear in @a cnt.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows examples for the @ref
    basic_json(size_type\, const basic_json&)
    constructor.,basic_json__size_type_basic_json}

    @since version 1.0.0
    */
    basic_json(size_type cnt, const basic_json& val)
        : m_type(value_t::array)
    {
        m_value.array = create<array_t>(cnt, val);
        assert_invariant();
    }

    /*!
    @brief construct a JSON container given an iterator range

    Constructs the JSON value with the contents of the range `[first, last)`.
    The semantics depends on the different types a JSON value can have:
    - In case of a null type, invalid_iterator.206 is thrown.
    - In case of other primitive types (number, boolean, or string), @a first
      must be `begin()` and @a last must be `end()`. In this case, the value is
      copied. Otherwise, invalid_iterator.204 is thrown.
    - In case of structured types (array, object), the constructor behaves as
      similar versions for `std::vector` or `std::map`; that is, a JSON array
      or object is constructed from the values in the range.

    @tparam InputIT an input iterator type (@ref iterator or @ref
    const_iterator)

    @param[in] first begin of the range to copy from (included)
    @param[in] last end of the range to copy from (excluded)

    @pre Iterators @a first and @a last must be initialized. **This
         precondition is enforced with an assertion (see warning).** If
         assertions are switched off, a violation of this precondition yields
         undefined behavior.

    @pre Range `[first, last)` is valid. Usually, this precondition cannot be
         checked efficiently. Only certain edge cases are detected; see the
         description of the exceptions below. A violation of this precondition
         yields undefined behavior.

    @warning A precondition is enforced with a runtime assertion that will
             result in calling `std::abort` if this precondition is not met.
             Assertions can be disabled by defining `NDEBUG` at compile time.
             See http://en.cppreference.com/w/cpp/error/assert for more
             information.

    @throw invalid_iterator.201 if iterators @a first and @a last are not
    compatible (i.e., do not belong to the same JSON value). In this case,
    the range `[first, last)` is undefined.
    @throw invalid_iterator.204 if iterators @a first and @a last belong to a
    primitive type (number, boolean, or string), but @a first does not point
    to the first element any more. In this case, the range `[first, last)` is
    undefined. See example code below.
    @throw invalid_iterator.206 if iterators @a first and @a last belong to a
    null value. In this case, the range `[first, last)` is undefined.

    @complexity Linear in distance between @a first and @a last.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows several ways to create JSON values by
    specifying a subrange with iterators.,basic_json__InputIt_InputIt}

    @since version 1.0.0
    */
    template<class InputIT, typename std::enable_if<
                 std::is_same<InputIT, typename basic_json_t::iterator>::value or
                 std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int>::type = 0>
    basic_json(InputIT first, InputIT last)
    {
        assert(first.m_object != nullptr);
        assert(last.m_object != nullptr);

        // make sure iterator fits the current value
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible"));
        }

        // copy type from first iterator
        m_type = first.m_object->m_type;

        // check if iterator range is complete for primitive values
        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_UNLIKELY(not first.m_it.primitive_iterator.is_begin()
                                  or not last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }
                break;
            }

            default:
                break;
        }

        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = first.m_object->m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = first.m_object->m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = first.m_object->m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = first.m_object->m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_value = *first.m_object->m_value.string;
                break;
            }

            case value_t::object:
            {
                m_value.object = create<object_t>(first.m_it.object_iterator,
                                                  last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_value.array = create<array_t>(first.m_it.array_iterator,
                                                last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " +
                                                    std::string(first.m_object->type_name())));
        }

        assert_invariant();
    }


    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    /// @private
    basic_json(const detail::json_ref<basic_json>& ref)
        : basic_json(ref.moved_or_copied())
    {}

    /*!
    @brief copy constructor

    Creates a copy of a given JSON value.

    @param[in] other  the JSON value to copy

    @post `*this == other`

    @complexity Linear in the size of @a other.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is linear.
    - As postcondition, it holds: `other == basic_json(other)`.

    @liveexample{The following code shows an example for the copy
    constructor.,basic_json__basic_json}

    @since version 1.0.0
    */
    basic_json(const basic_json& other)
        : m_type(other.m_type)
    {
        // check of passed value is valid
        other.assert_invariant();

        switch (m_type)
        {
            case value_t::object:
            {
                m_value = *other.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_value = *other.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_value = *other.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_value = other.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_value = other.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value = other.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value = other.m_value.number_float;
                break;
            }

            default:
                break;
        }

        assert_invariant();
    }

    /*!
    @brief move constructor

    Move constructor. Constructs a JSON value with the contents of the given
    value @a other using move semantics. It "steals" the resources from @a
    other and leaves it as JSON null value.

    @param[in,out] other  value to move to this object

    @post `*this` has the same value as @a other before the call.
    @post @a other is a JSON null value.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @requirement This function helps `basic_json` satisfying the
    [MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible)
    requirements.

    @liveexample{The code below shows the move constructor explicitly called
    via std::move.,basic_json__moveconstructor}

    @since version 1.0.0
    */
    basic_json(basic_json&& other) noexcept
        : m_type(std::move(other.m_type)),
          m_value(std::move(other.m_value))
    {
        // check that passed value is valid
        other.assert_invariant();

        // invalidate payload
        other.m_type = value_t::null;
        other.m_value = {};

        assert_invariant();
    }

    /*!
    @brief copy assignment

    Copy assignment operator. Copies a JSON value via the "copy and swap"
    strategy: It is expressed in terms of the copy constructor, destructor,
    and the `swap()` member function.

    @param[in] other  value to copy from

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is linear.

    @liveexample{The code below shows and example for the copy assignment. It
    creates a copy of value `a` which is then swapped with `b`. Finally\, the
    copy of `a` (which is the null value after the swap) is
    destroyed.,basic_json__copyassignment}

    @since version 1.0.0
    */
    reference& operator=(basic_json other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value and
        std::is_nothrow_move_assignable<value_t>::value and
        std::is_nothrow_move_constructible<json_value>::value and
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        // check that passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_type, other.m_type);
        swap(m_value, other.m_value);

        assert_invariant();
        return *this;
    }

    /*!
    @brief destructor

    Destroys the JSON value and frees all allocated memory.

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is linear.
    - All stored elements are destroyed and all memory is freed.

    @since version 1.0.0
    */
    ~basic_json()
    {
        assert_invariant();
        m_value.destroy(m_type);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /*!
    @brief serialization

    Serialization function for JSON values. The function tries to mimic
    Python's `json.dumps()` function, and currently supports its @a indent
    and @a ensure_ascii parameters.

    @param[in] indent If indent is nonnegative, then array elements and object
    members will be pretty-printed with that indent level. An indent level of
    `0` will only insert newlines. `-1` (the default) selects the most compact
    representation.
    @param[in] indent_char The character to use for indentation if @a indent is
    greater than `0`. The default is ` ` (space).
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.

    @return string containing the serialization of the JSON value

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @liveexample{The following example shows the effect of different @a indent\,
    @a indent_char\, and @a ensure_ascii parameters to the result of the
    serialization.,dump}

    @see https://docs.python.org/2/library/json.html#json.dump

    @since version 1.0.0; indentation character @a indent_char, option
           @a ensure_ascii and exceptions added in version 3.0.0
    */
    string_t dump(const int indent = -1, const char indent_char = ' ',
                  const bool ensure_ascii = false) const
    {
        string_t result;
        serializer s(detail::output_adapter<char>(result), indent_char);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /*!
    @brief return the type of the JSON value (explicit)

    Return the type of the JSON value as a value from the @ref value_t
    enumeration.

    @return the type of the JSON value
            Value type                | return value
            ------------------------- | -------------------------
            null                      | value_t::null
            boolean                   | value_t::boolean
            string                    | value_t::string
            number (integer)          | value_t::number_integer
            number (unsigned integer) | value_t::number_unsigned
            number (floating-point)   | value_t::number_float
            object                    | value_t::object
            array                     | value_t::array
            discarded                 | value_t::discarded

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `type()` for all JSON
    types.,type}

    @sa @ref operator value_t() -- return the type of the JSON value (implicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr value_t type() const noexcept
    {
        return m_type;
    }

    /*!
    @brief return whether type is primitive

    This function returns true if and only if the JSON type is primitive
    (string, number, boolean, or null).

    @return `true` if type is primitive (string, number, boolean, or null),
    `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_primitive()` for all JSON
    types.,is_primitive}

    @sa @ref is_structured() -- returns whether JSON value is structured
    @sa @ref is_null() -- returns whether JSON value is `null`
    @sa @ref is_string() -- returns whether JSON value is a string
    @sa @ref is_boolean() -- returns whether JSON value is a boolean
    @sa @ref is_number() -- returns whether JSON value is a number

    @since version 1.0.0
    */
    constexpr bool is_primitive() const noexcept
    {
        return is_null() or is_string() or is_boolean() or is_number();
    }

    /*!
    @brief return whether type is structured

    This function returns true if and only if the JSON type is structured
    (array or object).

    @return `true` if type is structured (array or object), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_structured()` for all JSON
    types.,is_structured}

    @sa @ref is_primitive() -- returns whether value is primitive
    @sa @ref is_array() -- returns whether value is an array
    @sa @ref is_object() -- returns whether value is an object

    @since version 1.0.0
    */
    constexpr bool is_structured() const noexcept
    {
        return is_array() or is_object();
    }

    /*!
    @brief return whether value is null

    This function returns true if and only if the JSON value is null.

    @return `true` if type is null, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_null()` for all JSON
    types.,is_null}

    @since version 1.0.0
    */
    constexpr bool is_null() const noexcept
    {
        return (m_type == value_t::null);
    }

    /*!
    @brief return whether value is a boolean

    This function returns true if and only if the JSON value is a boolean.

    @return `true` if type is boolean, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_boolean()` for all JSON
    types.,is_boolean}

    @since version 1.0.0
    */
    constexpr bool is_boolean() const noexcept
    {
        return (m_type == value_t::boolean);
    }

    /*!
    @brief return whether value is a number

    This function returns true if and only if the JSON value is a number. This
    includes both integer (signed and unsigned) and floating-point values.

    @return `true` if type is number (regardless whether integer, unsigned
    integer or floating-type), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number()` for all JSON
    types.,is_number}

    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() or is_number_float();
    }

    /*!
    @brief return whether value is an integer number

    This function returns true if and only if the JSON value is a signed or
    unsigned integer number. This excludes floating-point values.

    @return `true` if type is an integer or unsigned integer number, `false`
    otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_integer()` for all
    JSON types.,is_number_integer}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number_integer() const noexcept
    {
        return (m_type == value_t::number_integer or m_type == value_t::number_unsigned);
    }

    /*!
    @brief return whether value is an unsigned integer number

    This function returns true if and only if the JSON value is an unsigned
    integer number. This excludes floating-point and signed integer values.

    @return `true` if type is an unsigned integer number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_unsigned()` for all
    JSON types.,is_number_unsigned}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 2.0.0
    */
    constexpr bool is_number_unsigned() const noexcept
    {
        return (m_type == value_t::number_unsigned);
    }

    /*!
    @brief return whether value is a floating-point number

    This function returns true if and only if the JSON value is a
    floating-point number. This excludes signed and unsigned integer values.

    @return `true` if type is a floating-point number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_float()` for all
    JSON types.,is_number_float}

    @sa @ref is_number() -- check if value is number
    @sa @ref is_number_integer() -- check if value is an integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number

    @since version 1.0.0
    */
    constexpr bool is_number_float() const noexcept
    {
        return (m_type == value_t::number_float);
    }

    /*!
    @brief return whether value is an object

    This function returns true if and only if the JSON value is an object.

    @return `true` if type is object, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_object()` for all JSON
    types.,is_object}

    @since version 1.0.0
    */
    constexpr bool is_object() const noexcept
    {
        return (m_type == value_t::object);
    }

    /*!
    @brief return whether value is an array

    This function returns true if and only if the JSON value is an array.

    @return `true` if type is array, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_array()` for all JSON
    types.,is_array}

    @since version 1.0.0
    */
    constexpr bool is_array() const noexcept
    {
        return (m_type == value_t::array);
    }

    /*!
    @brief return whether value is a string

    This function returns true if and only if the JSON value is a string.

    @return `true` if type is string, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_string()` for all JSON
    types.,is_string}

    @since version 1.0.0
    */
    constexpr bool is_string() const noexcept
    {
        return (m_type == value_t::string);
    }

    /*!
    @brief return whether value is discarded

    This function returns true if and only if the JSON value was discarded
    during parsing with a callback function (see @ref parser_callback_t).

    @note This function will always be `false` for JSON values after parsing.
    That is, discarded values can only occur during parsing, but will be
    removed when inside a structured value or replaced by null in other cases.

    @return `true` if type is discarded, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_discarded()` for all JSON
    types.,is_discarded}

    @since version 1.0.0
    */
    constexpr bool is_discarded() const noexcept
    {
        return (m_type == value_t::discarded);
    }

    /*!
    @brief return the type of the JSON value (implicit)

    Implicitly return the type of the JSON value as a value from the @ref
    value_t enumeration.

    @return the type of the JSON value

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies the @ref value_t operator for
    all JSON types.,operator__value_t}

    @sa @ref type() -- return the type of the JSON value (explicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr operator value_t() const noexcept
    {
        return m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_LIKELY(is_boolean()))
        {
            return m_value.boolean;
        }

        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name())));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType, detail::enable_if_t<
                 std::is_same<typename std::remove_const<BasicJsonType>::type, basic_json_t>::value,
                 int> = 0>
    basic_json get() const
    {
        return *this;
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible)
    and [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
             detail::enable_if_t <
                 not std::is_same<basic_json_t, ValueType>::value and
                 detail::has_from_json<basic_json_t, ValueType>::value and
                 not detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                 int> = 0>
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(not std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        static_assert(std::is_default_constructible<ValueType>::value,
                      "types must be DefaultConstructible when used with get()");

        ValueType ret;
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible)
    and **not** [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueTypeCV>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
             detail::enable_if_t<not std::is_same<basic_json_t, ValueType>::value and
                                 detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                                 int> = 0>
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueTypeCV>::from_json(std::declval<const basic_json_t&>())))
    {
        static_assert(not std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return JSONSerializer<ValueTypeCV>::from_json(*this);
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    PointerType get() noexcept
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    constexpr const PointerType get() const noexcept
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a pointer value (implicit)

    Implicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning Writing data to the pointee of the result yields an undefined
    state.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t. Enforced by a static
    assertion.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get_ptr}

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    PointerType get_ptr() noexcept
    {
        // get the type of the PointerType (remove pointer and const)
        using pointee_t = typename std::remove_const<typename
                          std::remove_pointer<typename
                          std::remove_const<PointerType>::type>::type>::type;
        // make sure the type matches the allowed types
        static_assert(
            std::is_same<object_t, pointee_t>::value
            or std::is_same<array_t, pointee_t>::value
            or std::is_same<string_t, pointee_t>::value
            or std::is_same<boolean_t, pointee_t>::value
            or std::is_same<number_integer_t, pointee_t>::value
            or std::is_same<number_unsigned_t, pointee_t>::value
            or std::is_same<number_float_t, pointee_t>::value
            , "incompatible pointer type");

        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (implicit)
    @copydoc get_ptr()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value and
                 std::is_const<typename std::remove_pointer<PointerType>::type>::value, int>::type = 0>
    constexpr const PointerType get_ptr() const noexcept
    {
        // get the type of the PointerType (remove pointer and const)
        using pointee_t = typename std::remove_const<typename
                          std::remove_pointer<typename
                          std::remove_const<PointerType>::type>::type>::type;
        // make sure the type matches the allowed types
        static_assert(
            std::is_same<object_t, pointee_t>::value
            or std::is_same<array_t, pointee_t>::value
            or std::is_same<string_t, pointee_t>::value
            or std::is_same<boolean_t, pointee_t>::value
            or std::is_same<number_integer_t, pointee_t>::value
            or std::is_same<number_unsigned_t, pointee_t>::value
            or std::is_same<number_float_t, pointee_t>::value
            , "incompatible pointer type");

        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a reference value (implicit)

    Implicit reference access to the internally stored JSON value. No copies
    are made.

    @warning Writing data to the referee of the result yields an undefined
    state.

    @tparam ReferenceType reference type; must be a reference to @ref array_t,
    @ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
    @ref number_float_t. Enforced by static assertion.

    @return reference to the internally stored JSON value if the requested
    reference type @a ReferenceType fits to the JSON value; throws
    type_error.303 otherwise

    @throw type_error.303 in case passed type @a ReferenceType is incompatible
    with the stored JSON value; see example below

    @complexity Constant.

    @liveexample{The example shows several calls to `get_ref()`.,get_ref}

    @since version 1.1.0
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a reference value (implicit)
    @copydoc get_ref()
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value and
                 std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int>::type = 0>
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   not std::is_pointer<ValueType>::value and
                   not std::is_same<ValueType, detail::json_ref<basic_json>>::value and
                   not std::is_same<ValueType, typename string_t::value_type>::value
#ifndef _MSC_VER  // fix for issue #167 operator<< ambiguity under VS2015
                   and not std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
#endif
#if defined(JSON_HAS_CPP_17)
                   and not std::is_same<ValueType, typename std::string_view>::value
#endif
                   , int >::type = 0 >
    operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /// @}


    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /*!
    @brief access specified array element with bounds checking

    Returns a reference to the element at specified location @a idx, with
    bounds checking.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__size_type}
    */
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element with bounds checking

    Returns a const reference to the element at specified location @a idx,
    with bounds checking.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__size_type_const}
    */
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a reference to the element at with specified key @a key, with
    bounds checking.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__object_t_key_type}
    */
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a const reference to the element at with specified key @a key,
    with bounds checking.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__object_t_key_type_const}
    */
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element

    Returns a reference to the element at specified location @a idx.

    @note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
    then the array is silently filled up with `null` values to make `idx` a
    valid reference to the last stored element.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array or null; in that
    cases, using the [] operator with an index makes no sense.

    @complexity Constant if @a idx is in the range of the array. Otherwise
    linear in `idx - size()`.

    @liveexample{The example below shows how array elements can be read and
    written using `[]` operator. Note the addition of `null`
    values.,operatorarray__size_type}

    @since version 1.0.0
    */
    reference operator[](size_type idx)
    {
        // implicitly convert null value to an empty array
        if (is_null())
        {
            m_type = value_t::array;
            m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            // fill up array with null values if given idx is outside range
            if (idx >= m_value.array->size())
            {
                m_value.array->insert(m_value.array->end(),
                                      idx - m_value.array->size() + 1,
                                      basic_json());
            }

            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with " + std::string(type_name())));
    }

    /*!
    @brief access specified array element

    Returns a const reference to the element at specified location @a idx.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array; in that case,
    using the [] operator with an index makes no sense.

    @complexity Constant.

    @liveexample{The example below shows how array elements can be read using
    the `[]` operator.,operatorarray__size_type_const}

    @since version 1.0.0
    */
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    reference operator[](const typename object_t::key_type& key)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_LIKELY(is_object()))
        {
            assert(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    reference operator[](T* key)
    {
        // implicitly convert null to object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    const_reference operator[](T* key) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            assert(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(key);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const typename object_t::key_type&), this function
    does not throw if the given key @a key was not found.

    @note Unlike @ref operator[](const typename object_t::key_type& key), this
    function does not implicitly add an element to the position defined by @a
    key. This function is furthermore also applicable to const objects.

    @param[in] key  key of the element to access
    @param[in] default_value  the value to return if @a key is not found

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference

    @since version 1.0.0
    */
    template<class ValueType, typename std::enable_if<
                 std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(key);
            if (it != end())
            {
                return *it;
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const typename object_t::key_type&, ValueType) const
    */
    string_t value(const typename object_t::key_type& key, const char* default_value) const
    {
        return value(key, string_t(default_value));
    }

    /*!
    @brief access specified object element via JSON Pointer with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(ptr);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const json_pointer&), this function does not throw
    if the given key @a key was not found.

    @param[in] ptr  a JSON pointer to the element to access
    @param[in] default_value  the value to return if @a ptr found no value

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.306 if the JSON value is not an objec; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value_ptr}

    @sa @ref operator[](const json_pointer&) for unchecked access by reference

    @since version 2.0.2
    */
    template<class ValueType, typename std::enable_if<
                 std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            // if pointer resolves a value, return it or use default value
            JSON_TRY
            {
                return ptr.get_checked(this);
            }
            JSON_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const json_pointer&, ValueType) const
    */
    string_t value(const json_pointer& ptr, const char* default_value) const
    {
        return value(ptr, string_t(default_value));
    }

    /*!
    @brief access the first element

    Returns a reference to the first element in the container. For a JSON
    container `c`, the expression `c.front()` is equivalent to `*c.begin()`.

    @return In case of a structured type (array or object), a reference to the
    first element is returned. In case of number, string, or boolean values, a
    reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on `null` value

    @liveexample{The following code shows an example for `front()`.,front}

    @sa @ref back() -- access the last element

    @since version 1.0.0
    */
    reference front()
    {
        return *begin();
    }

    /*!
    @copydoc basic_json::front()
    */
    const_reference front() const
    {
        return *cbegin();
    }

    /*!
    @brief access the last element

    Returns a reference to the last element in the container. For a JSON
    container `c`, the expression `c.back()` is equivalent to
    @code {.cpp}
    auto tmp = c.end();
    --tmp;
    return *tmp;
    @endcode

    @return In case of a structured type (array or object), a reference to the
    last element is returned. In case of number, string, or boolean values, a
    reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on a `null` value. See example
    below.

    @liveexample{The following code shows an example for `back()`.,back}

    @sa @ref front() -- access the first element

    @since version 1.0.0
    */
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /*!
    @copydoc basic_json::back()
    */
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /*!
    @brief remove element given an iterator

    Removes the element specified by iterator @a pos. The iterator @a pos must
    be valid and dereferenceable. Thus the `end()` iterator (which is valid,
    but is not dereferenceable) cannot be used as a value for @a pos.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] pos iterator to the element to remove
    @return Iterator following the last removed element. If the iterator @a
    pos refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.202 if called on an iterator which does not belong
    to the current JSON value; example: `"iterator does not fit current
    value"`
    @throw invalid_iterator.205 if called on a primitive type with invalid
    iterator (i.e., any iterator which is not `begin()`); example: `"iterator
    out of range"`

    @complexity The complexity depends on the type:
    - objects: amortized constant
    - arrays: linear in distance between @a pos and the end of the container
    - strings: linear in the length of the string
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType}

    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_same<IteratorType, typename basic_json_t::iterator>::value or
                 std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
             = 0>
    IteratorType erase(IteratorType pos)
    {
        // make sure iterator fits the current value
        if (JSON_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_UNLIKELY(not pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove elements given an iterator range

    Removes the element specified by the range `[first; last)`. The iterator
    @a first does not need to be dereferenceable if `first == last`: erasing
    an empty range is a no-op.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] first iterator to the beginning of the range to remove
    @param[in] last iterator past the end of the range to remove
    @return Iterator following the last removed element. If the iterator @a
    second refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.203 if called on iterators which does not belong
    to the current JSON value; example: `"iterators do not fit current value"`
    @throw invalid_iterator.204 if called on a primitive type with invalid
    iterators (i.e., if `first != begin()` and `last != end()`); example:
    `"iterators out of range"`

    @complexity The complexity depends on the type:
    - objects: `log(size()) + std::distance(first, last)`
    - arrays: linear in the distance between @a first and @a last, plus linear
      in the distance between @a last and end of the container
    - strings: linear in the length of the string
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType_IteratorType}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_same<IteratorType, typename basic_json_t::iterator>::value or
                 std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
             = 0>
    IteratorType erase(IteratorType first, IteratorType last)
    {
        // make sure iterator fits the current value
        if (JSON_UNLIKELY(this != first.m_object or this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_LIKELY(not first.m_it.primitive_iterator.is_begin()
                                or not last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove element from a JSON object given a key

    Removes elements from a JSON object with the key value @a key.

    @param[in] key value of the elements to remove

    @return Number of elements removed. If @a ObjectType is the default
    `std::map` type, the return value will always be `0` (@a key was not
    found) or `1` (@a key was found).

    @post References and iterators to the erased elements are invalidated.
    Other references and iterators are not affected.

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`

    @complexity `log(size()) + count(key)`

    @liveexample{The example shows the effect of `erase()`.,erase__key_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    size_type erase(const typename object_t::key_type& key)
    {
        // this erase only works for objects
        if (JSON_LIKELY(is_object()))
        {
            return m_value.object->erase(key);
        }

        JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
    }

    /*!
    @brief remove element from a JSON array given an index

    Removes element from a JSON array at the index @a idx.

    @param[in] idx index of the element to remove

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`
    @throw out_of_range.401 when `idx >= size()`; example: `"array index 17
    is out of range"`

    @complexity Linear in distance between @a idx and the end of the container.

    @liveexample{The example shows the effect of `erase()`.,erase__size_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key

    @since version 1.0.0
    */
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            if (JSON_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }

            m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }
    }

    /// @}


    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /*!
    @brief find an element in a JSON object

    Finds an element in a JSON object with key equivalent to @a key. If the
    element is not found or the JSON value is not an object, end() is
    returned.

    @note This method always returns @ref end() when executed on a JSON type
          that is not an object.

    @param[in] key key value of the element to search for.

    @return Iterator to an element with key equivalent to @a key. If no such
    element is found or the JSON value is not an object, past-the-end (see
    @ref end()) iterator is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `find()` is used.,find__key_type}

    @since version 1.0.0
    */
    template<typename KeyT>
    iterator find(KeyT&& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief find an element in a JSON object
    @copydoc find(KeyT&&)
    */
    template<typename KeyT>
    const_iterator find(KeyT&& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief returns the number of occurrences of a key in a JSON object

    Returns the number of elements with key @a key. If ObjectType is the
    default `std::map` type, the return value will always be `0` (@a key was
    not found) or `1` (@a key was found).

    @note This method always returns `0` when executed on a JSON type that is
          not an object.

    @param[in] key key value of the element to count

    @return Number of elements with key @a key. If the JSON value is not an
    object, the return value will be `0`.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `count()` is used.,count}

    @since version 1.0.0
    */
    template<typename KeyT>
    size_type count(KeyT&& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
    }

    /// @}


    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /*!
    @brief returns an iterator to the first element

    Returns an iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `begin()`.,begin}

    @sa @ref cbegin() -- returns a const iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @copydoc basic_json::cbegin()
    */
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /*!
    @brief returns a const iterator to the first element

    Returns a const iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).begin()`.

    @liveexample{The following code shows an example for `cbegin()`.,cbegin}

    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @brief returns an iterator to one past the last element

    Returns an iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `end()`.,end}

    @sa @ref cend() -- returns a const iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @copydoc basic_json::cend()
    */
    const_iterator end() const noexcept
    {
        return cend();
    }

    /*!
    @brief returns a const iterator to one past the last element

    Returns a const iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).end()`.

    @liveexample{The following code shows an example for `cend()`.,cend}

    @sa @ref end() -- returns an iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @brief returns an iterator to the reverse-beginning

    Returns an iterator to the reverse-beginning; that is, the last element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(end())`.

    @liveexample{The following code shows an example for `rbegin()`.,rbegin}

    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /*!
    @copydoc basic_json::crbegin()
    */
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /*!
    @brief returns an iterator to the reverse-end

    Returns an iterator to the reverse-end; that is, one before the first
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(begin())`.

    @liveexample{The following code shows an example for `rend()`.,rend}

    @sa @ref crend() -- returns a const reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /*!
    @copydoc basic_json::crend()
    */
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /*!
    @brief returns a const reverse iterator to the last element

    Returns a const iterator to the reverse-beginning; that is, the last
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.

    @liveexample{The following code shows an example for `crbegin()`.,crbegin}

    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /*!
    @brief returns a const reverse iterator to one before the first

    Returns a const reverse iterator to the reverse-end; that is, one before
    the first element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rend()`.

    @liveexample{The following code shows an example for `crend()`.,crend}

    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /*!
    @brief wrapper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without iterator_wrapper:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without iterator proxy:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with iterator proxy:

    @code{cpp}
    for (auto it : json::iterator_wrapper(j_object))
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example).

    @param[in] ref  reference to a JSON value
    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the wrapper is used,iterator_wrapper}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @note The name of this function is not yet final and may change in the
    future.
    */
    static iteration_proxy<iterator> iterator_wrapper(reference ref)
    {
        return iteration_proxy<iterator>(ref);
    }

    /*!
    @copydoc iterator_wrapper(reference)
    */
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref)
    {
        return iteration_proxy<const_iterator>(ref);
    }

    /// @}


    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /*!
    @brief checks whether the container is empty.

    Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `true`
            boolean     | `false`
            string      | `false`
            number      | `false`
            object      | result of function `object_t::empty()`
            array       | result of function `array_t::empty()`

    @liveexample{The following code uses `empty()` to check if a JSON
    object contains any elements.,empty}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `empty()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return whether a string stored as JSON value
    is empty - it returns whether the JSON container itself is empty which is
    false in the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `begin() == end()`.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    bool empty() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_value.object->empty();
            }

            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /*!
    @brief returns the number of elements

    Returns the number of elements in a JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0`
            boolean     | `1`
            string      | `1`
            number      | `1`
            object      | result of function object_t::size()
            array       | result of function array_t::size()

    @liveexample{The following code calls `size()` on the different value
    types.,size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their size() functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return the length of a string stored as JSON
    value - it returns the number of elements in the JSON value which is 1 in
    the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `std::distance(begin(), end())`.

    @sa @ref empty() -- checks whether the container is empty
    @sa @ref max_size() -- returns the maximal number of elements

    @since version 1.0.0
    */
    size_type size() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_value.object->size();
            }

            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /*!
    @brief returns the maximum possible number of elements

    Returns the maximum number of elements a JSON value is able to hold due to
    system or library implementation limitations, i.e. `std::distance(begin(),
    end())` for the JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0` (same as `size()`)
            boolean     | `1` (same as `size()`)
            string      | `1` (same as `size()`)
            number      | `1` (same as `size()`)
            object      | result of function `object_t::max_size()`
            array       | result of function `array_t::max_size()`

    @liveexample{The following code calls `max_size()` on the different value
    types. Note the output is implementation specific.,max_size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `max_size()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @requirement This function helps `basic_json` satisfying the
    [Container](http://en.cppreference.com/w/cpp/concept/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of returning `b.size()` where `b` is the largest
      possible JSON value.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    size_type max_size() const noexcept
    {
        switch (m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_value.object->max_size();
            }

            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}


    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /*!
    @brief clears the contents

    Clears the content of a JSON value and resets it to the default value as
    if @ref basic_json(value_t) would have been called with the current value
    type from @ref type():

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`

    @post Has the same effect as calling
    @code {.cpp}
    *this = basic_json(type());
    @endcode

    @liveexample{The example below shows the effect of `clear()` to different
    JSON types.,clear}

    @complexity Linear in the size of the JSON value.

    @iterators All iterators, pointers and references related to this container
               are invalidated.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @sa @ref basic_json(value_t) -- constructor that creates an object with the
        same value than calling `clear()`

    @since version 1.0.0
    */
    void clear() noexcept
    {
        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_value.string->clear();
                break;
            }

            case value_t::array:
            {
                m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_value.object->clear();
                break;
            }

            default:
                break;
        }
    }

    /*!
    @brief add an object to an array

    Appends the given element @a val to the end of the JSON value. If the
    function is called on a JSON null value, an empty array is created before
    appending @a val.

    @param[in] val the value to add to the JSON array

    @throw type_error.308 when called on a type other than JSON array or
    null; example: `"cannot use push_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON array. Note how the `null` value was silently
    converted to a JSON array.,push_back}

    @since version 1.0.0
    */
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (move semantics)
        m_value.array->push_back(std::move(val));
        // invalidate object
        val.m_type = value_t::null;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array
        m_value.array->push_back(val);
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    Inserts the given element @a val to the JSON object. If the function is
    called on a JSON null value, an empty object is created before inserting
    @a val.

    @param[in] val the value to add to the JSON object

    @throw type_error.308 when called on a type other than JSON object or
    null; example: `"cannot use push_back() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON object. Note how the `null` value was silently
    converted to a JSON object.,push_back__object_t__value}

    @since version 1.0.0
    */
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_UNLIKELY(not(is_null() or is_object())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array
        m_value.object->insert(val);
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(const typename object_t::value_type&)
    */
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    This function allows to use `push_back` with an initializer list. In case

    1. the current value is an object,
    2. the initializer list @a init contains only two elements, and
    3. the first element of @a init is a string,

    @a init is converted into an object element and added using
    @ref push_back(const typename object_t::value_type&). Otherwise, @a init
    is converted to a JSON value and added using @ref push_back(basic_json&&).

    @param[in] init  an initializer list

    @complexity Linear in the size of the initializer list @a init.

    @note This function is required to resolve an ambiguous overload error,
          because pairs like `{"key", "value"}` can be both interpreted as
          `object_t::value_type` or `std::initializer_list<basic_json>`, see
          https://github.com/nlohmann/json/issues/235 for more information.

    @liveexample{The example shows how initializer lists are treated as
    objects when possible.,push_back__initializer_list}
    */
    void push_back(initializer_list_t init)
    {
        if (is_object() and init.size() == 2 and (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(initializer_list_t)
    */
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /*!
    @brief add an object to an array

    Creates a JSON value from the passed parameters @a args to the end of the
    JSON value. If the function is called on a JSON null value, an empty array
    is created before appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @throw type_error.311 when called on a type other than JSON array or
    null; example: `"cannot use emplace_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` can be used to add
    elements to a JSON array. Note how the `null` value was silently converted
    to a JSON array.,emplace_back}

    @since version 2.0.8
    */
    template<class... Args>
    void emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        m_value.array->emplace_back(std::forward<Args>(args)...);
    }

    /*!
    @brief add an object to an object if key does not exist

    Inserts a new element into a JSON object constructed in-place with the
    given @a args if there is no element with the key in the container. If the
    function is called on a JSON null value, an empty object is created before
    appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return a pair consisting of an iterator to the inserted element, or the
            already-existing element if no insertion happened, and a bool
            denoting whether the insertion took place.

    @throw type_error.311 when called on a type other than JSON object or
    null; example: `"cannot use emplace() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `emplace()` can be used to add elements
    to a JSON object. Note how the `null` value was silently converted to a
    JSON object. Further note how no value is added if there was already one
    value stored with the same key.,emplace}

    @since version 2.0.8
    */
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_object())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        auto res = m_value.object->emplace(std::forward<Args>(args)...);
        // create result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /*!
    @brief inserts element

    Inserts element @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] val element to insert
    @return iterator pointing to the inserted @a val.

    @throw type_error.309 if called on JSON values other than arrays;
    example: `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Constant plus linear in the distance between @a pos and end of
    the container.

    @liveexample{The example shows how `insert()` is used.,insert}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            iterator result(this);
            result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, val);
            return result;
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts element
    @copydoc insert(const_iterator, const basic_json&)
    */
    iterator insert(const_iterator pos, basic_json&& val)
    {
        return insert(pos, val);
    }

    /*!
    @brief inserts elements

    Inserts @a cnt copies of @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] cnt number of copies of @a val to insert
    @param[in] val element to insert
    @return iterator pointing to the first element inserted, or @a pos if
    `cnt==0`

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Linear in @a cnt plus linear in the distance between @a pos
    and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__count}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            iterator result(this);
            result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
            return result;
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)` before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`
    @throw invalid_iterator.211 if @a first or @a last are iterators into
    container for which insert is called; example: `"passed iterators may not
    belong to container"`

    @return iterator pointing to the first element inserted, or @a pos if
    `first==last`

    @complexity Linear in `std::distance(first, last)` plus linear in the
    distance between @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__range}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const_iterator first, const_iterator last)
    {
        // insert only works for arrays
        if (JSON_UNLIKELY(not is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        if (JSON_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container"));
        }

        // insert to array and return iterator
        iterator result(this);
        result.m_it.array_iterator = m_value.array->insert(
                                         pos.m_it.array_iterator,
                                         first.m_it.array_iterator,
                                         last.m_it.array_iterator);
        return result;
    }

    /*!
    @brief inserts elements

    Inserts elements from initializer list @a ilist before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] ilist initializer list to insert the values from

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @return iterator pointing to the first element inserted, or @a pos if
    `ilist` is empty

    @complexity Linear in `ilist.size()` plus linear in the distance between
    @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__ilist}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, initializer_list_t ilist)
    {
        // insert only works for arrays
        if (JSON_UNLIKELY(not is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // insert to array and return iterator
        iterator result(this);
        result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, ilist.begin(), ilist.end());
        return result;
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)`.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than objects; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
    of elements to insert.

    @liveexample{The example shows how `insert()` is used.,insert__range_object}

    @since version 3.0.0
    */
    void insert(const_iterator first, const_iterator last)
    {
        // insert only works for objects
        if (JSON_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_UNLIKELY(not first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from JSON object @a j and overwrites existing keys.

    @param[in] j  JSON object to read values from

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_reference j)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }
        if (JSON_UNLIKELY(not j.is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name())));
        }

        for (auto it = j.begin(); it != j.end(); ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from from range `[first, last)` and overwrites existing
    keys.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used__range.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_iterator first, const_iterator last)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_UNLIKELY(not first.m_object->is_object()
                          or not first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        for (auto it = first; it != last; ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of the JSON value with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other JSON value to exchange the contents with

    @complexity Constant.

    @liveexample{The example below shows how JSON values can be swapped with
    `swap()`.,swap__reference}

    @since version 1.0.0
    */
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value and
        std::is_nothrow_move_assignable<value_t>::value and
        std::is_nothrow_move_constructible<json_value>::value and
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_type, other.m_type);
        std::swap(m_value, other.m_value);
        assert_invariant();
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON array with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other array to exchange the contents with

    @throw type_error.310 when JSON value is not an array; example: `"cannot
    use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how arrays can be swapped with
    `swap()`.,swap__array_t}

    @since version 1.0.0
    */
    void swap(array_t& other)
    {
        // swap only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            std::swap(*(m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON object with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other object to exchange the contents with

    @throw type_error.310 when JSON value is not an object; example:
    `"cannot use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how objects can be swapped with
    `swap()`.,swap__object_t}

    @since version 1.0.0
    */
    void swap(object_t& other)
    {
        // swap only works for objects
        if (JSON_LIKELY(is_object()))
        {
            std::swap(*(m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON string with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other string to exchange the contents with

    @throw type_error.310 when JSON value is not a string; example: `"cannot
    use swap() with boolean"`

    @complexity Constant.

    @liveexample{The example below shows how strings can be swapped with
    `swap()`.,swap__string_t}

    @since version 1.0.0
    */
    void swap(string_t& other)
    {
        // swap only works for strings
        if (JSON_LIKELY(is_string()))
        {
            std::swap(*(m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /// @}

  public:
    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    /*!
    @brief comparison: equal

    Compares two JSON values for equality according to the following rules:
    - Two JSON values are equal if (1) they are from the same type and (2)
      their stored values are the same according to their respective
      `operator==`.
    - Integer and floating-point numbers are automatically converted before
      comparison. Note than two NaN values are always treated as unequal.
    - Two JSON null values are equal.

    @note Floating-point inside JSON values numbers are compared with
    `json::number_float_t::operator==` which is `double::operator==` by
    default. To compare floating-point while respecting an epsilon, an alternative
    [comparison function](https://github.com/mariokonrad/marnav/blob/master/src/marnav/math/floatingpoint.hpp#L34-#L39)
    could be used, for instance
    @code {.cpp}
    template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>
    inline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept
    {
        return std::abs(a - b) <= epsilon;
    }
    @endcode

    @note NaN values never compare equal to themselves or to other NaN values.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are equal

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Linear.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__equal}

    @since version 1.0.0
    */
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    return (*lhs.m_value.array == *rhs.m_value.array);

                case value_t::object:
                    return (*lhs.m_value.object == *rhs.m_value.object);

                case value_t::null:
                    return true;

                case value_t::string:
                    return (*lhs.m_value.string == *rhs.m_value.string);

                case value_t::boolean:
                    return (lhs.m_value.boolean == rhs.m_value.boolean);

                case value_t::number_integer:
                    return (lhs.m_value.number_integer == rhs.m_value.number_integer);

                case value_t::number_unsigned:
                    return (lhs.m_value.number_unsigned == rhs.m_value.number_unsigned);

                case value_t::number_float:
                    return (lhs.m_value.number_float == rhs.m_value.number_float);

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
        {
            return (static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float);
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
        {
            return (lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer));
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
        {
            return (static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float);
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
        {
            return (lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned));
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
        {
            return (static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
        {
            return (lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned));
        }

        return false;
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
    {
        return (lhs == basic_json(rhs));
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
    {
        return (basic_json(lhs) == rhs);
    }

    /*!
    @brief comparison: not equal

    Compares two JSON values for inequality by calculating `not (lhs == rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are not equal

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__notequal}

    @since version 1.0.0
    */
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs == rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return (lhs != basic_json(rhs));
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return (basic_json(lhs) != rhs);
    }

    /*!
    @brief comparison: less than

    Compares whether one JSON value @a lhs is less than another JSON value @a
    rhs according to the following rules:
    - If @a lhs and @a rhs have the same type, the values are compared using
      the default `<` operator.
    - Integer and floating-point numbers are automatically converted before
      comparison
    - In case @a lhs and @a rhs have different types, the values are ignored
      and the order of the types is considered, see
      @ref operator<(const value_t, const value_t).

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__less}

    @since version 1.0.0
    */
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    return (*lhs.m_value.array) < (*rhs.m_value.array);

                case value_t::object:
                    return *lhs.m_value.object < *rhs.m_value.object;

                case value_t::null:
                    return false;

                case value_t::string:
                    return *lhs.m_value.string < *rhs.m_value.string;

                case value_t::boolean:
                    return lhs.m_value.boolean < rhs.m_value.boolean;

                case value_t::number_integer:
                    return lhs.m_value.number_integer < rhs.m_value.number_integer;

                case value_t::number_unsigned:
                    return lhs.m_value.number_unsigned < rhs.m_value.number_unsigned;

                case value_t::number_float:
                    return lhs.m_value.number_float < rhs.m_value.number_float;

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
        }

        // We only reach this line if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        return operator<(lhs_type, rhs_type);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, const ScalarType rhs) noexcept
    {
        return (lhs < basic_json(rhs));
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const ScalarType lhs, const_reference rhs) noexcept
    {
        return (basic_json(lhs) < rhs);
    }

    /*!
    @brief comparison: less than or equal

    Compares whether one JSON value @a lhs is less than or equal to another
    JSON value by calculating `not (rhs < lhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greater}

    @since version 1.0.0
    */
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (rhs < lhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return (lhs <= basic_json(rhs));
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return (basic_json(lhs) <= rhs);
    }

    /*!
    @brief comparison: greater than

    Compares whether one JSON value @a lhs is greater than another
    JSON value by calculating `not (lhs <= rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__lessequal}

    @since version 1.0.0
    */
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs <= rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, const ScalarType rhs) noexcept
    {
        return (lhs > basic_json(rhs));
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const ScalarType lhs, const_reference rhs) noexcept
    {
        return (basic_json(lhs) > rhs);
    }

    /*!
    @brief comparison: greater than or equal

    Compares whether one JSON value @a lhs is greater than or equal to another
    JSON value by calculating `not (lhs < rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greaterequal}

    @since version 1.0.0
    */
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs < rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return (lhs >= basic_json(rhs));
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return (basic_json(lhs) >= rhs);
    }

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{

    /*!
    @brief serialize to stream

    Serialize the given JSON value @a j to the output stream @a o. The JSON
    value will be serialized using the @ref dump member function.

    - The indentation of the output can be controlled with the member variable
      `width` of the output stream @a o. For instance, using the manipulator
      `std::setw(4)` on @a o sets the indentation level to `4` and the
      serialization result is the same as calling `dump(4)`.

    - The indentation character can be controlled with the member variable
      `fill` of the output stream @a o. For instance, the manipulator
      `std::setfill('\\t')` sets indentation to use a tab character rather than
      the default space character.

    @param[in,out] o  stream to serialize to
    @param[in] j  JSON value to serialize

    @return the stream @a o

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @liveexample{The example below shows the serialization with different
    parameters to `width` to adjust the indentation level.,operator_serialize}

    @since version 1.0.0; indentation character added in version 3.0.0
    */
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as indentation parameter if nonzero
        const bool pretty_print = (o.width() > 0);
        const auto indentation = (pretty_print ? o.width() : 0);

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /*!
    @brief serialize to stream
    @deprecated This stream operator is deprecated and will be removed in a
                future version of the library. Please use
                @ref operator<<(std::ostream&, const basic_json&)
                instead; that is, replace calls like `j >> o;` with `o << j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_DEPRECATED
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }

    /// @}


    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /*!
    @brief deserialize from a compatible input

    This function reads from a compatible input. Examples are:
    - an array of 1-byte values
    - strings with character/literal type with size of 1 byte
    - input streams
    - container with contiguous storage of 1-byte values. Compatible container
      types include `std::vector`, `std::string`, `std::array`,
      `std::valarray`, and `std::initializer_list`. Furthermore, C-style
      arrays can be used with `std::begin()`/`std::end()`. User-defined
      containers can be used as long as they implement random-access iterators
      and a contiguous storage.

    @pre Each element of the container has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @pre The container storage is contiguous. Violating this precondition
    yields undefined behavior. **This precondition is enforced with an
    assertion.**
    @pre Each element of the container has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with a noncompliant container and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @param[in] i  input to read from
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)

    @return result of the deserialization

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an array.,parse__array__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__string__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__istream__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function reading
    from a contiguous container.,parse__contiguouscontainer__parser_callback_t}

    @since version 2.0.3 (contiguous containers)
    */
    static basic_json parse(detail::input_adapter i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true)
    {
        basic_json result;
        parser(i, cb, allow_exceptions).parse(true, result);
        return result;
    }

    /*!
    @copydoc basic_json parse(detail::input_adapter, const parser_callback_t)
    */
    static basic_json parse(detail::input_adapter& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true)
    {
        basic_json result;
        parser(i, cb, allow_exceptions).parse(true, result);
        return result;
    }

    static bool accept(detail::input_adapter i)
    {
        return parser(i).accept(true);
    }

    static bool accept(detail::input_adapter& i)
    {
        return parser(i).accept(true);
    }

    /*!
    @brief deserialize from an iterator range with contiguous storage

    This function reads from an iterator range of a container with contiguous
    storage of 1-byte values. Compatible container types include
    `std::vector`, `std::string`, `std::array`, `std::valarray`, and
    `std::initializer_list`. Furthermore, C-style arrays can be used with
    `std::begin()`/`std::end()`. User-defined containers can be used as long
    as they implement random-access iterators and a contiguous storage.

    @pre The iterator range is contiguous. Violating this precondition yields
    undefined behavior. **This precondition is enforced with an assertion.**
    @pre Each element in the range has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with noncompliant iterators and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @tparam IteratorType iterator of container with contiguous storage
    @param[in] first  begin of the range to parse (included)
    @param[in] last  end of the range to parse (excluded)
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return result of the deserialization

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an iterator range.,parse__iteratortype__parser_callback_t}

    @since version 2.0.3
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    static basic_json parse(IteratorType first, IteratorType last,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true)
    {
        basic_json result;
        parser(detail::input_adapter(first, last), cb, allow_exceptions).parse(true, result);
        return result;
    }

    template<class IteratorType, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    static bool accept(IteratorType first, IteratorType last)
    {
        return parser(detail::input_adapter(first, last)).accept(true);
    }

    /*!
    @brief deserialize from stream
    @deprecated This stream operator is deprecated and will be removed in a
                future version of the library. Please use
                @ref operator>>(std::istream&, basic_json&)
                instead; that is, replace calls like `j << i;` with `i >> j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_DEPRECATED
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /*!
    @brief deserialize from stream

    Deserializes an input stream to a JSON value.

    @param[in,out] i  input stream to read a serialized JSON value from
    @param[in,out] j  JSON value to write the deserialized input to

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below shows how a JSON value is constructed by
    reading a serialization from a stream.,operator_deserialize}

    @sa parse(std::istream&, const parser_callback_t) for a variant with a
    parser callback function to filter values while parsing

    @since version 1.0.0
    */
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }

    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /*!
    @brief return the type as string

    Returns the type name as string to be used in error messages - usually to
    indicate that a function was called on a wrong JSON type.

    @return a string representation of a the @a m_type member:
            Value type  | return value
            ----------- | -------------
            null        | `"null"`
            boolean     | `"boolean"`
            string      | `"string"`
            number      | `"number"` (for all number types)
            object      | `"object"`
            array       | `"array"`
            discarded   | `"discarded"`

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Constant.

    @liveexample{The following code exemplifies `type_name()` for all JSON
    types.,type_name}

    @sa @ref type() -- return the type of the JSON value
    @sa @ref operator value_t() -- return the type of the JSON value (implicit)

    @since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
    since 3.0.0
    */
    const char* type_name() const noexcept
    {
        {
            switch (m_type)
            {
                case value_t::null:
                    return "null";
                case value_t::object:
                    return "object";
                case value_t::array:
                    return "array";
                case value_t::string:
                    return "string";
                case value_t::boolean:
                    return "boolean";
                case value_t::discarded:
                    return "discarded";
                default:
                    return "number";
            }
        }
    }


  private:
    //////////////////////
    // member variables //
    //////////////////////

    /// the type of the current element
    value_t m_type = value_t::null;

    /// the value of the current element
    json_value m_value = {};

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /*!
    @brief create a CBOR serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
    Binary Object Representation) serialization format. CBOR is a binary
    serialization format which aims to be more compact than JSON itself, yet
    more efficient to parse.

    The library uses the following mapping from JSON values types to
    CBOR types according to the CBOR specification (RFC 7049):

    JSON value type | value/range                                | CBOR type                          | first byte
    --------------- | ------------------------------------------ | ---------------------------------- | ---------------
    null            | `null`                                     | Null                               | 0xF6
    boolean         | `true`                                     | True                               | 0xF5
    boolean         | `false`                                    | False                              | 0xF4
    number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
    number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
    number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
    number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
    number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
    number_integer  | 0..23                                      | Integer                            | 0x00..0x17
    number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
    number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_float    | *any value*                                | Double-Precision Float             | 0xFB
    string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
    string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
    string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
    string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
    string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
    array           | *size*: 0..23                              | array                              | 0x80..0x97
    array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
    array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
    array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
    array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
    object          | *size*: 0..23                              | map                                | 0xA0..0xB7
    object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
    object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
    object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
    object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a CBOR value.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The following CBOR types are not used in the conversion:
          - byte strings (0x40..0x5F)
          - UTF-8 strings terminated by "break" (0x7F)
          - arrays terminated by "break" (0x9F)
          - maps terminated by "break" (0xBF)
          - date/time (0xC0..0xC1)
          - bignum (0xC2..0xC3)
          - decimal fraction (0xC4)
          - bigfloat (0xC5)
          - tagged items (0xC6..0xD4, 0xD8..0xDB)
          - expected conversions (0xD5..0xD7)
          - simple values (0xE0..0xF3, 0xF8)
          - undefined (0xF7)
          - half and single-precision floats (0xF9-0xFA)
          - break (0xFF)

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in CBOR format.,to_cbor}

    @sa http://cbor.io
    @sa @ref from_cbor(const std::vector<uint8_t>&, const size_t) for the
        analogous deserialization
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_cbor(j);
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /*!
    @brief create a MessagePack serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the MessagePack
    serialization format. MessagePack is a binary serialization format which
    aims to be more compact than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    MessagePack types according to the MessagePack specification:

    JSON value type | value/range                       | MessagePack type | first byte
    --------------- | --------------------------------- | ---------------- | ----------
    null            | `null`                            | nil              | 0xC0
    boolean         | `true`                            | true             | 0xC3
    boolean         | `false`                           | false            | 0xC2
    number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
    number_integer  | -2147483648..-32769               | int32            | 0xD2
    number_integer  | -32768..-129                      | int16            | 0xD1
    number_integer  | -128..-33                         | int8             | 0xD0
    number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
    number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
    number_integer  | 128..255                          | uint 8           | 0xCC
    number_integer  | 256..65535                        | uint 16          | 0xCD
    number_integer  | 65536..4294967295                 | uint 32          | 0xCE
    number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
    number_unsigned | 128..255                          | uint 8           | 0xCC
    number_unsigned | 256..65535                        | uint 16          | 0xCD
    number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
    number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_float    | *any value*                       | float 64         | 0xCB
    string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
    string          | *length*: 32..255                 | str 8            | 0xD9
    string          | *length*: 256..65535              | str 16           | 0xDA
    string          | *length*: 65536..4294967295       | str 32           | 0xDB
    array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
    array           | *size*: 16..65535                 | array 16         | 0xDC
    array           | *size*: 65536..4294967295         | array 32         | 0xDD
    object          | *size*: 0..15                     | fix map          | 0x80..0x8F
    object          | *size*: 16..65535                 | map 16           | 0xDE
    object          | *size*: 65536..4294967295         | map 32           | 0xDF

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a MessagePack value.

    @note The following values can **not** be converted to a MessagePack value:
          - strings with more than 4294967295 bytes
          - arrays with more than 4294967295 elements
          - objects with more than 4294967295 elements

    @note The following MessagePack types are not used in the conversion:
          - bin 8 - bin 32 (0xC4..0xC6)
          - ext 8 - ext 32 (0xC7..0xC9)
          - float 32 (0xCA)
          - fixext 1 - fixext 16 (0xD4..0xD8)

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in MessagePack format.,to_msgpack}

    @sa http://msgpack.org
    @sa @ref from_msgpack(const std::vector<uint8_t>&, const size_t) for the
        analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_msgpack(j);
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /*!
    @brief create a JSON value from an input in CBOR format

    Deserializes a given input @a i to a JSON value using the CBOR (Concise
    Binary Object Representation) serialization format.

    The library maps CBOR types to JSON value types as follows:

    CBOR type              | JSON value type | first byte
    ---------------------- | --------------- | ----------
    Integer                | number_unsigned | 0x00..0x17
    Unsigned integer       | number_unsigned | 0x18
    Unsigned integer       | number_unsigned | 0x19
    Unsigned integer       | number_unsigned | 0x1A
    Unsigned integer       | number_unsigned | 0x1B
    Negative integer       | number_integer  | 0x20..0x37
    Negative integer       | number_integer  | 0x38
    Negative integer       | number_integer  | 0x39
    Negative integer       | number_integer  | 0x3A
    Negative integer       | number_integer  | 0x3B
    Negative integer       | number_integer  | 0x40..0x57
    UTF-8 string           | string          | 0x60..0x77
    UTF-8 string           | string          | 0x78
    UTF-8 string           | string          | 0x79
    UTF-8 string           | string          | 0x7A
    UTF-8 string           | string          | 0x7B
    UTF-8 string           | string          | 0x7F
    array                  | array           | 0x80..0x97
    array                  | array           | 0x98
    array                  | array           | 0x99
    array                  | array           | 0x9A
    array                  | array           | 0x9B
    array                  | array           | 0x9F
    map                    | object          | 0xA0..0xB7
    map                    | object          | 0xB8
    map                    | object          | 0xB9
    map                    | object          | 0xBA
    map                    | object          | 0xBB
    map                    | object          | 0xBF
    False                  | `false`         | 0xF4
    True                   | `true`          | 0xF5
    Nill                   | `null`          | 0xF6
    Half-Precision Float   | number_float    | 0xF9
    Single-Precision Float | number_float    | 0xFA
    Double-Precision Float | number_float    | 0xFB

    @warning The mapping is **incomplete** in the sense that not all CBOR
             types can be converted to a JSON value. The following CBOR types
             are not supported and will yield parse errors (parse_error.112):
             - byte strings (0x40..0x5F)
             - date/time (0xC0..0xC1)
             - bignum (0xC2..0xC3)
             - decimal fraction (0xC4)
             - bigfloat (0xC5)
             - tagged items (0xC6..0xD4, 0xD8..0xDB)
             - expected conversions (0xD5..0xD7)
             - simple values (0xE0..0xF3, 0xF8)
             - undefined (0xF7)

    @warning CBOR allows map keys of any type, whereas JSON only allows
             strings as keys in object values. Therefore, CBOR maps with keys
             other than UTF-8 strings are rejected (parse_error.113).

    @note Any CBOR output created @ref to_cbor can be successfully parsed by
          @ref from_cbor.

    @param[in] i  an input in CBOR format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @return deserialized JSON value

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from CBOR were
    used in the given input @a v or if the input is not valid CBOR
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in CBOR
    format to a JSON value.,from_cbor}

    @sa http://cbor.io
    @sa @ref to_cbor(const basic_json&) for the analogous serialization
    @sa @ref from_msgpack(detail::input_adapter, const bool) for the
        related MessagePack format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0
    */
    static basic_json from_cbor(detail::input_adapter i,
                                const bool strict = true)
    {
        return binary_reader(i).parse_cbor(strict);
    }

    /*!
    @copydoc from_cbor(detail::input_adapter, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    static basic_json from_cbor(A1 && a1, A2 && a2, const bool strict = true)
    {
        return binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).parse_cbor(strict);
    }

    /*!
    @brief create a JSON value from an input in MessagePack format

    Deserializes a given input @a i to a JSON value using the MessagePack
    serialization format.

    The library maps MessagePack types to JSON value types as follows:

    MessagePack type | JSON value type | first byte
    ---------------- | --------------- | ----------
    positive fixint  | number_unsigned | 0x00..0x7F
    fixmap           | object          | 0x80..0x8F
    fixarray         | array           | 0x90..0x9F
    fixstr           | string          | 0xA0..0xBF
    nil              | `null`          | 0xC0
    false            | `false`         | 0xC2
    true             | `true`          | 0xC3
    float 32         | number_float    | 0xCA
    float 64         | number_float    | 0xCB
    uint 8           | number_unsigned | 0xCC
    uint 16          | number_unsigned | 0xCD
    uint 32          | number_unsigned | 0xCE
    uint 64          | number_unsigned | 0xCF
    int 8            | number_integer  | 0xD0
    int 16           | number_integer  | 0xD1
    int 32           | number_integer  | 0xD2
    int 64           | number_integer  | 0xD3
    str 8            | string          | 0xD9
    str 16           | string          | 0xDA
    str 32           | string          | 0xDB
    array 16         | array           | 0xDC
    array 32         | array           | 0xDD
    map 16           | object          | 0xDE
    map 32           | object          | 0xDF
    negative fixint  | number_integer  | 0xE0-0xFF

    @warning The mapping is **incomplete** in the sense that not all
             MessagePack types can be converted to a JSON value. The following
             MessagePack types are not supported and will yield parse errors:
              - bin 8 - bin 32 (0xC4..0xC6)
              - ext 8 - ext 32 (0xC7..0xC9)
              - fixext 1 - fixext 16 (0xD4..0xD8)

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @param[in] i  an input in MessagePack format convertible to an input
                  adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from MessagePack were
    used in the given input @a i or if the input is not valid MessagePack
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    MessagePack format to a JSON value.,from_msgpack}

    @sa http://msgpack.org
    @sa @ref to_msgpack(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter, const bool) for the related CBOR
        format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0
    */
    static basic_json from_msgpack(detail::input_adapter i,
                                   const bool strict = true)
    {
        return binary_reader(i).parse_msgpack(strict);
    }

    /*!
    @copydoc from_msgpack(detail::input_adapter, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    static basic_json from_msgpack(A1 && a1, A2 && a2, const bool strict = true)
    {
        return binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).parse_msgpack(strict);
    }

    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. Similar to @ref operator[](const typename
    object_t::key_type&), `null` values are created in arrays and objects if
    necessary.

    In particular:
    - If the JSON pointer points to an object key that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned.
    - If the JSON pointer points to an array index that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned. All indices between the current maximum and the given
      index are also filled with `null`.
    - The special value `-` is treated as a synonym for the index past the
      end.

    @param[in] ptr  a JSON pointer

    @return reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer}

    @since version 2.0.0
    */
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. The function does not change the JSON
    value; no `null` values are created. In particular, the the special value
    `-` yields an exception.

    @param[in] ptr  JSON pointer to the desired element

    @return const reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer_const}

    @since version 2.0.0
    */
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a reference to the element at with specified JSON pointer @a ptr,
    with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer}
    */
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a const reference to the element at with specified JSON pointer @a
    ptr, with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer_const}
    */
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief return flattened JSON value

    The function creates a JSON object whose keys are JSON pointers (see [RFC
    6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
    primitive. The original JSON value can be restored using the @ref
    unflatten() function.

    @return an object that maps JSON pointers to primitive values

    @note Empty objects and arrays are flattened to `null` and will not be
          reconstructed correctly by the @ref unflatten() function.

    @complexity Linear in the size the JSON value.

    @liveexample{The following code shows how a JSON object is flattened to an
    object whose keys consist of JSON pointers.,flatten}

    @sa @ref unflatten() for the reverse function

    @since version 2.0.0
    */
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /*!
    @brief unflatten a previously flattened JSON value

    The function restores the arbitrary nesting of a JSON value that has been
    flattened before using the @ref flatten() function. The JSON value must
    meet certain constraints:
    1. The value must be an object.
    2. The keys must be JSON pointers (see
       [RFC 6901](https://tools.ietf.org/html/rfc6901))
    3. The mapped values must be primitive JSON types.

    @return the original JSON from a flattened version

    @note Empty objects and arrays are flattened by @ref flatten() to `null`
          values and can not unflattened to their original type. Apart from
          this example, for a JSON value `j`, the following is always true:
          `j == j.flatten().unflatten()`.

    @complexity Linear in the size the JSON value.

    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive

    @liveexample{The following code shows how a flattened JSON object is
    unflattened into the original nested JSON object.,unflatten}

    @sa @ref flatten() for the reverse function

    @since version 2.0.0
    */
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /*!
    @brief applies a JSON patch

    [JSON Patch](http://jsonpatch.com) defines a JSON document structure for
    expressing a sequence of operations to apply to a JSON) document. With
    this function, a JSON Patch is applied to the current JSON value by
    executing all operations from the patch.

    @param[in] json_patch  JSON patch document
    @return patched document

    @note The application of a patch is atomic: Either all operations succeed
          and the patched document is returned or an exception is thrown. In
          any case, the original value is not changed: the patch is applied
          to a copy of the value.

    @throw parse_error.104 if the JSON patch does not consist of an array of
    objects

    @throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
    attributes are missing); example: `"operation add must have member path"`

    @throw out_of_range.401 if an array index is out of range.

    @throw out_of_range.403 if a JSON pointer inside the patch could not be
    resolved successfully in the current JSON value; example: `"key baz not
    found"`

    @throw out_of_range.405 if JSON pointer has no parent ("add", "remove",
    "move")

    @throw other_error.501 if "test" operation was unsuccessful

    @complexity Linear in the size of the JSON value and the length of the
    JSON patch. As usually only a fraction of the JSON value is affected by
    the patch, the complexity can usually be neglected.

    @liveexample{The following code shows how a JSON patch is applied to a
    value.,patch}

    @sa @ref diff -- create a JSON patch by comparing two JSON values

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
    @sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)

    @since version 2.0.0
    */
    basic_json patch(const basic_json& json_patch) const
    {
        // make a working copy to apply the patch to
        basic_json result = *this;

        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const std::string & op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, basic_json val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.is_root())
            {
                result = val;
            }
            else
            {
                // make sure the top element of the pointer exists
                json_pointer top_pointer = ptr.top();
                if (top_pointer != ptr)
                {
                    result.at(top_pointer);
                }

                // get reference to parent of JSON pointer ptr
                const auto last_path = ptr.pop_back();
                basic_json& parent = result[ptr];

                switch (parent.m_type)
                {
                    case value_t::null:
                    case value_t::object:
                    {
                        // use operator[] to add value
                        parent[last_path] = val;
                        break;
                    }

                    case value_t::array:
                    {
                        if (last_path == "-")
                        {
                            // special case: append to back
                            parent.push_back(val);
                        }
                        else
                        {
                            const auto idx = std::stoi(last_path);
                            if (JSON_UNLIKELY(static_cast<size_type>(idx) > parent.size()))
                            {
                                // avoid undefined behavior
                                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
                            }
                            else
                            {
                                // default case: insert add offset
                                parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                            }
                        }
                        break;
                    }

                    default:
                    {
                        // if there exists a parent it cannot be primitive
                        assert(false);  // LCOV_EXCL_LINE
                    }
                }
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [&result](json_pointer & ptr)
        {
            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found"));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(static_cast<size_type>(std::stoi(last_path)));
            }
        };

        // type check: top level value must be an array
        if (JSON_UNLIKELY(not json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const std::string & op,
                                          const std::string & member,
                                          bool string_type) -> basic_json&
            {
                // find value
                auto it = val.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";

                // check if desired value is present
                if (JSON_UNLIKELY(it == val.m_value.object->end()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'"));
                }

                // check if result is of type string
                if (JSON_UNLIKELY(string_type and not it->second.is_string()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'"));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_UNLIKELY(not val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
            }

            // collect mandatory members
            const std::string op = get_value("op", "op", true);
            const std::string path = get_value(op, "path", true);
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const std::string from_path = get_value("move", "from", true);
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const std::string from_path = get_value("copy", "from", true);
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    result[ptr] = result.at(from_ptr);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if test fails
                    if (JSON_UNLIKELY(not success))
                    {
                        JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump()));
                    }

                    break;
                }

                case patch_operations::invalid:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid"));
                }
            }
        }

        return result;
    }

    /*!
    @brief creates a diff as a JSON patch

    Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
    be changed into the value @a target by calling @ref patch function.

    @invariant For two JSON values @a source and @a target, the following code
    yields always `true`:
    @code {.cpp}
    source.patch(diff(source, target)) == target;
    @endcode

    @note Currently, only `remove`, `add`, and `replace` operations are
          generated.

    @param[in] source  JSON value to compare from
    @param[in] target  JSON value to compare against
    @param[in] path    helper value to create JSON pointers

    @return a JSON patch to convert the @a source to @a target

    @complexity Linear in the lengths of @a source and @a target.

    @liveexample{The following code shows how a JSON patch is created as a
    diff for two JSON values.,diff}

    @sa @ref patch -- apply a JSON patch

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)

    @since version 2.0.0
    */
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const std::string& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
        }
        else
        {
            switch (source.type())
            {
                case value_t::array:
                {
                    // first pass: traverse common elements
                    std::size_t i = 0;
                    while (i < source.size() and i < target.size())
                    {
                        // recursive call to compare array values at index i
                        auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                        ++i;
                    }

                    // i now reached the end of at least one array
                    // in a second pass, traverse the remaining elements

                    // remove my remaining elements
                    const auto end_index = static_cast<difference_type>(result.size());
                    while (i < source.size())
                    {
                        // add operations in reverse order to avoid invalid
                        // indices
                        result.insert(result.begin() + end_index, object(
                        {
                            {"op", "remove"},
                            {"path", path + "/" + std::to_string(i)}
                        }));
                        ++i;
                    }

                    // add other remaining elements
                    while (i < target.size())
                    {
                        result.push_back(
                        {
                            {"op", "add"},
                            {"path", path + "/" + std::to_string(i)},
                            {"value", target[i]}
                        });
                        ++i;
                    }

                    break;
                }

                case value_t::object:
                {
                    // first pass: traverse this object's elements
                    for (auto it = source.begin(); it != source.end(); ++it)
                    {
                        // escape the key name to be used in a JSON patch
                        const auto key = json_pointer::escape(it.key());

                        if (target.find(it.key()) != target.end())
                        {
                            // recursive call to compare object values at key it
                            auto temp_diff = diff(it.value(), target[it.key()], path + "/" + key);
                            result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                        }
                        else
                        {
                            // found a key that is not in o -> remove it
                            result.push_back(object(
                            {
                                {"op", "remove"}, {"path", path + "/" + key}
                            }));
                        }
                    }

                    // second pass: traverse other object's elements
                    for (auto it = target.begin(); it != target.end(); ++it)
                    {
                        if (source.find(it.key()) == source.end())
                        {
                            // found a key that is not in this -> add it
                            const auto key = json_pointer::escape(it.key());
                            result.push_back(
                            {
                                {"op", "add"}, {"path", path + "/" + key},
                                {"value", it.value()}
                            });
                        }
                    }

                    break;
                }

                default:
                {
                    // both primitive type: replace value
                    result.push_back(
                    {
                        {"op", "replace"}, {"path", path}, {"value", target}
                    });
                    break;
                }
            }
        }

        return result;
    }

    /// @}
};

/////////////
// presets //
/////////////

/*!
@brief default JSON class

This type is the default specialization of the @ref basic_json class which
uses the standard template types.

@since version 1.0.0
*/
using json = basic_json<>;

//////////////////
// json_pointer //
//////////////////

NLOHMANN_BASIC_JSON_TPL_DECLARATION
NLOHMANN_BASIC_JSON_TPL&
json_pointer::get_and_create(NLOHMANN_BASIC_JSON_TPL& j) const
{
    using size_type = typename NLOHMANN_BASIC_JSON_TPL::size_type;
    auto result = &j;

    // in case no reference tokens exist, return a reference to the JSON value
    // j which will be overwritten by a primitive value
    for (const auto& reference_token : reference_tokens)
    {
        switch (result->m_type)
        {
            case detail::value_t::null:
            {
                if (reference_token == "0")
                {
                    // start a new array if reference token is 0
                    result = &result->operator[](0);
                }
                else
                {
                    // start a new object otherwise
                    result = &result->operator[](reference_token);
                }
                break;
            }

            case detail::value_t::object:
            {
                // create an entry in the object
                result = &result->operator[](reference_token);
                break;
            }

            case detail::value_t::array:
            {
                // create an entry in the array
                JSON_TRY
                {
                    result = &result->operator[](static_cast<size_type>(std::stoi(reference_token)));
                }
                JSON_CATCH(std::invalid_argument&)
                {
                    JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                }
                break;
            }

            /*
            The following code is only reached if there exists a reference
            token _and_ the current value is primitive. In this case, we have
            an error situation, because primitive values may only occur as
            single value; that is, with an empty list of reference tokens.
            */
            default:
                JSON_THROW(detail::type_error::create(313, "invalid value to unflatten"));
        }
    }

    return *result;
}

NLOHMANN_BASIC_JSON_TPL_DECLARATION
NLOHMANN_BASIC_JSON_TPL&
json_pointer::get_unchecked(NLOHMANN_BASIC_JSON_TPL* ptr) const
{
    using size_type = typename NLOHMANN_BASIC_JSON_TPL::size_type;
    for (const auto& reference_token : reference_tokens)
    {
        // convert null values to arrays or objects before continuing
        if (ptr->m_type == detail::value_t::null)
        {
            // check if reference token is a number
            const bool nums =
                std::all_of(reference_token.begin(), reference_token.end(),
                            [](const char x)
            {
                return (x >= '0' and x <= '9');
            });

            // change value to array for numbers or "-" or to object otherwise
            *ptr = (nums or reference_token == "-")
                   ? detail::value_t::array
                   : detail::value_t::object;
        }

        switch (ptr->m_type)
        {
            case detail::value_t::object:
            {
                // use unchecked object access
                ptr = &ptr->operator[](reference_token);
                break;
            }

            case detail::value_t::array:
            {
                // error condition (cf. RFC 6901, Sect. 4)
                if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                {
                    JSON_THROW(detail::parse_error::create(106, 0,
                                                           "array index '" + reference_token +
                                                           "' must not begin with '0'"));
                }

                if (reference_token == "-")
                {
                    // explicitly treat "-" as index beyond the end
                    ptr = &ptr->operator[](ptr->m_value.array->size());
                }
                else
                {
                    // convert array index to number; unchecked access
                    JSON_TRY
                    {
                        ptr = &ptr->operator[](
                            static_cast<size_type>(std::stoi(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                }
                break;
            }

            default:
                JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
        }
    }

    return *ptr;
}

NLOHMANN_BASIC_JSON_TPL_DECLARATION
NLOHMANN_BASIC_JSON_TPL&
json_pointer::get_checked(NLOHMANN_BASIC_JSON_TPL* ptr) const
{
    using size_type = typename NLOHMANN_BASIC_JSON_TPL::size_type;
    for (const auto& reference_token : reference_tokens)
    {
        switch (ptr->m_type)
        {
            case detail::value_t::object:
            {
                // note: at performs range check
                ptr = &ptr->at(reference_token);
                break;
            }

            case detail::value_t::array:
            {
                if (JSON_UNLIKELY(reference_token == "-"))
                {
                    // "-" always fails the range check
                    JSON_THROW(detail::out_of_range::create(402,
                                                            "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                            ") is out of range"));
                }

                // error condition (cf. RFC 6901, Sect. 4)
                if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                {
                    JSON_THROW(detail::parse_error::create(106, 0,
                                                           "array index '" + reference_token +
                                                           "' must not begin with '0'"));
                }

                // note: at performs range check
                JSON_TRY
                {
                    ptr = &ptr->at(static_cast<size_type>(std::stoi(reference_token)));
                }
                JSON_CATCH(std::invalid_argument&)
                {
                    JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                }
                break;
            }

            default:
                JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
        }
    }

    return *ptr;
}

NLOHMANN_BASIC_JSON_TPL_DECLARATION
const NLOHMANN_BASIC_JSON_TPL&
json_pointer::get_unchecked(const NLOHMANN_BASIC_JSON_TPL* ptr) const
{
    using size_type = typename NLOHMANN_BASIC_JSON_TPL::size_type;
    for (const auto& reference_token : reference_tokens)
    {
        switch (ptr->m_type)
        {
            case detail::value_t::object:
            {
                // use unchecked object access
                ptr = &ptr->operator[](reference_token);
                break;
            }

            case detail::value_t::array:
            {
                if (JSON_UNLIKELY(reference_token == "-"))
                {
                    // "-" cannot be used for const access
                    JSON_THROW(detail::out_of_range::create(402,
                                                            "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                            ") is out of range"));
                }

                // error condition (cf. RFC 6901, Sect. 4)
                if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                {
                    JSON_THROW(detail::parse_error::create(106, 0,
                                                           "array index '" + reference_token +
                                                           "' must not begin with '0'"));
                }

                // use unchecked array access
                JSON_TRY
                {
                    ptr = &ptr->operator[](
                        static_cast<size_type>(std::stoi(reference_token)));
                }
                JSON_CATCH(std::invalid_argument&)
                {
                    JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                }
                break;
            }

            default:
                JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
        }
    }

    return *ptr;
}

NLOHMANN_BASIC_JSON_TPL_DECLARATION
const NLOHMANN_BASIC_JSON_TPL&
json_pointer::get_checked(const NLOHMANN_BASIC_JSON_TPL* ptr) const
{
    using size_type = typename NLOHMANN_BASIC_JSON_TPL::size_type;
    for (const auto& reference_token : reference_tokens)
    {
        switch (ptr->m_type)
        {
            case detail::value_t::object:
            {
                // note: at performs range check
                ptr = &ptr->at(reference_token);
                break;
            }

            case detail::value_t::array:
            {
                if (JSON_UNLIKELY(reference_token == "-"))
                {
                    // "-" always fails the range check
                    JSON_THROW(detail::out_of_range::create(402,
                                                            "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                            ") is out of range"));
                }

                // error condition (cf. RFC 6901, Sect. 4)
                if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                {
                    JSON_THROW(detail::parse_error::create(106, 0,
                                                           "array index '" + reference_token +
                                                           "' must not begin with '0'"));
                }

                // note: at performs range check
                JSON_TRY
                {
                    ptr = &ptr->at(static_cast<size_type>(std::stoi(reference_token)));
                }
                JSON_CATCH(std::invalid_argument&)
                {
                    JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                }
                break;
            }

            default:
                JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
        }
    }

    return *ptr;
}

NLOHMANN_BASIC_JSON_TPL_DECLARATION
void json_pointer::flatten(const std::string& reference_string,
                           const NLOHMANN_BASIC_JSON_TPL& value,
                           NLOHMANN_BASIC_JSON_TPL& result)
{
    switch (value.m_type)
    {
        case detail::value_t::array:
        {
            if (value.m_value.array->empty())
            {
                // flatten empty array as null
                result[reference_string] = nullptr;
            }
            else
            {
                // iterate array and use index as reference string
                for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
                {
                    flatten(reference_string + "/" + std::to_string(i),
                            value.m_value.array->operator[](i), result);
                }
            }
            break;
        }

        case detail::value_t::object:
        {
            if (value.m_value.object->empty())
            {
                // flatten empty object as null
                result[reference_string] = nullptr;
            }
            else
            {
                // iterate object and use keys as reference string
                for (const auto& element : *value.m_value.object)
                {
                    flatten(reference_string + "/" + escape(element.first), element.second, result);
                }
            }
            break;
        }

        default:
        {
            // add primitive value with its reference string
            result[reference_string] = value;
            break;
        }
    }
}

NLOHMANN_BASIC_JSON_TPL_DECLARATION
NLOHMANN_BASIC_JSON_TPL
json_pointer::unflatten(const NLOHMANN_BASIC_JSON_TPL& value)
{
    if (JSON_UNLIKELY(not value.is_object()))
    {
        JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
    }

    NLOHMANN_BASIC_JSON_TPL result;

    // iterate the JSON object values
    for (const auto& element : *value.m_value.object)
    {
        if (JSON_UNLIKELY(not element.second.is_primitive()))
        {
            JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
        }

        // assign value to reference pointed to by JSON pointer; Note that if
        // the JSON pointer is "" (i.e., points to the whole value), function
        // get_and_create returns a reference to result itself. An assignment
        // will then create a primitive value.
        json_pointer(element.first).get_and_create(result) = element.second;
    }

    return result;
}

inline bool operator==(json_pointer const& lhs, json_pointer const& rhs) noexcept
{
    return (lhs.reference_tokens == rhs.reference_tokens);
}

inline bool operator!=(json_pointer const& lhs, json_pointer const& rhs) noexcept
{
    return not (lhs == rhs);
}
} // namespace nlohmann


///////////////////////
// nonmember support //
///////////////////////

// specialization of std::swap, and std::hash
namespace std
{
/*!
@brief exchanges the values of two JSON objects

@since version 1.0.0
*/
template<>
inline void swap(nlohmann::json& j1,
                 nlohmann::json& j2) noexcept(
                     is_nothrow_move_constructible<nlohmann::json>::value and
                     is_nothrow_move_assignable<nlohmann::json>::value
                 )
{
    j1.swap(j2);
}

/// hash value for JSON objects
template<>
struct hash<nlohmann::json>
{
    /*!
    @brief return a hash value for a JSON object

    @since version 1.0.0
    */
    std::size_t operator()(const nlohmann::json& j) const
    {
        // a naive hashing via the string representation
        const auto& h = hash<nlohmann::json::string_t>();
        return h(j.dump());
    }
};

/// specialization for std::less<value_t>
/// @note: do not remove the space after '<',
///        see https://github.com/nlohmann/json/pull/679
template<>
struct less< ::nlohmann::detail::value_t>
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(nlohmann::detail::value_t lhs,
                    nlohmann::detail::value_t rhs) const noexcept
    {
        return nlohmann::detail::operator<(lhs, rhs);
    }
};

} // namespace std

/*!
@brief user-defined string literal for JSON values

This operator implements a user-defined string literal for JSON objects. It
can be used by adding `"_json"` to a string literal and returns a JSON object
if no parse error occurred.

@param[in] s  a string representation of a JSON object
@param[in] n  the length of string @a s
@return a JSON object

@since version 1.0.0
*/
inline nlohmann::json operator "" _json(const char* s, std::size_t n)
{
    return nlohmann::json::parse(s, s + n);
}

/*!
@brief user-defined string literal for JSON pointer

This operator implements a user-defined string literal for JSON Pointers. It
can be used by adding `"_json_pointer"` to a string literal and returns a JSON pointer
object if no parse error occurred.

@param[in] s  a string representation of a JSON Pointer
@param[in] n  the length of string @a s
@return a JSON pointer object

@since version 2.0.0
*/
inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

// restore GCC/clang diagnostic settings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic pop
#endif
#if defined(__clang__)
    #pragma GCC diagnostic pop
#endif

// clean up
#undef JSON_CATCH
#undef JSON_THROW
#undef JSON_TRY
#undef JSON_LIKELY
#undef JSON_UNLIKELY
#undef JSON_DEPRECATED
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL

#endif

#line 0 "ext/pugixml.hpp"
/**
 * pugixml parser - version 1.2
 * --------------------------------------------------------
 * Copyright (C) 2006-2012, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

#ifndef PUGIXML_VERSION
// Define version macro; evaluates to major * 100 + minor so that it's safe to use in less-than comparisons
#	define PUGIXML_VERSION 120
#endif

// Include user configuration file (this can define various configuration macros)
/**
 * pugixml parser - version 1.2
 * --------------------------------------------------------
 * Copyright (C) 2006-2012, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

#ifndef HEADER_PUGICONFIG_HPP
#define HEADER_PUGICONFIG_HPP

// Uncomment this to enable wchar_t mode
// #define PUGIXML_WCHAR_MODE

// Uncomment this to disable XPath
// #define PUGIXML_NO_XPATH

// Uncomment this to disable STL
// #define PUGIXML_NO_STL

// Uncomment this to disable exceptions
// #define PUGIXML_NO_EXCEPTIONS

// Set this to control attributes for public classes/functions, i.e.:
// #define PUGIXML_API __declspec(dllexport) // to export all public symbols from DLL
// #define PUGIXML_CLASS __declspec(dllimport) // to import all classes from DLL
// #define PUGIXML_FUNCTION __fastcall // to set calling conventions to all public functions to fastcall
// In absence of PUGIXML_CLASS/PUGIXML_FUNCTION definitions PUGIXML_API is used instead

// Uncomment this to switch to header-only version
// #define PUGIXML_HEADER_ONLY
// #include "pugixml.cpp"

// Tune these constants to adjust memory-related behavior
// #define PUGIXML_MEMORY_PAGE_SIZE 32768
// #define PUGIXML_MEMORY_OUTPUT_STACK 10240
// #define PUGIXML_MEMORY_XPATH_PAGE_SIZE 4096

#endif

/**
 * Copyright (c) 2006-2012 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef HEADER_PUGIXML_HPP
#define HEADER_PUGIXML_HPP

// Include stddef.h for size_t and ptrdiff_t
#include <stddef.h>

// Include exception header for XPath
#if !defined(PUGIXML_NO_XPATH) && !defined(PUGIXML_NO_EXCEPTIONS)
#	include <exception>
#endif

// Include STL headers
#ifndef PUGIXML_NO_STL
#	include <iterator>
#	include <iosfwd>
#	include <string>
#endif

// Macro for deprecated features
#ifndef PUGIXML_DEPRECATED
#	if defined(__GNUC__)
#		define PUGIXML_DEPRECATED __attribute__((deprecated))
#	elif defined(_MSC_VER) && _MSC_VER >= 1300
#		define PUGIXML_DEPRECATED __declspec(deprecated)
#	else
#		define PUGIXML_DEPRECATED
#	endif
#endif

// If no API is defined, assume default
#ifndef PUGIXML_API
#	define PUGIXML_API
#endif

// If no API for classes is defined, assume default
#ifndef PUGIXML_CLASS
#	define PUGIXML_CLASS PUGIXML_API
#endif

// If no API for functions is defined, assume default
#ifndef PUGIXML_FUNCTION
#	define PUGIXML_FUNCTION PUGIXML_API
#endif

// Character interface macros
#ifdef PUGIXML_WCHAR_MODE
#	define PUGIXML_TEXT(t) L ## t
#	define PUGIXML_CHAR wchar_t
#else
#	define PUGIXML_TEXT(t) t
#	define PUGIXML_CHAR char
#endif

namespace pugi
{
	// Character type used for all internal storage and operations; depends on PUGIXML_WCHAR_MODE
	typedef PUGIXML_CHAR char_t;

#ifndef PUGIXML_NO_STL
	// String type used for operations that work with STL string; depends on PUGIXML_WCHAR_MODE
	typedef std::basic_string<PUGIXML_CHAR, std::char_traits<PUGIXML_CHAR>, std::allocator<PUGIXML_CHAR> > string_t;
#endif
}

// The PugiXML namespace
namespace pugi
{
	// Tree node types
	enum xml_node_type
	{
		node_null,			// Empty (null) node handle
		node_document,		// A document tree's absolute root
		node_element,		// Element tag, i.e. '<node/>'
		node_pcdata,		// Plain character data, i.e. 'text'
		node_cdata,			// Character data, i.e. '<![CDATA[text]]>'
		node_comment,		// Comment tag, i.e. '<!-- text -->'
		node_pi,			// Processing instruction, i.e. '<?name?>'
		node_declaration,	// Document declaration, i.e. '<?xml version="1.0"?>'
		node_doctype		// Document type declaration, i.e. '<!DOCTYPE doc>'
	};

	// Parsing options

	// Minimal parsing mode (equivalent to turning all other flags off).
	// Only elements and PCDATA sections are added to the DOM tree, no text conversions are performed.
	const unsigned int parse_minimal = 0x0000;

	// This flag determines if processing instructions (node_pi) are added to the DOM tree. This flag is off by default.
	const unsigned int parse_pi = 0x0001;

	// This flag determines if comments (node_comment) are added to the DOM tree. This flag is off by default.
	const unsigned int parse_comments = 0x0002;

	// This flag determines if CDATA sections (node_cdata) are added to the DOM tree. This flag is on by default.
	const unsigned int parse_cdata = 0x0004;

	// This flag determines if plain character data (node_pcdata) that consist only of whitespace are added to the DOM tree.
	// This flag is off by default; turning it on usually results in slower parsing and more memory consumption.
	const unsigned int parse_ws_pcdata = 0x0008;

	// This flag determines if character and entity references are expanded during parsing. This flag is on by default.
	const unsigned int parse_escapes = 0x0010;

	// This flag determines if EOL characters are normalized (converted to #xA) during parsing. This flag is on by default.
	const unsigned int parse_eol = 0x0020;
	
	// This flag determines if attribute values are normalized using CDATA normalization rules during parsing. This flag is on by default.
	const unsigned int parse_wconv_attribute = 0x0040;

	// This flag determines if attribute values are normalized using NMTOKENS normalization rules during parsing. This flag is off by default.
	const unsigned int parse_wnorm_attribute = 0x0080;
	
	// This flag determines if document declaration (node_declaration) is added to the DOM tree. This flag is off by default.
	const unsigned int parse_declaration = 0x0100;

	// This flag determines if document type declaration (node_doctype) is added to the DOM tree. This flag is off by default.
	const unsigned int parse_doctype = 0x0200;

	// This flag determines if plain character data (node_pcdata) that is the only child of the parent node and that consists only
	// of whitespace is added to the DOM tree.
	// This flag is off by default; turning it on may result in slower parsing and more memory consumption.
	const unsigned int parse_ws_pcdata_single = 0x0400;

	// The default parsing mode.
	// Elements, PCDATA and CDATA sections are added to the DOM tree, character/reference entities are expanded,
	// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.
	const unsigned int parse_default = parse_cdata | parse_escapes | parse_wconv_attribute | parse_eol;

	// The full parsing mode.
	// Nodes of all types are added to the DOM tree, character/reference entities are expanded,
	// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.
	const unsigned int parse_full = parse_default | parse_pi | parse_comments | parse_declaration | parse_doctype;

	// These flags determine the encoding of input data for XML document
	enum xml_encoding
	{
		encoding_auto,		// Auto-detect input encoding using BOM or < / <? detection; use UTF8 if BOM is not found
		encoding_utf8,		// UTF8 encoding
		encoding_utf16_le,	// Little-endian UTF16
		encoding_utf16_be,	// Big-endian UTF16
		encoding_utf16,		// UTF16 with native endianness
		encoding_utf32_le,	// Little-endian UTF32
		encoding_utf32_be,	// Big-endian UTF32
		encoding_utf32,		// UTF32 with native endianness
		encoding_wchar,		// The same encoding wchar_t has (either UTF16 or UTF32)
		encoding_latin1
	};

	// Formatting flags
	
	// Indent the nodes that are written to output stream with as many indentation strings as deep the node is in DOM tree. This flag is on by default.
	const unsigned int format_indent = 0x01;
	
	// Write encoding-specific BOM to the output stream. This flag is off by default.
	const unsigned int format_write_bom = 0x02;

	// Use raw output mode (no indentation and no line breaks are written). This flag is off by default.
	const unsigned int format_raw = 0x04;
	
	// Omit default XML declaration even if there is no declaration in the document. This flag is off by default.
	const unsigned int format_no_declaration = 0x08;

	// Don't escape attribute values and PCDATA contents. This flag is off by default.
	const unsigned int format_no_escapes = 0x10;

	// Open file using text mode in xml_document::save_file. This enables special character (i.e. new-line) conversions on some systems. This flag is off by default.
	const unsigned int format_save_file_text = 0x20;

	// The default set of formatting flags.
	// Nodes are indented depending on their depth in DOM tree, a default declaration is output if document has none.
	const unsigned int format_default = format_indent;
		
	// Forward declarations
	struct xml_attribute_struct;
	struct xml_node_struct;

	class xml_node_iterator;
	class xml_attribute_iterator;
	class xml_named_node_iterator;

	class xml_tree_walker;

	class xml_node;

	class xml_text;
	
	#ifndef PUGIXML_NO_XPATH
	class xpath_node;
	class xpath_node_set;
	class xpath_query;
	class xpath_variable_set;
	#endif

	// Range-based for loop support
	template <typename It> class xml_object_range
	{
	public:
		typedef It const_iterator;

		xml_object_range(It b, It e): _begin(b), _end(e)
		{
		}

		It begin() const { return _begin; }
		It end() const { return _end; }

	private:
		It _begin, _end;
	};

	// Writer interface for node printing (see xml_node::print)
	class PUGIXML_CLASS xml_writer
	{
	public:
		virtual ~xml_writer() {}

		// Write memory chunk into stream/file/whatever
		virtual void write(const void* data, size_t size) = 0;
	};

	// xml_writer implementation for FILE*
	class PUGIXML_CLASS xml_writer_file: public xml_writer
	{
	public:
		// Construct writer from a FILE* object; void* is used to avoid header dependencies on stdio
		xml_writer_file(void* file);

		virtual void write(const void* data, size_t size);

	private:
		void* file;
	};

	#ifndef PUGIXML_NO_STL
	// xml_writer implementation for streams
	class PUGIXML_CLASS xml_writer_stream: public xml_writer
	{
	public:
		// Construct writer from an output stream object
		xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream);
		xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);

		virtual void write(const void* data, size_t size);

	private:
		std::basic_ostream<char, std::char_traits<char> >* narrow_stream;
		std::basic_ostream<wchar_t, std::char_traits<wchar_t> >* wide_stream;
	};
	#endif

	// A light-weight handle for manipulating attributes in DOM tree
	class PUGIXML_CLASS xml_attribute
	{
		friend class xml_attribute_iterator;
		friend class xml_node;

	private:
		xml_attribute_struct* _attr;
	
		typedef void (*unspecified_bool_type)(xml_attribute***);

	public:
		// Default constructor. Constructs an empty attribute.
		xml_attribute();
		
		// Constructs attribute from internal pointer
		explicit xml_attribute(xml_attribute_struct* attr);

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;

		// Comparison operators (compares wrapped attribute pointers)
		bool operator==(const xml_attribute& r) const;
		bool operator!=(const xml_attribute& r) const;
		bool operator<(const xml_attribute& r) const;
		bool operator>(const xml_attribute& r) const;
		bool operator<=(const xml_attribute& r) const;
		bool operator>=(const xml_attribute& r) const;

		// Check if attribute is empty
		bool empty() const;

		// Get attribute name/value, or "" if attribute is empty
		const char_t* name() const;
		const char_t* value() const;

		// Get attribute value, or the default value if attribute is empty
		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;

		// Get attribute value as a number, or the default value if conversion did not succeed or attribute is empty
		int as_int(int def = 0) const;
		unsigned int as_uint(unsigned int def = 0) const;
		double as_double(double def = 0) const;
		float as_float(float def = 0) const;

		// Get attribute value as bool (returns true if first character is in '1tTyY' set), or the default value if attribute is empty
		bool as_bool(bool def = false) const;

		// Set attribute name/value (returns false if attribute is empty or there is not enough memory)
		bool set_name(const char_t* rhs);
		bool set_value(const char_t* rhs);

		// Set attribute value with type conversion (numbers are converted to strings, boolean is converted to "true"/"false")
		bool set_value(int rhs);
		bool set_value(unsigned int rhs);
		bool set_value(double rhs);
		bool set_value(bool rhs);

		// Set attribute value (equivalent to set_value without error checking)
		xml_attribute& operator=(const char_t* rhs);
		xml_attribute& operator=(int rhs);
		xml_attribute& operator=(unsigned int rhs);
		xml_attribute& operator=(double rhs);
		xml_attribute& operator=(bool rhs);

		// Get next/previous attribute in the attribute list of the parent node
		xml_attribute next_attribute() const;
		xml_attribute previous_attribute() const;

		// Get hash value (unique for handles to the same object)
		size_t hash_value() const;

		// Get internal pointer
		xml_attribute_struct* internal_object() const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xml_attribute& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xml_attribute& lhs, bool rhs);
#endif

	// A light-weight handle for manipulating nodes in DOM tree
	class PUGIXML_CLASS xml_node
	{
		friend class xml_attribute_iterator;
		friend class xml_node_iterator;
		friend class xml_named_node_iterator;

	protected:
		xml_node_struct* _root;

		typedef void (*unspecified_bool_type)(xml_node***);

	public:
		// Default constructor. Constructs an empty node.
		xml_node();

		// Constructs node from internal pointer
		explicit xml_node(xml_node_struct* p);

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;
	
		// Comparison operators (compares wrapped node pointers)
		bool operator==(const xml_node& r) const;
		bool operator!=(const xml_node& r) const;
		bool operator<(const xml_node& r) const;
		bool operator>(const xml_node& r) const;
		bool operator<=(const xml_node& r) const;
		bool operator>=(const xml_node& r) const;

		// Check if node is empty.
		bool empty() const;

		// Get node type
		xml_node_type type() const;

		// Get node name/value, or "" if node is empty or it has no name/value
		const char_t* name() const;
		const char_t* value() const;
	
		// Get attribute list
		xml_attribute first_attribute() const;
		xml_attribute last_attribute() const;

		// Get children list
		xml_node first_child() const;
		xml_node last_child() const;

		// Get next/previous sibling in the children list of the parent node
		xml_node next_sibling() const;
		xml_node previous_sibling() const;
		
		// Get parent node
		xml_node parent() const;

		// Get root of DOM tree this node belongs to
		xml_node root() const;

		// Get text object for the current node
		xml_text text() const;

		// Get child, attribute or next/previous sibling with the specified name
		xml_node child(const char_t* name) const;
		xml_attribute attribute(const char_t* name) const;
		xml_node next_sibling(const char_t* name) const;
		xml_node previous_sibling(const char_t* name) const;

		// Get child value of current node; that is, value of the first child node of type PCDATA/CDATA
		const char_t* child_value() const;

		// Get child value of child with specified name. Equivalent to child(name).child_value().
		const char_t* child_value(const char_t* name) const;

		// Set node name/value (returns false if node is empty, there is not enough memory, or node can not have name/value)
		bool set_name(const char_t* rhs);
		bool set_value(const char_t* rhs);
		
		// Add attribute with specified name. Returns added attribute, or empty attribute on errors.
		xml_attribute append_attribute(const char_t* name);
		xml_attribute prepend_attribute(const char_t* name);
		xml_attribute insert_attribute_after(const char_t* name, const xml_attribute& attr);
		xml_attribute insert_attribute_before(const char_t* name, const xml_attribute& attr);

		// Add a copy of the specified attribute. Returns added attribute, or empty attribute on errors.
		xml_attribute append_copy(const xml_attribute& proto);
		xml_attribute prepend_copy(const xml_attribute& proto);
		xml_attribute insert_copy_after(const xml_attribute& proto, const xml_attribute& attr);
		xml_attribute insert_copy_before(const xml_attribute& proto, const xml_attribute& attr);

		// Add child node with specified type. Returns added node, or empty node on errors.
		xml_node append_child(xml_node_type type = node_element);
		xml_node prepend_child(xml_node_type type = node_element);
		xml_node insert_child_after(xml_node_type type, const xml_node& node);
		xml_node insert_child_before(xml_node_type type, const xml_node& node);

		// Add child element with specified name. Returns added node, or empty node on errors.
		xml_node append_child(const char_t* name);
		xml_node prepend_child(const char_t* name);
		xml_node insert_child_after(const char_t* name, const xml_node& node);
		xml_node insert_child_before(const char_t* name, const xml_node& node);

		// Add a copy of the specified node as a child. Returns added node, or empty node on errors.
		xml_node append_copy(const xml_node& proto);
		xml_node prepend_copy(const xml_node& proto);
		xml_node insert_copy_after(const xml_node& proto, const xml_node& node);
		xml_node insert_copy_before(const xml_node& proto, const xml_node& node);

		// Remove specified attribute
		bool remove_attribute(const xml_attribute& a);
		bool remove_attribute(const char_t* name);

		// Remove specified child
		bool remove_child(const xml_node& n);
		bool remove_child(const char_t* name);

		// Find attribute using predicate. Returns first attribute for which predicate returned true.
		template <typename Predicate> xml_attribute find_attribute(Predicate pred) const
		{
			if (!_root) return xml_attribute();
			
			for (xml_attribute attrib = first_attribute(); attrib; attrib = attrib.next_attribute())
				if (pred(attrib))
					return attrib;
		
			return xml_attribute();
		}

		// Find child node using predicate. Returns first child for which predicate returned true.
		template <typename Predicate> xml_node find_child(Predicate pred) const
		{
			if (!_root) return xml_node();
	
			for (xml_node node = first_child(); node; node = node.next_sibling())
				if (pred(node))
					return node;
		
			return xml_node();
		}

		// Find node from subtree using predicate. Returns first node from subtree (depth-first), for which predicate returned true.
		template <typename Predicate> xml_node find_node(Predicate pred) const
		{
			if (!_root) return xml_node();

			xml_node cur = first_child();
			
			while (cur._root && cur._root != _root)
			{
				if (pred(cur)) return cur;

				if (cur.first_child()) cur = cur.first_child();
				else if (cur.next_sibling()) cur = cur.next_sibling();
				else
				{
					while (!cur.next_sibling() && cur._root != _root) cur = cur.parent();

					if (cur._root != _root) cur = cur.next_sibling();
				}
			}

			return xml_node();
		}

		// Find child node by attribute name/value
		xml_node find_child_by_attribute(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;
		xml_node find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const;

	#ifndef PUGIXML_NO_STL
		// Get the absolute node path from root as a text string.
		string_t path(char_t delimiter = '/') const;
	#endif

		// Search for a node by path consisting of node names and . or .. elements.
		xml_node first_element_by_path(const char_t* path, char_t delimiter = '/') const;

		// Recursively traverse subtree with xml_tree_walker
		bool traverse(xml_tree_walker& walker);
	
	#ifndef PUGIXML_NO_XPATH
		// Select single node by evaluating XPath query. Returns first node from the resulting node set.
		xpath_node select_single_node(const char_t* query, xpath_variable_set* variables = 0) const;
		xpath_node select_single_node(const xpath_query& query) const;

		// Select node set by evaluating XPath query
		xpath_node_set select_nodes(const char_t* query, xpath_variable_set* variables = 0) const;
		xpath_node_set select_nodes(const xpath_query& query) const;
	#endif
		
		// Print subtree using a writer object
		void print(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;

	#ifndef PUGIXML_NO_STL
		// Print subtree to stream
		void print(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;
		void print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, unsigned int depth = 0) const;
	#endif

		// Child nodes iterators
		typedef xml_node_iterator iterator;

		iterator begin() const;
		iterator end() const;

		// Attribute iterators
		typedef xml_attribute_iterator attribute_iterator;

		attribute_iterator attributes_begin() const;
		attribute_iterator attributes_end() const;

		// Range-based for support
		xml_object_range<xml_node_iterator> children() const;
		xml_object_range<xml_named_node_iterator> children(const char_t* name) const;
		xml_object_range<xml_attribute_iterator> attributes() const;

		// Get node offset in parsed file/string (in char_t units) for debugging purposes
		ptrdiff_t offset_debug() const;

		// Get hash value (unique for handles to the same object)
		size_t hash_value() const;

		// Get internal pointer
		xml_node_struct* internal_object() const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xml_node& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xml_node& lhs, bool rhs);
#endif

	// A helper for working with text inside PCDATA nodes
	class PUGIXML_CLASS xml_text
	{
		friend class xml_node;

		xml_node_struct* _root;

		typedef void (*unspecified_bool_type)(xml_text***);

		explicit xml_text(xml_node_struct* root);

		xml_node_struct* _data_new();
		xml_node_struct* _data() const;

	public:
		// Default constructor. Constructs an empty object.
		xml_text();

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;

		// Check if text object is empty
		bool empty() const;

		// Get text, or "" if object is empty
		const char_t* get() const;

		// Get text, or the default value if object is empty
		const char_t* as_string(const char_t* def = PUGIXML_TEXT("")) const;

		// Get text as a number, or the default value if conversion did not succeed or object is empty
		int as_int(int def = 0) const;
		unsigned int as_uint(unsigned int def = 0) const;
		double as_double(double def = 0) const;
		float as_float(float def = 0) const;

		// Get text as bool (returns true if first character is in '1tTyY' set), or the default value if object is empty
		bool as_bool(bool def = false) const;

		// Set text (returns false if object is empty or there is not enough memory)
		bool set(const char_t* rhs);

		// Set text with type conversion (numbers are converted to strings, boolean is converted to "true"/"false")
		bool set(int rhs);
		bool set(unsigned int rhs);
		bool set(double rhs);
		bool set(bool rhs);

		// Set text (equivalent to set without error checking)
		xml_text& operator=(const char_t* rhs);
		xml_text& operator=(int rhs);
		xml_text& operator=(unsigned int rhs);
		xml_text& operator=(double rhs);
		xml_text& operator=(bool rhs);

		// Get the data node (node_pcdata or node_cdata) for this object
		xml_node data() const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xml_text& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xml_text& lhs, bool rhs);
#endif

	// Child node iterator (a bidirectional iterator over a collection of xml_node)
	class PUGIXML_CLASS xml_node_iterator
	{
		friend class xml_node;

	private:
		mutable xml_node _wrap;
		xml_node _parent;

		xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent);

	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_node value_type;
		typedef xml_node* pointer;
		typedef xml_node& reference;

	#ifndef PUGIXML_NO_STL
		typedef std::bidirectional_iterator_tag iterator_category;
	#endif

		// Default constructor
		xml_node_iterator();

		// Construct an iterator which points to the specified node
		xml_node_iterator(const xml_node& node);

		// Iterator operators
		bool operator==(const xml_node_iterator& rhs) const;
		bool operator!=(const xml_node_iterator& rhs) const;

		xml_node& operator*() const;
		xml_node* operator->() const;

		const xml_node_iterator& operator++();
		xml_node_iterator operator++(int);

		const xml_node_iterator& operator--();
		xml_node_iterator operator--(int);
	};

	// Attribute iterator (a bidirectional iterator over a collection of xml_attribute)
	class PUGIXML_CLASS xml_attribute_iterator
	{
		friend class xml_node;

	private:
		mutable xml_attribute _wrap;
		xml_node _parent;

		xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent);

	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_attribute value_type;
		typedef xml_attribute* pointer;
		typedef xml_attribute& reference;

	#ifndef PUGIXML_NO_STL
		typedef std::bidirectional_iterator_tag iterator_category;
	#endif

		// Default constructor
		xml_attribute_iterator();

		// Construct an iterator which points to the specified attribute
		xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent);

		// Iterator operators
		bool operator==(const xml_attribute_iterator& rhs) const;
		bool operator!=(const xml_attribute_iterator& rhs) const;

		xml_attribute& operator*() const;
		xml_attribute* operator->() const;

		const xml_attribute_iterator& operator++();
		xml_attribute_iterator operator++(int);

		const xml_attribute_iterator& operator--();
		xml_attribute_iterator operator--(int);
	};

	// Named node range helper
	class xml_named_node_iterator
	{
	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_node value_type;
		typedef xml_node* pointer;
		typedef xml_node& reference;

	#ifndef PUGIXML_NO_STL
		typedef std::forward_iterator_tag iterator_category;
	#endif

		// Default constructor
		xml_named_node_iterator();

		// Construct an iterator which points to the specified node
		xml_named_node_iterator(const xml_node& node, const char_t* name);

		// Iterator operators
		bool operator==(const xml_named_node_iterator& rhs) const;
		bool operator!=(const xml_named_node_iterator& rhs) const;

		xml_node& operator*() const;
		xml_node* operator->() const;

		const xml_named_node_iterator& operator++();
		xml_named_node_iterator operator++(int);

	private:
		mutable xml_node _node;
		const char_t* _name;
	};

	// Abstract tree walker class (see xml_node::traverse)
	class PUGIXML_CLASS xml_tree_walker
	{
		friend class xml_node;

	private:
		int _depth;
	
	protected:
		// Get current traversal depth
		int depth() const;
	
	public:
		xml_tree_walker();
		virtual ~xml_tree_walker();

		// Callback that is called when traversal begins
		virtual bool begin(xml_node& node);

		// Callback that is called for each node traversed
		virtual bool for_each(xml_node& node) = 0;

		// Callback that is called when traversal ends
		virtual bool end(xml_node& node);
	};

	// Parsing status, returned as part of xml_parse_result object
	enum xml_parse_status
	{
		status_ok = 0,				// No error

		status_file_not_found,		// File was not found during load_file()
		status_io_error,			// Error reading from file/stream
		status_out_of_memory,		// Could not allocate memory
		status_internal_error,		// Internal error occurred

		status_unrecognized_tag,	// Parser could not determine tag type

		status_bad_pi,				// Parsing error occurred while parsing document declaration/processing instruction
		status_bad_comment,			// Parsing error occurred while parsing comment
		status_bad_cdata,			// Parsing error occurred while parsing CDATA section
		status_bad_doctype,			// Parsing error occurred while parsing document type declaration
		status_bad_pcdata,			// Parsing error occurred while parsing PCDATA section
		status_bad_start_element,	// Parsing error occurred while parsing start element tag
		status_bad_attribute,		// Parsing error occurred while parsing element attribute
		status_bad_end_element,		// Parsing error occurred while parsing end element tag
		status_end_element_mismatch // There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)
	};

	// Parsing result
	struct PUGIXML_CLASS xml_parse_result
	{
		// Parsing status (see xml_parse_status)
		xml_parse_status status;

		// Last parsed offset (in char_t units from start of input data)
		ptrdiff_t offset;

		// Source document encoding
		xml_encoding encoding;

		// Default constructor, initializes object to failed state
		xml_parse_result();

		// Cast to bool operator
		operator bool() const;

		// Get error description
		const char* description() const;
	};

	// Document class (DOM tree root)
	class PUGIXML_CLASS xml_document: public xml_node
	{
	private:
		char_t* _buffer;

		char _memory[192];
		
		// Non-copyable semantics
		xml_document(const xml_document&);
		const xml_document& operator=(const xml_document&);

		void create();
		void destroy();

		xml_parse_result load_buffer_impl(void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own);

	public:
		// Default constructor, makes empty document
		xml_document();

		// Destructor, invalidates all node/attribute handles to this document
		~xml_document();

		// Removes all nodes, leaving the empty document
		void reset();

		// Removes all nodes, then copies the entire contents of the specified document
		void reset(const xml_document& proto);

	#ifndef PUGIXML_NO_STL
		// Load document from stream.
		xml_parse_result load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
		xml_parse_result load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = parse_default);
	#endif

		// Load document from zero-terminated string. No encoding conversions are applied.
		xml_parse_result load(const char_t* contents, unsigned int options = parse_default);

		// Load document from file
		xml_parse_result load_file(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
		xml_parse_result load_file(const wchar_t* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the function returns.
		xml_parse_result load_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
		// You should ensure that buffer data will persist throughout the document's lifetime, and free the buffer memory manually once document is destroyed.
		xml_parse_result load_buffer_inplace(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
		// You should allocate the buffer with pugixml allocation function; document will free the buffer when it is no longer needed (you can't use it anymore).
		xml_parse_result load_buffer_inplace_own(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Save XML document to writer (semantics is slightly different from xml_node::print, see documentation for details).
		void save(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;

	#ifndef PUGIXML_NO_STL
		// Save XML document to stream (semantics is slightly different from xml_node::print, see documentation for details).
		void save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
		void save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default) const;
	#endif

		// Save XML to file
		bool save_file(const char* path, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
		bool save_file(const wchar_t* path, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;

		// Get document element
		xml_node document_element() const;
	};

#ifndef PUGIXML_NO_XPATH
	// XPath query return type
	enum xpath_value_type
	{
		xpath_type_none,	  // Unknown type (query failed to compile)
		xpath_type_node_set,  // Node set (xpath_node_set)
		xpath_type_number,	  // Number
		xpath_type_string,	  // String
		xpath_type_boolean	  // Boolean
	};

	// XPath parsing result
	struct PUGIXML_CLASS xpath_parse_result
	{
		// Error message (0 if no error)
		const char* error;

		// Last parsed offset (in char_t units from string start)
		ptrdiff_t offset;

		// Default constructor, initializes object to failed state
		xpath_parse_result();

		// Cast to bool operator
		operator bool() const;

		// Get error description
		const char* description() const;
	};

	// A single XPath variable
	class PUGIXML_CLASS xpath_variable
	{
		friend class xpath_variable_set;

	protected:
		xpath_value_type _type;
		xpath_variable* _next;

		xpath_variable();

		// Non-copyable semantics
		xpath_variable(const xpath_variable&);
		xpath_variable& operator=(const xpath_variable&);
		
	public:
		// Get variable name
		const char_t* name() const;

		// Get variable type
		xpath_value_type type() const;

		// Get variable value; no type conversion is performed, default value (false, NaN, empty string, empty node set) is returned on type mismatch error
		bool get_boolean() const;
		double get_number() const;
		const char_t* get_string() const;
		const xpath_node_set& get_node_set() const;

		// Set variable value; no type conversion is performed, false is returned on type mismatch error
		bool set(bool value);
		bool set(double value);
		bool set(const char_t* value);
		bool set(const xpath_node_set& value);
	};

	// A set of XPath variables
	class PUGIXML_CLASS xpath_variable_set
	{
	private:
		xpath_variable* _data[64];

		// Non-copyable semantics
		xpath_variable_set(const xpath_variable_set&);
		xpath_variable_set& operator=(const xpath_variable_set&);

		xpath_variable* find(const char_t* name) const;

	public:
		// Default constructor/destructor
		xpath_variable_set();
		~xpath_variable_set();

		// Add a new variable or get the existing one, if the types match
		xpath_variable* add(const char_t* name, xpath_value_type type);

		// Set value of an existing variable; no type conversion is performed, false is returned if there is no such variable or if types mismatch
		bool set(const char_t* name, bool value);
		bool set(const char_t* name, double value);
		bool set(const char_t* name, const char_t* value);
		bool set(const char_t* name, const xpath_node_set& value);

		// Get existing variable by name
		xpath_variable* get(const char_t* name);
		const xpath_variable* get(const char_t* name) const;
	};

	// A compiled XPath query object
	class PUGIXML_CLASS xpath_query
	{
	private:
		void* _impl;
		xpath_parse_result _result;

		typedef void (*unspecified_bool_type)(xpath_query***);

		// Non-copyable semantics
		xpath_query(const xpath_query&);
		xpath_query& operator=(const xpath_query&);

	public:
		// Construct a compiled object from XPath expression.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws xpath_exception on compilation errors.
		explicit xpath_query(const char_t* query, xpath_variable_set* variables = 0);

		// Destructor
		~xpath_query();

		// Get query expression return type
		xpath_value_type return_type() const;
		
		// Evaluate expression as boolean value in the specified context; performs type conversion if necessary.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		bool evaluate_boolean(const xpath_node& n) const;
		
		// Evaluate expression as double value in the specified context; performs type conversion if necessary.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		double evaluate_number(const xpath_node& n) const;
		
	#ifndef PUGIXML_NO_STL
		// Evaluate expression as string value in the specified context; performs type conversion if necessary.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		string_t evaluate_string(const xpath_node& n) const;
	#endif
		
		// Evaluate expression as string value in the specified context; performs type conversion if necessary.
		// At most capacity characters are written to the destination buffer, full result size is returned (includes terminating zero).
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors.
		// If PUGIXML_NO_EXCEPTIONS is defined, returns empty  set instead.
		size_t evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const;

		// Evaluate expression as node set in the specified context.
		// If PUGIXML_NO_EXCEPTIONS is not defined, throws xpath_exception on type mismatch and std::bad_alloc on out of memory errors.
		// If PUGIXML_NO_EXCEPTIONS is defined, returns empty node set instead.
		xpath_node_set evaluate_node_set(const xpath_node& n) const;

		// Get parsing result (used to get compilation errors in PUGIXML_NO_EXCEPTIONS mode)
		const xpath_parse_result& result() const;

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;
	};
	
	#ifndef PUGIXML_NO_EXCEPTIONS
	// XPath exception class
	class PUGIXML_CLASS xpath_exception: public std::exception
	{
	private:
		xpath_parse_result _result;

	public:
		// Construct exception from parse result
		explicit xpath_exception(const xpath_parse_result& result);

		// Get error message
		virtual const char* what() const throw();

		// Get parse result
		const xpath_parse_result& result() const;
	};
	#endif
	
	// XPath node class (either xml_node or xml_attribute)
	class PUGIXML_CLASS xpath_node
	{
	private:
		xml_node _node;
		xml_attribute _attribute;
	
		typedef void (*unspecified_bool_type)(xpath_node***);

	public:
		// Default constructor; constructs empty XPath node
		xpath_node();
		
		// Construct XPath node from XML node/attribute
		xpath_node(const xml_node& node);
		xpath_node(const xml_attribute& attribute, const xml_node& parent);

		// Get node/attribute, if any
		xml_node node() const;
		xml_attribute attribute() const;
		
		// Get parent of contained node/attribute
		xml_node parent() const;

		// Safe bool conversion operator
		operator unspecified_bool_type() const;
		
		// Borland C++ workaround
		bool operator!() const;

		// Comparison operators
		bool operator==(const xpath_node& n) const;
		bool operator!=(const xpath_node& n) const;
	};

#ifdef __BORLANDC__
	// Borland C++ workaround
	bool PUGIXML_FUNCTION operator&&(const xpath_node& lhs, bool rhs);
	bool PUGIXML_FUNCTION operator||(const xpath_node& lhs, bool rhs);
#endif

	// A fixed-size collection of XPath nodes
	class PUGIXML_CLASS xpath_node_set
	{
	public:
		// Collection type
		enum type_t
		{
			type_unsorted,			// Not ordered
			type_sorted,			// Sorted by document order (ascending)
			type_sorted_reverse		// Sorted by document order (descending)
		};
		
		// Constant iterator type
		typedef const xpath_node* const_iterator;
	
		// Default constructor. Constructs empty set.
		xpath_node_set();

		// Constructs a set from iterator range; data is not checked for duplicates and is not sorted according to provided type, so be careful
		xpath_node_set(const_iterator begin, const_iterator end, type_t type = type_unsorted);

		// Destructor
		~xpath_node_set();
		
		// Copy constructor/assignment operator
		xpath_node_set(const xpath_node_set& ns);
		xpath_node_set& operator=(const xpath_node_set& ns);

		// Get collection type
		type_t type() const;
		
		// Get collection size
		size_t size() const;

		// Indexing operator
		const xpath_node& operator[](size_t index) const;
		
		// Collection iterators
		const_iterator begin() const;
		const_iterator end() const;

		// Sort the collection in ascending/descending order by document order
		void sort(bool reverse = false);
		
		// Get first node in the collection by document order
		xpath_node first() const;
		
		// Check if collection is empty
		bool empty() const;
	
	private:
		type_t _type;
		
		xpath_node _storage;
		
		xpath_node* _begin;
		xpath_node* _end;

		void _assign(const_iterator begin, const_iterator end);
	};
#endif

#ifndef PUGIXML_NO_STL
	// Convert wide string to UTF8
	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const wchar_t* str);
	std::basic_string<char, std::char_traits<char>, std::allocator<char> > PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str);
	
	// Convert UTF8 to wide string
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const char* str);
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > PUGIXML_FUNCTION as_wide(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str);
#endif

	// Memory allocation function interface; returns pointer to allocated memory or NULL on failure
	typedef void* (*allocation_function)(size_t size);
	
	// Memory deallocation function interface
	typedef void (*deallocation_function)(void* ptr);

	// Override default memory management functions. All subsequent allocations/deallocations will be performed via supplied functions.
	void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate);
	
	// Get current memory management functions
	allocation_function PUGIXML_FUNCTION get_memory_allocation_function();
	deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function();
}

#if !defined(PUGIXML_NO_STL) && (defined(_MSC_VER) || defined(__ICC))
namespace std
{
	// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier)
	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_node_iterator&);
	std::bidirectional_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_attribute_iterator&);
	std::forward_iterator_tag PUGIXML_FUNCTION _Iter_cat(const pugi::xml_named_node_iterator&);
}
#endif

#if !defined(PUGIXML_NO_STL) && defined(__SUNPRO_CC)
namespace std
{
	// Workarounds for (non-standard) iterator category detection
	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_node_iterator&);
	std::bidirectional_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_attribute_iterator&);
	std::forward_iterator_tag PUGIXML_FUNCTION __iterator_category(const pugi::xml_named_node_iterator&);
}
#endif

#endif

/**
 * Copyright (c) 2006-2012 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#line 0 "../libs/openFrameworks/utils/ofConstants.h"
#pragma once
#include <stdint.h>

//-------------------------------
#define OF_VERSION_MAJOR 0
#define OF_VERSION_MINOR 11
#define OF_VERSION_PATCH 0
#define OF_VERSION_PRE_RELEASE "master"

// Set to 1 for compatibility with old projects using ofVec instead of glm
#ifndef OF_USE_LEGACY_VECTOR_MATH
	#define OF_USE_LEGACY_VECTOR_MATH 0
#endif

// Set to 1 to use std filesystem instead of boost's
#ifndef OF_USING_STD_FS
#define OF_USING_STD_FS 0
#endif

//-------------------------------

/// \brief This enumerates the targeted operating systems or platforms.
enum ofTargetPlatform{
	/// \brief 32- and 64-bit x86 architecture on Mac OSX.
	OF_TARGET_OSX,
	/// \brief 32- and 64-bit x86 architecture using MinGW on Windows OS.
    OF_TARGET_MINGW,
	/// \brief 32- and 64-bit x86 architecture using Visual Studio on Windows OS.
	OF_TARGET_WINVS,
	/// \brief 32- and 64-bit armv7, arm64, x86 (simulator) architecture Mac iOS.
	OF_TARGET_IOS,
	/// \brief 32- and 64-bit armeabi-v7a and x86 Android OS.
	OF_TARGET_ANDROID,
	/// \brief 32-bit x86 architecture on Linux OS.
	OF_TARGET_LINUX,
	/// \brief 64-bit x86 architecture on Linux OS.
	OF_TARGET_LINUX64,
	/// \brief 32-bit armv6 little endian architecture on Linux OS.
	OF_TARGET_LINUXARMV6L,
	/// \brief 32-bit armv7 little endian architecture on Linux OS.
	OF_TARGET_LINUXARMV7L,
	/// \brief Compiled to javascript using Emscripten.
	/// \sa https://github.com/kripken/emscripten
	OF_TARGET_EMSCRIPTEN,
	/// \brief Qt based build.
	OF_TARGET_QT,
};


#ifndef OF_TARGET_IPHONE
    #define OF_TARGET_IPHONE OF_TARGET_IOS
#endif


// Cross-platform deprecation warning
#ifdef __GNUC__
	// clang also has this defined. deprecated(message) is only for gcc>=4.5
	#if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || __GNUC__ > 4
        #define OF_DEPRECATED_MSG(message, ...) __VA_ARGS__ __attribute__ ((deprecated(message)))
    #else
        #define OF_DEPRECATED_MSG(message, ...) __VA_ARGS__ __attribute__ ((deprecated))
    #endif
	#define OF_DEPRECATED(...) __VA_ARGS__ __attribute__ ((deprecated))
	#define OF_INTERNAL_DEPRECATED(...) __VA_ARGS__ __attribute__ ((deprecated("OF core deprecated")))
#elif defined(_MSC_VER)
	#define OF_DEPRECATED_MSG(message, ...) __declspec(deprecated(message)) __VA_ARGS__
	#define OF_DEPRECATED(...) __declspec(deprecated) __VA_ARGS__
	#define OF_INTERNAL_DEPRECATED(...) __declspec(deprecated("OF core deprecated")) __VA_ARGS__
#else
	#pragma message("WARNING: You need to implement DEPRECATED for this compiler")
	#define OF_DEPRECATED_MSG(message, ...) __VA_ARGS__
	#define OF_DEPRECATED(...) __VA_ARGS__
#endif

//-------------------------------
//  find the system type --------
//-------------------------------

// 		helpful:
// 		http://www.ogre3d.org/docs/api/html/OgrePlatform_8h-source.html

#if defined(QT_GUI_LIB) || defined(QT_OPENGL_LIB)
	#define TARGET_QT
    #ifdef QT_OPENGL_ES_2
        #define TARGET_OPENGLES
    #endif
	#define TARGET_IMPLEMENTS_URL_LOADER
    #include <QDateTime>
    #include <QFile>
    #include <QFileInfo>
    #include <QDirIterator>
    #include <QMutex>
    #include <QWaitCondition>
#elif defined( __WIN32__ ) || defined( _WIN32 )
	#define TARGET_WIN32
#elif defined( __APPLE_CC__)
    #define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
    #include <TargetConditionals.h>
	#if (TARGET_OS_IPHONE || TARGET_OS_IOS || TARGET_OS_SIMULATOR || TARGET_OS_IPHONE_SIMULATOR) && !TARGET_OS_TV && !TARGET_OS_WATCH
        #define TARGET_OF_IPHONE
        #define TARGET_OF_IOS
        #define TARGET_OPENGLES
        #include <unistd.h>
    #elif TARGET_OS_TV
        #define TARGET_OF_IOS
        #define TARGET_OF_TVOS
        #define TARGET_OPENGLES
        #include <unistd.h>
    #elif TARGET_OS_WATCH
        #define TARGET_OF_IOS
        #define TARGET_OF_WATCHOS
        #define TARGET_OPENGLES
        #include <unistd.h>
	#else
		#define TARGET_OSX
	#endif
#elif defined (__ANDROID__)
	#define TARGET_ANDROID
	#define TARGET_OPENGLES
#elif defined(__ARMEL__)
	#define TARGET_LINUX
	#define TARGET_OPENGLES
	#define TARGET_LINUX_ARM
#elif defined(__EMSCRIPTEN__)
	#define TARGET_EMSCRIPTEN
	#define TARGET_OPENGLES
	#define TARGET_NO_THREADS
	#define TARGET_PROGRAMMABLE_GL
	#define TARGET_IMPLEMENTS_URL_LOADER
#else
	#define TARGET_LINUX
#endif
//-------------------------------


// use Qt implementation insted of external dependencies:
#ifdef TARGET_QT
class SleepSimulator {
	QMutex localMutex;
	QWaitCondition sleepSimulator;
public:
	SleepSimulator() { localMutex.lock(); }
	void sleep(unsigned long sleepMS) { sleepSimulator.wait(&localMutex, sleepMS); }
	void CancelSleep() { sleepSimulator.wakeAll(); }
};

namespace std { namespace filesystem {
    struct path : public std::string {
        path() : std::string() { }
        path(const std::string s) : std::string(s) { }
        path(const char *p) : std::string(p) { }
        std::string string() const { return *this; }
        std::string generic_string() const { return string(); }
        const char* c_str() const { return this->c_str(); }
        path extension() const { return path(QFileInfo(string().c_str()).completeSuffix().toStdString()); }
        path filename() const { return path(QFileInfo(string().c_str()).fileName().toStdString()); }
        path stem() const { return path(QFileInfo(string().c_str()).baseName().toStdString()); }
        path& replace_extension( const path& replacement = path() ) {
            QFileInfo info(string().c_str());
            QString newName = info.path() + info.baseName() + replacement.string().c_str();
            *this = newName.toStdString();
            return *this;
        }
        path & operator /= (const path & p) {
            if ( ! p.empty() ) {
                if (this->empty()) {
                    *this = p;
                } else {
                    const auto sep = QDir::separator().toLatin1();
                    if (*this->string().rbegin() != sep)
                        *this += sep;
                    if (*p.string().begin() == sep)
                        *this += p.substr(1);
                    else
                        *this += p;
                }
            }
            return *this;
        }
        path make_preferred() const {  return path( QDir::toNativeSeparators(string().c_str()).toStdString() ); }
        path parent_path() { path(QFileInfo(string().c_str()).dir().path().toStdString()); }
        bool is_absolute() const { return QFileInfo(string().c_str()).isAbsolute(); }
    };
    inline qint64 last_write_time(const path &p) { return QFileInfo(string().c_str()).lastModified().toSecsSinceEpoch(); }
    inline size_t file_size(const path &p) { return QFile::exists(p.string().c_str()); }
    inline bool exists(const path &p) { return QFile::exists(p.string().c_str()); }
    inline path current_path() { return path( QDir::currentPath().toStdString() ); }
    inline void current_path(const path &p) { QDir::setCurrent(p.string().c_str()); }
    inline bool copy_file(const path& from, const path& to) {}
    inline bool rename(const path& old_p, const path& new_p) {}
    inline bool remove(const path& p) { QFile::remove(p.string().c_str()); }
    inline bool remove_all(const path& p) { return QDir().rmpath(p.string().c_str()); }
    inline bool create_directories(const path& p) { return QDir().mkpath(p.string().c_str()); }
    inline bool create_directory(const path& p) { return QDir().mkdir(p.string().c_str()); }
    inline path canonical(const path& p) { return QFile::exists(p.string().c_str())?QFileInfo(p.string().c_str()).canonicalFilePath().toStdString():QFileInfo(p.string().c_str()).absoluteFilePath().toStdString(); }
    inline path absolute(const path& p) { return QFileInfo(p.string().c_str()).absoluteFilePath().toStdString(); }
    inline bool is_regular_file(const path &p) { QFileInfo(p.string().c_str()).isFile(); }
	inline bool is_symlink(const path &p) { QFileInfo(p.string().c_str()).isSymLink(); }
	inline bool is_directory(const path &p) { return QFileInfo(p.string().c_str()).isDir(); }
    struct status_info {
        status_info(long uid, long gid, int perm) : st_uid(uid), st_gid(gid), st_perm(perm) {}
        QFile::Permissions permissions() const { return st_perm; };
        long st_uid, st_gid;
        QFile::Permissions st_perm;
    };
    inline status_info status(const path &p) {
        QFile::Permissions pm = QFileInfo(p.string().c_str()).permissions();
        return status_info(0, 0, pm);
    };
    struct directory_entry {
        directory_entry() {}
        directory_entry(const std::string &p) : entry(p) {}
        const std::filesystem::path path() const { return entry; }
        operator const std::filesystem::path& () const { return entry; }
        std::filesystem::path entry;
    };
    struct directory_iterator : public QDirIterator {
        directory_iterator() : QDirIterator("") {}
        directory_iterator(const std::filesystem::path &p, IteratorFlags flags = NoIteratorFlags) : QDirIterator(p.c_str(), flags), entry(filePath().toStdString()) {}
        const directory_entry& operator*() const { return entry; }
        const directory_entry *operator ->() { return &entry; }
        bool operator == (const directory_iterator & other) const {
            return (entry.path().empty() && other.entry.path().empty());
        }
        bool operator != (const directory_iterator & other) const { return !(*this == other); }
        void operator ++() { entry = next().toStdString(); }
        directory_entry entry;
    };
    struct recursive_directory_iterator : public directory_iterator {
        recursive_directory_iterator() : directory_iterator() {}
        recursive_directory_iterator(const std::filesystem::path &p) : directory_iterator(p.c_str(), Subdirectories) {}
    };
    inline path operator / (const path & lhs, const path & rhs)
    {
        path p(lhs);
        p /= rhs;
        return p;
    }
} }
#endif

// then the the platform specific includes:
#ifdef TARGET_QT
    #include <qopengl.h>
#endif

#ifdef TARGET_WIN32
	#define GLEW_STATIC
	#define GLEW_NO_GLU
	#include "GL/glew.h"
    #include "GL/wglew.h"
	#define __WINDOWS_DS__
	#define __WINDOWS_MM__
	#if (_MSC_VER)       // microsoft visual studio
		//TODO: Fix this in the code instead of disabling the warnings
		#define _CRT_SECURE_NO_WARNINGS
		#define _WINSOCK_DEPRECATED_NO_WARNINGS

		#include <stdint.h>
		#include <functional>
		#pragma warning(disable : 4068)		// unknown pragmas
		#pragma warning(disable : 4756)		// overflow in constant arithmetic
		#pragma warning(disable : 4800)		// 'Boolean' : forcing value to bool 'true' or 'false'

		// make microsoft visual studio complain less about double / float conversion and
		// truncation
		#pragma warning(disable : 4244)
		#pragma warning(disable : 4305)
		// warnings: http://msdn.microsoft.com/library/2c8f766e.aspx

		// NOMINMAX doesn't seem to work anymore in vs2015 so let's just remove them
		#undef min
		#undef max
	#endif

	#define TARGET_LITTLE_ENDIAN			// intel cpu

	// some gl.h files, like dev-c++, are old - this is pretty universal
	#ifndef GL_BGR_EXT
	#define GL_BGR_EXT 0x80E0
	#endif

	#define WIN32_HIGH_RES_TIMING

	// note: this is experimental!
	// uncomment to turn this on (only for windows machines)
	// if you want to try setting the timer to be high resolution
	// this could make camera grabbing and other low level
	// operations quicker, but you must quit the app normally,
	// ie, using "esc", rather than killing the process or closing
	// the console window in order to set the timer resolution back
	// to normal (since the high res timer might give the OS
	// problems)
	// info: http://www.geisswerks.com/ryan/FAQS/timing.html

#endif

#ifdef TARGET_OSX
	#ifndef __MACOSX_CORE__
		#define __MACOSX_CORE__
	#endif
	#include <unistd.h>
	#include "GL/glew.h"
	#include <OpenGL/gl.h>
	#include <ApplicationServices/ApplicationServices.h>

	#if defined(__LITTLE_ENDIAN__)
		#define TARGET_LITTLE_ENDIAN		// intel cpu
	#endif
#endif

#ifdef TARGET_LINUX

	#include <unistd.h>

	#ifdef TARGET_LINUX_ARM
		#ifdef TARGET_RASPBERRY_PI
			#include "bcm_host.h"
			// rpi firmware headers define countof
			// which messes up other libraries like glm
			#undef countof
		#endif

		#include "GLES/gl.h"
		#include "GLES/glext.h"
		#include "GLES2/gl2.h"
		#include "GLES2/gl2ext.h"

		#define EGL_EGLEXT_PROTOTYPES
		#include "EGL/egl.h"
		#include "EGL/eglext.h"
	#else // normal linux
		#define GL_GLEXT_PROTOTYPES
		#include <GL/glew.h>
		#include <GL/gl.h>
		#include <GL/glext.h>
	#endif

	// for some reason, this isn't defined at compile time,
	// so this hack let's us work
	// for 99% of the linux folks that are on intel
	// everyone one else will have RGB / BGR issues.
	//#if defined(__LITTLE_ENDIAN__)
	#define TARGET_LITTLE_ENDIAN		// intel cpu
	//#endif

	// some things for serial compilation:
	#define B14400	14400
	#define B28800	28800

#endif


#ifdef TARGET_OF_IOS
	#import <OpenGLES/ES1/gl.h>
	#import <OpenGLES/ES1/glext.h>

	#import <OpenGLES/ES2/gl.h>
	#import <OpenGLES/ES2/glext.h>


	#define TARGET_LITTLE_ENDIAN		// arm cpu
#endif

#ifdef TARGET_ANDROID
	#include <typeinfo>
	#include <unistd.h>
	#include <GLES/gl.h>
	#define GL_GLEXT_PROTOTYPES
	#include <GLES/glext.h>

	#include <GLES2/gl2.h>
	#include <GLES2/gl2ext.h>

	#define TARGET_LITTLE_ENDIAN
#endif

#ifdef TARGET_EMSCRIPTEN
	#include <GLES2/gl2.h>
	#include <GLES2/gl2ext.h>
	#include "EGL/egl.h"
	#include "EGL/eglext.h"

	#define TARGET_LITTLE_ENDIAN
#endif

#include "tesselator.h"
typedef TESSindex ofIndexType;



#define OF_EXIT_APP(val)		std::exit(val);


// core: ---------------------------
#include <cstdio>
#include <cstdlib>
#include <string>
#include <cstring>
#include <iostream>
#include <vector>
#include <memory>
#include <functional>


//------------------------------------------------ capture
// check if any video capture system is already defined from the compiler
#ifdef QT_MULTIMEDIA_LIB
  // use Qt multimedia framework
  #define OF_VIDEO_CAPTURE_QT
#elif !defined(OF_VIDEO_CAPTURE_GSTREAMER) && !defined(OF_VIDEO_CAPTURE_QUICKTIME) && !defined(OF_VIDEO_CAPTURE_DIRECTSHOW) && !defined(OF_VIDEO_CAPTURE_ANDROID) && !defined(OF_VIDEO_CAPTURE_IOS)
	#ifdef TARGET_LINUX

		#define OF_VIDEO_CAPTURE_GSTREAMER

	#elif defined(TARGET_OSX)
		//on 10.6 and below we can use the old grabber
		#ifndef MAC_OS_X_VERSION_10_7
			#define OF_VIDEO_CAPTURE_QUICKTIME
		//if we are below 10.12 or targeting below 10.12 we use QTKit
		#elif !defined(MAC_OS_X_VERSION_10_12) || MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_12
			#define OF_VIDEO_CAPTURE_QTKIT
		#else
			#define OF_VIDEO_CAPTURE_AVF
        #endif

	#elif defined (TARGET_WIN32)

		// comment out this following line, if you'd like to use the
		// quicktime capture interface on windows
		// if not, we default to videoInput library for
		// direct show capture...

		#define OF_SWITCH_TO_DSHOW_FOR_WIN_VIDCAP

		#ifdef OF_SWITCH_TO_DSHOW_FOR_WIN_VIDCAP
			#define OF_VIDEO_CAPTURE_DIRECTSHOW
		#else
			#define OF_VIDEO_CAPTURE_QUICKTIME
		#endif

	#elif defined(TARGET_ANDROID)

		#define OF_VIDEO_CAPTURE_ANDROID

	#elif defined(TARGET_EMSCRIPTEN)

		#define OF_VIDEO_CAPTURE_EMSCRIPTEN

	#elif defined(TARGET_OF_IOS)

		#define OF_VIDEO_CAPTURE_IOS

	#endif
#endif

//------------------------------------------------  video player
// check if any video player system is already defined from the compiler
#ifdef QT_MULTIMEDIA_LIB
  // use Qt multimedia framework
  #define OF_VIDEO_PLAYER_QT
#elif !defined(OF_VIDEO_PLAYER_GSTREAMER) && !defined(OF_VIDEO_PLAYER_IOS) && !defined(OF_VIDEO_PLAYER_DIRECTSHOW) && !defined(OF_VIDEO_PLAYER_QUICKTIME) && !defined(OF_VIDEO_PLAYER_AVFOUNDATION) && !defined(OF_VIDEO_PLAYER_EMSCRIPTEN)
    #ifdef TARGET_LINUX
        #define OF_VIDEO_PLAYER_GSTREAMER
    #elif defined(TARGET_ANDROID)
        #define OF_VIDEO_PLAYER_ANDROID
    #elif defined(TARGET_OF_IOS)
        #define OF_VIDEO_PLAYER_IOS
	#elif defined(TARGET_WIN32)
        #define OF_VIDEO_PLAYER_DIRECTSHOW
    #elif defined(TARGET_OSX)
        //for 10.8 and 10.9 users we use AVFoundation, for 10.7 we use QTKit, for 10.6 users we use QuickTime
        #ifndef MAC_OS_X_VERSION_10_7
            #define OF_VIDEO_PLAYER_QUICKTIME
        #elif !defined(MAC_OS_X_VERSION_10_8)
            #define OF_VIDEO_PLAYER_QTKIT
        #else
            #define OF_VIDEO_PLAYER_AVFOUNDATION
        #endif
    #elif defined(TARGET_EMSCRIPTEN)
        #define OF_VIDEO_PLAYER_EMSCRIPTEN
    #else
        #define OF_VIDEO_PLAYER_QUICKTIME
    #endif
#endif

//------------------------------------------------ soundstream
// check if any soundstream api is defined from the compiler
#ifdef QT_MULTIMEDIA_LIB
  // use Qt multimedia framework
  #define OF_SOUNDSTREAM_QT
#elif !defined(OF_SOUNDSTREAM_RTAUDIO) && !defined(OF_SOUNDSTREAM_ANDROID) && !defined(OF_SOUNDSTREAM_IOS) && !defined(OF_SOUNDSTREAM_EMSCRIPTEN)
	#if defined(TARGET_LINUX) || defined(TARGET_WIN32) || defined(TARGET_OSX)
		#define OF_SOUNDSTREAM_RTAUDIO
	#elif defined(TARGET_ANDROID)
		#define OF_SOUNDSTREAM_ANDROID
	#elif defined(TARGET_OF_IOS)
		#define OF_SOUNDSTREAM_IOS
	#elif defined(TARGET_EMSCRIPTEN)
		#define OF_SOUNDSTREAM_EMSCRIPTEN
	#endif
#endif

//------------------------------------------------ soundplayer
// check if any soundplayer api is defined from the compiler
#ifdef QT_MULTIMEDIA_LIB
  // use Qt multimedia framework
  #define OF_SOUND_PLAYER_QT
#elif !defined(OF_SOUND_PLAYER_QUICKTIME) && !defined(OF_SOUND_PLAYER_FMOD) && !defined(OF_SOUND_PLAYER_OPENAL) && !defined(OF_SOUND_PLAYER_EMSCRIPTEN)
  #ifdef TARGET_OF_IOS
  	#define OF_SOUND_PLAYER_IPHONE
  #elif defined(TARGET_LINUX)
  	#define OF_SOUND_PLAYER_OPENAL
  #elif defined(TARGET_EMSCRIPTEN)
	#define OF_SOUND_PLAYER_EMSCRIPTEN
  #elif !defined(TARGET_ANDROID) && (!defined(USE_FMOD) || USE_FMOD)
  	#define OF_SOUND_PLAYER_FMOD
  #endif
#endif

//------------------------------------------------ c++11
// check if the compiler supports c++11. vs hasn't updated the value
// of __cplusplus so we need to check for vs >= 2012 (1700)
#if __cplusplus>=201103 || _MSC_VER >= 1700
#define HAS_CPP11 1
#endif

//------------------------------------------------ thread local storage
// clang has a bug where it won't support tls on some versions even
// on c++11, this is a workaround that bug
#ifndef HAS_TLS
	#if defined(__clang__) && __clang__
		#if __has_feature(cxx_thread_local) && !defined(__MINGW64__) && !defined(__MINGW32__) && !defined(__ANDROID__) && !defined(TARGET_OF_IOS)
			#define HAS_TLS 1
		#endif
    #elif !defined(TARGET_WIN32) || _MSC_VER
		#define HAS_TLS 1
	#endif
#endif

//------------------------------------------------ make_unique
// This is a helper method for make unique on platforms that support C++11, but not C++14.
#if !defined(NO_OF_MAKE_UNIQUE) && (defined(_MSC_VER) && _MSC_VER < 1800) || (!defined(_MSC_VER) && __cplusplus <= 201103L)

// Implementation for C++11 platforms that do not yet have std::make_unique.
// Implementation from http://stackoverflow.com/a/13512344/1518329
namespace std {


template <typename T, typename... Args>
std::unique_ptr<T> make_unique_helper(std::false_type, Args&&... args) {
	return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

template <typename T, typename... Args>
std::unique_ptr<T> make_unique_helper(std::true_type, Args&&... args) {
	static_assert(std::extent<T>::value == 0,
				  "make_unique<T[N]>() is forbidden, please use make_unique<T[]>().");

	typedef typename std::remove_extent<T>::type U;
	return std::unique_ptr<T>(new U[sizeof...(Args)]{std::forward<Args>(args)...});
}

template <typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
	return make_unique_helper<T>(std::is_array<T>(), std::forward<Args>(args)...);
}


} // namespace std

#endif

//------------------------------------------------ forward declaration for std::filesystem::path
// Remove from here once everything is using std::filesystem::path
#ifndef TARGET_QT
# if OF_USING_STD_FS
#	if __cplusplus < 201703L

		namespace std {
			namespace experimental{
				namespace filesystem {
					namespace v1 {
						namespace __cxx11 {
							class path;
						}
					}

					using v1::__cxx11::path;
				}
			}
			namespace filesystem = experimental::filesystem;
		}
#	else

	namespace std {
		namespace filesystem {
			class path;
		}
	}
#	endif
# else
#	if !_MSC_VER
#		define BOOST_NO_CXX11_SCOPED_ENUMS
#		define BOOST_NO_SCOPED_ENUMS
#	endif
	namespace boost {
		namespace filesystem {
			class path;
		}
	}
	namespace std {
		namespace filesystem = boost::filesystem;
	}
# endif
#endif // TARGET_QT

#line 0 "../libs/openFrameworks/math/ofMathConstants.h"
#pragma once

/* #include "ofConstants.h" */
#include "glm/fwd.hpp"

#if OF_USE_LEGACY_VECTOR_MATH
class ofVec2f;
class ofVec3f;
class ofVec4f;
using ofDefaultVec2 = ofVec2f;
using ofDefaultVec3 = ofVec3f;
using ofDefaultVec4 = ofVec4f;
#else
using ofDefaultVec2 = glm::vec2;
using ofDefaultVec3 = glm::vec3;
using ofDefaultVec4 = glm::vec4;
#endif


#ifndef PI
	#define PI       3.14159265358979323846
#endif

#ifndef TWO_PI
	#define TWO_PI   6.28318530717958647693
#endif

#ifndef M_TWO_PI
	#define M_TWO_PI   6.28318530717958647693
#endif

#ifndef FOUR_PI
	#define FOUR_PI 12.56637061435917295385
#endif

#ifndef HALF_PI
	#define HALF_PI  1.57079632679489661923
#endif

#ifndef DEG_TO_RAD
	#define DEG_TO_RAD (PI/180.0)
#endif

#ifndef RAD_TO_DEG
	#define RAD_TO_DEG (180.0/PI)
#endif

#ifndef MIN
	#define MIN(x,y) (((x) < (y)) ? (x) : (y))
#endif

#ifndef MAX
	#define MAX(x,y) (((x) > (y)) ? (x) : (y))
#endif

#ifndef CLAMP
	#define CLAMP(val,min,max) ((val) < (min) ? (min) : ((val > max) ? (max) : (val)))
#endif

#ifndef ABS
	#define ABS(x) (((x) < 0) ? -(x) : (x))
#endif


#line 0 "../libs/openFrameworks/math/ofMath.h"
#pragma once

/* #include "ofConstants.h" */
#include <cmath>
#include <glm/gtc/constants.hpp>
#include <glm/fwd.hpp>

/// \file
/// ofMath provides a collection of mathematical utilities and functions.
///
/// \warning Many ofRandom-style functions wrap `rand()` which is not reentrant
/// or thread safe.  To generate random numbers simultaneously in multiple
/// threads, consider using c++11 uniform_real_distribution.
///
/// \sa http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution

/// \name Random Numbers
/// \{

/// \brief Get a random floating point number between 0 and max.
///
/// A random number in the range [0, max) will be returned.
///
/// Example:
///	~~~~~{.cpp}
/// // Return a random floating point number between 0 and 20.
/// float randomNumber = ofRandom(20);
/// ~~~~~
///
/// \warning ofRandom wraps C++'s `rand()` which is not reentrant or thread safe.
///
/// \param max The maximum value of the random number.
float ofRandom(float max); 

/// \brief Get a random number between two values.
///
/// A random number in the range [min, max) will be returned.
///
/// Example:
///	~~~~~{.cpp}
/// // Return a random floating point number between -30 and 20.
/// float randomNumber = ofRandom(-30, 20);
/// ~~~~~
///
/// \warning ofRandom wraps `rand()` which is not reentrant or thread safe.
///
/// \param val0 the minimum value of the random number.
/// \param val1 The maximum value of the random number.
/// \returns A random floating point number between val0 and val1.
float ofRandom(float val0, float val1);

/// \brief Get a random floating point number.
///
/// \warning ofRandom wraps `rand()` which is not reentrant or thread safe.
///
/// \returns A random floating point number between -1 and 1.
float ofRandomf();

/// \brief Get a random unsigned floating point number.
///
/// \warning ofRandom wraps `rand()` which is not reentrant or thread safe.
///
/// \returns A random floating point number between 0 and 1.
float ofRandomuf();


/// \brief Get a random floating point number between 0 and the screen width.
///
/// A random number in the range [0, ofGetWidth()) will be returned.
///
/// \warning ofRandom wraps `rand()` which is not reentrant or thread safe.
///
/// \returns a random number between 0 and ofGetWidth().
float ofRandomWidth();

/// \brief Get a random floating point number between 0 and the screen height.
///
/// A random number in the range [0, ofGetHeight()) will be returned.
///
/// \warning ofRandom wraps `rand()` which is not reentrant or thread safe.
///
/// \returns a random number between 0 and ofGetHeight().
float ofRandomHeight();

/// \brief Seed the seeds the random number generator with a unique value.
///
/// This seeds the random number generator with an acceptably random value, 
/// generated from clock time and the PID.
void ofSeedRandom();

/// \brief Seed the random number generator.
///
/// If the user would like to repeat the same random sequence, a known random
/// seed can be used to initialize the random number generator during app
/// setup.  This can be useful for debugging and testing.
///
/// \param val The value with which to seed the generator.
void ofSeedRandom(int val);

/// \}

/// \name Number Ranges
/// \{

/// \brief Given a value and an input range, map the value to be within 0 and 1.
///
/// Often, you'll need to work with percentages or other methods that expect a
/// value between 0 and 1.  This function will take a minimum and maximum and
/// then finds where within that range a value sits.  If the value is outside
/// the range, it will be mapped to 0 or 1.
///
/// \param value The number to be normalized.
/// \param min The lower bound of the range.
/// \param max The upper bound of the range.
/// \returns A float between 0 and 1.
float ofNormalize(float value, float min, float max);

/// \brief Given a value and an input range, map the value to an output range.
/// 
/// ofMap linearly maps the given value to a new value given an input and output
/// range.  Thus if value is 50% of the way between inputMin and inputMax, the
/// output value will be 50% of the way between outpuMin and outputMax. For
/// an input value _outside_ of the intputMin and inputMax range, negative
/// percentages and percentages greater than 100% will be used.  For example, if
/// the input value is 150 and the input range is 0 - 100 and the output range
/// 0 - 1000, the output value will be 1500 or 150% of the total range.  The
/// user can avoid mapping outside of the input range by clamping the output
/// value.  Clamping is disabled by default and ensures that the output value
/// always stays in the range [outputMin, outputMax).
///
/// Example:
/// ~~~~~{.cpp}
///		float x = 5;
///		float newx = 0;
///		// 0 <= x < 10
///		newx = ofMap(x, 0, 10, 21, 22); // newx = 21.5 a value [21, 22).
/// ~~~~~
///
/// \param value The number to be mapped.
/// \param inputMin The lower bound of the input range.
/// \param inputMax The upper bound of the input range.
/// \param outputMin The lower bound of the output range.
/// \param outputMax The upper bound of the output range.
/// \param clamp True if the value should be clamped to [outputMin, outputMax).
/// \note If the absolute difference between inputMin and inputMax is less than
///		  FLT_EPSILON, outputMin will be returned to prevent divide by zero
///		  errors.
/// \returns a mapped floating point number.
float ofMap(float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp = false);

/// \brief Clamp a value between min and max.
/// 
/// Restricts a value to be within a specified range defined by values min and
/// max. If the value is min <= value <= max, returns value.  If the value is
/// greater than max, return max; if the value is less than min, return min.
/// Otherwise, return the value unchanged.
/// 
/// ~~~~{.cpp}
///		float val = 10;
///		float newVal = 0;
///		newval = ofClamp(val, 30, 40); // newval = 30
///		newval = ofClamp(val, 0, 5);   // newval = 5
///		newval = ofClamp(val, 0, 20);  // newval = 10
/// ~~~~
///
/// \param value The number to be clamped.
/// \param min The lower bound of the range.
/// \param max The upper bound of the range.
/// \returns a floating point number in the range [min, max].
float ofClamp(float value, float min, float max);

/// \brief Determine if a number is inside of a giv(float)(en range.
/// \param t The value to test.
/// \param min The lower bound of the range.
/// \param max The upper bound of the range.
/// \returns true if the number t is the range of [min, max].
bool ofInRange(float t, float min, float max);

/// \brief Linearly interpolate a value within a range.
/// 
/// Calculates a number between two numbers [start, stop] at a specific increment
/// (amt).  If we want the new number to be between start and stop numbers, amt
/// needs to be a number between 0 and 1, inclusive.  ofLerp() does not clamp
/// the values.
///
/// ~~~~{.cpp}
///		float init = 1;
///		float end = 2;
///		float increment = 0.2;
///		float result = ofLerp(init, end, increment); // result = 1.2
///		// Values outside 0...1 work as well.
///		increment = 2;
///		result = ofLerp(init, end, increment); // result = 3
/// ~~~~
///
/// \sa float ofClamp(float value, float min, float max)
/// \param start The lower bound of the range.
/// \param stop The upper bound of the range.
/// \param amt The normalized [0, 1] value within the range to return.
/// \returns A float between start and stop.
float ofLerp(float start, float stop, float amt);

/// \}

//---------------------
/// \name Distance
/// \{

/// \brief Calculates the 2D distance between two points.
///
/// Uses the [Pythagorean theorem](http://en.wikipedia.org/wiki/Pythagorean_theorem).
///
/// \param x1 X position of first point.
/// \param y1 Y position of first point.
/// \param x2 X position of second point.
/// \param y2 Y position of second point.
/// \returns float Distance between points.
float ofDist(float x1, float y1, float x2, float y2);
///
/// \brief Calculates the 3D distance between two points.
///
/// Uses the [Pythagorean theorem](http://en.wikipedia.org/wiki/Pythagorean_theorem).
///
/// \param x1 X position of first point.
/// \param y1 Y position of first point.
/// \param z1 Z position of first point.
/// \param x2 X position of second point.
/// \param y2 Y position of second point.
/// \param z2 Z position of second point.
/// \returns float Distance between points.
float ofDist(float x1, float y1, float z1, float x2, float y2, float z2);

/// \brief Calculates the squared 2D distance between two points.
///
/// Same as ofDist() but doesn't take the square root sqrt() of the result,
/// which is a faster operation if you need to calculate and compare multiple
/// distances.
///
/// \param x1 X position of first point.
/// \param y1 Y position of first point.
/// \param x2 X position of second point.
/// \param y2 Y position of second point.
/// \returns distance-squared between two points.
float ofDistSquared(float x1, float y1, float x2, float y2);

/// \brief Calculates the squared 3D distance between two points.
///
/// Same as ofDist() but doesn't take the square root sqrt() of the result,
/// which is a faster operation if you need to calculate and compare multiple
/// distances.
///
/// \param x1 X position of first point.
/// \param y1 Y position of first point.
/// \param z1 Z position of first point.
/// \param x2 X position of second point.
/// \param y2 Y position of second point.
/// \param z2 Z position of second point.
/// \returns distance-squared between two points.
float ofDistSquared(float x1, float y1, float z1, float x2, float y2, float z2);

/// \}


/// \name Angles
/// \{

/// \brief Convert radians to degrees.
///
/// Example:
/// ~~~~{.cpp}
///		float result = ofRadToDeg(PI/2); // The result will be 90.
/// ~~~~
///
/// \param radians An angle in radians.
/// \returns the angle in degrees.
float ofRadToDeg(float radians);

/// \brief Convert degrees to radians.
///
/// Example:
/// ~~~~{.cpp}
///		float result = ofDegToRad(90); // The result will be PI/2.
/// ~~~~
///
/// \param degrees An angle in degrees.
/// \returns the angle in radians.
float ofDegToRad(float degrees);

/// \brief Linearly interpolate a value between two angles in degrees.
/// 
/// Calculates a number between two numbers [start, stop) at a specific
/// increment (amt). This does constrain the result into a single rotation,
/// but does not clamp the values
///
/// \param currentAngle The lower bound of the range in degrees.
/// \param targetAngle The upper bound of the range in degrees.
/// \param pct An amount between [0.0, 1.0] within the range to return.
/// \returns An angle in degrees between currentAngle and targetAngle.
float ofLerpDegrees(float currentAngle, float targetAngle, float pct);

/// \brief Linearly interpolate a value between two angles in radians.
/// 
/// Calculates a number between two numbers (start, stop) at a specific
/// increment (amt).  This does constrain the result into a single rotation, but
/// does not clamp the values
///
/// \param currentAngle The lower bound of the range in radians.
/// \param targetAngle The upper bound of the range in radians.
/// \param pct An amount between [0.0, 1.0] within the range to return.
/// \returns An angle in radians between currentAngle and targetAngle.
float ofLerpRadians(float currentAngle, float targetAngle, float pct);

/// \brief Calculates the difference between two angles in degrees.
///
/// This will calculate the actual difference, taking into account multiple
/// revolutions. For example:
///
/// ~~~~{.cpp}
///		ofAngleDifferenceDegrees(0, 90); // Returns 90.
///		ofAngleDifferenceDegrees(0, 450); // Also returns 90.
/// ~~~~
///
/// \param currentAngle The current angle in degrees.
/// \param targetAngle the angle to be compared to in degrees.
/// \returns The difference between two angles in degrees.
float ofAngleDifferenceDegrees(float currentAngle, float targetAngle);

/// \brief Calculates the difference between two angles in radians.
///
/// This will calculate the actual difference, taking into account multiple
/// revolutions. For example:
///
/// ~~~~{.cpp}
///		ofAngleDifferenceRadians(0, PI); // Returns -PI.
///		ofAngleDifferenceRadians(0, 3*PI); // Also returns -PI.
/// ~~~~
///
/// \param currentAngle The current angle in radians.
/// \param targetAngle the angle to be compared to in radians.
/// \returns The difference between two angles in radians.
float ofAngleDifferenceRadians(float currentAngle, float targetAngle);

/// \}

/// \name Number wrapping
/// \{


/// \brief Find a value within a given range, wrapping the value if it overflows.
///
/// If a value is between from and to, return that value.
/// If a value is NOT within that range, wrap it.
///
/// Example:
/// ~~~~{.cpp}
///		ofWrap(5, 0, 10); // Returns 5.
///		ofWrap(15, 0, 10); // Also returns 5.
///		ofWrap(-5, 0, 10); // Also returns 5.
/// ~~~~
///
/// \param value The value to map.
/// \param from The lower bound of the range.
/// \returns to The upper bound of the range.
float ofWrap(float value, float from, float to);

// \brief Convenience function for ofWrap(), constrained between -PI...PI
float ofWrapRadians(float angle, float from = -glm::pi<float>(), float to=glm::pi<float>());

// \brief Convenience function for ofWrap(), constrained between -180...180
float ofWrapDegrees(float angle, float from = -180, float to=+180);

/// \}

/// \name Noise
/// \{


/// \brief Calculates a one dimensional Perlin noise value between 0.0...1.0.
float ofNoise(float x);

/// \brief Calculates a two dimensional Perlin noise value between 0.0...1.0.
float ofNoise(float x, float y);

/// \brief Calculates a two dimensional Perlin noise value between 0.0...1.0.
float ofNoise(const glm::vec2& p);

/// \brief Calculates a three dimensional Perlin noise value between 0.0...1.0.
float ofNoise(float x, float y, float z);

/// \brief Calculates a three dimensional Perlin noise value between 0.0...1.0.
float ofNoise(const glm::vec3& p);

/// \brief Calculates a four dimensional Perlin noise value between 0.0...1.0.
float ofNoise(float x, float y, float z, float w);

/// \brief Calculates a four dimensional Perlin noise value between 0.0...1.0.
float ofNoise(const glm::vec4& p);

/// \brief Calculates a one dimensional Perlin noise value between -1.0...1.0.
float ofSignedNoise(float x);

/// \brief Calculates a two dimensional Perlin noise value between -1.0...1.0.
float ofSignedNoise(float x, float y);

/// \brief Calculates a two dimensional Perlin noise value between -1.0...1.0.
float ofSignedNoise(const glm::vec2& p);

/// \brief Calculates a three dimensional Perlin noise value between -1.0...1.0.
float ofSignedNoise(float x, float y, float z);

/// \brief Calculates a three dimensional Perlin noise value between -1.0...1.0.
float ofSignedNoise(const glm::vec3& p);

/// \brief Calculates a four dimensional Perlin noise value between -1.0...1.0.
float ofSignedNoise(float x, float y, float z, float w);

/// \brief Calculates a four dimensional Perlin noise value between -1.0...1.0.
float ofSignedNoise(const glm::vec4 & p);

/// \}


/// \name Geometry
/// \{


/// \brief Determine the intersection between two lines.
/// \param line1Start Starting point for first line.
/// \param line1End End point for first line.
/// \param line2Start Starting point for second line.
/// \param line2End End point for second line.
/// \param intersection glm::vec3 reference in which to store the computed intersection point.
/// \returns True if the lines intersect.
template<class vectype>
bool ofLineSegmentIntersection(const vectype& line1Start, const vectype& line1End, const vectype& line2Start, const vectype& line2End, vectype& intersection){
	vectype diffLA, diffLB;
	float compareA, compareB;
	diffLA = line1End - line1Start;
	diffLB = line2End - line2Start;
	compareA = diffLA.x*line1Start.y - diffLA.y*line1Start.x;
	compareB = diffLB.x*line2Start.y - diffLB.y*line2Start.x;
	if (
		(
			( ( diffLA.x*line2Start.y - diffLA.y*line2Start.x ) < compareA ) ^
			( ( diffLA.x*line2End.y - diffLA.y*line2End.x ) < compareA )
		)
		&&
		(
			( ( diffLB.x*line1Start.y - diffLB.y*line1Start.x ) < compareB ) ^
			( ( diffLB.x*line1End.y - diffLB.y*line1End.x) < compareB )
		)
	)
	{
		float lDetDivInv = 1 / ((diffLA.x*diffLB.y) - (diffLA.y*diffLB.x));
		intersection.x =  -((diffLA.x*compareB) - (compareA*diffLB.x)) * lDetDivInv ;
		intersection.y =  -((diffLA.y*compareB) - (compareA*diffLB.y)) * lDetDivInv ;

		return true;
	}

	return false;
}

/// \brief Given the four points that determine a bezier curve, return an interpolated point on the curve.
/// \param a The beginning point of the curve.
/// \param b The first control point.
/// \param c The second control point.
/// \param d The end point of the curve.
/// \param t an offset along the curve, normalized between 0 and 1.
/// \returns A glm::vec3 on the curve.
template<class vectype>
vectype ofBezierPoint(const vectype& a, const vectype& b, const vectype& c, const vectype& d, float t){
	float tp = 1.0f - t;
	return a*tp*tp*tp + b*3*t*tp*tp + c*3*t*t*tp + d*t*t*t;
}

/// \brief Given the four points that determine a Catmull Rom curve, return an interpolated point on the curve.
/// \param a The first control point.
/// \param b The beginning point of the curve.
/// \param c The end point of the curve.
/// \param d The second control point.
/// \param t an offset along the curve, normalized between 0 and 1.
/// \returns A glm::vec3 on the curve.
template <class vectype>
vectype ofCurvePoint(const vectype& a, const vectype& b, const vectype& c, const vectype& d, float t){
	vectype pt;
	float t2 = t * t;
	float t3 = t2 * t;
	pt.x = 0.5f * ( ( 2.0f * b.x ) +
				   ( -a.x + c.x ) * t +
				   ( 2.0f * a.x - 5.0f * b.x + 4 * c.x - d.x ) * t2 +
				   ( -a.x + 3.0f * b.x - 3.0f * c.x + d.x ) * t3 );
	pt.y = 0.5f * ( ( 2.0f * b.y ) +
				   ( -a.y + c.y ) * t +
				   ( 2.0f * a.y - 5.0f * b.y + 4 * c.y - d.y ) * t2 +
				   ( -a.y + 3.0f * b.y - 3.0f * c.y + d.y ) * t3 );
	return pt;
}

/// Given the four points that determine a bezier curve and an offset along the curve, return an tangent vector to a point on the curve.
/// Currently this is not a normalized point, and will need to be normalized.
/// \param a The beginning point of the curve.
/// \param b The first control point.
/// \param c The second control point.
/// \param d The end point of the curve.
/// \param t an offset along the curve, normalized between 0 and 1.
/// \returns A glm::vec3 on the curve.
template <class vectype>
vectype ofBezierTangent(const vectype& a, const vectype& b, const vectype& c, const vectype& d, float t){
	return (d-a-c*3+b*3)*(t*t)*3 + (a+c-b*2)*t*6 - a*3+b*3;
}

/// \brief Return a tangent point for an offset along a Catmull Rom curve.
/// \param a The first control point.
/// \param b The beginning point of the curve.
/// \param c The end point of the curve.
/// \param d The second control point.
/// \param t an offset along the curve, normalized between 0 and 1.
/// \returns A glm::vec3 on the curve.
template <class vectype>
vectype ofCurveTangent(const vectype& a, const vectype& b, const vectype& c, const vectype& d, float t){
	auto v0 = ( c - a )*0.5;
	auto v1 = ( d - b )*0.5;
	return ( b*2 -c*2 + v0 + v1)*(3*t*t) + ( c*3 - b*3 - v1 - v0*2 )*( 2*t) + v0;

}

template<typename Type>
Type ofInterpolateCosine(const Type& y1, const Type& y2, float pct);
template<typename Type>
Type ofInterpolateCubic(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct);
template<typename Type>
Type ofInterpolateCatmullRom(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct);
template<typename Type>
Type ofInterpolateHermite(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct);
template<typename Type>
Type ofInterpolateHermite(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct, float tension, float bias);

/// \}


/// \name Others
/// \{

/// \brief Calculates the next larger power of 2.
///
/// If the input is already a power of 2, it will return itself.  
///
/// Example:
/// ~~~~{.cpp}
/// ofNextPow2(50); // returns 64
/// ofNextPow2(64); // returns 64
/// ofNextPow2(401); // returns 512
/// ~~~~
///
/// \param a The starting point for finding the next power of 2.
/// \returns value^2.
int ofNextPow2(int a);

/// \brief Returns the sign of a number.
/// \returns int -1 if n is negative, 1 if n is positive, and 0 is n == 0;
int ofSign(float n);

/// \brief Compare two floating point types for equality.
///
/// From C++ FAQ:
///
/// Floating point arithmetic is different from real number arithmetic.
/// Never use `==` to compare two floating point numbers.
///
/// This solution is not completely symmetric, meaning it is possible for
/// `ofIsFloatEqual(x, y) != ofIsFloatEqual(y, x)`. From a practical
/// standpoint, this does not usually occur when the magnitudes of x and y are
/// significantly larger than epsilon, but your mileage may vary.
///
/// \sa https://isocpp.org/wiki/faq/newbie#floating-point-arith
/// \sa https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
/// \tparam The floating point data type.
/// \param a The first floating point type variable to compare.
/// \param b The second floating point type variable to compare.
/// \returns True if `std::abs(x - y) <= std::numeric_limits<Type>::epsilon() * std::abs(x)`.
template<typename Type>
typename std::enable_if<std::is_floating_point<Type>::value, bool>::type ofIsFloatEqual(const Type& a, const Type& b)
{
	return std::abs(a - b) <= std::numeric_limits<Type>::epsilon() * std::abs(a);
}

/// \}




// from http://paulbourke.net/miscellaneous/interpolation/
//--------------------------------------------------
template<typename Type>
Type ofInterpolateCosine(const Type& y1, const Type& y2, float pct){
	float pct2;

	pct2 = (1-cos(pct*glm::pi<float>()))/2;
	return(y1*(1-pct2)+y2*pct2);
}

// from http://paulbourke.net/miscellaneous/interpolation/
//--------------------------------------------------
template<typename Type>
Type ofInterpolateCubic(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct){
	Type a0,a1,a2,a3;
	float pct2;

	pct2 = pct*pct;
	a0 = y3 - y2 - y0 + y1;
	a1 = y0 - y1 - a0;
	a2 = y2 - y0;
	a3 = y1;

	return(a0*pct*pct2+a1*pct2+a2*pct+a3);
}

// from http://paulbourke.net/miscellaneous/interpolation/
//--------------------------------------------------
template<typename Type>
Type ofInterpolateCatmullRom(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct){
	Type a0,a1,a2,a3;
	float pct2 = pct*pct;
	a0 = -0.5*y0 + 1.5*y1 - 1.5*y2 + 0.5*y3;
	a1 = y0 - 2.5*y1 + 2*y2 - 0.5*y3;
	a2 = -0.5*y0 + 0.5*y2;
	a3 = y1;
	return(a0*pct*pct2 + a1*pct2 + a2*pct +a3);
}

// from http://musicdsp.org/showArchiveComment.php?ArchiveID=93
// laurent de soras
//--------------------------------------------------
template<typename Type>
inline Type ofInterpolateHermite(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct){
	const Type c = (y2 - y0) * 0.5f;
	const Type v = y1 - y2;
	const Type w = c + v;
	const Type a = w + v + (y3 - y1) * 0.5f;
	const Type b_neg = w + a;

	return ((((a * pct) - b_neg) * pct + c) * pct + y1);
}

// from http://paulbourke.net/miscellaneous/interpolation/
//--------------------------------------------------
template<typename Type>
Type ofInterpolateHermite(const Type& y0, const Type& y1, const Type& y2, const Type& y3, float pct, float tension, float bias){
	float pct2,pct3;
	Type m0,m1;
	Type a0,a1,a2,a3;

	pct2 = pct * pct;
	pct3 = pct2 * pct;
	m0  = (y1-y0)*(1+bias)*(1-tension)/2;
	m0 += (y2-y1)*(1-bias)*(1-tension)/2;
	m1  = (y2-y1)*(1+bias)*(1-tension)/2;
	m1 += (y3-y2)*(1-bias)*(1-tension)/2;
	a0 =  Type(2*pct3 - 3*pct2 + 1);
	a1 =  Type(pct3 - 2*pct2 + pct);
	a2 =  Type(pct3 -   pct2);
	a3 =  Type(-2*pct3 + 3*pct2);

   return(a0*y1+a1*m0+a2*m1+a3*y2);
}

#line 0 "../libs/openFrameworks/math/ofVec4f.h"
#pragma once

class ofVec2f;
class ofVec3f;

/* #include "ofConstants.h" */
#include <cmath>
#include "glm/vec4.hpp"
#include "glm/fwd.hpp"

class ofVec4f {
public:
    /// \cond INTERNAL
    static const int DIM = 4;
    /// \endcond
	
	float x;
	float y;
	float z;
	float w;

	//---------------------
	/// \name Construct a 4D vector
	/// \{
    
	ofVec4f();
	explicit ofVec4f( float _scalar );
	ofVec4f( float _x, float _y, float _z, float _w );
	ofVec4f( const ofVec2f& vec);
	ofVec4f( const ofVec3f& vec);
	ofVec4f( const glm::vec2& vec);
	ofVec4f( const glm::vec3& vec);
	ofVec4f( const glm::vec4& vec);

    operator glm::vec4() const;

    /// \}

	//---------------------
	/// \name Access components
	/// \{

	
	float * getPtr() {
		return (float*)&x;
	}
	const float * getPtr() const {
		return (const float *)&x;
	}
	
	float& operator[]( int n ){
		return getPtr()[n];
	}
	
	float operator[]( int n ) const {
		return getPtr()[n];
	}

	void set( float _scalar );
    void set( float _x, float _y, float _z, float _w );
    void set( const ofVec4f& vec );
	
	
	/// \}

    //---------------------
	/// \name Comparison 
	/// \{


    bool operator==( const ofVec4f& vec ) const;
    bool operator!=( const ofVec4f& vec ) const;
    bool match( const ofVec4f& vec, float tolerance = 0.0001f) const;
	
	/// \}

	//---------------------
	/// \name Operators
	/// \{

    ofVec4f  operator+( const ofVec4f& vec ) const;
    ofVec4f  operator+( const float f ) const;
    ofVec4f& operator+=( const ofVec4f& vec );
    ofVec4f& operator+=( const float f );
    ofVec4f  operator-( const float f ) const;
    ofVec4f  operator-( const ofVec4f& vec ) const;
    ofVec4f  operator-() const;
    ofVec4f& operator-=( const float f );
    ofVec4f& operator-=( const ofVec4f& vec );
	
	
    ofVec4f  operator*( const ofVec4f& vec ) const;
    ofVec4f  operator*( const float f ) const;
    ofVec4f& operator*=( const ofVec4f& vec );
    ofVec4f& operator*=( const float f );
    ofVec4f  operator/( const ofVec4f& vec ) const;
    ofVec4f  operator/( const float f ) const;
    ofVec4f& operator/=( const ofVec4f& vec );
    ofVec4f& operator/=( const float f );
	    
	/// \cond INTERNAL
	friend std::ostream& operator<<(std::ostream& os, const ofVec4f& vec);
	friend std::istream& operator>>(std::istream& is, const ofVec4f& vec);
	/// \endcond

    /// \}
	
	//---------------------
	/// \name Simple manipulations
	/// \{

    /// \brief Returns a new ofVec4f that is the result of scaling this vector up or down so that it has the requested length.
    ///
    /// \param length The desired length of the new ofVec4f object.
    /// \returns The result of scaling the this vector up or down.
    ofVec4f  getScaled( const float length ) const;
    
    /// \brief Scales this vector up or down so that it has the requested length.
    ///
    /// \param length The desired length of the vector.
    ofVec4f& scale( const float length );
	
	/// \}
	
	
	//---------------------
	/// \name Distance
	/// \{

    /// \brief Treats this vector and 'pnt' as points in 4D space and calculates the distance between them.
    ///
    /// \param pnt The vector used in the distance calculation with the current vector.
    /// \returns The distance between the two vectors in 4D space.
    float distance( const ofVec4f& pnt) const;
    float squareDistance( const ofVec4f& pnt ) const;
	
	/// \}

	//---------------------
	/// \name Interpolation
	/// \{


    /// \brief Performs a linear interpolation of this vector towards 'pnt'.
    ///
    /// \param pnt The vector the interpolation will be performed on. 
    /// \param p The amount to move towards 'pnt'; 'p' is normally between 0 and 1 and where 0 means stay the original position and 1 means move all the way to 'pnt', but you can also have 'p' greater than 1 overshoot 'pnt', or less than 0 to move backwards away from 'pnt'.
    /// \returns The interpolation as an ofVec4f. 
    ofVec4f   getInterpolated( const ofVec4f& pnt, float p ) const;
    
    /// \brief Performs a linear interpolation of this vector towards 'pnt'. This modifies the current vector to the interpolated value.
    ///
    /// \param pnt The vector the interpolation will be performed on. 
    /// \param p The amount to move towards 'pnt'; 'p' is normally between 0 and 1 and where 0 means stay the original position and 1 means move all the way to 'pnt', but you can also have 'p' greater than 1 overshoot 'pnt', or less than 0 to move backwards away from 'pnt'.
    ofVec4f&  interpolate( const ofVec4f& pnt, float p );
    
    /// \brief Calculates and returns the midpoint (as a vector) between this vector and 'pnt'.
    ///
    /// \param pnt The vector used in the midpoint calculation with this vector.
    /// \returns The midpoint between this vector and 'pnt' as an ofVec4f.
    ofVec4f   getMiddle( const ofVec4f& pnt ) const;
    
    /// \brief Calculates and returns the midpoint (as a vector) between this vector and 'pnt'. This modifies the current vector to the midpoint value.
    ///
    /// \param pnt The vector used in the midpoint calculation with this vector.
    /// \returns The midpoint between this vector and 'pnt' as an ofVec4f.
    ofVec4f&  middle( const ofVec4f& pnt );
    
    /// \brief Sets this vector to be the average (center of gravity or centroid) of a given array of 'ofVec4f's.
    /// 
    /// \param points The array of 'ofVec4f's used in the average calculation.
    /// \param num The number of ofVec4f objects in the array.
    ofVec4f&  average( const ofVec4f* points, int num );

    /// \}

    //---------------------
	/// \name Limit
	/// \{
    
    /// \brief Returns a normalized copy of this vector.
    ///
    /// Normalization means to scale the vector so that its length (magnitude) is exactly 1, 
    /// at which stage all that is left is the direction. A normalized vector is usually called 
    /// a unit vector, and can be used to represent a pure direction (heading).
    ///
    /// \returns The normalized copy of the current vector.
    ofVec4f  getNormalized() const;
    
    /// \brief Normalizes the vector. This changes the current vector to its normalized value. 
    ///
    /// Normalization means to scale the vector so that its length (magnitude) is exactly 1, 
    /// at which stage all that is left is the direction. A normalized vector is usually called 
    /// a unit vector, and can be used to represent a pure direction (heading).
    ofVec4f& normalize();
	
	
    /// \brief Returns a copy of this vector with its length (magnitude) restricted to a maximum of 'max' units by scaling down if necessary.
    ///
    /// \param max The maximum length of the new vector. 
    /// \returns A copy of the current vector that is at most 'max' units long. 
    ofVec4f  getLimited(float max) const;
    /// \brief Restrict the length (magnitude) of this vector to a maximum of 'max' units by scaling down if necessary.
    ///
    /// \param max The maximum length of the current vector.
    ofVec4f& limit(float max);
	
	/// \}

	//---------------------
	/// \name Measurement
	/// \{
	
    /// \brief Returns the length (magnitude) of this vector.
    ///
    /// \returns The magnitude of the current vector. 
    float length() const;
    float lengthSquared() const;


  	/// \}

	//---------------------
	/// \name Calculations
	/// \{


    /// \brief Calculates and returns the dot product of this vector with 'vec'.
    ///
    /// Dot product (less commonly known as Euclidean inner product) expresses the angular 
    /// relationship between two vectors. In other words it is a measure of how parallel two vectors 
    /// are. If they are completely perpendicular the dot product is 0; if they are completely parallel 
    /// their dot product is either 1 if they are pointing in the same direction, or -1 if they are pointing 
    /// in opposite directions.
    /// 
    /// \param vec The vector used in the dot product calculation with this vector.
    /// \returns The dot product of this vector with 'vec'. 
    float dot( const ofVec4f& vec ) const;
		
	/// \}

	
	
	
    //---------------------------------------
    // this methods are deprecated in 006 please use:
	/// \cond INTERNAL
	
    // getScaled
    OF_DEPRECATED_MSG("Use member method getScaled() instead.", ofVec4f rescaled( const float length ) const);
	
    // scale
    OF_DEPRECATED_MSG("Use member method scale() instead.", ofVec4f& rescale( const float length ));
	
    // getNormalized
    OF_DEPRECATED_MSG("Use member method getNormalized() instead.", ofVec4f normalized() const);
	
    // getLimited
    OF_DEPRECATED_MSG("Use member method getLimited() instead.", ofVec4f limited(float max) const);
	
    // use squareDistance
    OF_DEPRECATED_MSG("Use member method squareDistance() instead.", float  distanceSquared( const ofVec4f& pnt ) const);
	
    // use getInterpolated
    OF_DEPRECATED_MSG("Use member method getInterpolated() instead.", ofVec4f interpolated( const ofVec4f& pnt, float p ) const);
	
    // use getMiddle
    OF_DEPRECATED_MSG("Use member method getMiddle() instead.", ofVec4f middled( const ofVec4f& pnt ) const);
    
    // return all zero vector
    static ofVec4f zero() { return ofVec4f(0, 0, 0, 0); }
    
    // return all one vector
    static ofVec4f one() { return ofVec4f(1, 1, 1, 1); }
    /// \endcond
};


/// \cond INTERNAL


// Non-Member operators
//
//
ofVec4f operator+( float f, const ofVec4f& vec );
ofVec4f operator-( float f, const ofVec4f& vec );
ofVec4f operator*( float f, const ofVec4f& vec );
ofVec4f operator/( float f, const ofVec4f& vec );







/////////////////
// Implementation
/////////////////

inline ofVec4f::ofVec4f(): x(0), y(0), z(0), w(0) {}
inline ofVec4f::ofVec4f(float _s): x(_s), y(_s), z(_s), w(_s) {}
inline ofVec4f::ofVec4f( float _x,
						float _y,
						float _z,
						float _w ):x(_x), y(_y), z(_z), w(_w) {}


inline ofVec4f::operator glm::vec4() const{
	return glm::vec4(x,y,z,w);
}
// Getters and Setters.
//
//
inline void ofVec4f::set( float _scalar) {
	x = _scalar;
	y = _scalar;
	z = _scalar;
	w = _scalar;
}

inline void ofVec4f::set( float _x, float _y, float _z, float _w ) {
	x = _x;
	y = _y;
	z = _z;
	w = _w;
}

inline void ofVec4f::set( const ofVec4f& vec ) {
	x = vec.x;
	y = vec.y;
	z = vec.z;
	w = vec.w;
}


// Check similarity/equality.
//
//
inline bool ofVec4f::operator==( const ofVec4f& vec ) const {
	return (x == vec.x) && (y == vec.y) && (z == vec.z) && (w == vec.w);
}

inline bool ofVec4f::operator!=( const ofVec4f& vec ) const {
	return (x != vec.x) || (y != vec.y) || (z != vec.z) || (w != vec.w);
}

inline bool ofVec4f::match( const ofVec4f& vec, float tolerance) const {
	return (fabs(x - vec.x) < tolerance)
	&& (fabs(y - vec.y) < tolerance)
	&& (fabs(z - vec.z) < tolerance)
	&& (fabs(w - vec.w) < tolerance);
}




// Additions and Subtractions.
//
//
inline ofVec4f ofVec4f::operator+( const ofVec4f& vec ) const {
	return ofVec4f( x+vec.x, y+vec.y, z+vec.z, w+vec.w);
}

inline ofVec4f& ofVec4f::operator+=( const ofVec4f& vec ) {
	x += vec.x;
	y += vec.y;
	z += vec.z;
	w += vec.w;
	return *this;
}

inline ofVec4f ofVec4f::operator-( const float f ) const {
	return ofVec4f( x-f, y-f, z-f, w-f );
}

inline ofVec4f& ofVec4f::operator-=( const float f ) {
	x -= f;
	y -= f;
	z -= f;
	w -= f;
	return *this;
}

inline ofVec4f ofVec4f::operator-( const ofVec4f& vec ) const {
	return ofVec4f( x-vec.x, y-vec.y, z-vec.z, w-vec.w );
}

inline ofVec4f& ofVec4f::operator-=( const ofVec4f& vec ) {
	x -= vec.x;
	y -= vec.y;
	z -= vec.z;
	w -= vec.w;
	return *this;
}

inline ofVec4f ofVec4f::operator+( const float f ) const {
	return ofVec4f( x+f, y+f, z+f, w+f );
}

inline ofVec4f& ofVec4f::operator+=( const float f ) {
	x += f;
	y += f;
	z += f;
	w += f;
	return *this;
}

inline ofVec4f ofVec4f::operator-() const {
	return ofVec4f( -x, -y, -z, -w );
}


// Scalings
//
//
inline ofVec4f ofVec4f::operator*( const ofVec4f& vec ) const {
	return ofVec4f( x*vec.x, y*vec.y, z*vec.z, w*vec.w );
}

inline ofVec4f& ofVec4f::operator*=( const ofVec4f& vec ) {
	x *= vec.x;
	y *= vec.y;
	z *= vec.z;
	w *= vec.w;
	return *this;
}

inline ofVec4f ofVec4f::operator*( const float f ) const {
	return ofVec4f( x*f, y*f, z*f, w*f );
}

inline ofVec4f& ofVec4f::operator*=( const float f ) {
	x *= f;
	y *= f;
	z *= f;
	w *= f;
	return *this;
}

inline ofVec4f ofVec4f::operator/( const ofVec4f& vec ) const {
	return ofVec4f( vec.x!=0 ? x/vec.x : x , vec.y!=0 ? y/vec.y : y, vec.z!=0 ? z/vec.z : z, vec.w!=0 ? w/vec.w : w  );
}

inline ofVec4f& ofVec4f::operator/=( const ofVec4f& vec ) {
	vec.x!=0 ? x/=vec.x : x;
	vec.y!=0 ? y/=vec.y : y;
	vec.z!=0 ? z/=vec.z : z;
	vec.w!=0 ? w/=vec.w : w;
	return *this;
}

inline ofVec4f ofVec4f::operator/( const float f ) const {
	if(f == 0) return ofVec4f(x, y, z, w);
	
	return ofVec4f( x/f, y/f, z/f, w/f );
}

inline ofVec4f& ofVec4f::operator/=( const float f ) {
	if(f == 0)return *this;
	
	x /= f;
	y /= f;
	z /= f;
	w /= f;
	return *this;
}


inline std::ostream& operator<<(std::ostream& os, const ofVec4f& vec) {
	os << vec.x << ", " << vec.y << ", " << vec.z << ", " << vec.w;
	return os;
}

inline std::istream& operator>>(std::istream& is, ofVec4f& vec) {
	is >> vec.x;
	is.ignore(2);
	is >> vec.y;
	is.ignore(2);
	is >> vec.z;
	is.ignore(2);
	is >> vec.w;
	return is;
}


inline ofVec4f ofVec4f::rescaled( const float length ) const {
	return getScaled(length);
}

inline ofVec4f ofVec4f::getScaled( const float length ) const {
	float l = (float)sqrt(x*x + y*y + z*z + w*w);
	if( l > 0 )
		return ofVec4f( (x/l)*length, (y/l)*length,
					   (z/l)*length, (w/l)*length );
	else
		return ofVec4f();
}

inline ofVec4f& ofVec4f::rescale( const float length ) {
	return scale(length);
}

inline ofVec4f& ofVec4f::scale( const float length ) {
	float l = (float)sqrt(x*x + y*y + z*z + w*w);
	if (l > 0) {
		x = (x/l)*length;
		y = (y/l)*length;
		z = (z/l)*length;
		w = (w/l)*length;
	}
	return *this;
}



// Distance between two points.
//
//
inline float ofVec4f::distance( const ofVec4f& pnt) const {
	float vx = x-pnt.x;
	float vy = y-pnt.y;
	float vz = z-pnt.z;
	float vw = w-pnt.w;
	return (float)sqrt( vx*vx + vy*vy + vz*vz + vw*vw );
}

inline float ofVec4f::distanceSquared( const ofVec4f& pnt ) const {
	return squareDistance(pnt);
}

inline float ofVec4f::squareDistance( const ofVec4f& pnt ) const {
	float vx = x-pnt.x;
	float vy = y-pnt.y;
	float vz = z-pnt.z;
	float vw = w-pnt.w;
	return vx*vx + vy*vy + vz*vz + vw*vw;
}



// Linear interpolation.
//
//
/**
 * p==0.0 results in this point, p==0.5 results in the
 * midpoint, and p==1.0 results in pnt being returned.
 */
inline ofVec4f ofVec4f::interpolated( const ofVec4f& pnt, float p ) const{
	return getInterpolated(pnt,p);
}

inline ofVec4f ofVec4f::getInterpolated( const ofVec4f& pnt, float p ) const {
	return ofVec4f( x*(1-p) + pnt.x*p,
				   y*(1-p) + pnt.y*p,
				   z*(1-p) + pnt.z*p,
				   w*(1-p) + pnt.w*p );
}

inline ofVec4f& ofVec4f::interpolate( const ofVec4f& pnt, float p ) {
	x = x*(1-p) + pnt.x*p;
	y = y*(1-p) + pnt.y*p;
	z = z*(1-p) + pnt.z*p;
	w = w*(1-p) + pnt.w*p;
	return *this;
}

inline ofVec4f ofVec4f::middled( const ofVec4f& pnt ) const {
	return getMiddle(pnt);
}

inline ofVec4f ofVec4f::getMiddle( const ofVec4f& pnt ) const {
	return ofVec4f( (x+pnt.x)/2.0f, (y+pnt.y)/2.0f,
				   (z+pnt.z)/2.0f, (w+pnt.w)/2.0f );
}

inline ofVec4f& ofVec4f::middle( const ofVec4f& pnt ) {
	x = (x+pnt.x)/2.0f;
	y = (y+pnt.y)/2.0f;
	z = (z+pnt.z)/2.0f;
	w = (w+pnt.w)/2.0f;
	return *this;
}


// Average (centroid) among points.
// (Addition is sometimes useful for calculating averages too)
//
//
inline ofVec4f& ofVec4f::average( const ofVec4f* points, int num ) {
	x = 0.f;
	y = 0.f;
	z = 0.f;
	w = 0.f;
	for( int i=0; i<num; i++) {
		x += points[i].x;
		y += points[i].y;
		z += points[i].z;
		w += points[i].w;
	}
	x /= num;
	y /= num;
	z /= num;
	w /= num;
	return *this;
}



// Normalization
//
//
inline ofVec4f ofVec4f::normalized() const {
	return getNormalized();
}

inline ofVec4f ofVec4f::getNormalized() const {
	float length = (float)sqrt(x*x + y*y + z*z + w*w);
	if( length > 0 ) {
		return ofVec4f( x/length, y/length, z/length, w/length );
	} else {
		return ofVec4f();
	}
}

inline ofVec4f& ofVec4f::normalize() {
	float lenght = (float)sqrt(x*x + y*y + z*z + w*w);
	if( lenght > 0 ) {
		x /= lenght;
		y /= lenght;
		z /= lenght;
		w /= lenght;
	}
	return *this;
}



// Limit length.
//
//
inline ofVec4f ofVec4f::limited(float max) const {
	return getLimited(max);
}

inline ofVec4f ofVec4f::getLimited(float max) const {
    ofVec4f limited;
    float lengthSquared = (x*x + y*y + z*z + w*w);
    if( lengthSquared > max*max && lengthSquared > 0 ) {
        float ratio = max/(float)sqrt(lengthSquared);
        limited.set( x*ratio, y*ratio, z*ratio, w*ratio );
    } else {
        limited.set(x,y,z,w);
    }
    return limited;
}

inline ofVec4f& ofVec4f::limit(float max) {
    float lengthSquared = (x*x + y*y + z*z + w*w);
    if( lengthSquared > max*max && lengthSquared > 0 ) {
        float ratio = max/(float)sqrt(lengthSquared);
        x *= ratio;
        y *= ratio;
        z *= ratio;
        w *= ratio;
    }
    return *this;
}



// Length
//
//
inline float ofVec4f::length() const {
	return (float)sqrt( x*x + y*y + z*z + w*w );
}

inline float ofVec4f::lengthSquared() const {
	return (float)(x*x + y*y + z*z + w*w);
}




/**
 * Dot Product.
 */
inline float ofVec4f::dot( const ofVec4f& vec ) const {
	return x*vec.x + y*vec.y + z*vec.z + w*vec.w;
}





// Non-Member operators
//
//
inline ofVec4f operator+( float f, const ofVec4f& vec ) {
    return ofVec4f( f+vec.x, f+vec.y, f+vec.z, f+vec.w );
}

inline ofVec4f operator-( float f, const ofVec4f& vec ) {
    return ofVec4f( f-vec.x, f-vec.y, f-vec.z, f-vec.w );
}

inline ofVec4f operator*( float f, const ofVec4f& vec ) {
    return ofVec4f( f*vec.x, f*vec.y, f*vec.z, f*vec.w );
}

inline ofVec4f operator/( float f, const ofVec4f& vec ) {
    return ofVec4f( f/vec.x, f/vec.y, f/vec.z, f/vec.w);
}


/// \endcond


#line 0 "../libs/openFrameworks/math/ofVec2f.h"
#pragma once

class ofVec3f;
class ofVec4f;

/* #include "ofConstants.h" */
/* #include "ofMathConstants.h" */
#include "glm/vec2.hpp"
#include "glm/fwd.hpp"
#include <cmath>

/// \brief
/// ofVec2f is a class for storing a two dimensional vector. 
///
/// Moving through space requires knowledge of where things are and where they are going.
/// Vector Maths is the class of mathematics that gives us control over these
/// things in space, allowing for elegant and intuitive descriptions of complex
/// structures and movement. Vectors are at the heart of animations, particle
/// systems, and 2D and 3D graphics.
/// 
/// Vectors in mathematics in general are entities with magnitude (also called
/// length) and direction. A vector whose magnitude is 1 (ie a vector that is
/// *normalized*) is called a *unit vector*. Unit vectors are very handy for
/// storing directions as they can be easily scaled up (or down) to represent
/// motion in a particular direction with a particular length.
/// 
/// *You will also see the term vector used to describe an array of objects in C++
/// (such as text strings). Don't let this confuse you, they are quite different:
/// one of them is a mathematical term for a fixed-length list of numbers that
/// you can do mathematical operations on, the other is a C++-specific term that
/// means 'dynamically sizeable array'.*
/// 
/// ofVec2f has two member variables, x and y, which allow to conveniently store
/// 2D properties of an object such as its position, velocity, or acceleration.
/// 
/// ~~~~{.cpp}
/// ofVec2f v1; // v1.x is 0, v1.y is 0
/// v1.set( 10, 50 ); // now v1.x is 10, v1.y is 50
/// ~~~~
/// 
/// Using ofVec2f greatly simplifies arithmetic operations in two dimensions. For
/// example if you have two vectors v1 and v2, both of which represent a 2D change
/// in position, you can find the total change of position of both of them just by
/// doing an addition v1 + v2:
/// 
/// ~~~~{.cpp}
/// ofVec2f v1(5, 2); // v1 represents walking 5 steps forward then 2 steps sideways
/// ofVec2f v2;
/// v2.set(1, 1); // v2 represents walking 1 step forward then 1 step sideways
/// // what happens if you do v1 followed by v2? just add v1 and v2 together:
/// ofVec2f result = v1 + v2; // result is 6 steps forward then 3 steps sideways
/// ~~~~
/// 
/// You can scale an ofVec2f by multiplying it with a float:
/// 
/// ~~~~{.cpp}
/// ofVec2f v1(5, 2); // walk 5 steps forward and 2 steps right
/// // what happens if we do v1 three times?
/// ofVec2f result = v1 * 3; // result is 15 steps forward and 6 steps right
/// ~~~~
/// 
/// This also works for subtraction and division.
/// 
/// As you can see this really makes dealing with vectors as easy as dealing with
/// single floats or ints, and can reduce the number of lines of code you have to
/// write by half, at the same time making your code much easier to read and
/// understand!
///
/// \sa ofVec3f for 3D vectors
/// \sa ofVec4f for 4D vectors
class ofVec2f {
public:
	/// \cond INTERNAL
	static const int DIM = 2;
	//// \endcond
	
	/// \brief Stores the `x` component of the vector.
	float x;

	/// \brief Stores the `y` component of the vector.
	float y;
    
    //---------------------
	/// \name Construct a 2D vector
	/// \{
    
	/// \brief Construct a 2D vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1; // default: v1.x is 0, v1.y is 0
	/// ofVec2f v2 = ofVec2f(40, 20); // v2.x is 40, v2.y is 20
	/// ofVec3f v3(0.1, 0.3); // v3.x is 0.1, v3.y is 0.3
	/// ~~~~
	///
	ofVec2f();

	/// \brief Construct a 2D vector with `x` and `y` set to `scalar`
	explicit ofVec2f( float scalar );
	
	/// \brief Construct a 2D vector with specific `x` and `y components
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1; // default: v1.x is 0, v1.y is 0
	/// ofVec2f v2 = ofVec2f(40, 20); // v2.x is 40, v2.y is 20
	/// ofVec3f v3(0.1, 0.3); // v3.x is 0.1, v3.y is 0.3
	/// ~~~~
	///
	/// \param x The x component
	/// \param y The y component
	ofVec2f( float x, float y );

	/// \brief Create a 2D vector (ofVec2f) from a 3D vector (ofVec3f) by
	/// \throwing away the z component of the 3D vector.
	///
	/// ~~~~{.cpp}
	/// ofVec3f mom3d(40, 20, 50); // 3d vector 
	/// ofVec2f v(mom3d); // v.x is 40, v.y is 20
	/// ~~~~
	/// 
    ofVec2f( const ofVec3f& vec );

	/// \brief Create a 2D vector (ofVec2f) from a 4D vector (ofVec4f) by throwing away the z
	/// and w components of the 4D vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec4f mom4d(40, 20, 50, 80); // 4d vector 
	/// ofVec2f v(mom4d); // v.x is 40, v.y is 20
	/// ~~~~
	/// 
    ofVec2f( const ofVec4f& vec );
	
	/// \}

	ofVec2f(const glm::vec2 & v);
	ofVec2f(const glm::vec3 & v);
	ofVec2f(const glm::vec4 & v);

	operator glm::vec2() const;

	//---------------------
	/// \name Access components
	/// \{


	/// \brief Returns a pointer to the memory position of the first element of the vector (x);
	/// the second element (y) immediately follows it in memory.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20);
	/// float * v1Ptr = v1.getPtr();
	/// float x = *(v1Ptr); // x is 40
	/// float y = *(v1Ptr+1); // y is 20
	/// ~~~~
	/// 
	/// This is very useful when using arrays of ofVec2fs to store geometry
	/// information, as it allows the vector to be treated as a simple C array of
	/// floats that can be passed verbatim to OpenGL.     
	float * getPtr() {
		return (float*)&x;     
	}

	const float * getPtr() const {
		return (const float *)&x;
	}
	
	/// \brief Allows to access the x and y components of an ofVec2f as though it is an array
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20);
	/// float x = v1[0]; // x is 40
	/// float y = v1[1]; // y is 20
	/// ~~~~
	/// 
	/// This function can be handy if you want to do the same operation to both x and
	/// y components, as it means you can just make a for loop that repeats twice.
	float& operator[]( int n ){
		return getPtr()[n];
	}
	
	float operator[]( int n ) const {
		return getPtr()[n];
	}
	
	
    
	/// \brief Set x and y components of this vector with just one function call.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1;///* #include "ofConstants.h" */
	//#include "glm/fwd.hpp"
	/// v1.set(40, 20);
	/// ~~~~
	/// 
    void set( float x, float y );

	/// \brief Set the x and y components of this vector by copying the corresponding values from vec.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(40, 20);
	/// ofVec2f v2;
	/// v2.set(v1); // v2.x is 40, v2.y is 20
	/// ~~~~
	/// 
    void set( const ofVec2f& vec );
	
	void set( float scalar );

    /// \}

    //---------------------
	/// \name Comparison 
	/// \{

	
	/// \brief Check for equality between two ofVec2f
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(40, 20); 
	/// ofVec2f v2(50, 30); 
	/// ofVec2f v3(40, 20); 
	/// // ( v1 == v2 ) is false
	/// // ( v1 == v3 ) is true
	/// ~~~~
	///
	/// \returns true if each component is the same as the corresponding
	/// component in vec, ie if x == vec.x and y == vec.y; otherwise returns
	/// false.
    bool operator==( const ofVec2f& vec ) const;

    /// \brief Check for inequality between two ofVec2f
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(40, 20); 
	/// ofVec2f v2(50, 30); 
	/// ofVec2f v3(40, 20); 
	/// // ( v1 != v2 ) is true
	/// // ( v1 != v3 ) is false
	/// ~~~~
	///
	/// \returns true if any component is different to its corresponding
	/// component in vec, ie if 'x != vec.x' or 'y != vec.y', otherwise returns
	/// false.
    bool operator!=( const ofVec2f& vec ) const;

	/// \brief Returns true if each component is *close enough* to its corresponding
	/// component in vec, where what is *close enough* is determined by the value of
	/// tolerance:
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20);
	/// ofVec2f v2 = ofVec2f(40.01, 19.999);
	/// // v1.match(v2, 0.1) returns true
	/// // v1.match(v2, 0.001) returns false
	/// ~~~~
	/// 
	/// This is handy if, for example, you want to find out when a point becomes
	/// *close enough* to another point to trigger an event.
	/// 
    bool match( const ofVec2f& vec, float tolerance = 0.0001f ) const;
    
	/// \brief Determine if two vectors are aligned
    /// 
    /// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20);
	/// ofVec2f v2 = ofVec2f(4, 2);
	/// v1.isAligned(v2) // returns true
	/// ~~~~
    /// \param vec The vector to compare alignment with
    /// \param tolerance an angle tolerance/threshold (specified in degrees) for deciding if the vectors are sufficiently aligned.
    /// \returns true if both vectors are aligned (pointing in the same direction). 
    bool isAligned( const ofVec2f& vec, float tolerance = 0.0001f ) const;
    
    /// \brief Determine if two vectors are aligned with tolerance in radians
    /// \param vec The vector to compare alignment with
    /// \param tolerance an angle tolerance/threshold (specified in radians) for deciding if the vectors are sufficiently aligned.
    /// \sa isAligned()
    bool isAlignedRad( const ofVec2f& vec, float tolerance = 0.0001f ) const;

    /// \brief Determine if two vectors are aligned
    /// 
    /// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20);
	/// ofVec2f v2 = ofVec2f(4, 2);
	/// v1.align(v2) // returns true
	/// ~~~~
    /// \param vec The vector to compare alignment with
    /// \param tolerance an angle tolerance/threshold (specified in degrees) for deciding if the vectors are sufficiently aligned.
    /// \returns true if both vectors are aligned (pointing in the same direction). 
    bool align( const ofVec2f& vec, float tolerance = 0.0001f ) const;

    /// \brief Determine if two vectors are aligned with tolerance in radians
    /// \param vec The vector to compare alignment with
    /// \param tolerance an angle tolerance/threshold (specified in radians) for deciding if the vectors are sufficiently aligned.
    /// \sa align()
    bool alignRad( const ofVec2f& vec, float tolerance = 0.0001f ) const;
	
	/// \}

	//---------------------
	/// \name Operators
	/// \{

    
	/// \brief Super easy vector addition. Returns a new vector (x+vec.x,y+vec.y).
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(25, 50);
	/// ofVec3f v3 = v1 + v2; // v3 is (65, 70)
	/// ~~~~
    ofVec2f  operator+( const ofVec2f& vec ) const;
    
    /// \brief Returns a new vector with a float value f added to both x and y members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// ofVec2f v2 = v1 + 10; // (12, 15)
	/// ~~~~
    ofVec2f  operator+( const float f ) const;

	/// \brief Super easy addition assignment. Adds vec.x to x, and adds vec.y to y.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(25, 50);
	/// v1 += v2; // v1 is (65, 70)
	/// ~~~~
    ofVec2f& operator+=( const ofVec2f& vec );

	/// \brief Adds a float value f to both x and y members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// v1 += 10; // (12, 15)
	/// ~~~~
    ofVec2f& operator+=( const float f );

    /// \brief Super easy vector subtraction. Returns a new vector (x-vec.x,y-vec.y).
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(25, 50);
	/// ofVec3f v3 = v1 - v2; // v3 is (15, -30)
	/// ~~~~
    ofVec2f  operator-( const ofVec2f& vec ) const;
    
	/// \brief Returns a new vector with a float value f subtracted from both x and y members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// ofVec2f v2 = v1 - 10; // (-8, -5)
	/// ~~~~
    ofVec2f  operator-( const float f ) const;

	/// \brief Returns a new ofVec2f that is the inverted version (mirrored in X and Y) of this vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// ofVec2f v2 = -v1; // (-2, -5)
	/// ~~~~    
    ofVec2f  operator-() const;

	/// \brief Super easy subtraction assignment. Subtracts vec.x from x, and subtracts vec.y from y.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(25, 50);
	/// v1 -= v2; // v1 is (15, -30)
	/// ~~~~
    ofVec2f& operator-=( const ofVec2f& vec );

    /// \brief Subtract a float value f from both x and y members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// v1 -= 10; // (-8, -5)
	/// ~~~~
	ofVec2f& operator-=( const float f );

	/// \brief Returns a new vector (x*vec.x , y*vec.y).
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(2, 4);
	/// ofVec2f v3 = v1 * v2; // (80, 80)
	/// ~~~~
	/// 
	/// Useful for scaling a 2D point by a non-uniform scale.
	/// 
    ofVec2f  operator*( const ofVec2f& vec ) const;
    
	/// \brief Return a new ofVec2f that is this vector scaled by multiplying both x
	/// and y members by the float.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// ofVec2f v2 = v1 * 4; // (8, 20)
	/// ~~~~
    ofVec2f  operator*( const float f ) const;

	/// \brief Multiplies x by vec.x, and multiplies y by vec.y.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(2, 4);
	/// v1 *= v2; // v1 is now (80, 80)
	/// ~~~~
	/// 
	/// Useful for scaling a 2D point by a non-uniform scale.
    ofVec2f& operator*=( const ofVec2f& vec );

	/// \brief Scale this vector by multiplying both x and y members by f.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// v1 *= 4; // (8, 20)
	/// ~~~~
    ofVec2f& operator*=( const float f );

	/// \brief Returns a new vector (x/vec.x,y/vec.y).
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(2, 4);
	/// ofVec3f v3 = v1 / v2; // (20, 5)
	/// ~~~~
	/// 
	/// Useful for scaling a 2D point by a non-uniform scale.
    ofVec2f  operator/( const ofVec2f& vec ) const;

	/// \brief Return a new ofVec2f that is this vector scaled by dividing
	/// both x and y members by f.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// ofVec2f v2 = v1 / 4; // (0.5, 1.25)
	/// ~~~~
    ofVec2f  operator/( const float f ) const;

	/// \brief Divides x by vec.x, and divides y by vec.y.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1 = ofVec2f(40, 20); 
	/// ofVec2f v2 = ofVec2f(2, 4);
	/// v1 *= v2; // v1 is now (20, 5)
	/// ~~~~
	/// 
	/// Useful for scaling a 2D point by a non-uniform scale.
    ofVec2f& operator/=( const ofVec2f& vec );
	
	/// \brief Scale this vector by dividing both x and y members by f.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(2, 5);
	/// v1 /= 4; // (0.5, 1.25)
	/// ~~~~
    ofVec2f& operator/=( const float f );

	
	/// \cond INTERNAL
	friend std::ostream& operator<<(std::ostream& os, const ofVec2f& vec);
	friend std::istream& operator>>(std::istream& is, const ofVec2f& vec);
	/// \endcond
	
	/// \}
	
	//---------------------
	/// \name Simple manipulations
	/// \{

	/// Return a new ofVec2f that is the result of scaling this vector up or down so
	/// that it has the requested length.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1( 3, 4 ); // length is 5
	/// ofVec2f v2 = v1.getScaled( 15 ); // ( 9, 12 ), length is now 15
	/// ~~~~ofVec2f  
	/// 
	/// \sa scale()
    ofVec2f  getScaled( const float length ) const;
    
	/// \brief Scales this vector up or down so that it has the requested length.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1( 3, 4 ); // length is 5
	/// v1.scale( 15 ); // v1 is now (9, 12), with length 15
	/// ~~~~
	///
	/// \sa getScaled()
    ofVec2f& scale( const float length );
	
	
	/// \brief Returns a new vector that is the result of rotating this vector 
	/// by 'angle' degrees about the origin.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(1, 0);
	/// ofVec2f v2 = v1.getRotated(45); // v2 is (0.707, 0.707)
	/// ~~~~
	/// 
	/// \sa getRotatedRad()
	/// \sa rotate()
    ofVec2f  getRotated( float angle ) const;

	/// \brief Returns a new vector that is the result of rotating this vector
	/// by 'angle' degrees about the point 'pivot'.
	///
    ofVec2f  getRotated( float angle, const ofVec2f& pivot ) const;
    
	/// \brief Returns a new vector that is the result of rotating this vector 
	/// by 'angle' radians about the origin.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(1, 0);
	/// ofVec2f v2 = v1.getRotatedRad(PI / 4); // v2 is (0.707, 0.707)
	/// ~~~~
	///     
    ofVec2f  getRotatedRad( float angle ) const;

	/// \brief Returns a new vector that is the result of rotating this vector
	/// by 'angle' radians about the origin. 
	///
    ofVec2f  getRotatedRad( float angle, const ofVec2f& pivot ) const;


	/// \brief Rotates this vector by 'angle' degrees about the origin.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(1, 0);
	/// v1.rotate(45); // v1 is now (0.707, 0.707)
	/// ~~~~
	///
	/// \sa getRotated()
    ofVec2f& rotate( float angle );

	/// \brief Rotates this vector by 'angle' degrees about the point 'pivot'.
    ofVec2f& rotate( float angle, const ofVec2f& pivot );
    
	/// \brief Rotates this vector by 'angle' radians about the origin.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(1, 0);
	/// v1.rotateRad(PI / 4); // v1 is now (0.707, 0.707)
	/// ~~~~
	///
	/// \sa getRotatedRad()
    ofVec2f& rotateRad( float angle );
	
	/// \brief Rotates this vector by 'angle' radians about the point 'pivot'.
	ofVec2f& rotateRad( float angle, const ofVec2f& pivot );
	
	
    
	/// \brief Get vector mapped to new coordinate system
	/// 
	/// In most cases you want `vx` and `vy` to be perpendicular and of unit length; if
	/// they are not perpendicular you will have shearing as part of the mapping, and
	/// if they are not of unit length you will have scaling as part of the mapping.
	///
	/// \returns A new ofVec2f calculated by copying this vector and then mapping from
	/// its default coordinate system -- origin (0,0), X direction (1,0), Y direction
	/// (0,1) -- to a new coordinate system defined with origin at origin, X direction
	/// vx, and Y direction vy.
    ofVec2f getMapped( const ofVec2f& origin,
					  const ofVec2f& vx,
					  const ofVec2f& vy ) const;


	/// \brief Maps this vector from its default coordinate system -- origin (0,0), X
	/// direction (1,0), Y direction (0,1) -- to a new coordinate system defined with
	/// origin at origin, X direction vx, and Y direction vy.
	/// 
	/// In most case you want vx and vy to be perpendicular and of unit length; if
	/// they are not perpendicular you will have shearing as part of the mapping, and
	/// if they are not of unit length you will have scaling as part of the mapping.
    /// 
	/// \sa perpendicular()
    ofVec2f& map( const ofVec2f& origin,
				 const ofVec2f& vx, const ofVec2f& vy );


    /// \}
	
	
	//---------------------
	/// \name Distance
	/// \{

    /// \brief Distance between two points.
    ///
    /// Treats both this vector and pnt as points in 2D space, and calculates and
    /// returns the distance between them.
    ///
	/// ~~~~{.cpp}
	/// ofVec2f p1( 3, 4 );
	/// ofVec2f p2( 6, 8 );
	/// float distance = p1.distance( p2 ); // distance is 5
	/// ~~~~
	/// 
	/// Distance involves a square root calculation, which is one of the slowest
	/// things you can do in programming. If you don't need an exact number but rather
	/// just a rough idea of distance (for example when finding the shortest distance
	/// of a bunch of points to a reference point, where it doesn't matter exactly
	/// what the distances are, you just want the shortest), you can use
	/// squareDistance() instead.
	/// 
	/// \param pnt The point to calculate the distance to
	/// \returns The distance as float
	/// \sa squareDistance()
    float distance( const ofVec2f& pnt) const;

    /// \brief Distance between two points squared.
    ///
	/// Treats both this vector and pnt as points in 2D space, and calculates and
	/// returns the squared distance between them.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f p1( 3, 4 );
	/// ofVec2f p2( 6, 8 );
	/// float distance = p1.distance( p2 ); // distance is 5
	/// ~~~~
	/// 
	/// Use as a much faster alternative to [distance](#distance) if you don't need to
	/// know an exact number but rather just a rough idea of distance (for example
	/// when finding the shortest distance of a bunch of points to a reference point,
	/// where it doesn't matter exactly what the distances are, you just want the
	/// shortest). It avoids the square root calculation that is ordinarily required
	/// to calculate a length.
	///
	/// \returns The distance squared as float
	/// \sa distance()
    float squareDistance( const ofVec2f& pnt ) const;
	
	/// \}

	//---------------------
	/// \name Interpolation
	/// \{

    /// \brief Linear interpolation
    /// 
	/// Perform a linear interpolation of this vector's position towards pnt
	/// and return the interpolated position without altering the original
	/// vector. 
	/// 
	/// `p` is normally between 0 and 1 and where 0 means stay the original position and 1
	/// means move all the way to pnt, but you can also have p greater than 1
	/// overshoot pnt, or less than 0 to move backwards away from pnt.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1( 0, 5 );
	/// ofVec2f v2( 10, 10 );
	/// ofVec3f v3 = v1.getInterpolated( v2, 0.5 ); // v3 is (5, 7.5)
	/// ofVec3f v4 = v1.getInterpolated( v2, 0.8 ); // v4 is (8, 9)
	/// ~~~~
	///
	/// \param pnt The point to move towards
	/// \param p The amount to move towards pnt
	/// \sa interpolate()
    ofVec2f   getInterpolated( const ofVec2f& pnt, float p ) const;
    
    /// \brief Linear interpolation
    /// 
	/// Perform a linear interpolation of this vector's position towards pnt. p
	/// controls the amount to move towards pnt. p is normally between 0 and 1 and
	/// where 0 means stay the original position and 1 means move all the way to pnt,
	/// but you can also have p greater than 1 overshoot pnt, or less than 0 to move
	/// backwards away from pnt.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1( 0, 5 );
	/// ofVec2f v2( 10, 10 );
	/// // go go gadget zeno
	/// v1.interpolate( v2, 0.5 ); // v1 is now (5, 7.5)
	/// v1.interpolate( v2, 0.5 ); // v1 is now (7.5, 8.75)
	/// v1.interpolate( v2, 0.5 ); // v1 is now (8.75, 9.375)
	/// v1.interpolate( v2, 0.5 ); // v1 is now (9.375, 9.6875)
	/// ~~~~
	/// 
	/// \sa getInterpolated()
    ofVec2f&  interpolate( const ofVec2f& pnt, float p );

	/// \brief Calculate and return the midpoint between this vector and pnt.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(5, 0);
	/// ofVec2f v2(10, 10);
	/// ofVec3f mid = v1.getMiddle(v2); // mid gets (7.5, 5)
	/// ~~~~
	///
	/// \param pnt The vector to find the middle to
	/// \returns The middle between this vector and `pnt`
	/// \sa middle()
    ofVec2f   getMiddle( const ofVec2f& pnt ) const;

	/// \brief Set this vector to the midpoint between itself and pnt.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1( 0, 5 );
	/// ofVec2f v2( 10, 10 );
	/// v1.middle( v2 ); // v1 is now (5, 7.5)
	/// v1.middle( v2 ); // v1 is now (7.5, 8.75)
	/// v1.middle( v2 ); // v1 is now (8.75, 9.375)
	/// v1.middle( v2 ); // v1 is now (9.375, 9.6875)
	/// ~~~~    
	/// 
	/// \sa getMiddle()
    ofVec2f&  middle( const ofVec2f& pnt );

	/// \brief Average vector over an array of points 
	///  
	/// Sets this vector to be the average (*centre of gravity* or *centroid*) 
	/// of a given array of ofVec2f. 
	/// 
	/// ~~~~{.cpp}
	/// int numPoints = 10;
	/// ofVec2f points[numPoints];
	/// for ( int i=0; i<numPoints; i++ ) {
	/// 	points[i].set( ofRandom(0,100), ofRandom(0,100) );
	/// }
	/// ofVec2f centroid;
	/// centroid.average( points, numPoints ); 
	/// // centroid now is the centre of gravity/average of all the random points
	/// ~~~~
	/// 
	/// \param points The array of ofVec2f to avarage over
	/// \param num specifies the number of ofVec2f in the array.
	/// \returns Vector that is the avarage of the points in the array
    ofVec2f&  average( const ofVec2f* points, std::size_t num );
    
    /// \}

    //---------------------
	/// \name Limit
	/// \{

	/// \brief Returns a normalized copy of this vector. 
	/// 	
	/// *Normalization* means to scale the vector so that its length
	/// (magnitude) is exactly 1, at which stage all that is left is the
	/// direction. A normalized vector is usually called a *unit vector*, and
	/// can be used to represent a pure direction (heading).	
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(5, 0);
	/// ofVec2f v1Normalized = v1.getNormalized(); // (1, 0)
	/// ofVec2f v2(5, 5);
	/// ofVec2f v2Normalized = v2.getNormalized(); // (2, 2)
	/// ~~~~
    ofVec2f  getNormalized() const;

	/// \brief Normalize the vector.
	/// 
	/// *Normalizing* means to scale the vector so that its length (magnitude) is
	/// exactly 1, at which stage all that is left is the direction. A normalized
	/// vector is usually called a *unit vector*, and can be used to represent a pure
	/// direction (heading).
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(5, 0);
	/// v1.normalize(); // v2 is now (1, 0)
	/// ofVec2f v2(5, 5);
	/// v2.normalize(); // v2 is now (2, 2)
	/// ~~~~
	/// \sa getNormalized()
    ofVec2f& normalize();
	
	
    
    /// \brief Get vector limited by length
	///     
	/// ~~~~{.cpp}
	/// ofVec2f v1(5, 1); // length is about 5.1
	/// ofVec2f v2(2, 1); // length is about 2.2
	/// ofVec2f v1Limited = v1.getLimited(3); 
	/// // v1Limited is (2.9417, 0.58835) which has length of 3 in the same direction as v1
	/// ofVec2f v2Limited = v2.getLimited(3);
	/// // v2Limited is (2, 1) (same as v2)
	/// ~~~~
	/// 
	/// \sa limit()
	/// \param max The maximum length of the vector to return
	/// \returns A copy of this vector with its length (magnitude) restricted to a
    /// maximum of max units by scaling down if necessary.
	ofVec2f  getLimited(float max) const;


   	/// \brief Restrict the length (magnitude) of this vector to a maximum of max units by scaling down if necessary.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v1(5, 1); // length is about 5.1
	/// ofVec2f v2(2, 1); // length is about 2.2
	/// v1.limit(3); 
	/// // v1 is now (2.9417, 0.58835) which has length of 3 in the same direction as at initialization
	/// v2.limit(3);
	/// // v2 is unchanged
	/// ~~~~
	///
	/// \sa limit()
    ofVec2f& limit(float max);

	
	/// \}

	//---------------------
	/// \name Measurement
	/// \{

	
	/// \brief Return the length (magnitude) of this vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v(3, 4);
	/// float len = v.length(); // len is 5 (3,4,5 triangle)
	/// ~~~~
	/// 
	/// length() involves a square root calculation, which is one of the slowest things
	/// you can do in programming. If you don't need an exact number but rather just a
	/// rough idea of a length (for example when finding the shortest distance of a
	/// bunch of points to a reference point, where it doesn't matter exactly what the
	/// lengths are, you just want the shortest), you can use
	/// lengthSquared() instead.
	///
	/// \sa lengthSquared()
    float length() const;
    
	/// \brief Return the squared length (squared magnitude) of this vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v(3, 4);
	/// float len = v.length(); // len is 5 (3,4,5 triangle)
	/// ~~~~
	/// 
	/// Use as a much faster alternative to length() if you don't
	/// need to know an accurate length but rather just a rough idea of a
	/// length (for example when finding the shortest distance of a bunch of
	/// points to a reference point, where it doesn't matter exactly what the
	/// lengths are, you just want the shortest). It avoids the square root
	/// calculation that is ordinarily required to calculate a length.
	///
	/// \sa length()
    float lengthSquared() const;

    /// \brief Calculate the angle to another vector in degrees
    ///
	/// ~~~~{.cpp}
	/// ofVec2f v1(1,0);
	/// ofVec2f v2(0,1);
	/// float angle = v1.angle(v2); // angle is 90
	/// ~~~~
	/// \param vec The vector to calculate the angle to
	/// \returns The angle in degrees (-180...180)
	float angle( const ofVec2f& vec ) const;

    /// \brief Calculate the angle to another vector in radians
    ///
	/// ~~~~{.cpp}
	/// ofVec2f v1(1,0);
	/// ofVec2f v2(0,1);
	/// float angle = v1.angleRad(v2); // angle is HALF_PI
	/// ~~~~
	/// \param vec The vector to calculate the angle to
	/// \returns The angle in radians (-PI...PI)
    float angleRad( const ofVec2f& vec ) const;
	
	/// \}

	//---------------------
	/// \name Perpendicular
	/// \{

	/// \brief Return the *normalized* ofVec2f that is perpendicular to this vector
	/// (ie rotated 90 degrees and normalized).
	/// 
	/// ![PERPENDICULAR](math/perpendicular.png)
	/// Image courtesy of Wikipedia
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v(2, 5);
	/// ofVec2f u = v.getPerpendicular(); // u is (0.928, -0.371)
	/// ~~~~
	/// 
	/// \sa perpendicular()
    ofVec2f  getPerpendicular() const;

	/// \brief Set this vector to its own **normalized** perpendicular (by
	/// rotating 90 degrees and normalizing).
	/// 
	/// ![PERPENDICULAR](math/perpendicular.png)
	/// Image courtesy of Wikipedia
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f v(2, 5);
	/// v.perpendicular(); // v is (0.928, -0.371)
	/// ~~~~
	/// \sa getPerpendicular()
	ofVec2f& perpendicular();
	
	/// \brief Returns the dot product of this vector with 'vec'.
	///
	/// The *dot product* of two vectors, also known as the *scalar product*, is
	/// the product of the magnitude of the two vectors and the cosine of the
	/// angle between them.
	///
	/// One interpretation of the dot product is as a measure of how closely two
	/// vectors align with each other. If they point in exactly the same
	/// direction, their dot product will simply be the product of their
	/// magnitudes, if they are perpendicular, their dot product will be 0, and
	/// if they point in opposite directions, their dot product will be
	/// negative.
	///
	/// The dot product is in contrast to the *cross product*, which returns a
	/// vector rather than a scalar.
	/// 
	/// ~~~~{.cpp}
	/// ofVec2f a1(2, 0); // magnitude 2, parallel to x-axis
	/// ofVec2f b1(3, 4); // magnitude 5, 53.13 degree angle to a1
	/// float dot = a1.dot(b1); // dot is 2 * 5 * cos(53.13) = 6.0
	///
	/// ofVec2f a2(1, 0); // magnitude 1, parallel to x-axis
	/// ofVec2f b2(0, 1); // magnitude 1, 90 degree angle to a2
	/// dot = a2.dot(b2); // dot is 1 * 1 * cos(90) = 0.0
	///
	/// ofVec2f a3(0, 1); // magnitude 1, parallel to y-axis
	/// ofVec2f b3(0, -1); // magnitude 1, 180 degree angle to a3
	/// dot = a3.dot(b3); // dot is 1 * 1 * cos(180) = -1.0
	/// ~~~~
	/// 
    float dot( const ofVec2f& vec ) const;
	
	
	/// \}



    //---------------------------------------------------
    // this methods are deprecated in 006 please dont use:
	/// \cond INTERNAL

    // getScaled
    OF_DEPRECATED_MSG("Use member method getScaled() instead.", ofVec2f rescaled( const float length ) const);
	
    // scale
    OF_DEPRECATED_MSG("Use member method scale() instead.", ofVec2f& rescale( const float length ));
	
    // getRotated
    OF_DEPRECATED_MSG("Use member method getRotated() instead.", ofVec2f rotated( float angle ) const);
	
    // getNormalized
    OF_DEPRECATED_MSG("Use member method getNormalized() instead.", ofVec2f normalized() const);
	
    // getLimited
    OF_DEPRECATED_MSG("Use member method getLimited() instead.", ofVec2f limited(float max) const);
	
    // getPerpendicular
    OF_DEPRECATED_MSG("Use member method getPerpendicular() instead.", ofVec2f perpendiculared() const);
	
    // getInterpolated
    OF_DEPRECATED_MSG("Use member method getInterpolated() instead.", ofVec2f interpolated( const ofVec2f& pnt, float p ) const);
    
    // getMiddled
    OF_DEPRECATED_MSG("Use member method getMiddled() instead.", ofVec2f middled( const ofVec2f& pnt ) const);
    
    // getMapped 
    OF_DEPRECATED_MSG("Use member method getMapped() instead.", ofVec2f mapped( const ofVec2f& origin, const ofVec2f& vx, const ofVec2f& vy ) const);
    
    // squareDistance
    OF_DEPRECATED_MSG("Use member method squareDistance() instead.", float distanceSquared( const ofVec2f& pnt ) const);
    
    // use getRotated
    OF_DEPRECATED_MSG("Use member method getRotated() instead.", ofVec2f rotated( float angle, const ofVec2f& pivot ) const);    
    
    // return all zero vector
    static ofVec2f zero() { return ofVec2f(0, 0); }

    // return all one vector
    static ofVec2f one() { return ofVec2f(1, 1); }

    /// \endcond
};



/// \cond INTERNAL

// Non-Member operators
//
ofVec2f operator+( float f, const ofVec2f& vec );
ofVec2f operator-( float f, const ofVec2f& vec );
ofVec2f operator*( float f, const ofVec2f& vec );
ofVec2f operator/( float f, const ofVec2f& vec );


/// \endcond




/////////////////
// Implementation
/////////////////
/// \cond INTERNAL


inline ofVec2f::ofVec2f(): x(0), y(0) {}
inline ofVec2f::ofVec2f( float _scalar ): x(_scalar), y(_scalar) {}
inline ofVec2f::ofVec2f( float _x, float _y ):x(_x), y(_y) {}
inline ofVec2f::ofVec2f(const glm::vec2 & v): x(v.x), y(v.y) {}

// Getters and Setters.
//
//
inline void ofVec2f::set( float _scalar ) {
	x = _scalar;
	y = _scalar;
}

inline void ofVec2f::set( float _x, float _y ) {
	x = _x;
	y = _y;
}

inline void ofVec2f::set( const ofVec2f& vec ) {
	x = vec.x;
	y = vec.y;
}

inline ofVec2f::operator glm::vec2() const{
	return glm::vec2(x,y);
}

// Check similarity/equality.
//
//
inline bool ofVec2f::operator==( const ofVec2f& vec ) const {
	return (x == vec.x) && (y == vec.y);
}

inline bool ofVec2f::operator!=( const ofVec2f& vec ) const {
	return (x != vec.x) || (y != vec.y);
}

inline bool ofVec2f::match( const ofVec2f& vec, float tolerance ) const {
	return (fabs(x - vec.x) < tolerance)
	&& (fabs(y - vec.y) < tolerance);
}

//
// Checks if vectors look in the same direction.
// Tolerance is specified in degree.
 
inline bool ofVec2f::isAligned( const ofVec2f& vec, float tolerance ) const { 
	return  fabs( this->angle( vec ) ) < tolerance;
}
inline bool ofVec2f::align( const ofVec2f& vec, float tolerance ) const {
    return isAligned( vec, tolerance );
}

inline bool ofVec2f::isAlignedRad( const ofVec2f& vec, float tolerance ) const {
	return  fabs( this->angleRad( vec ) ) < tolerance;
}
inline bool ofVec2f::alignRad( const ofVec2f& vec, float tolerance ) const {
    return isAlignedRad( vec, tolerance );
}


// Overloading for any type to any type
//
//

inline ofVec2f ofVec2f::operator+( const ofVec2f& vec ) const {
	return ofVec2f( x+vec.x, y+vec.y);
}

inline ofVec2f& ofVec2f::operator+=( const ofVec2f& vec ) {
	x += vec.x;
	y += vec.y;
	return *this;
}

inline ofVec2f ofVec2f::operator-( const ofVec2f& vec ) const {
	return ofVec2f(x-vec.x, y-vec.y);
}

inline ofVec2f& ofVec2f::operator-=( const ofVec2f& vec ) {
	x -= vec.x;
	y -= vec.y;
	return *this;
}

inline ofVec2f ofVec2f::operator*( const ofVec2f& vec ) const {
	return ofVec2f(x*vec.x, y*vec.y);
}

inline ofVec2f& ofVec2f::operator*=( const ofVec2f& vec ) {
	x*=vec.x;
	y*=vec.y;
	return *this;
}

inline ofVec2f ofVec2f::operator/( const ofVec2f& vec ) const {
	return ofVec2f( vec.x!=0 ? x/vec.x : x , vec.y!=0 ? y/vec.y : y);
}

inline ofVec2f& ofVec2f::operator/=( const ofVec2f& vec ) {
	vec.x!=0 ? x/=vec.x : x;
	vec.y!=0 ? y/=vec.y : y;
	return *this;
}

inline std::ostream& operator<<(std::ostream& os, const ofVec2f& vec) {
	os << vec.x << ", " << vec.y;
	return os;
}

inline std::istream& operator>>(std::istream& is, ofVec2f& vec) {
	is >> vec.x;
	is.ignore(2);
	is >> vec.y;
	return is;
}

//operator overloading for float
//
//
//inline void ofVec2f::operator=( const float f){
//	x = f;
//	y = f;
//}

inline ofVec2f ofVec2f::operator+( const float f ) const {
	return ofVec2f( x+f, y+f);
}

inline ofVec2f& ofVec2f::operator+=( const float f ) {
	x += f;
	y += f;
	return *this;
}

inline ofVec2f ofVec2f::operator-( const float f ) const {
	return ofVec2f( x-f, y-f);
}

inline ofVec2f& ofVec2f::operator-=( const float f ) {
	x -= f;
	y -= f;
	return *this;
}

inline ofVec2f ofVec2f::operator-() const {
	return ofVec2f(-x, -y);
}

inline ofVec2f ofVec2f::operator*( const float f ) const {
	return ofVec2f(x*f, y*f);
}

inline ofVec2f& ofVec2f::operator*=( const float f ) {
	x*=f;
	y*=f;
	return *this;
}

inline ofVec2f ofVec2f::operator/( const float f ) const {
	if(f == 0) return ofVec2f(x, y);
	
	return ofVec2f(x/f, y/f);
}

inline ofVec2f& ofVec2f::operator/=( const float f ) {
	if(f == 0) return *this;
	
	x/=f;
	y/=f;
	return *this;
}

inline ofVec2f ofVec2f::rescaled( const float length ) const {
	return getScaled(length);
}

inline ofVec2f ofVec2f::getScaled( const float length ) const {
	float l = (float)sqrt(x*x + y*y);
	if( l > 0 )
		return ofVec2f( (x/l)*length, (y/l)*length );
	else
		return ofVec2f();
}

inline ofVec2f& ofVec2f::rescale( const float length ){
	return scale(length);
}

inline ofVec2f& ofVec2f::scale( const float length ) {
	float l = (float)sqrt(x*x + y*y);
	if (l > 0) {
		x = (x/l)*length;
		y = (y/l)*length;
	}
	return *this;
}



// Rotation
//
//
inline ofVec2f ofVec2f::rotated( float angle ) const {
	return getRotated(angle);
}

inline ofVec2f ofVec2f::getRotated( float angle ) const {
	float a = (float)(angle*DEG_TO_RAD);
	return ofVec2f( x*cos(a) - y*sin(a),
				   x*sin(a) + y*cos(a) );
}

inline ofVec2f ofVec2f::getRotatedRad( float angle ) const {
	float a = angle;
	return ofVec2f( x*cos(a) - y*sin(a),
				   x*sin(a) + y*cos(a) );
}

inline ofVec2f& ofVec2f::rotate( float angle ) {
	float a = (float)(angle * DEG_TO_RAD);
	float xrot = x*cos(a) - y*sin(a);
	y = x*sin(a) + y*cos(a);
	x = xrot;
	return *this;
}

inline ofVec2f& ofVec2f::rotateRad( float angle ) {
	float a = angle;
	float xrot = x*cos(a) - y*sin(a);
	y = x*sin(a) + y*cos(a);
	x = xrot;
	return *this;
}



// Rotate point by angle (deg) around pivot point.
//
//

// This method is deprecated in 006 please use getRotated instead
inline ofVec2f ofVec2f::rotated( float angle, const ofVec2f& pivot ) const {
	return getRotated(angle, pivot);
}

inline ofVec2f ofVec2f::getRotated( float angle, const ofVec2f& pivot ) const {
	float a = (float)(angle * DEG_TO_RAD);
	return ofVec2f( ((x-pivot.x)*cos(a) - (y-pivot.y)*sin(a)) + pivot.x,
				   ((x-pivot.x)*sin(a) + (y-pivot.y)*cos(a)) + pivot.y );
}

inline ofVec2f& ofVec2f::rotate( float angle, const ofVec2f& pivot ) {
	float a = (float)(angle * DEG_TO_RAD);
	float xrot = ((x-pivot.x)*cos(a) - (y-pivot.y)*sin(a)) + pivot.x;
	y = ((x-pivot.x)*sin(a) + (y-pivot.y)*cos(a)) + pivot.y;
	x = xrot;
	return *this;
}

inline ofVec2f ofVec2f::getRotatedRad( float angle, const ofVec2f& pivot ) const {
	float a = angle;
	return ofVec2f( ((x-pivot.x)*cos(a) - (y-pivot.y)*sin(a)) + pivot.x,
				   ((x-pivot.x)*sin(a) + (y-pivot.y)*cos(a)) + pivot.y );
}

inline ofVec2f& ofVec2f::rotateRad( float angle, const ofVec2f& pivot ) {
	float a = angle;
	float xrot = ((x-pivot.x)*cos(a) - (y-pivot.y)*sin(a)) + pivot.x;
	y = ((x-pivot.x)*sin(a) + (y-pivot.y)*cos(a)) + pivot.y;
	x = xrot;
	return *this;
}



// Map point to coordinate system defined by origin, vx, and vy.
//
//

// This method is deprecated in 006 please use getMapped instead
inline ofVec2f ofVec2f::mapped( const ofVec2f& origin,
							   const ofVec2f& vx,
							   const ofVec2f& vy ) const{
	return getMapped(origin, vx, vy);
}

inline ofVec2f ofVec2f::getMapped( const ofVec2f& origin,
								  const ofVec2f& vx,
								  const ofVec2f& vy ) const
{
	return ofVec2f( origin.x + x*vx.x + y*vy.x,
				   origin.y + x*vx.y + y*vy.y );
}

inline ofVec2f& ofVec2f::map( const ofVec2f& origin,
							 const ofVec2f& vx, const ofVec2f& vy )
{
	float xmap = origin.x + x*vx.x + y*vy.x;
	y = origin.y + x*vx.y + y*vy.y;
	x = xmap;
	return *this;
}


// Distance between two points.
//
//
inline float ofVec2f::distance( const ofVec2f& pnt) const {
	float vx = x-pnt.x;
	float vy = y-pnt.y;
	return (float)sqrt(vx*vx + vy*vy);
}

//this method is deprecated in 006 please use squareDistance
inline float ofVec2f::distanceSquared( const ofVec2f& pnt ) const {
	return squareDistance(pnt);
}

inline float ofVec2f::squareDistance( const ofVec2f& pnt ) const {
	float vx = x-pnt.x;
	float vy = y-pnt.y;
	return vx*vx + vy*vy;
}



// Linear interpolation.
//
//
//
// p==0.0 results in this point, p==0.5 results in the
// midpoint, and p==1.0 results in pnt being returned.
//

// this method is deprecated in 006 please use getInterpolated
inline ofVec2f ofVec2f::interpolated( const ofVec2f& pnt, float p ) const{
	return getInterpolated(pnt, p);
}

inline ofVec2f ofVec2f::getInterpolated( const ofVec2f& pnt, float p ) const {
	return ofVec2f( x*(1-p) + pnt.x*p, y*(1-p) + pnt.y*p );
}

inline ofVec2f& ofVec2f::interpolate( const ofVec2f& pnt, float p ) {
	x = x*(1-p) + pnt.x*p;
	y = y*(1-p) + pnt.y*p;
	return *this;
}

// this method is deprecated in 006 please use getMiddle
inline ofVec2f ofVec2f::middled( const ofVec2f& pnt ) const{
	return getMiddle(pnt);
}

inline ofVec2f ofVec2f::getMiddle( const ofVec2f& pnt ) const {
	return ofVec2f( (x+pnt.x)/2.0f, (y+pnt.y)/2.0f );
}

inline ofVec2f& ofVec2f::middle( const ofVec2f& pnt ) {
	x = (x+pnt.x)/2.0f;
	y = (y+pnt.y)/2.0f;
	return *this;
}





inline ofVec2f& ofVec2f::average( const ofVec2f* points, std::size_t num ) {
	if (0 == num) {
		return *this;
	}
	x = 0.f;
	y = 0.f;
	for( std::size_t i=0; i<num; i++) {
		x += points[i].x;
		y += points[i].y;
	}
	x /= num;
	y /= num;
	return *this;
}



// Normalization
//
//
inline ofVec2f ofVec2f::normalized() const {
	return getNormalized();
}

inline ofVec2f ofVec2f::getNormalized() const {
	float length = (float)sqrt(x*x + y*y);
	if( length > 0 ) {
		return ofVec2f( x/length, y/length );
	} else {
		return ofVec2f();
	}
}

inline ofVec2f& ofVec2f::normalize() {
	float length = (float)sqrt(x*x + y*y);
	if( length > 0 ) {
		x /= length;
		y /= length;
	}
	return *this;
}



// Limit length.
//
//
inline ofVec2f ofVec2f::limited(float max) const{
	return getLimited(max);
}

inline ofVec2f ofVec2f::getLimited(float max) const {
    ofVec2f limited;
    float lengthSquared = (x*x + y*y);
    if( lengthSquared > max*max && lengthSquared > 0 ) {
        float ratio = max/(float)sqrt(lengthSquared);
        limited.set( x*ratio, y*ratio);
    } else {
        limited.set(x,y);
    }
    return limited;
}

inline ofVec2f& ofVec2f::limit(float max) {
    float lengthSquared = (x*x + y*y);
    if( lengthSquared > max*max && lengthSquared > 0 ) {
        float ratio = max/(float)sqrt(lengthSquared);
        x *= ratio;
        y *= ratio;
    }
    return *this;
}



// Perpendicular normalized vector.
//
//
inline ofVec2f ofVec2f::perpendiculared() const {
	return getPerpendicular();
}

inline ofVec2f ofVec2f::getPerpendicular() const {
	float length = (float)sqrt( x*x + y*y );
	if( length > 0 )
		return ofVec2f( -(y/length), x/length );
	else
		return ofVec2f();
}

inline ofVec2f& ofVec2f::perpendicular() {
	float length = (float)sqrt( x*x + y*y );
	if( length > 0 ) {
		float _x = x;
		x = -(y/length);
		y = _x/length;
	}
	return *this;
}


// Length
//
//
inline float ofVec2f::length() const {
	return (float)sqrt( x*x + y*y );
}

inline float ofVec2f::lengthSquared() const {
	return (float)(x*x + y*y);
}


inline float ofVec2f::angle( const ofVec2f& vec ) const {
	return (float)(atan2( x*vec.y-y*vec.x, x*vec.x + y*vec.y )*RAD_TO_DEG);
}

inline float ofVec2f::angleRad( const ofVec2f& vec ) const {
	return atan2( x*vec.y-y*vec.x, x*vec.x + y*vec.y );
}


inline float ofVec2f::dot( const ofVec2f& vec ) const {
	return x*vec.x + y*vec.y;
}







// Non-Member operators
//
//
inline ofVec2f operator+( float f, const ofVec2f& vec ) {
    return ofVec2f( f+vec.x, f+vec.y);
}

inline ofVec2f operator-( float f, const ofVec2f& vec ) {
    return ofVec2f( f-vec.x, f-vec.y);
}

inline ofVec2f operator*( float f, const ofVec2f& vec ) {
    return ofVec2f( f*vec.x, f*vec.y);
}

inline ofVec2f operator/( float f, const ofVec2f& vec ) {
    return ofVec2f( f/vec.x, f/vec.y);
}


/// \endcond

#line 0 "../libs/openFrameworks/math/ofVec3f.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofVec2f.h" */
/* #include "ofVec4f.h" */
/* #include "ofMathConstants.h" */
#include "glm/vec3.hpp"
#include "glm/geometric.hpp"

#include <cmath>
#include <iostream>

/// \brief  ofVec3f is a class for storing a three dimensional vector.
/// 
/// Moving through space requires knowledge of where things are and where they are
/// going. Vector Maths is the class of mathematics that gives us control over
/// these things in space, allowing for elegant and intuitive descriptions of
/// complex structures and movement. Vectors are at the heart of animations,
/// particle systems, and 2D and 3D graphics.
/// 
/// Vectors in mathematics in general are entities with magnitude (also called
/// length) and direction. A vector whose magnitude is 1 (ie a vector that is
/// *normalized*) is called a *unit vector*. Unit vectors are very handy for
/// storing directions as they can be easily scaled up (or down) to represent
/// motion in a particular direction with a particular length.
/// 
/// *You will also see the term 'vector' used to describe an array of objects in
/// C++ (such as text strings). Don't let this confuse you, they are quite
/// different: one of them is a mathematical term for a fixed-length list of
/// numbers that you can do mathematical operations on, the other is a
/// C++-specific term that means 'dynamically sizeable array'.*
/// 
/// 'ofVec3f has three member variables, x, y, and z, which allow to conveniently
/// 'store 3D properties of an object such as its position, velocity, or
/// 'acceleration.
/// 
/// ~~~~{.cpp}
/// ofVec3f v1; // v1.x is 0, v1.y is 0, v1.z is 0
/// v1.set(10, 50, 80); // now v1.x is 10, v1.y is 50, v1.z is 80
/// ~~~~
/// 
/// Using 'ofVec3f' greatly simplifies arithmetic operations in three dimensions.
/// For example if you have two vectors 'v1' and 'v2', both of which represent a
/// 3D change in position, you can find the total change of position of both of
/// them just by doing an addition 'v1 + v2':
/// 
/// ~~~~{.cpp}
/// ofVec3f v1(5, 2, 1); 
/// // so now v1 represents walking 5 steps forward then 2 steps 
/// // sideways then 1 step upwards
/// ofVec3f v2;
/// v2.set(1, 1, 1); 
/// // so now v2 represents walking 1 step forward then 1 step 
/// // sideways then 1 step upwards
/// 
/// // what happens if you do v1 followed by v2?
/// // to find out just add v1 and v2 together:
/// ofVec3f result = v1 + v2; 
/// // result is (6, 3, 1), or 6 steps forward then 3 steps sideways
/// // then 2 steps upwards
/// ~~~~
/// 
/// You can scale an 'ofVec3f' by multiplying it with a float:
/// 
/// ~~~~{.cpp}
/// // walk 5 steps forward then 2 steps sideways then 1 step upwards
/// ofVec3f v1(5, 2, 1); 
/// // what happens if we do v1 three times?
/// ofVec3f result = v1 * 3; // result is (15, 6, 3), or 
/// // 15 steps forward, 6 steps sideways and 3 steps upwards
/// ~~~~
/// 
/// This also works for subtraction and division.
/// 
/// As you can see this really makes dealing with vectors as easy as dealing with
/// single 'float's or 'int's, and can reduce the number of lines of code you have
/// to write by half, at the same time making your code much easier to read and
/// understand!
/// \sa ofVec2f for 2D vectors
/// \sa ofVec4f for 4D vectors
class ofVec3f {
public:
   	/// \cond INTERNAL
	static const int DIM = 3;
	/// \endcond
	
	/// \brief Stores the `X` component of this vector.
	float x;
	
	/// \brief Stores the `Y` component of this vector.
	float y;
	
	/// \brief Stores the `Z` component of this vector.
	float z;
    
	//---------------------
	/// \name Construct a 3D vector
	/// \{
    
	/// \brief Construct a 3D vector. Defaults to (0,0,0).
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1; 
	/// // default: v1.x is 0, v1.y is 0, v1.z is 0
	///
	/// ofVec3f v2 = ofVec3f(40, 20, 10); 
	/// // v2.x is 40, v2.y is 20, v2.z is 10
	///
	/// ofVec3f v3(0.1, 0.3, -1.5); 
	/// // v3.x is 0.1, v3.y is 0.3, v3.z is -1.5
	/// ~~~~
	ofVec3f();

	/// \brief Construt a 3D vector with `x`, `y` and `z` specified
	ofVec3f( float x, float y, float z=0 );
	
	/// \brief Construct a 3D vector with `x`, `y` and `z` set to `scalar`
	explicit ofVec3f( float scalar );
	
    ofVec3f( const ofVec2f& vec );

	/// \brief Construct a new 3D vector from a 4D vector by 
	/// throwing away the 'w' component.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f mom = ofVec4f(40, 20, 10, 100);
	/// ofVec3f v(mom); // v is (40, 20, 10)
	/// ~~~~
    ofVec3f( const ofVec4f& vec );

	ofVec3f( const glm::vec2 & vec );
	ofVec3f( const glm::vec3 & vec );
	ofVec3f( const glm::vec4 & vec );

    operator glm::vec3() const;

	/// \}

	//---------------------
	/// \name Access components
	/// \{


	/// \brief Returns a pointer to the memory position of the first element of the vector
	/// ('x'); the other elements ('y' and 'z') immediately follow it in memory.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10);
	/// float * v1Ptr = v1.getPtr();
	/// float x = *(v1Ptr); // x is 40
	/// float y = *(v1Ptr+1); // y is 20
	/// float z = *(v1Ptr+2); // z is 10
	/// ~~~~
	/// 
	/// This is very useful when using arrays of 'ofVec3f's to store geometry
	/// information, as it allows the vector to be treated as a simple C array of
	/// 'float's that can be passed verbatim to OpenGL.
	/// 
	float * getPtr() {
		return (float*)&x;
	}
	const float * getPtr() const {
		return (const float *)&x;
	}
	

	/// \brief Allows to access the individual components of an 'ofVec3f' as though it is an
	/// array
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10);
	/// float x = v1[0]; // x is 40
	/// float y = v1[1]; // y is 20
	/// float z = v1[2]; // z is 10
	/// ~~~~
	/// 
	/// This function can be handy if you want to do the same operation to all 'x',
	/// 'y' and 'z' components, as it means you can just make a 'for' loop that
	/// repeats 3 times.
	float& operator[]( int n ){
		return getPtr()[n];
	}
	
	float operator[]( int n ) const {
		return getPtr()[n];
	}
	
    
	/// \brief Set 'x', 'y' and 'z' components of this vector with just one function call.
	/// 'z' is optional, it defaults to 0.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1;
	/// v1.set(40, 20, 70);
	/// ~~~~
    void set( float x, float y, float z = 0 );


	/// \brief Setting the values by using other 3 dimension vector ofVec3f.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1;
	/// ofVec3f v2;
	/// v1.set(40, 20, 70);
	/// v2.set(v1);
	/// ~~~~
    void set( const ofVec3f& vec );
	void set( float _scalar );

	/// \}

    //---------------------
	/// \name Comparison 
	/// \{

    /// \brief Check for equality between two ofVec3f
    ///
	/// Returns 'true' if each component is the same as the corresponding component in
	/// 'vec', ie if 'x == vec.x' and 'y == vec.y' and 'z == vec.z'; otherwise returns
	/// 'false'. But you should probably be using ['match'](#match) instead.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(40, 20, 10); 
	/// ofVec3f v2(50, 30, 10); 
	/// ofVec3f v3(40, 20, 10); 
	/// // ( v1 == v2 ) is false
	/// // ( v1 == v3 ) is true
	/// ~~~~
    bool operator==( const ofVec3f& vec ) const;
    
	/// \brief Returns 'true' if any component is different to its corresponding component in
	/// 'vec', ie if 'x != vec.x' or 'y != vec.y' or 'z != vec.z'; otherwise returns
	/// 'false'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(40, 20, 10); 
	/// ofVec3f v2(50, 20, 40); 
	/// ofVec3f v3(40, 20, 10); 
	/// // ( v1 != v2 ) is true
	/// // ( v1 != v3 ) is false
	/// ~~~~
    bool operator!=( const ofVec3f& vec ) const;
    bool operator!=( const glm::vec3& vec ) const;

	/// \brief Let you check if two vectors are similar given a tolerance threshold
	/// 'tolerance' (default = 0.0001).	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 70);
	/// ofVec3f v2 = ofVec3f(40.01, 19.999, 70.05);
	/// // v1.match(v2, 0.1) is true
	/// // v1.match(v2, 0.01) is false (because (70.5-70) > 0.01)
	/// ~~~~
	/// 
    bool match( const ofVec3f& vec, float tolerance = 0.0001f ) const;
    /**
	 * Checks if vectors look in the same direction.
	 */
    bool isAligned( const ofVec3f& vec, float tolerance = 0.0001f ) const;
    bool isAlignedRad( const ofVec3f& vec, float tolerance = 0.0001f ) const;
    
	/// \brief Returns 'true' if this vector is pointing in the same direction as
	/// 'vec', with an angle error threshold 'tolerance' in degrees (default
	/// 0.0001 degrees).	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 70);
	/// ofVec3f v2 = ofVec3f(4, 2, 7);
	/// // v1.align(v2, 0.0) is true
	/// ~~~~
    bool align( const ofVec3f& vec, float tolerance = 0.0001f ) const;
    
	/// \brief Returns 'true' if this vector is pointing in the same direction
	/// as 'vec', with an angle error threshold 'tolerance' in radians
	/// (default 0.0001).
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 70);
	/// ofVec3f v2 = ofVec3f(4, 2, 7);
	/// // v1.align(v2, 0.0) is true
	/// ~~~~
    bool alignRad( const ofVec3f& vec, float tolerance = 0.0001f ) const;
	
	
    /// \}

	//---------------------
	/// \name Operators
	/// \{

	/// Super easy vector addition. Returns a new vector
	/// ('x'+'vec.x','y'+'vec.y','z'+'vec.z').
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); 
	/// ofVec3f v2 = ofVec3f(25, 50, 10);
	/// ofVec3f v3 = v1 + v2; // v3 is (65, 70, 20)
	/// ~~~~
	ofVec3f  operator+( const ofVec3f& pnt ) const;

	/// Returns a new vector with a float value 'f' added to 'x', 'y' and 'z'
	/// members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// ofVec3f v2 = v1 + 10; // (12, 15, 11)
	/// ~~~~

    ofVec3f  operator+( const float f ) const;
    
	/// Super easy addition assignment. Adds 'vec.x' to 'x', adds 'vec.y' to 'y' and
	/// adds 'vec.z' to 'z'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); 
	/// ofVec3f v2 = ofVec3f(25, 50, 10);
	/// v1 += v2; // v1 is (65, 70, 20)
	/// ~~~~
	ofVec3f& operator+=( const ofVec3f& pnt );
    
	/// Adds a float value 'f' to 'x', 'y' and 'z' members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// v1 += 10; // (12, 15, 11)
	/// ~~~~
    ofVec3f& operator+=( const float f );
    
	/// Super easy vector subtraction. Returns a new vector
	/// ('x'-'vec.x','y'-'vec.y','z'-'vec.z').	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); 
	/// ofVec3f v2 = ofVec3f(25, 50, 10);
	/// ofVec3f v3 = v1 - v2; // v3 is (15, -30, 0)
	/// ~~~~
	ofVec3f  operator-( const ofVec3f& vec ) const;



	/// Returns a new vector with a float value 'f' subtracted from 'x', 'y' and 'z'
	/// members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// ofVec3f v2 = v1 - 10; // (-8, -5, -9)
	/// ~~~~
 	ofVec3f  operator-( const float f ) const;

	/// Returns a new 'ofVec3f' that is the inverted version (mirrored in X, Y and Z)
	/// of this vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// ofVec3f v2 = -v1; // (-2, -5, -1)
	/// ~~~~
	/// 
    ofVec3f  operator-() const;

	/// Super easy subtraction assignment. Subtracts 'vec.x' from 'x', subtracts
	/// 'vec.y' from 'y' and subtracts 'vec.z' from 'z'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); 
	/// ofVec3f v2 = ofVec3f(25, 50, 10);
	/// v1 -= v2; // v1 is (15, -30, 0)
	/// ~~~~    
	ofVec3f& operator-=( const ofVec3f& vec );

	/// Subtract a float value 'f' from 'x', 'y', and 'z' members.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// v1 -= 10; // (-8, -5, -9)
	/// ~~~~
	ofVec3f& operator-=( const float f );

	/// Returns a new vector ('x'*'vec.x','y'*'vec.y','z'*'vec.z').
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); inline
	/// ofVec3f v2 = ofVec3f(2, 4, 10);
	/// ofVec3f v3 = v1 * v2; // (80, 80, 100)
	/// ~~~~
	/// 
	/// Useful for scaling a 3D point by a non-uniform scale.
	/// 
    ofVec3f  operator*( const ofVec3f& vec ) const;

	/// Return a new 'ofVec3f' that is this vector scaled by multiplying 'x', 'y', 'z'
	/// members by 'f'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// ofVec3f v2 = v1 * 4; // (8, 20, 4)
	/// ~~~~
    ofVec3f  operator*( const float f ) const;
    
	/// Multiplies 'x' by 'vec.x', and multiplies 'y' by 'vec.y', and multiplies 'z'
	/// by 'vec.z'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); 
	/// ofVec3f v2 = ofVec3f(2, 4, 10);
	/// v1 *= v2; // v1 is now (80, 80, 100)
	/// ~~~~
	/// 
	/// Useful for scaling a 3D point by a non-uniform scale.
    ofVec3f& operator*=( const ofVec3f& vec );

	/// Scale this vector by multiplying 'x', 'y' and 'z' members by 'f'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// v1 *= 4; // (8, 20, 4)
	/// ~~~~
    ofVec3f& operator*=( const float f );
    
	/// Returns a new vector ('x'/'vec.x','y'/'vec.y','z'/'vec.z').
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); 
	/// ofVec3f v2 = ofVec3f(2, 4, 10);
	/// ofVec3f v3 = v1 / v2; // (20, 5, 1)
	/// ~~~~
	/// 
	/// Useful for scaling a 3D point by a non-uniform scale.
    ofVec3f  operator/( const ofVec3f& vec ) const;
    
	/// Return a new 'ofVec3f' that is this vector scaled by dividing 'x', 'y'
	/// and 'z' members by 'f'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// ofVec3f v2 = v1 / 4; // (0.5, 1.25, 0.25)
	/// ~~~~
    ofVec3f  operator/( const float f ) const;
    
	/// Divides 'x' by 'vec.x', divides 'y' by 'vec.y', and divides 'z' by 'vec.z'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1 = ofVec3f(40, 20, 10); 
	/// ofVec3f v2 = ofVec3f(2, 4, 10);
	/// v1 *= v2; // v1 is now (20, 5, 1)
	/// ~~~~
	/// 
	/// Useful for scaling a 3D point by a non-uniform scale.
    ofVec3f& operator/=( const ofVec3f& vec );

	/// Scale this vector by dividing 'x', 'y' and 'z' members by 'f'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(2, 5, 1);
	/// v1 /= 4; // (0.5, 1.25, 0.25)
	/// ~~~~
    ofVec3f& operator/=( const float f );
	
    /// \cond INTERNAL
	friend std::ostream& operator<<(std::ostream& os, const ofVec3f& vec);
	friend std::istream& operator>>(std::istream& is, ofVec3f& vec);
	/// \endcond

    /// \}
	
	//---------------------
	/// \name Simple manipulations
	/// \{

	/// \brief Return a new 'ofVec3f' that is the result of scaling this vector up or down so that it has
	/// the requested length.	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(3, 4); // length is 5
	/// ofVec3f v2 = v1.getScaled(15); // v2 is (9, 12), which has length of 15
	/// ~~~~
	/// 
    ofVec3f  getScaled( const float length ) const;


	/// \brief Scales this vector up or down so that it has the requested length.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(3, 4); // length is 5
	/// v1.scale(15); // v1 is now (9, 12), which has length of 15
	/// ~~~~
    ofVec3f& scale( const float length );
    
	
	/// \brief Returns a new vector that is the result of rotating this vector
	/// by 'angle' degrees about the given axis.
	///
	/// ~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2 = v1.getRotated(45, ofVec3f(0, 0, 1)); // v2 is (0.707, 0.707, 0)
	/// ofVec3f v3 = v1.getRotated(45, ofVec3f(0, 1, 0)); // v3 is (0.707, 0, -0.707)
	/// ~~~~
	///
    ofVec3f  getRotated( float angle, const ofVec3f& axis ) const;

	/// \brief Returns a new vector that is the result of performing an Euler
	/// rotation of this vector by 'ax' degrees about the x axis, 'ay' degrees
	/// about the y axis, and 'az' degrees about the z axis.
	///
	/// ~~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2 = v1.getRotated(0, 0, 45); // v2 is (0.707, 0.707, 0)
	/// ofVec3f v3 = v1.getRotated(0, 45, 0); // v3 is (0.707, 0, -0.707)
	/// ~~~~~
	///
	/// Watch out for gimbal lock when specifying multiple rotations in the same call.
	///
    ofVec3f  getRotated(float ax, float ay, float az) const;

	/// \brief Returns a new vector that is the result of rotating this vector by
	/// 'angle' degrees about the axis specified by 'axis', using 'pivot' as the
	/// origin of rotation.
    ofVec3f  getRotated( float angle, const ofVec3f& pivot, const ofVec3f& axis ) const;


	/// \brief Returns a new vector that is the result of rotating this vector by
	/// 'angle' radians about the given axis.
	///
	/// ~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2 = v1.getRotated(PI / 4, ofVec3f(0, 0, 1)); // v2 is (0.707, 0.707, 0)
	/// ofVec3f v3 = v1.getRotated(PI / 4, ofVec3f(0, 1, 0)); // v3 is (0.707, 0, -0.707)
	/// ~~~~
    ofVec3f  getRotatedRad( float angle, const ofVec3f& axis ) const;

	/// \brief Returns a new vector that is the result of performing an Euler
	/// rotation of this vector by 'ax' radians about the x axis, 'ay' radians
	/// about the y axis, and 'az' radians about the z axis.
	///
	/// ~~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2 = v1.getRotatedRad(0, 0, PI / 4); // v2 is (0.707, 0.707, 0)
	/// ofVec3f v3 = v1.getRotatedRad(0, PI / 4, 0); // v3 is (0.707, 0, -0.707)
	/// ~~~~~
	///
	/// Watch out for gimbal lock when specifying multiple rotations in the same call.
	///
	ofVec3f  getRotatedRad(float ax, float ay, float az) const;

	/// \brief Returns a new vector that is the result of rotating this vector by
	/// 'angle' radians about the axis specified by 'axis', using 'pivot' as the
	/// origin of rotation.
    ofVec3f   getRotatedRad( float angle, const ofVec3f& pivot, const ofVec3f& axis ) const;

	/// \brief Rotates this vector by 'angle' degrees around the given axis.
	///
	/// ~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2(1, 0, 0);
	/// v1.rotate(45, ofVec3f(0, 0, 1)); // v1 is now (0.707, 0.707, 0)
	/// v2.rotate(45, ofVec3f(0, 1, 0)); // v2 is now (0.707, 0, -0.707)
	/// ~~~~
	ofVec3f& rotate( float angle, const ofVec3f& axis );

	/// \brief Performs an Euler rotation of this vector by 'ax' degrees about the
	/// x axis, 'ay' degrees about the y axis, and 'az' degrees about the z axis.
	///
	/// ~~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2(1, 0, 0);
	/// v1.rotate(0, 0, 45); // v1 is now (0.707, 0.707, 0)
	/// v2.rotate(0, 45, 0); // v2 is now (0.707, 0, -0.707)
	/// ~~~~~
	///
	/// Watch out for gimbal lock when specifying multiple rotations in the same call.
	///
    ofVec3f& rotate(float ax, float ay, float az);

	/// \brief Rotates this vector by 'angle' degrees about the axis specified by 'axis',
	/// using 'pivot' as the origin of rotation.
	ofVec3f& rotate( float angle, const ofVec3f& pivot, const ofVec3f& axis );


	/// \brief Rotates this vector by 'angle' radians about the given axis.
	///
	/// ~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2(1, 0, 0)
	/// v1.rotateRad(PI / 4, ofVec3f(0, 0, 1)); // v1 is now (0.707, 0.707, 0)
	/// v2.rotateRad(PI / 4, ofVec3f(0, 1, 0)); // v2 is now (0.707, 0, -0.707)
	/// ~~~~
    ofVec3f& rotateRad( float angle, const ofVec3f& axis );

	/// \brief Performs an Euler rotation of this vector by 'ax' radians about
	/// the x axis, 'ay' radians about the y axis, and 'az' radians about the z axis.
	///
	/// ~~~~~{.cpp}
	/// ofVec3f v1(1, 0, 0);
	/// ofVec3f v2(1, 0, 0);
	/// v1.rotateRad(0, 0, PI / 4); // v1 is now (0.707, 0.707, 0)
	/// v2.rotateRad(0, PI / 4, 0); // v2 is now (0.707, 0, -0.707)
	/// ~~~~~
	///
	/// Watch out for gimbal lock when specifying multiple rotations in the same call.
    ofVec3f& rotateRad(float ax, float ay, float az);

	/// \brief Rotates this vector by 'angle' radians around the axis specified by 'axis',
	/// using 'pivot' as the origin of rotation.
    ofVec3f& rotateRad( float angle, const ofVec3f& pivot, const ofVec3f& axis );


    	
	
	/// \brief Return a new 'ofVec3f' calculated by copying this vector and then mapping from
	/// its default coordinate system -- origin (0,0,0), X direction (1,0,0), Y
	/// direction (0,1,0), Z direction (0,0,1) -- to a new coordinate system defined
	/// with origin at 'origin', X direction 'vx', and Y direction 'vy', and Z
	/// direction 'vz'.
	/// 
	/// *In most cases you want 'vx', 'vy', and 'vz' to be perpendicular and of unit
	/// length; if they are not perpendicular you will have shearing as part of the
	/// mapping, and if they are not of unit length you will have scaling as part of
	/// the mapping.*
	/// 
	ofVec3f getMapped( const ofVec3f& origin,
					  const ofVec3f& vx,
					  const ofVec3f& vy,
					  const ofVec3f& vz ) const;

	/// \brief Map this vector from its default coordinate system -- origin (0,0,0), X
	/// direction (1,0,0), Y direction (0,1,0), Z direction (0,0,1) -- to a new
	/// coordinate system defined with origin at 'origin', X direction 'vx', and Y
	/// direction 'vy', and Z direction 'vz'.
	///
	/// *In most cases you want 'vx', 'vy', and 'vz' to be perpendicular and of
	/// unit length; if they are not perpendicular you will have shearing as part
	/// of the mapping, and if they are not of unit length you will have scaling
	/// as part of the mapping.*
	/// 
    ofVec3f& map( const ofVec3f& origin,
				 const ofVec3f& vx,
				 const ofVec3f& vy,
				 const ofVec3f& vz );
	
	

    /// \}
	
	
	//---------------------
	/// \name Distance
	/// \{


	/// \brief Treats both this vector and 'pnt' as points in 3D space, and
	/// calculates and returns the distance between them.	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f p1(3, 4, 2);
	/// ofVec3f p2(6, 8, 5);
	/// float distance = p1.distance( p2 ); // distance is 5.8310
	/// ~~~~
	/// 	
	/// 'distance' involves a square root calculation, which is one of the
	/// slowest things you can do in programming. If you don't need an exact
	/// number but rather just a rough idea of distance (for example when
	/// finding the shortest distance of a bunch of points to a reference
	/// point, where it doesn't matter exactly what the distances are, you
	/// just want the shortest), you can use squareDistance() instead.
	float distance( const ofVec3f& pnt) const;
    
	/// \brief Treats both this vector and 'pnt' as points in 3D space, and calculates and
	/// returns the squared distance between them.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f p1(3, 4, 2);
	/// ofVec3f p2(6, 8, 5);
	/// float distance = p1.distance( p2 ); // distance is 5.8310
	/// ~~~~
	/// 
	/// Use as a much faster alternative to distance() if you don't need
	/// to know an exact number but rather just a rough idea of distance (for example
	/// when finding the shortest distance of a bunch of points to a reference point,
	/// where it doesn't matter exactly what the distances are, you just want the
	/// shortest). It avoids the square root calculation that is ordinarily required
	/// to calculate a length.
	/// 
    float squareDistance( const ofVec3f& pnt ) const;
	
		
	/// \}

	//---------------------
	/// \name Interpolation
	/// \{

	/// \brief Perform a linear interpolation of this vector's position towards 'pnt'
	/// and return the interpolated vector without altering the original. 'p'
	/// controls the amount to move towards 'pnt'. 'p' is normally between 0
	/// and 1 and where 0 means stay the original position and 1 means move
	/// all the way to 'pnt', but you can also have 'p' greater than 1
	/// overshoot 'pnt', or less than 0 to move backwards away from 'pnt'.	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(0, 5, 0);
	/// ofVec3f v2(10, 10, 20);
	/// ofVec3f v3 = v1.getInterpolated(p2, 0.5); // v3 is (5, 7.5, 10)
	/// ofVec3f v4 = v1.getInterpolated(p2, 0.8); // v4 is (8, 9, 16)
	/// ~~~~
	/// 
    ofVec3f   getInterpolated( const ofVec3f& pnt, float p ) const;

	/// \brief Perform a linear interpolation of this vector's position towards
	/// 'pnt'. 'p' controls the amount to move towards 'pnt'. 'p' is normally
	/// between 0 and 1 and where 0 means stay the original position and 1
	/// means move all the way to 'pnt', but you can also have 'p' greater
	/// than 1 overshoot 'pnt', or less than 0 to move backwards away from
	/// 'pnt'.	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1( 0, 5, 0 );
	/// ofVec3f v2( 10, 10, 20 );
	/// // go go gadget zeno
	/// v1.interpolate( v2, 0.5 ); // v1 is now (5, 7.5, 10)
	/// v1.interpolate( v2, 0.5 ); // v1 is now (7.5, 8.75, 15)
	/// v1.interpolate( v2, 0.5 ); // v1 is now (8.75, 9.375, 17.5)
	/// v1.interpolate( v2, 0.5 ); // v1 is now (9.375, 9.6875, 18.75)
	/// ~~~~
    ofVec3f&  interpolate( const ofVec3f& pnt, float p );
    
	/// \brief Calculate and return the midpoint between this vector and 'pnt'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(5, 0, 0);
	/// ofVec3f v2(10, 10, 20);
	/// ofVec3f mid = v1.getMiddle(v2); // mid gets (7.5, 5, 10)
	/// ~~~~
    ofVec3f   getMiddle( const ofVec3f& pnt ) const;

	/// Set this vector to the midpoint between itself and 'pnt'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1( 0, 5, 0 );
	/// ofVec3f v2( 10, 10, 20);
	/// // go go gadget zeno
	/// v1.middle( v2 ); // v1 is now (5, 7.5, 10)
	/// v1.middle( v2 ); // v1 is now (7.5, 8.75, 15)
	/// v1.middle( v2 ); // v1 is now (8.75, 9.375, 17.5)
	/// v1.middle( v2 ); // v1 is now (9.375, 9.6875, 18.75)
	/// ~~~~
    ofVec3f&  middle( const ofVec3f& pnt );
    
	/// \brief Sets this vector to be the average (*centre of gravity* or
	/// *centroid*) of a given array of 'ofVec3f's. 'points' is the array of
	/// 'ofVec3f's and 'num' specifies the number of 'ofVec3f's in the array.	
	/// 
	/// ~~~~{.cpp}
	/// int numPoints = 10;
	/// ofVec3f points[numPoints];
	/// for ( int i=0; i<numPoints; i++ ) {
	/// 	points[i].set( ofRandom(0,100), ofRandom(0,100), ofRandom(0,100) );
	/// }
	/// ofVec3f centroid;
	/// centroid.average( points, numPoints ); 
	/// // centroid now is the centre of gravity/average of all the random points
	/// ~~~~
	ofVec3f&  average( const ofVec3f* points, int num );
    
    /// \}

    //---------------------
	/// \name Limit
	/// \{
	
	/// \brief Return a normalized copy of this vector. 
	/// 
	/// *Normalization* means to scale the vector so that its length
	/// (magnitude) is exactly 1, at which stage all that is left is the
	/// direction. A normalized vector is usually called a *unit vector*, and
	/// can be used to represent a pure direction (heading).	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(5, 0, 0);
	/// ofVec3f v1Normalized = v1.getNormalized(); // (1, 0, 0)
	/// ofVec3f v2(5, 0, 5);
	/// ofVec3f v2Normalized = v2.getNormalized(); // (2, 0, 2)
	/// ~~~~
	ofVec3f  getNormalized() const;
   
	/// \brief Normalize the vector.
	/// 
	/// *Normalizing* means to scale the vector so that its length (magnitude)
	/// is exactly 1, at which stage all that is left is the direction. A
	/// normalized vector is usually called a *unit vector*, and can be used
	/// to represent a pure direction (heading).	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(5, 0, 0);
	/// v1.normalize(); // v2 is now (1, 0, 0)
	/// ofVec3f v2(5, 0, 5);
	/// v2.normalize(); // v2 is now (2, 0, 2)
	/// ~~~~
	/// 
  	ofVec3f& normalize();
	
	
	/// \brief Return a copy of this vector with its length (magnitude) restricted to a
	/// maximum of 'max' units by scaling down if necessary.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(5, 0, 1); // length is about 5.1
	/// ofVec3f v2(2, 0, 1); // length is about 2.2
	/// ofVec3f v1Limited = v1.getLimited(3); 
	/// // v1Limited is (2.9417, 0, 0.58835) which has length of 3 in the same direction as v1
	/// ofVec3f v2Limited = v2.getLimited(3);
	/// // v2Limited is (2, 0, 1) (same as v2)
	/// ~~~~
	ofVec3f  getLimited(float max) const;

	/// \brief Restrict the length (magnitude) of this vector to a maximum of 'max'
	/// units by scaling down if necessary.	
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(5, 0, 1); // length is about 5.1
	/// ofVec3f v2(2, 0, 1); // length is about 2.2
	/// v1.limit(3); 
	/// // v1 is now (2.9417, 0, 0.58835) which has length of 3 in the same direction as at initialization
	/// v2.limit(3);
	/// // v2 is unchanged
	/// ~~~~
    ofVec3f& limit(float max);

	
	/// \}

	//---------------------
	/// \name Measurement
	/// \{


	/// Return the length (magnitude) of this vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v(3, 4, 1);
	/// float len = v.length(); // len is 5.0990
	/// ~~~~
	/// 
	/// `length' involves a square root calculation, which is one of the
	/// slowest things you can do in programming. If you don't need an exact
	/// number but rather just a rough idea of a length (for example when
	/// finding the shortest distance of a bunch of points to a reference
	/// point, where it doesn't matter exactly what the lengths are, you just
	/// want the shortest), you can use lengthSquared() instead.
	///    
    float length() const;

    /// \brief Return the squared length (squared magnitude) of this vector.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v(3, 4, 1);
	/// float len = v.length(); // len is 5.0990
	/// ~~~~
	/// 
	/// Use as a much faster alternative to length() if you don't need
	/// to know an accurate length but rather just a rough idea of a length (for
	/// example when finding the shortest distance of a bunch of points to a
	/// reference point, where it doesn't matter exactly what the lengths are, you
	/// just want the shortest). It avoids the square root calculation that is
	/// ordinarily required to calculate a length.
    float lengthSquared() const;

	/// \brief Calculate and return the coplanar angle in degrees between this vector
	/// and 'vec'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(1,0,0);
	/// ofVec3f v2(0,1,0);
	/// float angle = v1.angle(v2); // angle is 90
	/// ~~~~    
	float angle( const ofVec3f& vec ) const;
    
	/// \brief Calculate and return the coplanar angle in radians between this 
	/// vector and 'vec'.
	/// 
	/// ~~~~{.cpp}
	/// ofVec3f v1(1,0,0);
	/// ofVec3f v2(0,1,0);
	/// float angle = v1.angle(v2); // angle is 90
	/// ~~~~
	/// 
    float angleRad( const ofVec3f& vec ) const;
	

	/// \}

	//---------------------
	/// \name Perpendicular
	/// \{

    
	/// \brief Construct a plane using this vector and 'vec' (by finding the plane that both
	/// lectors lie on), and return the vector that is perpendicular to that plane
	/// (the normal to that plane).
	/// 
	/// ~~~~{.cpp}
	/// ofSetLogLevel(OF_LOG_NOTICE);
	/// ofVec3f v1(1,0,0);
	/// ofVec3f v2(0,1,0);
	/// ofVec3f p = v1.getPerpendicular(v2);
	/// ofLog(OF_LOG_NOTICE, "%1.1f, %1.1f, %1.1f\n", p.x, p.y, p.z);
	/// // prints "0.0, 0.0, 1.0"
	/// ~~~~
	/// 
	/// This method is usually used to calculate a normal vector to a surface, which
	/// can then be used to calculate lighting, collisions, and other 3D effects.
	/// 
	ofVec3f  getPerpendicular( const ofVec3f& vec ) const;


	/// \brief Construct a plane using this vector and 'vec' (by finding the plane that both
	/// lie on), and set our 'x', 'y' and 'z' to be the vector that is perpendicular
	/// to the constructed plane (the normal to the plane).
	/// 
	/// ~~~~{.cpp}
	/// ofSetLogLevel(OF_LOG_NOTICE);
	/// ofVec3f v1(1,0,0);
	/// ofVec3f v2(0,1,0); 
	/// v1.perpendicular(v2); 
	/// ofLog(OF_LOG_NOTICE, "%1.1f, %1.1f, %1.1f\n", v1.x, v1.y, v1.z);
	/// // prints "0.0, 0.0, 1.0'
	/// ~~~~
	/// 
	/// This method is usually used to calculate a normal vector to a surface, which
	/// can then be used to calculate lighting, collisions, and other 3D effects.
	/// 
    ofVec3f& perpendicular( const ofVec3f& vec );
	
	

	/// \brief Returns the cross product (vector product) of this vector and 'vec'. This is a
	/// binary operation on two vectors in three-dimensional space, which results in a
	/// vector that is perpendicular to both of the vectors being multiplied, and
	/// normal to the plane containing them. The name *cross product* is derived from
	/// the cross symbol X that is often used to designate this operation; the
	/// alternative name *vector product* emphasizes the vector (rather than scalar)
	/// nature of the result.
	/// 
	/// ![CROSS](math/crossproduct.png)
	/// Image courtesy of Wikipedia
    ofVec3f  getCrossed( const ofVec3f& vec ) const;
    
	/// Set this vector to the cross product (vector product) of itself and
	/// 'vec'. This is a binary operation on two vectors in three-dimensional
	/// space, which results in a vector that is perpendicular to both of the
	/// vectors being multiplied, and normal to the plane containing them. The
	/// name *cross product* is derived from the cross symbol X that is often
	/// used to designate this operation; the alternative name *vector
	/// product* emphasizes the vector (rather than scalar) nature of the
	/// result.
    ofVec3f& cross( const ofVec3f& vec );

	
	
	
	/// \brief Returns the dot product of this vector with 'vec'.
	///
	/// The *dot product* of two vectors, also known as the *scalar product*, is
	/// the product of the magnitude of the two vectors and the cosine of the
	/// angle between them.
	///
	/// One interpretation of the dot product is as a measure of how closely two
	/// vectors align with each other. If they point in exactly the same
	/// direction, their dot product will simply be the product of their
	/// magnitudes, if they are perpendicular, their dot product will be 0, and
	/// if they point in opposite directions, their dot product will be
	/// negative.
	///
	/// The dot product is in contrast to the *cross product*, which returns a
	/// vector rather than a scalar.
	///
	/// ~~~~{.cpp}
	/// ofVec3f a1(2, 0, 0); // magnitude 2, parallel to x-axis
	/// ofVec3f b1(3, 4, 0); // magnitude 5, 53.13 degree angle to a1
	/// float dot = a1.dot(b1); // dot is 2 * 5 * cos(53.13) = 6.0
	///
	/// ofVec3f a2(1, 0, 0); // magnitude 1, parallel to x-axis
	/// ofVec3f b2(0, 0, 1); // magnitude 1, 90 degree angle to a2
	/// dot = a2.dot(b2); // dot is 1 * 1 * cos(90) = 0.0
	///
	/// ofVec3f a3(0, 1, 0); // magnitude 1, parallel to y-axis
	/// ofVec3f b3(0, -1, 0); // magnitude 1, 180 degree angle to a3
	/// dot = a3.dot(b3); // dot is 1 * 1 * cos(180) = -1.0
	/// ~~~~
	/// 
    float dot( const ofVec3f& vec ) const;
	
	/// \}


	
    //-----------------------------------------------
    // this methods are deprecated in 006 please use:
	/// \cond INTERNAL

    // getScaled
    OF_DEPRECATED_MSG("Use member method getScaled() instead.", ofVec3f rescaled( const float length ) const);
	
    // scale
    OF_DEPRECATED_MSG("Use member method scale() instead.", ofVec3f& rescale( const float length ));
	
    // getRotated
    OF_DEPRECATED_MSG("Use member method getRotated() instead.", ofVec3f rotated( float angle, const ofVec3f& axis ) const);
	
    // getRotated should this be const???
    OF_DEPRECATED_MSG("Use member method getRotated() instead.", ofVec3f rotated(float ax, float ay, float az));
	
    // getNormalized
    OF_DEPRECATED_MSG("Use member method getNormalized() instead.", ofVec3f normalized() const);
	
    // getLimited
    OF_DEPRECATED_MSG("Use member method getLimited() instead.", ofVec3f limited(float max) const);
	
    // getCrossed
    OF_DEPRECATED_MSG("Use member method getCrossed() instead.", ofVec3f crossed( const ofVec3f& vec ) const);
	
    // getPerpendicular
    OF_DEPRECATED_MSG("Use member method getPerpendicular() instead.", ofVec3f perpendiculared( const ofVec3f& vec ) const);
    
    // use getMapped
    OF_DEPRECATED_MSG("Use member method getMapped() instead.", ofVec3f mapped( const ofVec3f& origin,
					const ofVec3f& vx,
					const ofVec3f& vy,
					const ofVec3f& vz ) const);
	
    // use squareDistance
    OF_DEPRECATED_MSG("Use member method squareDistance() instead.", float  distanceSquared( const ofVec3f& pnt ) const);
	
    // use getInterpolated
    OF_DEPRECATED_MSG("Use member method getInterpolated() instead.", ofVec3f interpolated( const ofVec3f& pnt, float p ) const);
	
    // use getMiddle
    OF_DEPRECATED_MSG("Use member method getMiddle() instead.", ofVec3f middled( const ofVec3f& pnt ) const);
    
    // use getRotated
    OF_DEPRECATED_MSG("Use member method getRotated() instead.", ofVec3f rotated( float angle,
						const ofVec3f& pivot,
						const ofVec3f& axis ) const);    

    // return all zero vector
    static ofVec3f zero() { return ofVec3f(0, 0, 0); }
    
    // return all one vector
    static ofVec3f one() { return ofVec3f(1, 1, 1); }

    /// \endcond

};


/// \cond INTERNAL


// Non-Member operators
//
//
ofVec3f operator+( float f, const ofVec3f& vec );
ofVec3f operator-( float f, const ofVec3f& vec );
ofVec3f operator*( float f, const ofVec3f& vec );
ofVec3f operator/( float f, const ofVec3f& vec );


/////////////////
// Implementation
/////////////////


inline ofVec3f::ofVec3f( const ofVec2f& vec ):x(vec.x), y(vec.y), z(0) {}
inline ofVec3f::ofVec3f( const ofVec4f& vec ):x(vec.x), y(vec.y), z(vec.z) {}
inline ofVec3f::ofVec3f(): x(0), y(0), z(0) {}
inline ofVec3f::ofVec3f( float _all ): x(_all), y(_all), z(_all) {}
inline ofVec3f::ofVec3f( float _x, float _y, float _z ):x(_x), y(_y), z(_z) {}

inline ofVec3f::ofVec3f( const glm::vec2 & vec ):x(vec.x), y(vec.y), z(0.f){}
inline ofVec3f::ofVec3f( const glm::vec3 & vec ):x(vec.x), y(vec.y), z(vec.z){}
inline ofVec3f::ofVec3f( const glm::vec4 & vec ):x(vec.x), y(vec.y), z(vec.z){}

inline ofVec3f::operator glm::vec3() const{
	return glm::vec3(x,y,z);
}


// Getters and Setters.
//
//
inline void ofVec3f::set( float _scalar ) {
	x = _scalar;
	y = _scalar;
	z = _scalar;
}

inline void ofVec3f::set( float _x, float _y, float _z ) {
	x = _x;
	y = _y;
	z = _z;
}

inline void ofVec3f::set( const ofVec3f& vec ) {
	x = vec.x;
	y = vec.y;
	z = vec.z;
}


// Check similarity/equality.
//
//
inline bool ofVec3f::operator==( const ofVec3f& vec ) const {
	return (x == vec.x) && (y == vec.y) && (z == vec.z);
}

inline bool ofVec3f::operator!=( const ofVec3f& vec ) const {
	return (x != vec.x) || (y != vec.y) || (z != vec.z);
}

inline bool ofVec3f::operator!=( const glm::vec3& vec ) const {
	return (x != vec.x) || (y != vec.y) || (z != vec.z);
}

inline bool ofVec3f::match( const ofVec3f& vec, float tolerance ) const{
	return (fabs(x - vec.x) < tolerance)
	&& (fabs(y - vec.y) < tolerance)
	&& (fabs(z - vec.z) < tolerance);
}

/**
 * Checks if vectors look in the same direction.
 */
inline bool ofVec3f::isAligned( const ofVec3f& vec, float tolerance ) const {
	float angle = this->angle( vec );
	return  angle < tolerance;
}
inline bool ofVec3f::align( const ofVec3f& vec, float tolerance ) const {
    return isAligned( vec, tolerance );
}

inline bool ofVec3f::isAlignedRad( const ofVec3f& vec, float tolerance ) const {
	float angle = this->angleRad( vec );
	return  angle < tolerance;
}
inline bool ofVec3f::alignRad( const ofVec3f& vec, float tolerance ) const {
    return isAlignedRad( vec, tolerance );
}


// Operator overloading for ofVec3f
//
//

inline std::ostream& operator<<(std::ostream& os, const ofVec3f& vec) {
	os << vec.x << ", " << vec.y << ", " << vec.z;
	return os;
}

inline std::istream& operator>>(std::istream& is, ofVec3f& vec) {
	is >> vec.x;
	is.ignore(2);
	is >> vec.y;
	is.ignore(2);
	is >> vec.z;
	return is;
}

inline ofVec3f ofVec3f::operator+( const ofVec3f& pnt ) const {
	return ofVec3f( x+pnt.x, y+pnt.y, z+pnt.z );
}

inline ofVec3f& ofVec3f::operator+=( const ofVec3f& pnt ) {
	x+=pnt.x;
	y+=pnt.y;
	z+=pnt.z;
	return *this;
}

inline ofVec3f ofVec3f::operator-( const ofVec3f& vec ) const {
	return ofVec3f( x-vec.x, y-vec.y, z-vec.z );
}

inline ofVec3f& ofVec3f::operator-=( const ofVec3f& vec ) {
	x -= vec.x;
	y -= vec.y;
	z -= vec.z;
	return *this;
}

inline ofVec3f ofVec3f::operator*( const ofVec3f& vec ) const {
	return ofVec3f( x*vec.x, y*vec.y, z*vec.z );
}

inline ofVec3f& ofVec3f::operator*=( const ofVec3f& vec ) {
	x*=vec.x;
	y*=vec.y;
	z*=vec.z;
	return *this;
}

inline ofVec3f ofVec3f::operator/( const ofVec3f& vec ) const {
	return ofVec3f( vec.x!=0 ? x/vec.x : x , vec.y!=0 ? y/vec.y : y, vec.z!=0 ? z/vec.z : z );
}

inline ofVec3f& ofVec3f::operator/=( const ofVec3f& vec ) {
	vec.x!=0 ? x/=vec.x : x;
	vec.y!=0 ? y/=vec.y : y;
	vec.z!=0 ? z/=vec.z : z;
	return *this;
}

inline ofVec3f ofVec3f::operator-() const {
	return ofVec3f( -x, -y, -z );
}


//operator overloading for float
//
//
//inline void ofVec3f::operator=( const float f){
//	x = f;
//	y = f;
//	z = f;
//}

inline ofVec3f ofVec3f::operator+( const float f ) const {
	return ofVec3f( x+f, y+f, z+f);
}

inline ofVec3f& ofVec3f::operator+=( const float f ) {
	x += f;
	y += f;
	z += f;
	return *this;
}

inline ofVec3f ofVec3f::operator-( const float f ) const {
	return ofVec3f( x-f, y-f, z-f);
}

inline ofVec3f& ofVec3f::operator-=( const float f ) {
	x -= f;
	y -= f;
	z -= f;
	return *this;
}

inline ofVec3f ofVec3f::operator*( const float f ) const {
	return ofVec3f( x*f, y*f, z*f );
}

inline ofVec3f& ofVec3f::operator*=( const float f ) {
	x*=f;
	y*=f;
	z*=f;
	return *this;
}

inline ofVec3f ofVec3f::operator/( const float f ) const {
	if(f == 0) return ofVec3f( x, y, z);
	
	return ofVec3f( x/f, y/f, z/f );
}

inline ofVec3f& ofVec3f::operator/=( const float f ) {
	if(f == 0) return *this;
	
	x/=f;
	y/=f;
	z/=f;
	return *this;
}


//Scale
//
//
inline ofVec3f ofVec3f::rescaled( const float length ) const {
	return getScaled(length);
}
inline ofVec3f ofVec3f::getScaled( const float length ) const {
	float l = (float)sqrt(x*x + y*y + z*z);
	if( l > 0 )
		return ofVec3f( (x/l)*length, (y/l)*length, (z/l)*length );
	else
		return ofVec3f();
}
inline ofVec3f& ofVec3f::rescale( const float length ) {
	return scale(length);
}
inline ofVec3f& ofVec3f::scale( const float length ) {
	float l = (float)sqrt(x*x + y*y + z*z);
	if (l > 0) {
		x = (x/l)*length;
		y = (y/l)*length;
		z = (z/l)*length;
	}
	return *this;
}



// Rotation
//
//
inline ofVec3f ofVec3f::rotated( float angle, const ofVec3f& axis ) const {
	return getRotated(angle, axis);
}
inline ofVec3f ofVec3f::getRotated( float angle, const ofVec3f& axis ) const {
	ofVec3f ax = axis.getNormalized();
	float a = (float)(angle*DEG_TO_RAD);
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	return ofVec3f( x*(ax.x*ax.x*cosb + cosa)
				   + y*(ax.x*ax.y*cosb - ax.z*sina)
				   + z*(ax.x*ax.z*cosb + ax.y*sina),
				   x*(ax.y*ax.x*cosb + ax.z*sina)
				   + y*(ax.y*ax.y*cosb + cosa)
				   + z*(ax.y*ax.z*cosb - ax.x*sina),
				   x*(ax.z*ax.x*cosb - ax.y*sina)
				   + y*(ax.z*ax.y*cosb + ax.x*sina)
				   + z*(ax.z*ax.z*cosb + cosa) );
}

inline ofVec3f ofVec3f::getRotatedRad( float angle, const ofVec3f& axis ) const {
	ofVec3f ax = axis.getNormalized();
	float a = angle;
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	return ofVec3f( x*(ax.x*ax.x*cosb + cosa)
				   + y*(ax.x*ax.y*cosb - ax.z*sina)
				   + z*(ax.x*ax.z*cosb + ax.y*sina),
				   x*(ax.y*ax.x*cosb + ax.z*sina)
				   + y*(ax.y*ax.y*cosb + cosa)
				   + z*(ax.y*ax.z*cosb - ax.x*sina),
				   x*(ax.z*ax.x*cosb - ax.y*sina)
				   + y*(ax.z*ax.y*cosb + ax.x*sina)
				   + z*(ax.z*ax.z*cosb + cosa) );
}

inline ofVec3f& ofVec3f::rotate( float angle, const ofVec3f& axis ) {
	ofVec3f ax = axis.getNormalized();
	float a = (float)(angle*DEG_TO_RAD);
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	float nx = x*(ax.x*ax.x*cosb + cosa)
	+ y*(ax.x*ax.y*cosb - ax.z*sina)
	+ z*(ax.x*ax.z*cosb + ax.y*sina);
	float ny = x*(ax.y*ax.x*cosb + ax.z*sina)
	+ y*(ax.y*ax.y*cosb + cosa)
	+ z*(ax.y*ax.z*cosb - ax.x*sina);
	float nz = x*(ax.z*ax.x*cosb - ax.y*sina)
	+ y*(ax.z*ax.y*cosb + ax.x*sina)
	+ z*(ax.z*ax.z*cosb + cosa);
	x = nx; y = ny; z = nz;
	return *this;
}


inline ofVec3f& ofVec3f::rotateRad(float angle, const ofVec3f& axis ) {
	ofVec3f ax = axis.getNormalized();
	float a = angle;
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	float nx = x*(ax.x*ax.x*cosb + cosa)
	+ y*(ax.x*ax.y*cosb - ax.z*sina)
	+ z*(ax.x*ax.z*cosb + ax.y*sina);
	float ny = x*(ax.y*ax.x*cosb + ax.z*sina)
	+ y*(ax.y*ax.y*cosb + cosa)
	+ z*(ax.y*ax.z*cosb - ax.x*sina);
	float nz = x*(ax.z*ax.x*cosb - ax.y*sina)
	+ y*(ax.z*ax.y*cosb + ax.x*sina)
	+ z*(ax.z*ax.z*cosb + cosa);
	x = nx; y = ny; z = nz;
	return *this;
}

// const???
inline ofVec3f ofVec3f::rotated(float ax, float ay, float az) {
	return getRotated(ax,ay,az);
}

inline ofVec3f ofVec3f::getRotated(float ax, float ay, float az) const {
	float a = (float)cos(DEG_TO_RAD*(ax));
	float b = (float)sin(DEG_TO_RAD*(ax));
	float c = (float)cos(DEG_TO_RAD*(ay));
	float d = (float)sin(DEG_TO_RAD*(ay));
	float e = (float)cos(DEG_TO_RAD*(az));
	float f = (float)sin(DEG_TO_RAD*(az));
	
	float nx = c * e * x - c * f * y + d * z;
	float ny = (a * f + b * d * e) * x + (a * e - b * d * f) * y - b * c * z;
	float nz = (b * f - a * d * e) * x + (a * d * f + b * e) * y + a * c * z;
	
	return ofVec3f( nx, ny, nz );
}

inline ofVec3f ofVec3f::getRotatedRad(float ax, float ay, float az) const {
	float a = cos(ax);
	float b = sin(ax);
	float c = cos(ay);
	float d = sin(ay);
	float e = cos(az);
	float f = sin(az);
	
	float nx = c * e * x - c * f * y + d * z;
	float ny = (a * f + b * d * e) * x + (a * e - b * d * f) * y - b * c * z;
	float nz = (b * f - a * d * e) * x + (a * d * f + b * e) * y + a * c * z;
	
	return ofVec3f( nx, ny, nz );
}


inline ofVec3f& ofVec3f::rotate(float ax, float ay, float az) {
	float a = (float)cos(DEG_TO_RAD*(ax));
	float b = (float)sin(DEG_TO_RAD*(ax));
	float c = (float)cos(DEG_TO_RAD*(ay));
	float d = (float)sin(DEG_TO_RAD*(ay));
	float e = (float)cos(DEG_TO_RAD*(az));
	float f = (float)sin(DEG_TO_RAD*(az));
	
	float nx = c * e * x - c * f * y + d * z;
	float ny = (a * f + b * d * e) * x + (a * e - b * d * f) * y - b * c * z;
	float nz = (b * f - a * d * e) * x + (a * d * f + b * e) * y + a * c * z;
	
	x = nx; y = ny; z = nz;
	return *this;
}


inline ofVec3f& ofVec3f::rotateRad(float ax, float ay, float az) {
	float a = cos(ax);
	float b = sin(ax);
	float c = cos(ay);
	float d = sin(ay);
	float e = cos(az);
	float f = sin(az);
	
	float nx = c * e * x - c * f * y + d * z;
	float ny = (a * f + b * d * e) * x + (a * e - b * d * f) * y - b * c * z;
	float nz = (b * f - a * d * e) * x + (a * d * f + b * e) * y + a * c * z;
	
	x = nx; y = ny; z = nz;
	return *this;
}


// Rotate point by angle (deg) around line defined by pivot and axis.
//
//
inline ofVec3f ofVec3f::rotated( float angle,
								const ofVec3f& pivot,
								const ofVec3f& axis ) const{
	return getRotated(angle, pivot, axis);
}

inline ofVec3f ofVec3f::getRotated( float angle,
								   const ofVec3f& pivot,
								   const ofVec3f& axis ) const
{
	ofVec3f ax = axis.getNormalized();
	float tx = x - pivot.x;
	float ty = y - pivot.y;
	float tz = z - pivot.z;
	
	float a = (float)(angle*DEG_TO_RAD);
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	float xrot = tx*(ax.x*ax.x*cosb + cosa)
	+ ty*(ax.x*ax.y*cosb - ax.z*sina)
	+ tz*(ax.x*ax.z*cosb + ax.y*sina);
	float yrot = tx*(ax.y*ax.x*cosb + ax.z*sina)
	+ ty*(ax.y*ax.y*cosb + cosa)
	+ tz*(ax.y*ax.z*cosb - ax.x*sina);
	float zrot = tx*(ax.z*ax.x*cosb - ax.y*sina)
	+ ty*(ax.z*ax.y*cosb + ax.x*sina)
	+ tz*(ax.z*ax.z*cosb + cosa);
	
	
	return ofVec3f( xrot+pivot.x, yrot+pivot.y, zrot+pivot.z );
}


inline ofVec3f ofVec3f::getRotatedRad( float angle,
									  const ofVec3f& pivot,
									  const ofVec3f& axis ) const
{
	ofVec3f ax = axis.getNormalized();
	float tx = x - pivot.x;
	float ty = y - pivot.y;
	float tz = z - pivot.z;
	
	float a = angle;
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	float xrot = tx*(ax.x*ax.x*cosb + cosa)
	+ ty*(ax.x*ax.y*cosb - ax.z*sina)
	+ tz*(ax.x*ax.z*cosb + ax.y*sina);
	float yrot = tx*(ax.y*ax.x*cosb + ax.z*sina)
	+ ty*(ax.y*ax.y*cosb + cosa)
	+ tz*(ax.y*ax.z*cosb - ax.x*sina);
	float zrot = tx*(ax.z*ax.x*cosb - ax.y*sina)
	+ ty*(ax.z*ax.y*cosb + ax.x*sina)
	+ tz*(ax.z*ax.z*cosb + cosa);
	
	
	return ofVec3f( xrot+pivot.x, yrot+pivot.y, zrot+pivot.z );
}


inline ofVec3f& ofVec3f::rotate( float angle,
								const ofVec3f& pivot,
								const ofVec3f& axis )
{
	ofVec3f ax = axis.getNormalized();
	x -= pivot.x;
	y -= pivot.y;
	z -= pivot.z;
	
	float a = (float)(angle*DEG_TO_RAD);
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	float xrot = x*(ax.x*ax.x*cosb + cosa)
	+ y*(ax.x*ax.y*cosb - ax.z*sina)
	+ z*(ax.x*ax.z*cosb + ax.y*sina);
	float yrot = x*(ax.y*ax.x*cosb + ax.z*sina)
	+ y*(ax.y*ax.y*cosb + cosa)
	+ z*(ax.y*ax.z*cosb - ax.x*sina);
	float zrot = x*(ax.z*ax.x*cosb - ax.y*sina)
	+ y*(ax.z*ax.y*cosb + ax.x*sina)
	+ z*(ax.z*ax.z*cosb + cosa);
	
	x = xrot + pivot.x;
	y = yrot + pivot.y;
	z = zrot + pivot.z;
	
	return *this;
}


inline ofVec3f& ofVec3f::rotateRad( float angle,
								   const ofVec3f& pivot,
								   const ofVec3f& axis )
{
	ofVec3f ax = axis.getNormalized();
	x -= pivot.x;
	y -= pivot.y;
	z -= pivot.z;
	
	float a = angle;
	float sina = sin( a );
	float cosa = cos( a );
	float cosb = 1.0f - cosa;
	
	float xrot = x*(ax.x*ax.x*cosb + cosa)
	+ y*(ax.x*ax.y*cosb - ax.z*sina)
	+ z*(ax.x*ax.z*cosb + ax.y*sina);
	float yrot = x*(ax.y*ax.x*cosb + ax.z*sina)
	+ y*(ax.y*ax.y*cosb + cosa)
	+ z*(ax.y*ax.z*cosb - ax.x*sina);
	float zrot = x*(ax.z*ax.x*cosb - ax.y*sina)
	+ y*(ax.z*ax.y*cosb + ax.x*sina)
	+ z*(ax.z*ax.z*cosb + cosa);
	
	x = xrot + pivot.x;
	y = yrot + pivot.y;
	z = zrot + pivot.z;
	
	return *this;
}




// Map point to coordinate system defined by origin, vx, vy, and vz.
//
//
inline ofVec3f ofVec3f::mapped( const ofVec3f& origin,
							   const ofVec3f& vx,
							   const ofVec3f& vy,
							   const ofVec3f& vz ) const{
	return getMapped(origin, vx, vy, vz);
}

inline ofVec3f ofVec3f::getMapped( const ofVec3f& origin,
								  const ofVec3f& vx,
								  const ofVec3f& vy,
								  const ofVec3f& vz ) const
{
	return ofVec3f( origin.x + x*vx.x + y*vy.x + z*vz.x,
				   origin.y + x*vx.y + y*vy.y + z*vz.y,
				   origin.z + x*vx.z + y*vy.z + z*vz.z );
}

inline ofVec3f& ofVec3f::map( const ofVec3f& origin,
							 const ofVec3f& vx,
							 const ofVec3f& vy,
							 const ofVec3f& vz )
{
	float xmap = origin.x + x*vx.x + y*vy.x + z*vz.x;
	float ymap =  origin.y + x*vx.y + y*vy.y + z*vz.y;
	z = origin.z + x*vx.z + y*vy.z + z*vz.z;
	x = xmap;
	y = ymap;
	return *this;
}


// Distance between two points.
//
//
inline float ofVec3f::distance( const ofVec3f& pnt) const {
	float vx = x-pnt.x;
	float vy = y-pnt.y;
	float vz = z-pnt.z;
	return (float)sqrt(vx*vx + vy*vy + vz*vz);
}

inline float  ofVec3f::distanceSquared( const ofVec3f& pnt ) const{
	return squareDistance(pnt);
}

inline float  ofVec3f::squareDistance( const ofVec3f& pnt ) const {
	float vx = x-pnt.x;
	float vy = y-pnt.y;
	float vz = z-pnt.z;
	return vx*vx + vy*vy + vz*vz;
}



// Linear interpolation.
//
//
/**
 * p==0.0 results in this point, p==0.5 results in the
 * midpoint, and p==1.0 results in pnt being returned.
 */

inline ofVec3f ofVec3f::interpolated( const ofVec3f& pnt, float p ) const {
	return getInterpolated(pnt,p);
}

inline ofVec3f ofVec3f::getInterpolated( const ofVec3f& pnt, float p ) const {
	return ofVec3f( x*(1-p) + pnt.x*p,
				   y*(1-p) + pnt.y*p,
				   z*(1-p) + pnt.z*p );
}

inline ofVec3f& ofVec3f::interpolate( const ofVec3f& pnt, float p ) {
	x = x*(1-p) + pnt.x*p;
	y = y*(1-p) + pnt.y*p;
	z = z*(1-p) + pnt.z*p;
	return *this;
}


inline ofVec3f ofVec3f::middled( const ofVec3f& pnt ) const {
	return getMiddle(pnt);
}

inline ofVec3f ofVec3f::getMiddle( const ofVec3f& pnt ) const {
	return ofVec3f( (x+pnt.x)/2.0f, (y+pnt.y)/2.0f, (z+pnt.z)/2.0f );
}

inline ofVec3f& ofVec3f::middle( const ofVec3f& pnt ) {
	x = (x+pnt.x)/2.0f;
	y = (y+pnt.y)/2.0f;
	z = (z+pnt.z)/2.0f;
	return *this;
}


// Average (centroid) among points.
// Addition is sometimes useful for calculating averages too.
//
//
inline ofVec3f& ofVec3f::average( const ofVec3f* points, int num ) {
	x = 0.f;
	y = 0.f;
	z = 0.f;
	for( int i=0; i<num; i++) {
		x += points[i].x;
		y += points[i].y;
		z += points[i].z;
	}
	x /= num;
	y /= num;
	z /= num;
	return *this;
}



// Normalization
//
//
inline ofVec3f ofVec3f::normalized() const {
	return getNormalized();
}

inline ofVec3f ofVec3f::getNormalized() const {
	float length = (float)sqrt(x*x + y*y + z*z);
	if( length > 0 ) {
		return ofVec3f( x/length, y/length, z/length );
	} else {
		return ofVec3f();
	}
}

inline ofVec3f& ofVec3f::normalize() {
	float length = (float)sqrt(x*x + y*y + z*z);
	if( length > 0 ) {
		x /= length;
		y /= length;
		z /= length;
	}
	return *this;
}



// Limit length.
//
//

inline ofVec3f ofVec3f::limited(float max) const {
	return getLimited(max);
}

inline ofVec3f ofVec3f::getLimited(float max) const {
    ofVec3f limited;
    float lengthSquared = (x*x + y*y + z*z);
    if( lengthSquared > max*max && lengthSquared > 0 ) {
        float ratio = max/(float)sqrt(lengthSquared);
        limited.set( x*ratio, y*ratio, z*ratio);
    } else {
        limited.set(x,y,z);
    }
    return limited;
}

inline ofVec3f& ofVec3f::limit(float max) {
    float lengthSquared = (x*x + y*y + z*z);
    if( lengthSquared > max*max && lengthSquared > 0 ) {
        float ratio = max/(float)sqrt(lengthSquared);
        x *= ratio;
        y *= ratio;
        z *= ratio;
    }
    return *this;
}


// Perpendicular vector.
//
//
inline ofVec3f ofVec3f::crossed( const ofVec3f& vec ) const {
	return getCrossed(vec);
}
inline ofVec3f ofVec3f::getCrossed( const ofVec3f& vec ) const {
	return ofVec3f( y*vec.z - z*vec.y,
				   z*vec.x - x*vec.z,
				   x*vec.y - y*vec.x );
}

inline ofVec3f& ofVec3f::cross( const ofVec3f& vec ) {
	float _x = y*vec.z - z*vec.y;
	float _y = z*vec.x - x*vec.z;
	z = x*vec.y - y*vec.x;
	x = _x;
	y = _y;
	return *this;
}

/**
 * Normalized perpendicular.
 */
inline ofVec3f ofVec3f::perpendiculared( const ofVec3f& vec ) const {
	return getPerpendicular(vec);
}

inline ofVec3f ofVec3f::getPerpendicular( const ofVec3f& vec ) const {
	float crossX = y*vec.z - z*vec.y;
	float crossY = z*vec.x - x*vec.z;
	float crossZ = x*vec.y - y*vec.x;
	
	float length = (float)sqrt(crossX*crossX +
							   crossY*crossY +
							   crossZ*crossZ);
	
	if( length > 0 )
		return ofVec3f( crossX/length, crossY/length, crossZ/length );
	else
		return ofVec3f();
}

inline ofVec3f& ofVec3f::perpendicular( const ofVec3f& vec ) {
	float crossX = y*vec.z - z*vec.y;
	float crossY = z*vec.x - x*vec.z;
	float crossZ = x*vec.y - y*vec.x;
	
	float length = (float)sqrt(crossX*crossX +
							   crossY*crossY +
							   crossZ*crossZ);
	
	if( length > 0 ) {
		x = crossX/length;
		y = crossY/length;
		z = crossZ/length;
	} else {
		x = 0.f;
		y = 0.f;
		z = 0.f;
	}
	
	return *this;
}


// Length
//
//
inline float ofVec3f::length() const {
	return (float)sqrt( x*x + y*y + z*z );
}

inline float ofVec3f::lengthSquared() const {
	return (float)(x*x + y*y + z*z);
}



/**
 * Angle (deg) between two vectors.
 * This is an unsigned relative angle from 0 to 180.
 * http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm
 */
inline float ofVec3f::angle( const ofVec3f& vec ) const {
	ofVec3f n1 = this->getNormalized();
	ofVec3f n2 = vec.getNormalized();
	return (float)(acos( n1.dot(n2) )*RAD_TO_DEG);
}

inline float ofVec3f::angleRad( const ofVec3f& vec ) const {
	ofVec3f n1 = this->getNormalized();
	ofVec3f n2 = vec.getNormalized();
	return (float)acos( n1.dot(n2) );
}



/**
 * Dot Product.
 */
inline float ofVec3f::dot( const ofVec3f& vec ) const {
	return x*vec.x + y*vec.y + z*vec.z;
}





// Non-Member operators
//
//
inline ofVec3f operator+( float f, const ofVec3f& vec ) {
    return ofVec3f( f+vec.x, f+vec.y, f+vec.z );
}

inline ofVec3f operator-( float f, const ofVec3f& vec ) {
    return ofVec3f( f-vec.x, f-vec.y, f-vec.z );
}

inline ofVec3f operator*( float f, const ofVec3f& vec ) {
    return ofVec3f( f*vec.x, f*vec.y, f*vec.z );
}

inline ofVec3f operator/( float f, const ofVec3f& vec ) {
    return ofVec3f( f/vec.x, f/vec.y, f/vec.z);
}




// glm utilities
//
//
namespace glm {
    inline float distancesquared(const vec3 &a, const vec3 &b) {
        const vec3 t = a - b;
        return dot(t, t);
    }
}

/// \endcond

#line 0 "../libs/openFrameworks/math/ofMatrix3x3.h"
/*
 * Credits:
 * Code adopted from Lode Vandevenne http://student.kuleuven.be/~m0216922/CG/
 */

#pragma once

/* #include "ofConstants.h" */
#include <glm/mat3x3.hpp>


/// \brief A 3x3 Matrix
///
/// The layout is like this:
///
///     [ a b c ]
///     [ d e f ]
///     [ g h i ]

class ofMatrix3x3 {
	
	
public:
	
	float a;
	float b;
	float c;
	float d;
	float e;
	float f;
	float g;
	float h;
	float i;
	
	
	
	//---------------------
	/// \name Constructor
	/// \{
	
	ofMatrix3x3( float _a=0.0, float _b=0.0, float _c=0.0,
				float _d=0.0, float _e=0.0, float _f=0.0,
				float _g=0.0, float _h=0.0, float _i=0.0 );


	ofMatrix3x3( const glm::mat3 & mat) {
		*this = reinterpret_cast<const ofMatrix3x3&>(mat);
	}

	operator glm::mat3() const{
		return *reinterpret_cast<const glm::mat3*>(this);
	}
	
	/// \}
	
	//---------------------
	/// \name Matrix access
	/// \{
	
	void set( float _a, float _b, float _c,
			 float _d, float _e, float _f,
			 float _g, float _h, float _i );
	
	
	float& operator[]( const int& index );

	
	/// \}
	
	//---------------------
	/// \name Functions
	/// \{
	
	
	/// \brief Transpose the matrix
	///
	/// This changes the matrix.
	///
	///     [ a b c ]T    [ a d g ]
	///     [ d e f ]  =  [ b e h ]
	///     [ g h i ]     [ c f i ]
	void transpose();
		
	/// \brief Transpose without changing the matrix.
	/// Uses the "swap" method with additions and subtractions to swap the elements that aren't on the main diagonal.
	/// \returns transposed matrix.	
	ofMatrix3x3 transpose(const ofMatrix3x3& A);
	
	/// \brief Find the determinant of the matrix
	/// \sa [Wolfram explanation](http://mathworld.wolfram.com/Determinant.html)
	float determinant() const;
	
	float determinant(const ofMatrix3x3& A);
	
	
	
	
	/// \brief Inverse of a 3x3 matrix
	///
	/// the inverse is the adjoint divided through the determinant
	/// find the matrix of minors (minor = determinant of 2x2 matrix of the 2 rows/colums current element is NOT in)
	/// turn them in cofactors (= change some of the signs)
	/// find the adjoint by transposing the matrix of cofactors
	/// divide this through the determinant to get the inverse
	///
	/// \sa invert();	
	ofMatrix3x3 inverse(const ofMatrix3x3& A);
	
	void invert();
	
	
	/// \brief Multiply a matrix by a matrix entry by entry (i.e. a*a, b*b, c*c...)
	///
	/// This is referred to as an entrywise, Hadamard, or Schur product.
	ofMatrix3x3 entrywiseTimes(const ofMatrix3x3& A);

	/// \}
	
	//---------------------
	/// \name Operators
	/// \{
	

	
	/// \brief Add two matrices
	ofMatrix3x3 operator+(const ofMatrix3x3& B);
	
	/// \brief Add matrix to existing matrix
	void operator+=(const ofMatrix3x3& B);
	
	/// \brief Subtract two matrices
	ofMatrix3x3 operator-(const ofMatrix3x3& B);
	
	/// \brief Subtract matrix from existing matrix
	void operator-=(const ofMatrix3x3& B);
	
	/// \brief Multiply a matrix with a scalar		
	ofMatrix3x3 operator*(float scalar);
	
	/// \brief Multiply a matrix by a matrix this = this*B (in that order)	 
	void operator*=(const ofMatrix3x3& B);
	
	/// \brief Multiply a matrix by a scalar (multiples all entries by scalar)	 
	void operator*=(float scalar);
	
	/// \brief Multiply a 3x3 matrix with a 3x3 matrix	 
	ofMatrix3x3 operator*(const ofMatrix3x3& B);
	
	/// \brief Divide a matrix through a scalar		
	ofMatrix3x3 operator/(float scalar);
	
	void operator/=(const ofMatrix3x3& B);
	
	void operator/=(float scalar);
	
	friend std::ostream& operator<<(std::ostream& os, const ofMatrix3x3& M);
	friend std::istream& operator>>(std::istream& is, ofMatrix3x3& M);
	
	/// \}
};


#line 0 "../libs/openFrameworks/math/ofQuaternion.h"
/*
 *  ofQuaternion.h
 *  
 *  Created by Aaron Meyers on 6/22/09 -- modified by Arturo Castro, Zach Lieberman, Memo Akten
 *  based on code from OSG - 
 *  see OSG license for more details: 
 *  http://www.openscenegraph.org/projects/osg/wiki/Legal
 * 
 */

#pragma once
/* #include "ofConstants.h" */
/* #include "ofVec3f.h" */
/* #include "ofVec4f.h" */
#include <cmath>

#if (_MSC_VER)       
// make microsoft visual studio complain less about double / float conversion.
#pragma warning(disable : 4244)
#endif


class ofMatrix4x4;


class ofQuaternion {
public:
    //    float _v[4];
    /// \cond INTERNAL
    ofVec4f _v;
    /// \endcond
    

    
    //---------------------
    /// \name Constructor
    /// \{

    inline ofQuaternion();
    inline ofQuaternion(float x, float y, float z, float w);
    inline ofQuaternion(const ofVec4f& v);
    inline ofQuaternion(float angle, const ofVec3f& axis);
    
    // rotation order is axis3,axis2,axis1
    inline ofQuaternion(float angle1, const ofVec3f& axis1, float angle2, const ofVec3f& axis2, float angle3, const ofVec3f& axis3);
    
	ofQuaternion(const glm::quat & q);

    operator glm::quat() const;

    /// \}
    
    //---------------------
    /// \name Setters
    /// \{
    
    inline void set(float x, float y, float z, float w);
    inline void set(const ofVec4f& v);
    
    void set(const ofMatrix4x4& matrix);


    /// \}
    
    //---------------------
    /// \name Getters
    /// \{
    

    inline float& operator [](int i);
    inline float operator [](int i) const;
    
    void get(ofMatrix4x4& matrix) const;
    

    inline float& x();
    inline float& y();
    inline float& z();
    inline float& w();
    
    inline float x() const;
    inline float y() const;
    inline float z() const;
    inline float w() const;
    
    inline ofVec4f asVec4() const;
    inline ofVec3f asVec3() const;
    

    /// \}
    
    //---------------------
    /// \name Functions
    /// \{
    
  
    /// \brief return true if the Quat represents a zero rotation, 
    /// and therefore can be ignored in computations.
    inline bool zeroRotation() const;
    
    
    /// \brief Length of the quaternion = sqrt(vec . vec)
    inline float length() const;
    
    /// \brief Length of the quaternion = vec . vec
    inline float length2() const;
    
    /// \brief Conjugate
    inline ofQuaternion conj() const;
    
    /// \brief Multiplicative inverse method
    ///
    ///     q^(-1) = q^*/(q.q^*)
    inline const ofQuaternion inverse() const;
    
    
    
    /// \briefSet a quaternion which will perform a rotation of an
    /// angle around the axis given by the vector(x,y,z).
    ///
    /// Define Spherical Linear interpolation method also
    void makeRotate(float angle, float x, float y, float z);
    void makeRotate(float angle, const ofVec3f& vec);
    void makeRotate(float angle1, const ofVec3f& axis1, float angle2, const ofVec3f& axis2, float angle3, const ofVec3f& axis3);
    
    
    /// \brief Make a rotation Quat which will rotate vec1 to vec2.
    /// Generally take a dot product to get the angle between these
    /// and then use a cross product to get the rotation axis
    /// Watch out for the two special cases when the vectors
    /// are co-incident or opposite in direction.
    void makeRotate(const ofVec3f& vec1, const ofVec3f& vec2);
    
    void makeRotate_original(const ofVec3f& vec1, const ofVec3f& vec2);
    
    /// \brief Return the angle and vector components represented by the quaternion.
    void getRotate(float&angle, float& x, float& y, float& z) const;
    void getRotate(float& angle, ofVec3f& vec) const;
    
    /// \brief Calculate and return the rotation as euler angles
    ofVec3f getEuler() const;
    
    
    /// \brief Spherical Linear Interpolation.
    ///
    /// As t goes from 0 to 1, the Quat object goes from "from" to "to".
    void slerp(float t, const ofQuaternion& from, const ofQuaternion& to);

    inline void normalize();

    /// \}
    
    //---------------------
    /// \name Operators
    /// \{
    

    // Implemented in terms of Vec4s. Some Vec4 operators, e.g.
    // operator* are not appropriate for quaternions (as
    // mathematical objects) so they are implemented differently.
    // Also define methods for conjugate and the multiplicative inverse.

    inline ofQuaternion& operator =(const ofQuaternion& q);
    inline bool operator ==(const ofQuaternion& q) const;
    inline bool operator !=(const ofQuaternion& q) const;
    //    inline bool operator <(const ofQuaternion& q) const;  // why?
    

    inline const ofQuaternion operator *(float rhs) const;                  ///< Multiply by scalar
    inline const ofQuaternion operator*(const ofQuaternion& rhs) const;     ///< Binary multiply
    inline ofVec3f operator*(const ofVec3f& v) const;                       ///< Rotate a vector by this quaternion.
    inline ofQuaternion& operator *=(float rhs);                            ///< Unary multiply by scalar
    inline ofQuaternion& operator*=(const ofQuaternion& rhs);               ///< Unary multiply
    inline ofQuaternion operator /(float rhs) const;                        ///< Divide by scalar
    inline const ofQuaternion operator/(const ofQuaternion& denom) const;   ///< Binary divide
    inline ofQuaternion& operator /=(float rhs);                            ///< Unary divide by scalar
    inline ofQuaternion& operator/=(const ofQuaternion& denom);             ///< Unary divide
    inline const ofQuaternion operator +(const ofQuaternion& rhs) const;    ///< Binary addition
    inline ofQuaternion& operator +=(const ofQuaternion& rhs);              ///< Unary addition
    inline ofQuaternion& operator -=(const ofQuaternion& rhs);              ///< Unary subtraction
    inline const ofQuaternion operator -(const ofQuaternion& rhs) const;    ///< Binary subtraction
    inline const ofQuaternion operator -() const;                           ///< returns the negative of the quaternion. calls operator -() on the Vec4
    
    friend std::ostream& operator<<(std::ostream& os, const ofQuaternion &q);
    friend std::istream& operator>>(std::istream& is, ofQuaternion &q);
    
    /// \}
};

// ----------------------------------------------------------------
// IMPLEMENTATION
// ----------------------------------------------------------------



//----------------------------------------
ofQuaternion::ofQuaternion() {
    _v.set(0, 0, 0, 1);
}


//----------------------------------------
ofQuaternion::ofQuaternion(float x, float y, float z, float w) {
    _v.set(x, y, z, w);
}


//----------------------------------------
ofQuaternion::ofQuaternion(const ofVec4f& v) {
    _v = v;
}


//----------------------------------------
ofQuaternion::ofQuaternion(float angle, const ofVec3f& axis) {
    makeRotate(angle, axis);
}


//----------------------------------------
ofQuaternion::ofQuaternion(float angle1, const ofVec3f& axis1, float angle2, const ofVec3f& axis2, float angle3, const ofVec3f& axis3) {
    makeRotate(angle1, axis1, angle2, axis2, angle3, axis3);
}

//----------------------------------------
ofQuaternion& ofQuaternion::operator =(const ofQuaternion& q) {
    _v = q._v;
    return *this;
}


//----------------------------------------
bool ofQuaternion::operator ==(const ofQuaternion& q) const {
    return _v == q._v;
}


//----------------------------------------
bool ofQuaternion::operator !=(const ofQuaternion& q) const {
    return _v != q._v;
}


//----------------------------------------
//bool ofQuaternion::operator <(const ofQuaternion& q) const {
//    if(_v.x < v._v.x) return true;
//    else if(_v.x > v._v.x) return false;
//    else if(_v.y < v._v.y) return true;
//    else if(_v.y > v._v.y) return false;
//    else if(_v.z < v._v.z) return true;
//    else if(_v.z > v._v.z) return false;
//    else return (_v.w < v._v.w);
//}



//----------------------------------------
ofVec4f ofQuaternion::asVec4() const {
    return _v;
}


//----------------------------------------
ofVec3f ofQuaternion::asVec3() const {
    return ofVec3f(_v);
}


//----------------------------------------
void ofQuaternion::set(float x, float y, float z, float w) {
    _v.set(x, y, z, w);
}


//----------------------------------------
void ofQuaternion::set(const ofVec4f& v) {
    _v = v;
}


//----------------------------------------
float& ofQuaternion::operator [](int i) {
    return _v[i];
}



//----------------------------------------
float ofQuaternion::operator [](int i) const {
    return _v[i];
}


//----------------------------------------
float& ofQuaternion::x() {
    return _v.x;
}


//----------------------------------------
float& ofQuaternion::y() {
    return _v.y;
}


//----------------------------------------
float& ofQuaternion::z() {
    return _v.z;
}


//----------------------------------------
float& ofQuaternion::w() {
    return _v.w;
}


//----------------------------------------
float ofQuaternion::x() const {
    return _v.x;
}


//----------------------------------------
float ofQuaternion::y() const {
    return _v.y;
}


//----------------------------------------
float ofQuaternion::z() const {
    return _v.z;
}


//----------------------------------------
float ofQuaternion::w() const {
    return _v.w;
}


//----------------------------------------
bool ofQuaternion::zeroRotation() const {
    return _v.x == 0.0 && _v.y == 0.0 && _v.z == 0.0 && _v.w == 1.0;
}



//----------------------------------------
const ofQuaternion ofQuaternion::operator *(float rhs) const {
    return ofQuaternion(_v.x*rhs, _v.y*rhs, _v.z*rhs, _v.w*rhs);
}


//----------------------------------------
ofQuaternion& ofQuaternion::operator *=(float rhs) {
    _v.x *= rhs;
    _v.y *= rhs;
    _v.z *= rhs;
    _v.w *= rhs;
    return *this; // enable nesting
}


//----------------------------------------
const ofQuaternion ofQuaternion::operator*(const ofQuaternion& rhs) const {
    return ofQuaternion(rhs._v.w*_v.x + rhs._v.x*_v.w + rhs._v.y*_v.z - rhs._v.z*_v.y,
                        rhs._v.w*_v.y - rhs._v.x*_v.z + rhs._v.y*_v.w + rhs._v.z*_v.x,
                        rhs._v.w*_v.z + rhs._v.x*_v.y - rhs._v.y*_v.x + rhs._v.z*_v.w,
                        rhs._v.w*_v.w - rhs._v.x*_v.x - rhs._v.y*_v.y - rhs._v.z*_v.z);
}


//----------------------------------------
ofQuaternion& ofQuaternion::operator*=(const ofQuaternion& rhs) {
    float x = rhs._v.w * _v.x + rhs._v.x * _v.w + rhs._v.y * _v.z - rhs._v.z * _v.y;
    float y = rhs._v.w * _v.y - rhs._v.x * _v.z + rhs._v.y * _v.w + rhs._v.z * _v.x;
    float z = rhs._v.w * _v.z + rhs._v.x * _v.y - rhs._v.y * _v.x + rhs._v.z * _v.w;
    _v.w = rhs._v.w * _v.w - rhs._v.x * _v.x - rhs._v.y * _v.y - rhs._v.z * _v.z;
    
    _v.z = z;
    _v.y = y;
    _v.x = x;
    
    return (*this); // enable nesting
}


//----------------------------------------
ofQuaternion ofQuaternion::operator /(float rhs) const {
    float div = 1.0f / rhs;
    return ofQuaternion(_v.x*div, _v.y*div, _v.z*div, _v.w*div);
}


//----------------------------------------
ofQuaternion& ofQuaternion::operator /=(float rhs) {
    float div = 1.0f / rhs;
    _v.x *= div;
    _v.y *= div;
    _v.z *= div;
    _v.w *= div;
    return *this;
}


//----------------------------------------
const ofQuaternion ofQuaternion::operator/(const ofQuaternion& denom) const {
    return ((*this) * denom.inverse());
}


//----------------------------------------
ofQuaternion& ofQuaternion::operator/=(const ofQuaternion& denom) {
    (*this) = (*this) * denom.inverse();
    return (*this); // enable nesting
}


//----------------------------------------
const ofQuaternion ofQuaternion::operator +(const ofQuaternion& rhs) const {
    return ofQuaternion(_v.x + rhs._v.x, _v.y + rhs._v.y,
                        _v.z + rhs._v.z, _v.w + rhs._v.w);
}


//----------------------------------------
ofQuaternion& ofQuaternion::operator +=(const ofQuaternion& rhs) {
    _v.x += rhs._v.x;
    _v.y += rhs._v.y;
    _v.z += rhs._v.z;
    _v.w += rhs._v.w;
    return *this; // enable nesting
}


//----------------------------------------
const ofQuaternion ofQuaternion::operator -(const ofQuaternion& rhs) const {
    return ofQuaternion(_v.x - rhs._v.x, _v.y - rhs._v.y,
                        _v.z - rhs._v.z, _v.w - rhs._v.w);
}


//----------------------------------------
ofQuaternion& ofQuaternion::operator -=(const ofQuaternion& rhs) {
    _v.x -= rhs._v.x;
    _v.y -= rhs._v.y;
    _v.z -= rhs._v.z;
    _v.w -= rhs._v.w;
    return *this; // enable nesting
}


//----------------------------------------
const ofQuaternion ofQuaternion::operator -() const {
    return ofQuaternion(-_v.x, -_v.y, -_v.z, -_v.w);
}


//----------------------------------------
float ofQuaternion::length() const {
    return sqrt(_v.x*_v.x + _v.y*_v.y + _v.z*_v.z + _v.w*_v.w);
}


//----------------------------------------
float ofQuaternion::length2() const {
    return _v.x*_v.x + _v.y*_v.y + _v.z*_v.z + _v.w*_v.w;
}


//----------------------------------------
ofQuaternion ofQuaternion::conj() const {
    return ofQuaternion(-_v.x, -_v.y, -_v.z, _v.w);
}


//----------------------------------------
const ofQuaternion ofQuaternion::inverse() const {
    return conj() / length2();
}



//----------------------------------------
ofVec3f ofQuaternion::operator*(const ofVec3f& v) const {
    // nVidia SDK implementation
    ofVec3f uv, uuv;
    ofVec3f qvec(_v.x, _v.y, _v.z);
    uv = qvec.getCrossed(v);    //uv = qvec ^ v;
    uuv = qvec.getCrossed(uv);    //uuv = qvec ^ uv;
    uv *= (2.0f * _v.w);
    uuv *= 2.0f;
    return v + uv + uuv;
}

void ofQuaternion::normalize(){
	float len = _v.w*_v.w + _v.x*_v.x + _v.y*_v.y + _v.z*_v.z;
	float factor = 1.0f / sqrt(len);
	_v.x *= factor;
	_v.y *= factor;
	_v.z *= factor;
	_v.w *= factor;
}


//----------------------------------------
// glm utilities
#include "glm/gtc/quaternion.hpp"

namespace glm {
	template <typename T, precision P>
	GLM_FUNC_QUALIFIER tquat<T, P> operator-(tquat<T, P> const& p, tquat<T, P> const& q)
	{
		return detail::compute_quat_sub<T, P, detail::is_aligned<P>::value>::call(tquat<T, P>(p), tquat<T, P>(q));
	}
}

#line 0 "../libs/openFrameworks/math/ofMatrix4x4.h"
/*
 *  ofMatrix4x4.h
 *  
 *  Created by Aaron Meyers on 6/22/09 -- modified by Arturo Castro, Zach Lieberman, Memo Akten
 *  based on code from OSG - 
 *  see OSG license for more details: 
 *  http://www.openscenegraph.org/projects/osg/wiki/Legal
 * 
 */

#pragma once

/* #include "ofConstants.h" */
/* #include "ofVec4f.h" */
/* #include "ofQuaternion.h" */
#include <cmath>
#include "glm/mat4x4.hpp"
/* #include "ofMathConstants.h" */

class ofVec3f;

/// \brief The ofMatrix4x4 is the big class of the math part of openFrameworks.
/// 
/// You'll sometimes see it used for doing things like setting where the camera
/// in OpenGL (the mathematically calculated one, not the ofCamera one) is 
/// looking or is pointed, or figuring how to position something in 3d space,
/// doing scaling, etc. The great thing about the 4x4 matrix is that it can do 
/// all these things at the same time. A single ofMatrix4x4 can represent a ton 
/// of different information about a stuff that goes on in doing 3d 
/// programming: where an object is, how you want to scale an object, where a 
/// camera is. Let's look at a few really basic examples:
/// 
/// ![MATS](math/mats.png)
/// 
/// Not particularly exciting, but you can see how they'd be useful. Luckily most
/// of the need to transform, rotate, scale, shear, or further bazzlemunge (just
/// kidding, bazzlemunging is not a thing) stuff in oF is handled internally by
/// objects like ofNode or ofCamera.
/// 
/// oF uses row-vector style by default, meaning that when transforming a vector
/// by multiplying with a matrix, you should put the vector on the left side and
/// the matrix (or matrices) to its right. When multiplying by multiple matrices,
/// the order of application of the transforms is left-to-right. This means that
/// the standard order of manipulation operations is 
/// vector * scale * rotate * translate.
/// 
/// Note that in GLSL, this convention is reversed, and column-vector style is
/// used. oF uploads the matrices to the GL context correctly, but you should
/// reverse the order of your vertex manipulations to right-to-left style, e.g.
/// translate * rotate * scale * vector.
/// 
/// On the application side, oF has operators which let you do matrix-vector 
/// multiplication with the vector on the right if that's your preferred style. 
/// To set up a combined transformation matrix for working in this style, you
/// should do matrix transformations with the functions like glTranslate,
/// glRotate, and glScale.
/// 
class ofMatrix4x4 {
public:
//	float _mat[4][4];
	
	/// \brief The values of the matrix, stored in row-major order.
	ofVec4f _mat[4];
	/// \cond INTERNAL
	// Should this be moved to private?
	/// \endcond

	/// \name Constructors
	/// \{

	/// \brief The default constructor provides an identity matrix.
	ofMatrix4x4() {
		makeIdentityMatrix();
	}

	ofMatrix4x4( const glm::mat4 & mat) {
		*this = reinterpret_cast<const ofMatrix4x4&>(mat);
	}

	operator glm::mat4() const{
		return *reinterpret_cast<const glm::mat4*>(this);
	}

	/// \brief Construct with a pointer.
	/// 
	/// You can pass a pointer to floats, and the first 16 contents will be 
	/// extracted into this matrix.
	/// 
	/// \warning the validity of these values is not checked!
	ofMatrix4x4( float const * const ptr ) {
		set(ptr);
	}

	/// \brief Rotation matrices can be constructed from a quaternion.
	ofMatrix4x4( const ofQuaternion& quat ) {
		makeRotationMatrix(quat);
	}

	/// \brief Positional style.
	/// 
	/// All 16 values of the matrix as positional arguments in row-major order.
	ofMatrix4x4(	float a00, float a01, float a02, float a03,
	              float a10, float a11, float a12, float a13,
	              float a20, float a21, float a22, float a23,
	              float a30, float a31, float a32, float a33);

	/// \} end Constructor group

	/// \brief destructor.
	~ofMatrix4x4() {}

	/// \name make* Methods
	/// \{
	/// These methods perform a total matrix makeover. All make* methods delete
	/// the current data and the matrix becomes a new type of transform.
	
	/// \brief Matrix becomes the identity matrix.
	void makeIdentityMatrix();

	/// \name Scale
	/// \{
	/// Matrix becomes a scale transform.
	/// 
	/// Accepts x, y, z scale values as a vector or separately.
	void makeScaleMatrix( const ofVec3f& );
	void makeScaleMatrix( float, float, float );
	/// \}

	/// \name Translation
	/// \{
	/// Matrix becomes a translation transform.
	/// 
	/// Accepts x, y, z translation values as a vector or separately.
	void makeTranslationMatrix( const ofVec3f& );
	void makeTranslationMatrix( float, float, float );
	/// \}

	/// \name Rotation
	/// \{
	/// Matrix becomes a rotation transform.
	/// 
	/// \param from Matrix becomes a rotation from this vector direction.
	/// \param to Matrix becomes a rotation to this vector direction.
	void makeRotationMatrix( const ofVec3f& from, const ofVec3f& to );
	/// \param angle Matrix becomes a rotation by angle (degrees).
	/// \param axis Rotation is performed around this vector.
	void makeRotationMatrix( float angle, const ofVec3f& axis );
	/// \param angle Matrix becomes a rotation by angle (degrees).
	/// \param x X-value of the rotation axis.
	/// \param y Y-value of the rotation axis.
	/// \param z Z-value of the rotation axis.
	void makeRotationMatrix( float angle, float x, float y, float z );
	/// \param quaternion Matrix becomes a rotation that produces the quaternion's orientation.
	void makeRotationMatrix( const ofQuaternion& quaternion );
	/// \brief Matrix becomes a rotation around multiple axes.
	/// 
	/// The final rotation is the result of rotating around each of the three
	/// axes, in order. Angles are given in degrees, and axes can be arbitrary
	/// vectors.
	void makeRotationMatrix( float angle1, const ofVec3f& axis1,
	                 float angle2, const ofVec3f& axis2,
	                 float angle3, const ofVec3f& axis3);
	/// \}


	/// \name Make* methods related to another matrix
	/// \{

	/// \brief Matrix becomes the inverse of the provided matrix.
	bool makeInvertOf( const ofMatrix4x4& rhs);

	/// \brief Matrix becomes an orthonormalized version of the provided matrix.
	/// 
	/// The basis vectors (the 3x3 chunk embedded in the upper left of the matrix)
	/// are normalized. This means the resulting matrix has had scaling effects
	/// removed. The fourth column and the fourth row are transferred over
	/// untouched, so translation will be included as well.
	void makeOrthoNormalOf(const ofMatrix4x4& rhs);

	/// \brief Matrix becomes the result of the multiplication of two other matrices.
	void makeFromMultiplicationOf( const ofMatrix4x4&, const ofMatrix4x4& );

	/// \}

	/// \name View matrix make*
	/// \{
	/// These functions are based on some OpenGL matrix functions used for
	/// perspective settings. See the OpenGL docs of the related function
	/// for further details.

	/// \brief Matrix becomes an orthographic projection matrix.
	/// 
	/// Related to: glOrtho. The orthographic projection has a box-shaped
	/// viewing volume described by the six parameters. Left, right, bottom,
	/// and top specify coordinates in the zNear clipping plane where the
	/// corresponding box sides intersect it.
	void makeOrthoMatrix(double left,   double right,
	               double bottom, double top,
	               double zNear,  double zFar);

	/// \brief Matrix becomes a 2D orthographic projection matrix.
	/// 
	/// Related to: glOrtho2D. The box-shaped viewing volume is 
	/// described by the four parameters and, implicitly, a zNear of -1 
	/// and a zFar of 1.
	void makeOrtho2DMatrix(double left,   double right,
	                        double bottom, double top);

	/// \brief Matrix becomes a perspective projection matrix.
	/// 
	/// Related to: glFrustum. The viewing volume is frustum-shaped and
	/// defined by the six parameters. Left, right, top, and bottom specify 
	/// coordinates in the zNear clipping plane where the frustum edges intersect
	/// it, and the zNear and zFar parameters define the forward distances of 
	/// the view volume. The resulting volume can be vertically and 
	/// horizontally asymmetrical around the center of the near plane.
	void makeFrustumMatrix(double left,   double right,
	                 double bottom, double top,
	                 double zNear,  double zFar);

	/// \brief Matrix becomes a perspective projection matrix.
	/// 
	/// Related to: gluPerspective. The viewing volume is frustum-shaped amd
	/// defined by the four parameters. The fovy and aspect ratio
	/// are used to compute the positions of the left, right, top, and bottom sides
	/// of the viewing volume in the zNear plane. The fovy is the y field-of-view,
	/// the angle made by the top and bottom sides of frustum if they were to
	/// intersect. The aspect ratio is the width of the frustum divided by its
	/// height. Note that the resulting volume is both vertically and 
	/// horizontally symmetrical around the center of the near plane.
	void makePerspectiveMatrix(double fovy,  double aspectRatio,
						 double zNear, double zFar);

	/// \brief Matrix becomes a combination of translation and rotation.
	/// 
	/// Matrix becomes a combination of a translation to the position of 'eye'
	/// and a rotation matrix which orients an object to point towards 'center'
	/// along its z-axis. Use this function if you want an object to look at a 
	/// point from another point in space.
	/// 
	/// \param eye The position of the object.
	/// \param center The point which the object is "looking" at.
	/// \param up The direction which the object considers to be "up".
	void makeLookAtMatrix(const ofVec3f& eye, const ofVec3f& center, const ofVec3f& up);

	/// \brief Matrix becomes a combination of an inverse translation and rotation.
	/// 
	/// Related to: gluLookAt. This creates the inverse of makeLookAtMatrix.
	/// The matrix will be an opposite translation from the 'eye' position,
	/// and it will rotate things in the opposite direction of the eye-to-center
	/// orientation. This is definitely confusing, but the main reason to use
	/// this transform is to set up a view matrix for a camera that's looking 
	/// at a certain point. To achieve the effect of moving the camera somewhere
	/// and rotating it so that it points at something, the rest of the world
	/// is moved in the *opposite* direction and rotated in the *opposite* way 
	/// around the camera. This way, you get the same effect as moving the actual
	/// camera, but all the projection math can still be done with the camera
	/// positioned at the origin (which makes it way simpler).
	void makeLookAtViewMatrix(const ofVec3f& eye, const ofVec3f& center, const ofVec3f& up);

	/// \} end view-related group

	/// \} end make* group

	/// \name Static new* matrix functions
	/// \{
	/// 
	/// These are static utility functions to create new matrices. These
	/// functions generally return the equivalent of declaring a matrix and
	/// calling the corresponding "make..." function on it.

	/// \sa makeIdentityMatrix
	inline static ofMatrix4x4 newIdentityMatrix( void );

	/// \sa makeScaleMatrix
	inline static ofMatrix4x4 newScaleMatrix( const ofVec3f& sv);
	inline static ofMatrix4x4 newScaleMatrix( float sx, float sy, float sz);

	/// \sa makeTranslationMatrix
	inline static ofMatrix4x4 newTranslationMatrix( const ofVec3f& dv);
	inline static ofMatrix4x4 newTranslationMatrix( float x, float y, float z);

	/// \sa makeRotationMatrix
	inline static ofMatrix4x4 newRotationMatrix( const ofVec3f& from, const ofVec3f& to);
	inline static ofMatrix4x4 newRotationMatrix( float angle, float x, float y, float z);
	inline static ofMatrix4x4 newRotationMatrix( float angle, const ofVec3f& axis);
	inline static ofMatrix4x4 newRotationMatrix( float angle1, const ofVec3f& axis1,
	                                   float angle2, const ofVec3f& axis2,
	                                   float angle3, const ofVec3f& axis3);
	inline static ofMatrix4x4 newRotationMatrix( const ofQuaternion& quat);

	/// These functions create new matrices related to glFunctions. See 
	/// the description of the corresponding make* methods for more info.

	/// \sa makeOrthoMatrix
	inline static ofMatrix4x4 newOrthoMatrix(double left,   double right,
	                                 double bottom, double top,
	                                 double zNear,  double zFar);

	/// \sa makeOrtho2DMatrix
	inline static ofMatrix4x4 newOrtho2DMatrix(double left,   double right,
	                                   double bottom, double top);

	/// \sa makeFrustumMatrix
	inline static ofMatrix4x4 newFrustumMatrix(double left,   double right,
	                                   double bottom, double top,
	                                   double zNear,  double zFar);

	/// \sa makePerspectiveMatrix
	inline static ofMatrix4x4 newPerspectiveMatrix(double fovy,  double aspectRatio,
	                                       double zNear, double zFar);

	/// \sa makeLookAtMatrix
	inline static ofMatrix4x4 newLookAtMatrix(const ofVec3f& eye,
	                                  const ofVec3f& center,
	                                  const ofVec3f& up);

	/// \} end Static new* matrix group

	//---------------------
	/// \name Accessors
	/// \{

	/// \brief Write data with `matrix(row,col)=number`
	float& operator()(std::size_t row, std::size_t col) {
		return _mat[row][col];
	}

	/// \brief Read data with `matrix(row, col)`
	float operator()(std::size_t row, std::size_t col) const {
		return _mat[row][col];
	}

	/// \brief returns a copy of row i
	ofVec3f getRowAsVec3f(std::size_t i) const {
		return ofVec3f(_mat[i][0], _mat[i][1], _mat[i][2]);
	}
	
	/// \brief returns a copy of row i
	ofVec4f getRowAsVec4f(std::size_t i) const {
		return _mat[i];
	}
	
	/// \cond INTERNAL
	friend std::ostream& operator<<(std::ostream& os, const ofMatrix4x4& M);
	friend std::istream& operator>>(std::istream& is, ofMatrix4x4& M);
	/// \endcond
	
	/// \brief Access the internal data in `float*` format
	/// useful for opengl matrix transformations
	float * getPtr() {
		return (float*)_mat;
	}
	const float * getPtr() const {
		return (const float *)_mat;
	}
	
	/// \} end accessors group

	//---------------------
	/// \name Checking
	/// \{
	
	/// \brief Checks if the matrix is valid by ensuring its items are numbers.
	bool isValid() const {
		return !isNaN();
	}

	/// \brief Checks if the matrix contains items that are not numbers.
	bool isNaN() const;

	/// \brief Checks if the matrix is the identity matrix.
	bool isIdentity() const;

	/// \}

	//---------------------
	/// \name Setters
	/// \{

	/// \brief Copy a matrix using `=` operator.
	ofMatrix4x4& operator = (const ofMatrix4x4& rhs);

	
	/// \brief Set the data of the matrix.
	/// 
	/// These functions are analogous to the corresponding constructors.
	void set(const ofMatrix4x4& rhs);
	void set(float const * const ptr);
	void set(double const * const ptr);
	void set(float a00, float a01, float a02, float a03,
	         float a10, float a11, float a12, float a13,
	         float a20, float a21, float a22, float a23,
	         float a30, float a31, float a32, float a33);

	/// \}

	//---------------------
	/// \name Getters
	/// \{

	/// \brief Gets the inverse matrix.
	ofMatrix4x4 getInverse() const;

	/// \brief Get the perspective components from a matrix.
	/// 
	/// This only works with pure perspective projection matrices.
	bool getOrtho(double& left,   double& right,
	              double& bottom, double& top,
	              double& zNear,  double& zFar) const;

	/// \brief Gets the perspective components for a frustum projection matrix.
	bool getFrustum(double& left,   double& right,
	                double& bottom, double& top,
	                double& zNear,  double& zFar) const;

	/// \brief Get the frustum settings of a symmetric perspective projection
	/// matrix.
	/// 
	/// Note, if matrix is not a symmetric perspective matrix then the
	/// shear will be lost.
	/// Asymmetric matrices occur when stereo, power walls, caves and
	/// reality center display are used.
	/// In these configuration one should use the getFrustum method instead.
	///
	/// \returns false if matrix is not a perspective matrix,
	/// where parameter values are undefined.
	bool getPerspective(double& fovy,  double& aspectRatio,
	                    double& zNear, double& zFar) const;

	/// \brief Gets the lookAt determiners of the matrix.
	/// 
	/// This function will only work for modelview matrices.
	void getLookAt(ofVec3f& eye, ofVec3f& center, ofVec3f& up,
	               float lookDistance = 1.0f) const;

	/// \brief Decompose the matrix into translation, rotation,
	/// scale and scale orientation.
	void decompose( ofVec3f& translation,
					ofQuaternion& rotation,
					ofVec3f& scale,
					ofQuaternion& so ) const;

	/// Create new matrices as transformation of another.

	/// \brief Makes a new matrix which is the inverse of the given matrix.
	inline static ofMatrix4x4 getInverseOf( const ofMatrix4x4& matrix);
	/// \brief Makes a new matrix which is the transpose of the given matrix.
	inline static ofMatrix4x4 getTransposedOf( const ofMatrix4x4& matrix);
	/// \brief Makes a new matrix which is the given matrix, normalized.
	inline static ofMatrix4x4 getOrthoNormalOf(const ofMatrix4x4& matrix);


	/// \}

	//---------------------
	/// \name Matrix multiplication
	/// \{

	/// Although OpenGL uses post-multiplication (vector-on-the-right) with
	/// column-major matrix memory layout, oF uses pre-multiplication
	/// (vector-on-the-left) with row-major matrix memory layout by default.
	/// 
	/// openGL:
	///
	/// |   |   |   |   |
	/// |:-:|:-:|:-:|:-:|
	/// | 0 | 4 | 8 | 12|
	/// | 1 | 5 | 9 | 13|
	/// | 2 | 6 | 10| 14|
	/// | 3 | 7 | 11| 15|
	/// 
	/// ofMatrix4x4:
	/// 
	/// |   |   |   |   |
	/// |:-:|:-:|:-:|:-:|
	/// | 0 | 1 | 2 | 3 |
	/// | 4 | 5 | 6 | 7 |
	/// | 8 | 9 | 10| 11|
	/// | 12| 13| 14| 15|
	///
	/// However, the two memory layouts are compatible because of a funny trick.
	/// 
	/// When the ofMatrix4x4 is uploaded into OpenGL's memory, OpenGL treats it
	/// like a column-major matrix. The rows of the ofMatrix4x4 are loaded as
	/// columns for the GLSL mat4. The result is that the matrix is transposed.
	/// This seems like a bug, but it's in fact exactly what we want, because to
	/// do the transition from pre-multiplication to post-multiplication style,
	/// we need to perform the very same transpose.
	/// 
	/// By using pre-multiplication, oF treats vectors as 1x4 matrices, since 
	/// that provides a valid 1x4 * 4x4 operation. When moving to
	/// post-multiplication, OpenGL is treating vectors like columns, 
	/// providing a similarly valid 4x4 * 4x1 operation. This means that the
	///  resulting vector in OGL-land is the transpose of the result when
	/// done in oF-land.
	/// 
	/// Recall that in matrix multiplication,
	/// 
	/// (V * M * S)^T = (S^T) * (M^T) * (V^T)
	/// 
	/// What this means is that to convert from pre-multiplication to 
	/// post-multiplication, we need to transpose our matrices (and vectors) 
	/// and reverse the order of multiplication. You're already reversing
	/// the order of multiplication by writing your shaders with the vector
	/// on the right, and the implicit transpose that happens when your matrix
	/// is uploaded to GL memory accomplishes the transposition for free!
	/// 
	/// For more information on this subject, check out
	/// [this post](http://seanmiddleditch.com/matrices-handedness-pre-and-post-multiplication-row-vs-column-major-and-notations/).

	/// \brief Matrix * vector multiplication.
	/// 
	/// This operation implicitly treat vectors as column-matrices.
	inline ofVec3f postMult( const ofVec3f& v ) const;
	inline ofVec4f postMult( const ofVec4f& v ) const;

	/// \brief Post-multiply by another matrix.
	/// 
	/// This matrix becomes `this * other`.
	void postMult( const ofMatrix4x4& );

	/// \brief Vector * matrix multiplication.
	/// 
	/// This operation implicitly treats vectors as row-matrices.
	inline ofVec3f preMult( const ofVec3f& v ) const;
	inline ofVec4f preMult( const ofVec4f& v ) const;

	/// \brief Pre-multiply by another matrix.
	/// 
	/// This matrix becomes `other * this`.
	void preMult( const ofMatrix4x4& );

	/// \brief The *= operation for matrices.
	/// 
	/// This is equivalent to calling postMult(other), but it allows you to do
	/// someMatrix *= someMatrix without breaking const-correctness. Calling
	/// someMatrix.postMult(someMatrix) won't work.
	inline void operator *= ( const ofMatrix4x4& other ) {
		if ( this == &other ) {
			ofMatrix4x4 temp(other);
			postMult( temp );
		} else postMult( other );
	}

	/// \brief creates a new matrix from the product of two matrices.
	inline ofMatrix4x4 operator * ( const ofMatrix4x4 &m ) const {
		ofMatrix4x4 r;
		r.makeFromMultiplicationOf(*this, m);
		return  r;
	}

	/// \brief Matrix * Vector operator.
	/// 
	/// Calls postMult() internally.
	inline ofVec3f operator* (const ofVec3f& v) const {
		return postMult(v);
	}

	inline ofVec4f operator* (const ofVec4f& v) const {
		return postMult(v);
	}

	/// These are specialized postMult methods, usually you want to use these
	/// for transforming with ofVec.

	/// \brief Equivalent to postMult(newTranslationMatrix(v)).
	inline void postMultTranslate( const ofVec3f& v );
	/// \brief Equivalent to postMult(scale(v)).
	inline void postMultScale( const ofVec3f& v );
	/// \brief Equivalent to postMult(newRotationMatrix(q)).
	inline void postMultRotate( const ofQuaternion& q );

	inline void postMultTranslate(float x, float y, float z);
	inline void postMultRotate(float angle, float x, float y, float z);
	inline void postMultScale(float x, float y, float z);

	/// \brief Equivalent to preMult(newScaleMatrix(v)).
	inline void preMultScale( const ofVec3f& v );
	/// \brief Equivalent to preMult(newTranslationMatrix(v)).
	inline void preMultTranslate( const ofVec3f& v );
	/// \brief Equivalent to preMult(newRotationMatrix(q)).
	inline void preMultRotate( const ofQuaternion& q );

	/// \}

	//---------------------
	/// \name Matrix transformation
	/// \{

	/// \name Set methods
	/// \{
	/// 
	/// All of these methods alter the components,
	/// deleting the previous data only in that component.
	void setRotate(const ofQuaternion& q);
	void setTranslation( float tx, float ty, float tz );
	void setTranslation( const ofVec3f& v );
	/// \}

	/// \name PostMult Transformations
	/// \{
	/// 
	/// All of these methods apply the transformations over the current one,
	/// calling postMult under the hood. These work as the opposite of the 
	/// equivalent OpenGL functions.
	/// 
	/// For example, glTranslate + glRotate == rotate + translate.

	/// \brief Rotates by angle (degrees) around the given x, y, z axis.
	void rotate(float angle, float x, float y, float z);
	/// \brief Rotates by angle (radians) around the given x, y, z axis.
	void rotateRad(float angle, float x, float y, float z);
	/// \brief Rotates based on the quarternion.
	void rotate(const ofQuaternion& q);
	/// \brief Translates by tx, ty, tz.
	void translate( float tx, float ty, float tz );
	/// \brief Translates along the vector.
	void translate( const ofVec3f& v );
	/// \brief Scales each axis by the corresponding x, y, z.
	void scale(float x, float y, float z);
	/// \brief Scales each axis by the corresponding x, y, z of the vector.
	void scale( const ofVec3f& v );
	/// \}

	/// \name PreMult Transformations
	/// \{
	/// 
	/// All of these methods apply the transformations over the current one,
	/// calling preMult under the hood. These work the the same the equivalent 
	/// OpenGL functions.

	/// \sa rotate
	void glRotate(float angle, float x, float y, float z);
	/// \sa rotate
	void glRotateRad(float angle, float x, float y, float z);
	/// \sa rotate
	void glRotate(const ofQuaternion& q);
	/// \sa translate
	void glTranslate( float tx, float ty, float tz );
	/// \sa translate
	void glTranslate( const ofVec3f& v );
	/// \sa scale
	void glScale(float x, float y, float z);
	/// \sa scale
	void glScale( const ofVec3f& v );
	/// \}

	/// \name Get Methods
	/// \{
	/// 
	/// These return matrix components. getRotate and getScale can only be 
	/// used if the matrix only has rotation or only has scale, since these
	/// transform values are stored in the same area of the matrix.
	/// For matrices with both use decompose instead.
	ofQuaternion getRotate() const;
	ofVec3f getTranslation() const;
	ofVec3f getScale() const;
	/// \}

	/// \brief Apply a 3x3 transform (no translation) of v * M.
	inline static ofVec3f transform3x3(const ofVec3f& v, const ofMatrix4x4& m);

	/// \brief Apply a 3x3 transform (no translation) of M * v.
	inline static ofVec3f transform3x3(const ofMatrix4x4& m, const ofVec3f& v);

	/// \}
	
};

/// \cond INTERNAL

//--------------------------------------------------
// implementation of inline methods

inline bool ofMatrix4x4::isNaN() const {
	return std::isnan(_mat[0][0]) || std::isnan(_mat[0][1]) || std::isnan(_mat[0][2]) || std::isnan(_mat[0][3]) ||
	       std::isnan(_mat[1][0]) || std::isnan(_mat[1][1]) || std::isnan(_mat[1][2]) || std::isnan(_mat[1][3]) ||
	       std::isnan(_mat[2][0]) || std::isnan(_mat[2][1]) || std::isnan(_mat[2][2]) || std::isnan(_mat[2][3]) ||
		   std::isnan(_mat[3][0]) || std::isnan(_mat[3][1]) || std::isnan(_mat[3][2]) || std::isnan(_mat[3][3]);
}



std::ostream& operator<<(std::ostream& os, const ofMatrix4x4& M);

std::istream& operator>>(std::istream& is, ofMatrix4x4& M);


inline ofMatrix4x4& ofMatrix4x4::operator = (const ofMatrix4x4& rhs) {
	if ( &rhs == this ) return *this;
	set(rhs.getPtr());
	return *this;
}

inline void ofMatrix4x4::set(const ofMatrix4x4& rhs) {
	set(rhs.getPtr());
}

inline void ofMatrix4x4::set(float const * const ptr) {
	float* local_ptr = (float*)_mat;
	for (std::size_t i = 0;i < 16;++i) local_ptr[i] = (float)ptr[i];
}

inline void ofMatrix4x4::set(double const * const ptr) {
	float* local_ptr = (float*)_mat;
	for (std::size_t i = 0;i < 16;++i) local_ptr[i] = (float)ptr[i];
}

inline bool ofMatrix4x4::isIdentity() const {
	return _mat[0][0] == 1.0f && _mat[0][1] == 0.0f && _mat[0][2] == 0.0f &&  _mat[0][3] == 0.0f &&
		   _mat[1][0] == 0.0f && _mat[1][1] == 1.0f && _mat[1][2] == 0.0f &&  _mat[1][3] == 0.0f &&
		   _mat[2][0] == 0.0f && _mat[2][1] == 0.0f && _mat[2][2] == 1.0f &&  _mat[2][3] == 0.0f &&
		   _mat[3][0] == 0.0f && _mat[3][1] == 0.0f && _mat[3][2] == 0.0f &&  _mat[3][3] == 1.0f;
}

inline void ofMatrix4x4::makeOrtho2DMatrix(double left,   double right,
	                        double bottom, double top) {
	makeOrthoMatrix(left, right, bottom, top, -1.0, 1.0);
}

inline ofVec3f ofMatrix4x4::getTranslation() const {
	return ofVec3f(_mat[3][0], _mat[3][1], _mat[3][2]);
}

inline ofVec3f ofMatrix4x4::getScale() const {
	ofVec3f x_vec(_mat[0][0], _mat[1][0], _mat[2][0]);
	ofVec3f y_vec(_mat[0][1], _mat[1][1], _mat[2][1]);
	ofVec3f z_vec(_mat[0][2], _mat[1][2], _mat[2][2]);
	return ofVec3f(x_vec.length(), y_vec.length(), z_vec.length());
}

//static utility methods
inline ofMatrix4x4 ofMatrix4x4::newIdentityMatrix(void) {
	ofMatrix4x4 m;
	m.makeIdentityMatrix();
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newScaleMatrix(float sx, float sy, float sz) {
	ofMatrix4x4 m;
	m.makeScaleMatrix(sx, sy, sz);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newScaleMatrix(const ofVec3f& v ) {
	return newScaleMatrix(v.x, v.y, v.z );
}

inline ofMatrix4x4 ofMatrix4x4::newTranslationMatrix(float tx, float ty, float tz) {
	ofMatrix4x4 m;
	m.makeTranslationMatrix(tx, ty, tz);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newTranslationMatrix(const ofVec3f& v ) {
	return newTranslationMatrix(v.x, v.y, v.z );
}

inline ofMatrix4x4 ofMatrix4x4::newRotationMatrix( const ofQuaternion& q ) {
	return ofMatrix4x4(q);
}
inline ofMatrix4x4 ofMatrix4x4::newRotationMatrix(float angle, float x, float y, float z ) {
	ofMatrix4x4 m;
	m.makeRotationMatrix(angle, x, y, z);
	return m;
}
inline ofMatrix4x4 ofMatrix4x4::newRotationMatrix(float angle, const ofVec3f& axis ) {
	ofMatrix4x4 m;
	m.makeRotationMatrix(angle, axis);
	return m;
}
inline ofMatrix4x4 ofMatrix4x4::newRotationMatrix(	float angle1, const ofVec3f& axis1,
    float angle2, const ofVec3f& axis2,
    float angle3, const ofVec3f& axis3) {
	ofMatrix4x4 m;
	m.makeRotationMatrix(angle1, axis1, angle2, axis2, angle3, axis3);
	return m;
}
inline ofMatrix4x4 ofMatrix4x4::newRotationMatrix(const ofVec3f& from, const ofVec3f& to ) {
	ofMatrix4x4 m;
	m.makeRotationMatrix(from, to);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::getInverseOf( const ofMatrix4x4& matrix) {
	ofMatrix4x4 m;
	m.makeInvertOf(matrix);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::getTransposedOf( const ofMatrix4x4& matrix) {
	ofMatrix4x4 m(matrix._mat[0][0], matrix._mat[1][0], matrix._mat[2][0],
	               matrix._mat[3][0], matrix._mat[0][1], matrix._mat[1][1], matrix._mat[2][1],
	               matrix._mat[3][1], matrix._mat[0][2], matrix._mat[1][2], matrix._mat[2][2],
	               matrix._mat[3][2], matrix._mat[0][3], matrix._mat[1][3], matrix._mat[2][3],
	               matrix._mat[3][3]);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::getOrthoNormalOf(const ofMatrix4x4& matrix) {
	ofMatrix4x4 m;
	m.makeOrthoNormalOf(matrix);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newOrthoMatrix(double left, double right,
                                        double bottom, double top,
                                        double zNear, double zFar) {
	ofMatrix4x4 m;
	m.makeOrthoMatrix(left, right, bottom, top, zNear, zFar);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newOrtho2DMatrix(double left, double right,
    double bottom, double top) {
	ofMatrix4x4 m;
	m.makeOrtho2DMatrix(left, right, bottom, top);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newFrustumMatrix(double left, double right,
    double bottom, double top,
    double zNear, double zFar) {
	ofMatrix4x4 m;
	m.makeFrustumMatrix(left, right, bottom, top, zNear, zFar);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newPerspectiveMatrix(double fovy, double aspectRatio,
    double zNear, double zFar) {
	ofMatrix4x4 m;
	m.makePerspectiveMatrix(fovy, aspectRatio, zNear, zFar);
	return m;
}

inline ofMatrix4x4 ofMatrix4x4::newLookAtMatrix(const ofVec3f& eye, const ofVec3f& center, const ofVec3f& up) {
	ofMatrix4x4 m;
	m.makeLookAtMatrix(eye, center, up);
	return m;
}

inline ofVec3f ofMatrix4x4::postMult( const ofVec3f& v ) const {
	float d = 1.0f / (_mat[3][0] * v.x + _mat[3][1] * v.y + _mat[3][2] * v.z + _mat[3][3]) ;
	return ofVec3f( (_mat[0][0]*v.x + _mat[0][1]*v.y + _mat[0][2]*v.z + _mat[0][3])*d,
	                 (_mat[1][0]*v.x + _mat[1][1]*v.y + _mat[1][2]*v.z + _mat[1][3])*d,
	                 (_mat[2][0]*v.x + _mat[2][1]*v.y + _mat[2][2]*v.z + _mat[2][3])*d) ;
}

inline ofVec3f ofMatrix4x4::preMult( const ofVec3f& v ) const {
	float d = 1.0f / (_mat[0][3] * v.x + _mat[1][3] * v.y + _mat[2][3] * v.z + _mat[3][3]) ;
	return ofVec3f( (_mat[0][0]*v.x + _mat[1][0]*v.y + _mat[2][0]*v.z + _mat[3][0])*d,
	                 (_mat[0][1]*v.x + _mat[1][1]*v.y + _mat[2][1]*v.z + _mat[3][1])*d,
	                 (_mat[0][2]*v.x + _mat[1][2]*v.y + _mat[2][2]*v.z + _mat[3][2])*d);
}

/// \brief post-multiplies the vector by the matrix (i.e. returns M mult v).
/// The vector is implicitly treated as a column-matrix
inline ofVec4f ofMatrix4x4::postMult( const ofVec4f& v ) const {
	return ofVec4f( (_mat[0][0]*v.x + _mat[0][1]*v.y + _mat[0][2]*v.z + _mat[0][3]*v.w),
	                 (_mat[1][0]*v.x + _mat[1][1]*v.y + _mat[1][2]*v.z + _mat[1][3]*v.w),
	                 (_mat[2][0]*v.x + _mat[2][1]*v.y + _mat[2][2]*v.z + _mat[2][3]*v.w),
	                 (_mat[3][0]*v.x + _mat[3][1]*v.y + _mat[3][2]*v.z + _mat[3][3]*v.w)) ;
}

/// \brief pre-multiplies the vector by the matrix (i.e. returns v mult M)
/// The vector is implicitly treated as a row-matrix
inline ofVec4f ofMatrix4x4::preMult( const ofVec4f& v ) const {
	return ofVec4f( (_mat[0][0]*v.x + _mat[1][0]*v.y + _mat[2][0]*v.z + _mat[3][0]*v.w),
	                 (_mat[0][1]*v.x + _mat[1][1]*v.y + _mat[2][1]*v.z + _mat[3][1]*v.w),
	                 (_mat[0][2]*v.x + _mat[1][2]*v.y + _mat[2][2]*v.z + _mat[3][2]*v.w),
	                 (_mat[0][3]*v.x + _mat[1][3]*v.y + _mat[2][3]*v.z + _mat[3][3]*v.w));
}

/// \brief performs a pre-multiplication transformation on the vector using only the
/// upper left 3x3 portion of the matrix (i.e. only the rotation part).
inline ofVec3f ofMatrix4x4::transform3x3(const ofVec3f& v, const ofMatrix4x4& m) {
	return ofVec3f( (m._mat[0][0]*v.x + m._mat[1][0]*v.y + m._mat[2][0]*v.z),
	                 (m._mat[0][1]*v.x + m._mat[1][1]*v.y + m._mat[2][1]*v.z),
	                 (m._mat[0][2]*v.x + m._mat[1][2]*v.y + m._mat[2][2]*v.z));
}

/// \brief performs a post-multiplication transformation on the vector using only the
/// upper left 3x3 portion of the matrix (i.e. only the rotation part).
inline ofVec3f ofMatrix4x4::transform3x3(const ofMatrix4x4& m, const ofVec3f& v) {
	return ofVec3f( (m._mat[0][0]*v.x + m._mat[0][1]*v.y + m._mat[0][2]*v.z),
	                 (m._mat[1][0]*v.x + m._mat[1][1]*v.y + m._mat[1][2]*v.z),
	                 (m._mat[2][0]*v.x + m._mat[2][1]*v.y + m._mat[2][2]*v.z) ) ;
}

/// \brief translates this matrix by treating the ofVec3f like a translation matrix,
/// and multiplying this Matrix by it in a pre-multiplication manner (T mult M)
inline void ofMatrix4x4::preMultTranslate( const ofVec3f& v ) {
	for (unsigned i = 0; i < 3; ++i) {
		float tmp = v.getPtr()[i];
		if (tmp == 0)
			continue;
		_mat[3][0] += tmp * _mat[i][0];
		_mat[3][1] += tmp * _mat[i][1];
		_mat[3][2] += tmp * _mat[i][2];
		_mat[3][3] += tmp * _mat[i][3];
	}
}

/// \brief translates this matrix by treating the ofVec3f like a translation matrix,
/// and multiplying this Matrix by it in a post-multiplication manner (M mult T)
inline void ofMatrix4x4::postMultTranslate( const ofVec3f& v ) {
	for (std::size_t i = 0; i < 3; ++i) {
		float tmp = v.getPtr()[i];
		if (tmp == 0)
			continue;
		_mat[0][i] += tmp * _mat[0][3];
		_mat[1][i] += tmp * _mat[1][3];
		_mat[2][i] += tmp * _mat[2][3];
		_mat[3][i] += tmp * _mat[3][3];
	}
}

// AARON METHOD
/// \brief the positional argument version of the above
inline void ofMatrix4x4::postMultTranslate( float x, float y, float z) {
	if (x != 0) {
		_mat[0][0] += x * _mat[0][3];
		_mat[1][0] += x * _mat[1][3];
		_mat[2][0] += x * _mat[2][3];
		_mat[3][0] += x * _mat[3][3];
	}
	if (y != 0) {
		_mat[0][1] += y * _mat[0][3];
		_mat[1][1] += y * _mat[1][3];
		_mat[2][1] += y * _mat[2][3];
		_mat[3][1] += y * _mat[3][3];
	}
	if (z != 0) {
		_mat[0][2] += z * _mat[0][3];
		_mat[1][2] += z * _mat[1][3];
		_mat[2][2] += z * _mat[2][3];
		_mat[3][2] += z * _mat[3][3];
	}
}

/// \brief treats the ofVec3f like a scaling matrix and edits this Matrix
/// by multiplying the vector with it in a pre-multiplication style (V mult M)
inline void ofMatrix4x4::preMultScale( const ofVec3f& v ) {
	_mat[0][0] *= v.getPtr()[0];
	_mat[0][1] *= v.getPtr()[0];
	_mat[0][2] *= v.getPtr()[0];
	_mat[0][3] *= v.getPtr()[0];
	_mat[1][0] *= v.getPtr()[1];
	_mat[1][1] *= v.getPtr()[1];
	_mat[1][2] *= v.getPtr()[1];
	_mat[1][3] *= v.getPtr()[1];
	_mat[2][0] *= v.getPtr()[2];
	_mat[2][1] *= v.getPtr()[2];
	_mat[2][2] *= v.getPtr()[2];
	_mat[2][3] *= v.getPtr()[2];
}

/// \brief treats the ofVec3f like a scaling matrix and edits this Matrix
/// by multiplying the vector with it in a post-multiplication style (M mult V)
inline void ofMatrix4x4::postMultScale( const ofVec3f& v ) {
	_mat[0][0] *= v.getPtr()[0];
	_mat[1][0] *= v.getPtr()[0];
	_mat[2][0] *= v.getPtr()[0];
	_mat[3][0] *= v.getPtr()[0];
	_mat[0][1] *= v.getPtr()[1];
	_mat[1][1] *= v.getPtr()[1];
	_mat[2][1] *= v.getPtr()[1];
	_mat[3][1] *= v.getPtr()[1];
	_mat[0][2] *= v.getPtr()[2];
	_mat[1][2] *= v.getPtr()[2];
	_mat[2][2] *= v.getPtr()[2];
	_mat[3][2] *= v.getPtr()[2];
}

/// \brief rotates this Matrix by the provided quaternion
inline void ofMatrix4x4::rotate(const ofQuaternion& q){
	postMultRotate(q);
}

/// \brief rotates this Matrix by the provided angle (in degrees) around an axis defined by the three values
inline void ofMatrix4x4::rotate(float angle, float x, float y, float z){
	postMultRotate(angle,x,y,z);
}

/// \brief Rotates this Matrix by the provided angle (in Radians) around an axis defined by the three values
inline void ofMatrix4x4::rotateRad(float angle, float x, float y, float z){
	postMultRotate(angle*static_cast<float>(RAD_TO_DEG),x,y,z);
}

/// \brief Translates this matrix by the provided amount
inline void ofMatrix4x4::translate( float tx, float ty, float tz ){
	postMultTranslate(tx,ty,tz);
}

/// \brief Translates this matrix by the provided vector
inline void ofMatrix4x4::translate( const ofVec3f& v ){
	postMultTranslate(v);
}

/// \brief scales this matrix by the provided scales
inline void ofMatrix4x4::scale(float x, float y, float z){
	postMultScale(x,y,z);
}

/// \brief scales this matrix, treating the ofVec3f as the diagonal of a scaling matrix.
inline void ofMatrix4x4::scale( const ofVec3f& v ){
	postMultScale(v);
}

/// implementation of the gl-style pre-multiplication versions of the above functions
inline void ofMatrix4x4::glRotate(float angle, float x, float y, float z){
	preMultRotate(ofQuaternion(angle,ofVec3f(x,y,z)));
}

inline void ofMatrix4x4::glRotateRad(float angle, float x, float y, float z){
	preMultRotate(ofQuaternion(angle*static_cast<float>(RAD_TO_DEG),ofVec3f(x,y,z)));
}

inline void ofMatrix4x4::glRotate(const ofQuaternion& q){
	preMultRotate(q);
}

inline void ofMatrix4x4::glTranslate( float tx, float ty, float tz ){
	preMultTranslate(ofVec3f(tx,ty,tz));
}

inline void ofMatrix4x4::glTranslate( const ofVec3f& v ){
	preMultTranslate(v);
}

inline void ofMatrix4x4::glScale(float x, float y, float z){
	preMultScale(ofVec3f(x,y,z));
}

inline void ofMatrix4x4::glScale( const ofVec3f& v ){
	preMultScale(v);
}

// AARON METHOD
inline void ofMatrix4x4::postMultScale( float x, float y, float z ) {
	_mat[0][0] *= x;
	_mat[1][0] *= x;
	_mat[2][0] *= x;
	_mat[3][0] *= x;
	_mat[0][1] *= y;
	_mat[1][1] *= y;
	_mat[2][1] *= y;
	_mat[3][1] *= y;
	_mat[0][2] *= z;
	_mat[1][2] *= z;
	_mat[2][2] *= z;
	_mat[3][2] *= z;
}


inline void ofMatrix4x4::preMultRotate( const ofQuaternion& q ) {
	if (q.zeroRotation())
		return;
	ofMatrix4x4 r;
	r.setRotate(q);
	preMult(r);
}

inline void ofMatrix4x4::postMultRotate( const ofQuaternion& q ) {
	if (q.zeroRotation())
		return;
	ofMatrix4x4 r;
	r.setRotate(q);
	postMult(r);
}

// AARON METHOD
inline void ofMatrix4x4::postMultRotate(float angle, float x, float y, float z) {
	ofMatrix4x4 r;
	r.makeRotationMatrix(angle, x, y, z);
	postMult(r);
}

/// \brief provides Vector3 * Matrix multiplication. Vectors are implicitly treated as row-matrices.
inline ofVec3f operator* (const ofVec3f& v, const ofMatrix4x4& m ) {
	return m.preMult(v);
}
/// \brief provides Vector4 * Matrix multiplication. Vectors are implicitly treated as row-matrices.
inline ofVec4f operator* (const ofVec4f& v, const ofMatrix4x4& m ) {
	return m.preMult(v);
}


/// \endcond

#line 0 "../libs/openFrameworks/math/ofVectorMath.h"
#pragma once


/* #include "ofConstants.h" */
//#include "glm/glm.hpp"

//#include "glm/detail/setup.hpp"
//#include "glm/detail/_swizzle.hpp"
//#include "glm/detail/_swizzle_func.hpp"

#include "glm/vec2.hpp"
#include "glm/vec3.hpp"
#include "glm/vec4.hpp"
#include "glm/mat3x3.hpp"
#include "glm/mat4x4.hpp"
#include "glm/geometric.hpp"
#include "glm/common.hpp"
#include "glm/trigonometric.hpp"
#include "glm/exponential.hpp"
#include "glm/vector_relational.hpp"
#include "glm/ext.hpp"

#include "glm/gtc/constants.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/matrix_inverse.hpp"
#include "glm/gtc/quaternion.hpp"
#include "glm/gtc/epsilon.hpp"
#include "glm/gtx/norm.hpp"
#include "glm/gtx/perpendicular.hpp"
#include "glm/gtx/quaternion.hpp"
#include "glm/gtx/rotate_vector.hpp"
#include "glm/gtx/spline.hpp"
#include "glm/gtx/transform.hpp"
#include "glm/gtx/vector_angle.hpp"
#include "glm/gtx/scalar_multiplication.hpp"
#include <glm/gtc/type_ptr.hpp>

#include <iomanip>
/* #include "ofMathConstants.h" */
/* #include "ofVec2f.h" */
/* #include "ofVec3f.h" */
/* #include "ofVec4f.h" */
/* #include "ofMatrix3x3.h" */
/* #include "ofMatrix4x4.h" */
/* #include "ofQuaternion.h" */

//--------------------------------------------------------------
inline const ofVec2f & toOf(const glm::vec2 & v){
	return *reinterpret_cast<const ofVec2f*>(&v);
}

//--------------------------------------------------------------
inline const ofVec3f & toOf(const glm::vec3 & v){
	return *reinterpret_cast<const ofVec3f*>(&v);
}

//--------------------------------------------------------------
inline const ofVec4f & toOf(const glm::vec4 & v){
	return *reinterpret_cast<const ofVec4f*>(&v);
}

//--------------------------------------------------------------
inline const ofMatrix4x4 & toOf(const glm::mat4 & v){
	return *reinterpret_cast<const ofMatrix4x4*>(&v);
}

//--------------------------------------------------------------
inline const ofMatrix3x3 & toOf(const glm::mat3 & v){
	return *reinterpret_cast<const ofMatrix3x3*>(&v);
}

//--------------------------------------------------------------
inline const glm::vec2 & toGlm(const ofVec2f & v){
	return *reinterpret_cast<const glm::vec2*>(&v);
}

//--------------------------------------------------------------
inline const glm::vec3 & toGlm(const ofVec3f & v){
	return *reinterpret_cast<const glm::vec3*>(&v);
}

//--------------------------------------------------------------
inline const glm::vec4 & toGlm(const ofVec4f & v){
	return *reinterpret_cast<const glm::vec4*>(&v);
}

//--------------------------------------------------------------
inline const glm::mat4 & toGlm(const ofMatrix4x4 & v){
	return *reinterpret_cast<const glm::mat4*>(&v);
}

//--------------------------------------------------------------
inline const glm::mat3 & toGlm(const ofMatrix3x3 & v){
	return *reinterpret_cast<const glm::mat3*>(&v);
}

//--------------------------------------------------------------
inline const glm::vec2 & toGlm(const glm::vec2 & v){
	return v;
}

//--------------------------------------------------------------
inline const glm::vec3 & toGlm(const glm::vec3 & v){
	return v;
}

//--------------------------------------------------------------
inline const glm::vec4 & toGlm(const glm::vec4 & v){
	return v;
}

//--------------------------------------------------------------
inline const glm::quat toGlm(const ofQuaternion & q){
	return glm::quat(q.w(), glm::vec3(q.x(), q.y(), q.z()));
}

//--------------------------------------------------------------
inline const glm::quat & toGlm(const glm::quat & q){
	return q;
}

namespace glm {
	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::ostream& operator<<(std::ostream& os, const tvec3<T, P>& vec) {
		os << vec.x << ", " << vec.y << ", " << vec.z;
		return os;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::istream& operator>>(std::istream& is, tvec3<T, P>& vec) {
		is >> vec.x;
		is.ignore(2);
		is >> vec.y;
		is.ignore(2);
		is >> vec.z;
		return is;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::ostream& operator<<(std::ostream& os, const tvec2<T, P>& vec) {
		os << vec.x << ", " << vec.y;
		return os;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::istream& operator>>(std::istream& is, tvec2<T, P>& vec) {
		is >> vec.x;
		is.ignore(2);
		is >> vec.y;
		return is;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::ostream& operator<<(std::ostream& os, const tvec4<T, P>& vec) {
		os << vec.x << ", " << vec.y << ", " << vec.z << ", " << vec.w;
		return os;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::istream& operator>>(std::istream& is, tvec4<T, P>& vec) {
		is >> vec.x;
		is.ignore(2);
		is >> vec.y;
		is.ignore(2);
		is >> vec.z;
		is.ignore(2);
		is >> vec.w;
		return is;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::ostream& operator<<(std::ostream& os, const tmat3x3<T, P>& mat) {
		int w = 8;
		os << std::setw(w)
			<< mat[0][0] << ", " << std::setw(w)
			<< mat[0][1] << ", " << std::setw(w)
			<< mat[0][2] << std::endl;

		os << std::setw(w)
			<< mat[1][0] << ", " << std::setw(w)
			<< mat[1][1] << ", " << std::setw(w)
			<< mat[1][2] << std::endl;

		os << std::setw(w)
			<< mat[2][0] << ", " << std::setw(w)
			<< mat[2][1] << ", " << std::setw(w)
			<< mat[2][2];
		return os;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::istream& operator>>(std::istream& is, tmat3x3<T, P>& mat) {
		is >> mat[0][0]; is.ignore(2);
		is >> mat[0][1]; is.ignore(2);
		is >> mat[0][2]; is.ignore(1);

		is >> mat[1][0]; is.ignore(2);
		is >> mat[1][1]; is.ignore(2);
		is >> mat[1][2]; is.ignore(1);
		
		is >> mat[2][0]; is.ignore(2);
		is >> mat[2][1]; is.ignore(2);
		is >> mat[2][2];
		return is;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::ostream& operator<<(std::ostream& os, const tmat4x4<T, P>& mat) {
		int w = 8;
		os << std::setw(w)
			<< mat[0][0] << ", " << std::setw(w)
			<< mat[0][1] << ", " << std::setw(w)
			<< mat[0][2] << ", " << std::setw(w)
			<< mat[0][3] << std::endl;

		os << std::setw(w)
			<< mat[1][0] << ", " << std::setw(w)
			<< mat[1][1] << ", " << std::setw(w)
			<< mat[1][2] << ", " << std::setw(w)
			<< mat[1][3] << std::endl;

		os << std::setw(w)
			<< mat[2][0] << ", " << std::setw(w)
			<< mat[2][1] << ", " << std::setw(w)
			<< mat[2][2] << ", " << std::setw(w)
			<< mat[2][3] << std::endl;

		os << std::setw(w)
			<< mat[3][0] << ", " << std::setw(w)
			<< mat[3][1] << ", " << std::setw(w)
			<< mat[3][2] << ", " << std::setw(w)
			<< mat[3][3];
		return os;
	}

	//--------------------------------------------------------------
	template <typename T, precision P>
	inline std::istream& operator>>(std::istream& is, tmat4x4<T, P>& mat) {
		is >> mat[0][0]; is.ignore(2);
		is >> mat[0][1]; is.ignore(2);
		is >> mat[0][2]; is.ignore(2);
		is >> mat[0][3]; is.ignore(1);
			  
		is >> mat[1][0]; is.ignore(2);
		is >> mat[1][1]; is.ignore(2);
		is >> mat[1][2]; is.ignore(2);
		is >> mat[1][3]; is.ignore(1);
			  
		is >> mat[2][0]; is.ignore(2);
		is >> mat[2][1]; is.ignore(2);
		is >> mat[2][2]; is.ignore(2);
		is >> mat[2][3]; is.ignore(1);
			  
		is >> mat[3][0]; is.ignore(2);
		is >> mat[3][1]; is.ignore(2);
		is >> mat[3][2]; is.ignore(2);
		is >> mat[3][3];
		return is;
	}

	//----------------------------------------
	template <typename T, precision P>
	inline std::ostream& operator<<(std::ostream& os, const tquat<T, P>& q) {
		os << q.w << ", " << q.x << ", " << q.y << ", " << q.z;
		return os;
	}


	//----------------------------------------
	template <typename T, precision P>
	inline std::istream& operator>> (std::istream& is, tquat<T, P>& q) {
		is >> q.w;
		is.ignore(2);
		is >> q.x;
		is.ignore(2);
		is >> q.y;
		is.ignore(2);
		is >> q.z;
		return is;
	}
}

//--------------------------------------------------------------
inline glm::vec3 operator+(const glm::vec3 & v1, const ofVec3f & v2){
	return v1 + glm::vec3(v2);
}

//--------------------------------------------------------------
inline glm::vec3 operator-(const glm::vec3 & v1, const ofVec3f & v2){
	return v1 - glm::vec3(v2);
}

//--------------------------------------------------------------
inline glm::vec3 operator*(const glm::vec3 & v1, const ofVec3f & v2){
	return v1 * glm::vec3(v2);
}

//--------------------------------------------------------------
inline glm::vec3 operator/(const glm::vec3 & v1, const ofVec3f & v2){
	return v1 / glm::vec3(v2);
}

//--------------------------------------------------------------
inline glm::vec3 & operator+=(glm::vec3 & v1, const ofVec3f & v2){
	v1 += glm::vec3(v2);
	return v1;
}

//--------------------------------------------------------------
inline glm::vec3 & operator-=(glm::vec3 & v1, const ofVec3f & v2){
	v1 -= glm::vec3(v2);
	return v1;
}

//--------------------------------------------------------------
inline glm::vec3 & operator*=(glm::vec3 & v1, const ofVec3f & v2){
	v1 *= glm::vec3(v2);
	return v1;
}

//--------------------------------------------------------------
inline glm::vec3 & operator/=(glm::vec3 & v1, const ofVec3f & v2){
	v1 /= glm::vec3(v2);
	return v1;
}

//--------------------------------------------------------------
inline glm::vec2 operator+(const glm::vec2 & v1, const ofVec2f & v2){
	return v1 + glm::vec2(v2);
}

//--------------------------------------------------------------
inline glm::vec2 operator-(const glm::vec2 & v1, const ofVec2f & v2){
	return v1 - glm::vec2(v2);
}

//--------------------------------------------------------------
inline glm::vec2 operator*(const glm::vec2 & v1, const ofVec2f & v2){
	return v1 * glm::vec2(v2);
}

//--------------------------------------------------------------
inline glm::vec2 operator/(const glm::vec2 & v1, const ofVec2f & v2){
	return v1 / glm::vec2(v2);
}

//--------------------------------------------------------------
inline glm::vec2 & operator+=(glm::vec2 & v1, const ofVec2f & v2){
	v1 += glm::vec2(v2);
	return v1;
}

//--------------------------------------------------------------
inline glm::vec2 & operator-=(glm::vec2 & v1, const ofVec2f & v2){
	v1 -= glm::vec2(v2);
	return v1;
}

//--------------------------------------------------------------
inline glm::vec2 & operator*=(glm::vec2 & v1, const ofVec2f & v2){
	v1 *= glm::vec2(v2);
	return v1;
}

//--------------------------------------------------------------
inline glm::vec2 & operator/=(glm::vec2 & v1, const ofVec2f & v2){
	v1 /= glm::vec2(v2);
	return v1;
}



#line 0 "../libs/openFrameworks/types/ofColor.h"
#pragma once


/* #include "ofConstants.h" */
#include <limits>
#include "glm/common.hpp"

/// \class ofColor_
///
/// \brief ofColor represents a color in openFrameworks. 
/// 
/// The default ofColor uses unsigned char values [0,255], but use 
/// ofFloatColor for floating point values [0.0,1.0], or ofShortColor for 
/// unsigned short ints [0,[65,535]]. ofColor can be represented by an RGB 
/// value, an HSB value or a hex value. 
///
/// \tparam PixelType The data type used to represent a single pixel value.
template<typename PixelType>
class ofColor_{
public:
    /// \name Create an ofColor
    /// \{

    /// \brief Construct a default white color.
    ofColor_():
        r(limit()),
        g(limit()),
        b(limit()),
        a(limit()) {};

    /// \brief Construct an ofColor_ by using channel values.
    ///
    /// \param red The red component.
    /// \param green The green component.
    /// \param blue The blue component.
    /// \param alpha The alpha component.
    ofColor_(float red, float green, float blue, float alpha = limit());

    /// \brief Construct a grayscale ofColor_ by specifying a single number.
    /// 
    /// \param gray A grayscale value.
    /// \param alpha The opacity of the color.
    ofColor_(float gray, float alpha = limit());

    /// \brief Construct an ofColor_ from an existing ofColor_.
    ///
    /// \warning Depending on the PixelType and SrcType used, color precision
    ///          may be lost when converting a higher precision to a lower
    ///          precision representation.
    ///
    /// \param color The ofColor_ to copy.
    template<typename SrcType>
    ofColor_(const ofColor_<SrcType>& color);

    /// \brief Construct an ofColor_ from an existing ofColor_.
    ///
    /// \param color The ofColor_ to copy.
    /// \param alpha The new alpha value to replace the alpha value in color.
    ofColor_(const ofColor_<PixelType>& color, float alpha);

    /// \brief Create an ofColor_ from an HSB representation.
    ///
    /// \param hue The hue of the color.
    /// \param saturation The saturation of the color.
    /// \param brightness The brightness of the color.
    /// \param alpha The alpha value of the color.
    static ofColor_<PixelType> fromHsb(float hue,
                                       float saturation,
                                       float brightness,
                                       float alpha = limit());

    /// \brief Create an ofColor_ from a hexadecimal value.
    ///
    /// \param hexColor A color in hexadecimal form.
    /// \param alpha The alpha value of the color.
    static ofColor_<PixelType> fromHex(int hexColor, float alpha = limit());

    /// \}

    /// \name Data Accessors
    /// \{

    /// \brief A union representing the internal data.
	///
    /// \sa r, g, b and a
    union {
        struct {
            PixelType r; ///< \brief The red color component.
            PixelType g; ///< \brief The green color component.
            PixelType b; ///< \brief The blue color component.
            PixelType a; ///< \brief The alpha color component.
        };
        PixelType v[4]; ///< \brief The pixel values as an array.
    };

    /// \}

    /// \name Setters
    /// \{

    /// \brief Set an ofColor_ by using RGB values.
    ///
    /// \param red The red component.
    /// \param green The green component.
    /// \param blue The blue component.
    /// \param alpha The alpha component.
    void set(float red, float green, float blue, float alpha = limit());

    /// \brief Set a grayscale ofColor_ by specifying a single number.
    ///
    /// \param gray A grayscale value.
    /// \param alpha The opacity of the color.
    void set(float gray, float alpha = limit());

    /// \brief Set an ofColor_ from an existing ofColor_.
    ///
    /// This will use the R, G, B and A components from the passed color.
    ///
    /// \param color The ofColor_ to copy.
    void set(const ofColor_<PixelType>& color);

    /// \brief Set an ofColor_ from a hexadecimal representation.
    ///
    /// \warning The alpha value _should not_ be packed in the hexColor and
    ///     must be specified separately.
    ///
    /// \param hexColor An RGB color in hexadecimal form.
    /// \param alpha The alpha value of the color.
    void setHex(int hexColor, float alpha = limit());

    /// \brief Set the hue of this color.
    ///
    /// \param hue A hue value to set in the range of 0 - limit().
    void setHue(float hue);

    /// \brief Set the hue angle of this color.
	///
    /// \param angle A hue angle value to set in the range of 0 - 360 degrees.
    void setHueAngle(float angle);

    /// \brief Set the saturation of this color.
    ///
    /// This method uses HSB not HSL. So red desaturated is white, not gray
    ///
    /// \param saturation A saturation value value in the range of 0 - limit().
    /// \sa http://en.wikipedia.org/wiki/HSL_and_HSV
    void setSaturation(float saturation);

    /// \brief Set the brightness of this color.
    ///
    /// \param brightness A brightness value to set in the range of 0 - limit().
    void setBrightness(float brightness);

    /// \brief Set the color using HSB components.
	///
    /// \param hue A hue value to set in the range of 0 - limit().
    /// \param saturation A saturation value to set in the range of 0 - limit().
    /// \param brightness A brightness value to set in the range of 0 - limit().
    /// \param alpha An alpha value to set in the range of 0 - limit().
    void setHsb(float hue,
                float saturation,
                float brightness,
                float alpha = limit());

    /// \}

    /// \name Modifiers
    /// \{

    /// \brief Clamp values between 0 and the limit().
    ///
    /// Clamps the value of each component, R, G, B and A to a maximum of
    /// limit() and a minimum of zero.
    ///
    /// \returns A reference to itself.
    ofColor_<PixelType>& clamp();

    /// \brief Invert the R, G and B components.
    ///
    /// Performs an inversion operation on the color by replacing the red, green
    /// and blue components with their original value subtracted from the
    /// limit(). 
    ///
    /// \returns A reference to itself.
    ofColor_<PixelType>& invert();

    /// \brief Normalize the R, G and B components.
    ///
    /// Performs a normalization operation on the red, green and blue components
    /// by scaling them by brightness of the original color divided by the
    /// limit().  The brightness is calculated by finding the maximum of
    /// original red, green and blue components. 
    /// In short: ofColor / (brightness / limit())
    ///
    /// \returns A reference to itself.
    ofColor_<PixelType>& normalize();

    /// \brief A linear interpolation between all components of two colors.
    ///
    /// The linear interpolation is carried out
    /// on _all_ components, R, G, B _and_ A.
    ///
    /// \param target The target color corresponding to an amount of 1.0.
    /// \param amount The amount (between 0.0 and 1.0) to interpolate.
    ///     A value of 0.0 will yield an unchanged color.  A value of 1.0
    ///     will yield the target color.
    /// \returns A reference to itself.
    ofColor_<PixelType>& lerp(const ofColor_<PixelType>& target, float amount);

    /// \}

    /// \name Getters
    /// \{

    /// \brief A non-destructive version of clamp().
	///
    /// \sa clamp()
    /// \returns A copy of this color, clamped.
    ofColor_<PixelType> getClamped() const;

    /// \brief A non-destructive version of invert().
	///
    /// \sa invert()
    /// \returns A copy of this color, inverted.
    ofColor_<PixelType> getInverted() const;

    /// \brief A non-destructive version of normalize().
	///
	/// \sa normalize()
    /// \returns A copy of this color, normalized.
    ofColor_<PixelType> getNormalized() const;


    /// \brief A non-destructive version of lerp().
	///
    /// \param target The target color corresponding to an amount of 1.0.
    /// \param amount The amount (between 0.0 and 1.0) to interpolate.
    ///     A value of 0.0 will yield an unchanged color.  A value of 1.0
    ///     will yield the target color.
    /// \returns A copy of this color, lerped.
    /// \sa lerp()
    ofColor_<PixelType> getLerped(const ofColor_<PixelType>& target,
                                  float amount) const;

    /// \brief Get a 24-bit hexadecimal representation of the RGB color.
    ///
    /// \warning This method does _not_ encode the alpha component.
    ///
    /// \returns An integer representing an RGB color.
    int getHex() const;

    /// \brief Get the Hue of this color.
    ///
    /// The color is converted from the default RGB to an HSB color space and
    /// the resulting Hue value is returned.  The resulting hue value will
    /// always be returned in the range 0 - limit().
    ///
    /// \returns The Hue value in the range 0 - limit().
    float getHue() const;

    /// \brief Get the Hue angle of this color.
    ///
    /// The color is converted from the default RGB to an HSB color space and
    /// the resulting Hue angle is returned.  The resulting hue value will
    /// always be returned in degrees in the range 0 - 360.
    ///
    /// \returns The Hue angle in the range 0 - 360.
    float getHueAngle() const;

    /// \brief Get the Saturation of this color.
    ///
    /// The color is converted from the default RGB to an HSB color space and
    /// the resulting saturation is returned.  The resulting saturation value
    /// will always be returned in the range 0 - limit().
    ///
    /// \returns The saturation in the range 0 - limit().
    float getSaturation() const;

    /// \brief Calculate the brightness of of the R, G and B components.
    ///
    /// Brightness is simply the maximum of the three color components. This
    /// method of calculating brightness is used by Photoshop (HSB) and
    /// Processing (HSB).  Note that brightness is also called "Value".
    ///
    /// \returns the brightness in the range 0 - limit().
    float getBrightness() const;

    /// \brief Calculate the lightness of the R, G and B components.
    ///
    /// Lightness is simply the average of the three color components. This
    /// method of calculating lightness is used by the Lab and HSL color spaces.
    ///
    /// \returns the lightness in the range 0 - limit().
    float getLightness() const;

    /// \brief Extract the hue, saturation and brightness (HSB) from this color.
    ///
    /// \param hue A reference to the hue to fill. Will be in the range of
    ///     0 - limit().
    /// \param saturation A reference to the saturation to fill. Will be in the
	///		range of 0 - limit().
    /// \param brightness A reference to the brightness to fill. Will be in the
    ///     range of 0 - limit().
    void getHsb(float& hue, float& saturation, float& brightness) const;

    /// \brief Get the maximum value of a color component.
    ///
    /// \returns The value associated with a fully saturated color component.
    static float limit();

    /// \}

    /// \name Operators
    /// \{

    /// \brief Assign a color using an existing color.
    ///
    /// R, G, B and A components are set to the the values of the assigned
    /// color.
    ///
    /// \warning Depending on the PixelType and SrcType used, color precision
    ///     may be lost when converting a higher precision to a lower precision
    ///     representation.
    ///
    /// \param color The color to assign.
    /// \returns A reference to itself.
    template<typename SrcType>
    ofColor_<PixelType>& operator = (const ofColor_<SrcType>& color);

    /// \brief Assign a color using a grayscale value.
    ///
    /// \param value The grayscale value.
    /// \returns A reference to itself.
    ofColor_<PixelType>& operator = (float value);

    /// \brief Test two colors for equality.
	///
    /// \returns true iff the R, G, B and A components are all equal.
    bool operator == (const ofColor_<PixelType>& color) const;

    /// \brief Test two colors for inequality.
    /// \returns true iff any of the R, G, B or A components are not equal.
    bool operator != (const ofColor_<PixelType>& color) const;

    /// \brief Clamped addition operator.
    ///
    /// Add two colors by summing and clamping their R, G and B components.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The color to add.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator +  (const ofColor_<PixelType>& color) const;

    /// \brief Clamped addition operator.
    ///
    /// Add a value to each of the R, G and B components and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The value to add.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator +  (float color) const;

    /// \brief Clamped addition operator.
    ///
    /// Add two colors by summing and clamping their R, G and B components.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The color to add.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator += (const ofColor_<PixelType>& color);

    /// \brief Clamped addition operator.
    ///
    /// Add a value to each of the R, G and B components and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The value to add.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator += (float color);

    /// \brief Clamped subtraction operator.
    ///
    /// Subtract two colors by subtracting and clamping their R, G and B
    /// components.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The color to subtract.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator -  (const ofColor_<PixelType>& color) const;

    /// \brief Clamped subtraction operator.
    ///
    /// Subtract a value from each of the R, G and B components and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param value The value to subtract.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator -  (float value) const;

    /// \brief Clamped subtraction operator.
    ///
    /// Add two colors by subtracting and clamping their R, G and B components.
    ///
    /// \param color The color to subtract.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator -= (const ofColor_<PixelType>& color);

    /// \brief Clamped subtraction operator.
    ///
    /// Subtract a value to each of the R, G and B components and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The value to subtract.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator -= (float color);

    /// \brief Clamped multiplication operator.
    ///
    /// Multiply two colors by multiplying and clamping their R, G and B
    /// components.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The color to multiply.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator *  (const ofColor_<PixelType>& color) const;

    /// \brief Clamped scalar multiplication operator.
    ///
    /// Multiply the R, G and B components by a scaler and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param value The value to multiply.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator *  (float value) const;

    /// \brief Clamped multiplication operator.
    ///
    /// Multiply two colors by multiplying and clamping their R, G and B
    /// components.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The color to multiply.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator *= (const ofColor_<PixelType>& color);

    /// \brief Clamped scalar multiplication operator.
    ///
    /// Multiply the R, G and B components by a scaler and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param value The scaler value.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator *= (float value);

    /// \brief Clamped division operator.
    ///
    /// Divide two colors by treating the passed color components as divisors.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param color The divisor color.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator /  (const ofColor_<PixelType>& color) const;

    /// \brief Clamped scalar division operator.
    ///
    /// Divide each of the R, G and B components by a scalar and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param value The divisor value.
    /// \returns The new clamped color.
    ofColor_<PixelType>  operator /  (float value) const;

    /// \brief Clamped division operator.
    ///
    /// Divide two colors by treating the passed color components as divisors.
    ///
    /// \param color The divisor color.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator /= (const ofColor_<PixelType>& color);

    /// \brief Clamped scalar division operator.
    ///
    /// Divide each of the R, G and B components by a scalar and clamp each.
    ///
    /// \warning The alpha component is ignored.
    ///
    /// \param value The divisor value.
    /// \returns A reference to itself, the new clamped color.
    ofColor_<PixelType>& operator /= (float value);

    /// \brief Array subscript operator.
    ///
    /// If n is 0 returns .r, if 1 returns .g, if 2 returns .b, if 3 returns
    /// alpha.
    ///
    /// \param n An index 0-3 of the component to get.
    /// \returns The value of the requested component.
    const PixelType& operator [] (std::size_t n) const;

    /// \brief Array subscript operator.
    ///
    /// If n is 0 returns .r, if 1 returns .g, if 2 returns .b, if 3 returns
    /// alpha.
    ///
    /// \param n An index 0-3 of the component to get.
    /// \returns The value of the requested component.
	PixelType& operator [] (std::size_t n);

    /// \brief An output stream operator.
    ///
    /// Colors can be serialized into comma separated values (CSV) using the
    /// output stream operator.
    ///
    /// \param os An output stream reference.
    /// \param color The color to write to the output stream.
    /// \returns The passed output stream reference, useful for method chaining.
	friend std::ostream& operator << (std::ostream& os, const ofColor_<PixelType>& color) {
		if(sizeof(PixelType) == 1) {
			os << (int) color.r << ", " << (int) color.g << ", " << (int) color.b << ", " << (int) color.a;
		} else {
			os << color.r << ", " << color.g << ", " << color.b << ", " << color.a;
		}
		return os;
	}

    /// \brief An input stream operator.
    ///
    /// Colors can be deserialized from comma separated values (CSV) input
    /// stream using the input stream operator.
    ///
    /// \param is An input stream reference.
    /// \param color The color to fill with the input stream.
    /// \returns The passed input stream reference, useful for method chaining.
	friend std::istream& operator >> (std::istream& is, ofColor_<PixelType>& color) {
		if(sizeof(PixelType) == 1) {
			int component;
			is >> std::skipws >> component;
			color.r = component;
			is.ignore(1);
			is >> std::skipws >> component;
			color.g = component;
			is.ignore(1);
			is >> std::skipws >> component;
			color.b = component;
			is.ignore(1);
			is >> std::skipws >> component;
			color.a = component;
		}else{
			is >> std::skipws >> color.r;
			is.ignore(1);
			is >> std::skipws >> color.g;
			is.ignore(1);
			is >> std::skipws >> color.b;
			is.ignore(1);
			is >> std::skipws >> color.a;
		}
		return is;
	}


    /// \}

    /// \name Predefined Colors
	///
	/// \brief A collection of static colors defined by name.
    ///
    /// These constants allow the user to access colors by name.  For example,
    /// if using ofColor, one might set a color in the following way:
    ///
    /// ~~~~{.cpp}
    ///     ofColor myColor = ofColor::white;
    ///     // myColor is now full white (255,255,255,255).
    /// ~~~~
    ///
    /// The list of colors is based upon the CSS names colors and can be viewed
    /// [here](http://www.w3schools.com/cssref/css_colornames.asp).
    ///
    /// \{

    static const ofColor_<PixelType> white, gray, black, red, green, blue, cyan, magenta,
    yellow,aliceBlue,antiqueWhite,aqua,aquamarine,azure,beige,bisque,blanchedAlmond,
    blueViolet,brown,burlyWood,cadetBlue,chartreuse,chocolate,coral,cornflowerBlue,cornsilk,
    crimson,darkBlue,darkCyan,darkGoldenRod,darkGray,darkGrey,darkGreen,darkKhaki,
    darkMagenta,darkOliveGreen,darkorange,darkOrchid,darkRed,darkSalmon,darkSeaGreen,
    darkSlateBlue,darkSlateGray,darkSlateGrey,darkTurquoise,darkViolet,deepPink,
    deepSkyBlue,dimGray,dimGrey,dodgerBlue,fireBrick,floralWhite,forestGreen,fuchsia,
    gainsboro,ghostWhite,gold,goldenRod,grey,greenYellow,honeyDew,hotPink,indianRed,indigo,
    ivory,khaki,lavender,lavenderBlush,lawnGreen,lemonChiffon,lightBlue,lightCoral,
    lightCyan,lightGoldenRodYellow,lightGray,lightGrey,lightGreen,lightPink,lightSalmon,
    lightSeaGreen,lightSkyBlue,lightSlateGray,lightSlateGrey,lightSteelBlue,lightYellow,
    lime,limeGreen,linen,maroon,mediumAquaMarine,mediumBlue,mediumOrchid,mediumPurple,
    mediumSeaGreen,mediumSlateBlue,mediumSpringGreen,mediumTurquoise,mediumVioletRed,
    midnightBlue,mintCream,mistyRose,moccasin,navajoWhite,navy,oldLace,olive,oliveDrab,
    orange,orangeRed,orchid,paleGoldenRod,paleGreen,paleTurquoise,paleVioletRed,papayaWhip,
    peachPuff,peru,pink,plum,powderBlue,purple,rosyBrown,royalBlue,saddleBrown,salmon,
    sandyBrown,seaGreen,seaShell,sienna,silver,skyBlue,slateBlue,slateGray,slateGrey,snow,
    springGreen,steelBlue,blueSteel,tan,teal,thistle,tomato,turquoise,violet,wheat,whiteSmoke,
    yellowGreen;


    /// \}


private:
    template<typename SrcType>
    void copyFrom(const ofColor_<SrcType>& mom);

};

/// \name Variants
/// \{

/// \typedef ofColor
/// \brief A typedef representing an 8-bit (`unsigned char`) RGBA color.
typedef ofColor_<unsigned char> ofColor;

/// \typedef ofShortColor
/// \brief A typedef representing a 16-bit (`unsigned short`) RGBA color.
typedef ofColor_<unsigned short> ofShortColor;

/// \typedef ofFloatColor
/// \brief A typedef representing a floating (`float`) point RGBA color.
typedef ofColor_<float> ofFloatColor;

/// \}


template<typename PixelType>
template<typename SrcType>
ofColor_<PixelType>::ofColor_(const ofColor_<SrcType> & mom){
	copyFrom(mom);
}

template<typename PixelType>
template<typename SrcType>
ofColor_<PixelType> & ofColor_<PixelType>::operator=(const ofColor_<SrcType> & mom){
	copyFrom(mom);
	return *this;
}

template<typename PixelType>
template<typename SrcType>
void ofColor_<PixelType>::copyFrom(const ofColor_<SrcType> & mom){
	const float srcMax = mom.limit();
	const float dstMax = limit();
	const float factor = dstMax / srcMax;

	if(sizeof(SrcType) == sizeof(float)) {
		// coming from float we need a special case to clamp the values
		for(int i = 0; i < 4; i++){
			v[i] = glm::clamp(float(mom[i]), 0.f, 1.f) * factor;
		}
	} else{
		// everything else is a straight scaling
		for(int i = 0; i < 4; i++){
			v[i] = mom[i] * factor;
		}
	}
}

template <typename PixelType>
ofColor_<PixelType> operator*(float val, const ofColor_<PixelType> &color) {
	return color * val;
}

template<typename PixelType>
inline float ofColor_<PixelType>::limit() {
	return std::numeric_limits<PixelType>::max();
}

template<>
inline float ofColor_<float>::limit() {
	return 1.f;
}

template<>
inline int ofColor_<unsigned char>::getHex() const {
	return
		((0xff & (unsigned char) r) << 16) |
		((0xff & (unsigned char) g) << 8) |
		((0xff & (unsigned char) b));
}

template<typename PixelType>
inline int ofColor_<PixelType>::getHex() const {
	return ((ofColor) *this).getHex();
}

template<>
inline void ofColor_<unsigned char>::setHex(int hexColor, float alpha){
	r = (hexColor >> 16) & 0xff;
	g = (hexColor >> 8) & 0xff;
	b = (hexColor >> 0) & 0xff;
	a = alpha;
}

template<typename PixelType>
inline void ofColor_<PixelType>::setHex (int hexColor, float alpha){
	ofColor c = ofColor::fromHex(hexColor);
	*this = c;
	a = alpha;
}


extern template class ofColor_<char>;
extern template class ofColor_<unsigned char>;
extern template class ofColor_<short>;
extern template class ofColor_<unsigned short>;
extern template class ofColor_<int>;
extern template class ofColor_<unsigned int>;
extern template class ofColor_<long>;
extern template class ofColor_<unsigned long>;
extern template class ofColor_<float>;
extern template class ofColor_<double>;

#line 0 "../libs/openFrameworks/types/ofTypes.h"
#pragma once

/* #include "ofConstants.h" */


//----------------------------------------------------------
// ofMutex
//----------------------------------------------------------

#include <mutex>
/// \brief A typedef for a cross-platform mutex.
/// \deprecated Please use std::mutex instead of ofMutex. See also the note below.
///
/// A mutex is used to lock data when it is accessible from multiple threads.
/// Locking data with a mutex prevents data-races, deadlocks and other problems
/// associated with concurrent access to data.
///
/// The mutex can be locked with a call to ofMutex::lock(). All calls to
/// ofMutex::lock() must be paired with a call to ofMutex::unlock().
///
/// ~~~~{.cpp}
///
///     ofMutex myMutex; // Your member mutex.
///     int mySharedData; // Your member shared data.
///
///     // ...
///
///     // A method to modify some shared data.
///     void modifyMySharedData() {
///         myMutex.lock(); // Lock the mutex.
///         mySharedData++; // Modify the shared data.
///         myMutex.unlock(); // Unlock the mutex;
///     }
///
/// ~~~~
///
/// \note Currently ofMutex is a typedef for std::mutex. This is done
/// to preserve backwards compatibility. Please use std::mutex for new
/// code.
///
/// \sa http://www.cplusplus.com/reference/mutex/mutex/
/// \sa ofScopedLock
typedef std::mutex ofMutex;

/// \brief A typedef for a cross-platform scoped mutex.
/// \deprecated Please use std::unique_lock<std::mutex> instead of ofScopedLock. See also the note below.
///
/// Normally ofMutex requres explicit calls to ofMutex::lock() and
/// ofMutex::unlock() to lock and release the mutex. Sometimes, despite best
/// efforts, developers forget to unlock a mutex, leaving the data inaccessible.
/// ofScopedLock makes ofMutex easier to use by calling ofMutex::unlock when
/// the scoped lock's destructor is called. Since the destructor is called when
/// a variable goes out of scope, we call this a "scoped lock". A "scoped lock"
/// is sometimes known as a "lock guard" as well.
///
/// ofScopedLock is used to lock and unlock an existing ofMutex.
///
/// ~~~~{.cpp}
///
///     ofMutex myMutex; // Your member mutex.
///     int mySharedData; // Your member shared data.
///
///     // ...
///
///     // A method to modify some shared data.
///     void modifyMySharedData() {
///         ofScopedLock lock(myMutex); // Lock the mutex.
///         mySharedData++; // Modify the shared data.
///
///         // `lock` will unlock the mutex when it goes out of scope.
///     }
///
/// ~~~~
///
/// \warning Currently ofScopedLock is a typedef for std::unique_lock<std::mutex>.
/// This is done to preserve backwards compatibility. Please use
/// std::unique_lock<std::mutex> for new code.
///
/// \sa http://en.cppreference.com/w/cpp/thread/unique_lock
/// \sa ofMutex
typedef std::unique_lock<std::mutex> ofScopedLock;



//----------------------------------------------------------
// ofPtr
//----------------------------------------------------------
template <typename T>
using ofPtr = std::shared_ptr<T>;

#line 0 "../libs/openFrameworks/types/ofRectangle.h"
    #pragma once


/* #include "ofConstants.h" */
#include <glm/vec3.hpp>



/// \brief Used to represent the available rectangle aspect ratio scaling modes.
///
/// \sa ofRectangle
enum ofAspectRatioMode {
	/// \brief Set the rectangle's width and height to match the target.
	OF_ASPECT_RATIO_IGNORE            = 0,
	/// \brief Resizes the rectangle to completely fit within the target.
	OF_ASPECT_RATIO_KEEP              = 1,
	/// \brief Resizes the rectangle to completely enclose the target.
	OF_ASPECT_RATIO_KEEP_BY_EXPANDING = 2,
};

/// \brief Used to represent the available vertical rectangle alignment modes.
///
/// \sa ofRectangle
enum ofAlignVert {
	/// \brief Do not perform any vertical alignment.
	OF_ALIGN_VERT_IGNORE   = 0x0000,
	/// \brief Use the upper edge of the rectangle to vertically anchor the alignment.
	OF_ALIGN_VERT_TOP      = 0x0010,
	/// \brief Use the bottom edge of the rectangle to vertically anchor the alignment.
	OF_ALIGN_VERT_BOTTOM   = 0x0020,
	/// \brief Use the center of the rectangle to vertically anchor the alignment.
	OF_ALIGN_VERT_CENTER   = 0x0040,
};


/// \brief Used to represent the available horizontal rectangle alignment modes.
///
/// \sa ofRectangle
enum ofAlignHorz {
	/// \brief Do not perform any horizontal alignment.
	OF_ALIGN_HORZ_IGNORE   = 0x0000,
	/// \brief Use the left edge of the rectangle to horizontally anchor the alignment.
	OF_ALIGN_HORZ_LEFT     = 0x0001,
	/// \brief Use the right edge of the rectangle to horizontally anchor the alignment.
	OF_ALIGN_HORZ_RIGHT    = 0x0002,
	/// \brief Use the center of the rectangle to horizontally anchor the alignment.
	OF_ALIGN_HORZ_CENTER   = 0x0004,
};

/// \brief Used to represent the available rectangle scaling modes.
///
/// ofScaleMode can usually be interpreted as a concise combination of
/// an ::ofAspectRatioMode, an ::ofAlignVert and an ::ofAlignHorz.
enum ofScaleMode{

	/// \brief Center and scale the rectangle to fit inside the target.
	///
	/// This centers the subject rectangle within the target rectangle and
	/// resizes the subject rectangle to completely fit within the target
	/// rectangle.
	OF_SCALEMODE_FIT     = 0,

	/// \brief Move and scale the rectangle to completely enclose the target.
	///
	/// This centers the subject rectangle within the target rectangle and
	/// resizes the subject rectangle to completely encompass the target
	/// rectangle.
	OF_SCALEMODE_FILL    = 1,

	/// \brief Move the rectangle to be centered on the target.
	///
	/// This centers the subject rectangle within the target rectangle and
	/// does not modify the Subject's size or aspect ratio.
	OF_SCALEMODE_CENTER  = 2, // centers the subject

	/// \brief Match the target rectangle's position and dimensions.
	OF_SCALEMODE_STRETCH_TO_FILL = 3
};


/// \brief A class representing a 2D rectangle.
///
/// ofRectangle is a simple container for describing the position and size of a
/// 2D rectangle. The ofRectangle::standardize() method can be used to ensure
/// that the origin is in the "standard" form.
///
/// \warning While ofRectangle takes glm::vec3
/// all ofRectangle operations are 2D only, ignoring the z-component.
class ofRectangle{
public:

    /// \name Constructor
    /// \{

    /// \brief Construct a rectangle with zero width and zero height at 0, 0.
    ofRectangle();

    /// \brief Construct a rectangle using position and size.
    ///
    /// To produce consistent results, users are encouraged to initialize
    /// rectangles in the standardized form with width >=0 and height >= 0.
    ///
    /// \param px The x-position of the rectangle.
    /// \param py The y-position of the rectangle.
    /// \param w The width of the rectangle.
    /// \param h The height of the rectangle.
    ofRectangle(float px, float py, float w, float h);

    /// \brief Construct a rectangle from a point and dimensions.
    ///
    /// To produce consistent results, users are encouraged to initialize
    /// rectangles in the standardized form with width >=0 and height >= 0.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
	/// \param p The glm::vec3 representing the position of the rectangle.
    /// \param w The width of the rectangle.
    /// \param h The height of the rectangle.
	ofRectangle(const glm::vec3& p, float w, float h);
	ofRectangle(const glm::vec2& p, float w, float h);

    /// \brief Construct a rectangle by copying another rectangle.
    /// \param rect The rectangle to copy.
    ofRectangle(const ofRectangle& rect);

    /// \brief Construct a rectangle by defining two corners.
    ///
	/// \warning The z-components of the passed glm::vec3s are ignored.
    ///
	/// \param p0 An glm::vec3 representing the upper left hand corner.
	/// \param p1 An glm::vec3 representing the lower right hand corner.
	ofRectangle(const glm::vec3& p0, const glm::vec3& p1);
	ofRectangle(const glm::vec2& p0, const glm::vec2& p1);

    /// \brief Destroy the rectangle.
    virtual ~ofRectangle();

    /// \}

    /// \name Setters
    /// \{

    /// \brief Set the position and size of the rectangle.
    ///
    /// To produce consistent results, users are encouraged to initialize
    /// rectangles in the standardized form with width >=0 and height >= 0.
    ///
    /// \param px The new x-position.
    /// \param py The new y-position.
    /// \param w The new width.
    /// \param h The new height.
    void set(float px, float py, float w, float h);

    /// \brief Set the position and size of the rectangle.
    ///
    /// To produce consistent results, users are encouraged to initialize
    /// rectangles in the standardized form with width >=0 and height >= 0.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
    /// \param p The new position.
    /// \param w The new width.
    /// \param h The new height.
	void set(const glm::vec3& p, float w, float h);
	void set(const glm::vec2& p, float w, float h);

    /// \brief Set the position and size by copying them from anohter rectangle.
    /// \param rect The rectangle to copy.
    void set(const ofRectangle& rect);

    /// \brief Set the position and size of the rectangle using corners.
    ///
	/// \warning The z-components of the passed glm::vec3s are ignored.
    ///
	/// \param p0 The glm::vec3 representing the upper left hand corner.
	/// \param p1 The glm::vec3 representing the lower right hand corner.
	void set(const glm::vec3& p0, const glm::vec3& p1);
	void set(const glm::vec2& p0, const glm::vec2& p1);

    /// \brief Set the x-position of the rectangle.
    /// \param px The new x-position.
    void setX(float px);

    /// \brief Set the y-position of the rectangle.
    /// \param py The new y-position.
    void setY(float py);

    /// \brief Set the width of the rectangle.
    /// \param w The new width.
    void setWidth(float w);

    /// \brief Set the height of the rectangle.
    /// \param h The new height.
    void setHeight(float h);

    /// \brief Set the position of the rectangle.
    /// \param px The new x-position.
    /// \param py The new y-position.
    void setPosition(float px, float py);

    /// \brief Set the position of the rectangle.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
	/// \param p The position as an glm::vec3.
	void setPosition(const glm::vec3& p);

	/// \brief Set the size of the rectangle.
	/// \param w The new width.
	/// \param h The new height.
	void setSize(float w, float h);

    /// \brief Set position and size of the rectangle from the center.
    ///
    /// The center of the rectangle is defined and the width and height grow
    /// out around the center.
    ///
    /// \param px The x-position of the rectangle's center.
    /// \param py The y-position of the rectangle's center.
    /// \param w The width of the rectangle.
    /// \param h The height of the rectangle.
    void setFromCenter(float px, float py, float w, float h);

    /// \brief Set position and size of the rectangle from the center.
    ///
    /// The center of the rectangle is defined and the width and height grow
    /// out around the center.
    ///
	/// \param p The position of the rectangle's center as an glm::vec3.
    /// \param w The width of the rectangle.
    /// \param h The height of the rectangle.
	void setFromCenter(const glm::vec3& p, float w, float h);
	void setFromCenter(const glm::vec2& p, float w, float h);

    /// \}

    /// \name Transformation
    /// \{

    /// \brief Translate the rectangle's position by an x and y amount.
    /// \param dx The amount to translate in the x direction.
    /// \param dy The amount to translate in the y direction.
    void translate(float dx, float dy);

    /// \brief Translate the rectangle's position by an x and y amount.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
	/// \param dp The amount to translate as an glm::vec3.
	void translate(const glm::vec3& dp);
	void translate(const glm::vec2& dp);

    /// \brief Translate the x-position of the rectangle.
    /// \param dx The amount to translate on the x-axis.
    void translateX(float dx);

    /// \brief Translate the y-position of the rectangle.
    /// \param dy The amount to translate on the y-axis.
    void translateY(float dy);

    /// \brief Scale the rectangle.
    ///
    /// Scaling will scale the width and the height, but will not change the
    /// position.
    ///
    /// \param s The scaling factor.
    void scale(float s);

    /// \brief Scale the rectangle.
    ///
    /// Scaling will scale the width and the height, but will not change the
    /// position.
    ///
    /// \param sX The width-scaling factor.
    /// \param sY The height-scaling factor.
    void scale(float sX, float sY);

    /// \brief Scale the rectangle.
    ///
    /// Scaling will scale the width and the height, but will not change the
    /// position.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
    /// \param s The scaling factor.
	void scale(const glm::vec3& s);
	void scale(const glm::vec2& s);

    /// \brief Scale the width of the rectangle.
    ///
    /// This will scale the width but will not change the position or height.
    ///
    /// \param sX The width-scaling factor.
    void scaleWidth(float sX);

    /// \brief Scale the height of the rectangle.
    ///
    /// This will scale the height but will not change the position and width.
    ///
    /// \param sY The height-scaling factor.
    void scaleHeight(float sY);

    /// \brief Scales both the width and height the ofRectangle from its center.
    ///
    /// The center point of the rectangle will remain fixed and the width,
    /// height, x, and y will be adjusted.
    ///
    /// \param s The scaling factor.
    void scaleFromCenter(float s);

    /// \brief Scales both the width and height the ofRectangle from its center.
    ///
    /// The center point of the rectangle will remain fixed and the width,
    /// height, x, and y will be adjusted.
    ///
    /// \param sX the width-scaling factor.
    /// \param sY the height-scaling factor.
    void scaleFromCenter(float sX, float sY);

    /// \brief Scales both the width and height the ofRectangle from its center.
    ///
    /// The center point of the rectangle will remain fixed and the width,
    /// height, x, and y will be adjusted.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
    /// \param s The scaling factor.
	void scaleFromCenter(const glm::vec3& s);
	void scaleFromCenter(const glm::vec2& s);

    /// \brief Scale the rectanle using a target ofRectangle and ofScaleMode.
    ///
    /// Adjusts the ofRectangle to match the provided ofRectangle using the
    /// provided ofScaleMode.
    ///
    /// \param targetRect The Target Rectangle to scale to.
    /// \param scaleMode The scale mode to use when scaling.
    void scaleTo(const ofRectangle& targetRect,
                 ofScaleMode scaleMode = OF_SCALEMODE_FIT);


    /// \brief Scale the rectangle using a target ofRectangle and parameters.
    ///
    /// Scales the ofRectangle to match the target ofRectangle. It will use the
    /// ofAspectRatioMode to scale the ofRectangle and will use the
    /// alignment anchor parameters to position the rectangle.
    ///
    /// \param targetRect The Target Rectangle to scale to.
    /// \param subjectAspectRatioMode Aspect ratio scaling mode.
    /// \param sharedHorzAnchor The horizontal alignment method.
    /// \param sharedVertAnchor The vertical alignment method.
    void scaleTo(const ofRectangle& targetRect,
                 ofAspectRatioMode subjectAspectRatioMode,
                 ofAlignHorz sharedHorzAnchor = OF_ALIGN_HORZ_CENTER,
                 ofAlignVert sharedVertAnchor = OF_ALIGN_VERT_CENTER);

    /// \brief Scale the rectangle using a target ofRectangle and parameters.
    ///
    /// Adjusts the ofRectangle to match the passed-in ofRectangle. It will
    /// use the ofAspectRatioMode to scale the ofRectangle, and will use the
    /// use the alignment anchor parameters to position the rectangle.
    ///
    /// \param targetRect The Target Rectangle to scale to.
    /// \param subjectAspectRatioMode Aspect ratio scaling mode.
    /// \param modelHorzAnchor The target horizontal alignment method.
    /// \param modelVertAnchor The target vertical alignment method.
    /// \param subjectHorzAnchor The subject horizontal alignment method.
    /// \param subjectVertAnchor The subject vertical alignment method.
    void scaleTo(const ofRectangle& targetRect,
                 ofAspectRatioMode subjectAspectRatioMode,
                 ofAlignHorz modelHorzAnchor,
                 ofAlignVert modelVertAnchor,
                 ofAlignHorz subjectHorzAnchor,
                 ofAlignVert subjectVertAnchor);

    /// \}

    /// \name Alignment
    /// \{


    /// \brief Horizontally align a rectangle using a position and anchor edge.
    ///
    /// Aligns the horizontal position of the ofRectangle to the given x-
    /// position using an ofAlignHorz constant as anchor. If a constant is not passed in
    /// this will align the center of the rectangle.
    ///
    /// \param targetX The x-position to align this rectangle to.
    /// \param thisHorzAnchor The edge of this rectangle to align.
    void alignToHorz(const float& targetX,
                     ofAlignHorz thisHorzAnchor = OF_ALIGN_HORZ_CENTER);

    /// \brief Horizontally align two rectangles to another using one anchor for both.
    ///
    /// Aligns the horizontal position of the ofRectangle to that of the
    /// passed-in ofRectangle using an ofAlignHorz constant as anchor.
    ///
    /// If a constant is not passed in, this will align the horizontal centers
    /// of the rectangles.
    ///
    /// If a constant is passed in, it will use that constant for both
    /// rectangles.
    ///
    /// \param targetRect The target rectangle to align this rectangle to.
    /// \param sharedAnchor The common edge of the rectangles to align.
    void alignToHorz(const ofRectangle& targetRect,
                     ofAlignHorz sharedAnchor = OF_ALIGN_HORZ_CENTER);

    /// \brief Horizontally align two rectangles to another using two anchors.
    ///
    /// Aligns the horizontal position of the ofRectangle to that of the
    /// passed-in ofRectangle. Takes two ofAlignHorz constants as anchors.
    ///
    /// Will align the chosen anchor in the ofRectangle with the chosen anchor
    /// in the passed-in ofRectangle.
    ///
    /// \param targetRect The target rectangle to align this rectangle to.
    /// \param targetHorzAnchor The edge of the other rectangle to align.
    /// \param thisHorzAnchor The edge of this rectangle to align.
    void alignToHorz(const ofRectangle& targetRect,
                     ofAlignHorz targetHorzAnchor,
                     ofAlignHorz thisHorzAnchor);

    /// \brief Vertically align a rectangle using a position and anchor edge.
    ///
    /// Aligns the vertical position of the ofRectangle to the given y-
    /// position using an ofAlignVert constant as anchor. If a constant is not passed in
    /// this will align the center of the rectangle.
    ///
    /// \param targetY The target y-position to align this rectangle to.
    /// \param sharedAnchor The alignment position of this ofRectangle to use.
    void alignToVert(const float& targetY,
                     ofAlignVert sharedAnchor = OF_ALIGN_VERT_CENTER);

    /// \brief Vertically align two rectangles to another using one anchor for both.
    ///
    /// Aligns the vertical position of the ofRectangle to that of the
    /// passed-in ofRectangle using an ofAlignVert constant as anchor.
    ///
    /// If a constant is not passed in, this will align the vertical centers
    /// of the rectangles.
    ///
    /// If a constant is passed in, it will use that constant for both rectangles.
    ///
    /// \param targetRect The target ofRectangle to align this rectangle to.
    /// \param sharedAnchor The alignment position for both rectangles to use.
    void alignToVert(const ofRectangle& targetRect,
                     ofAlignVert sharedAnchor = OF_ALIGN_VERT_CENTER);


    /// \brief Vertically align two rectangles to another using two anchors.
    ///
    /// Will align the chosen anchor in the ofRectangle with the chosen anchor
    /// in the passed-in ofRectangle.
    ///
    /// \param targetRect The target ofRectangle to align this rectangle to.
    /// \param targetVertAnchor The alignment anchor for this rectangle.
    /// \param thisVertAnchor The alignment anchor for the other rectangle.
    void alignToVert(const ofRectangle& targetRect,
                     ofAlignVert targetVertAnchor,
                     ofAlignVert thisVertAnchor);

	/// \brief Align this ofRectangle to an glm::vec3 in both x- and y dimentions.
    ///
    /// Aligns the position of the ofRectangle to the given point using an
    /// ofAlignHorz constant and an ofAlignVert constant. If neither constant is
    /// passed in, this will align the center of the rectangle.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
	/// \param targetPoint The target glm::vec3 to align to.
    /// \param thisHorzAnchor The horizontal alignment anchor.
    /// \param thisVertAnchor The vertical alignment anchor.
	void alignTo(const glm::vec3& targetPoint,
                ofAlignHorz thisHorzAnchor = OF_ALIGN_HORZ_CENTER,
                ofAlignVert thisVertAnchor = OF_ALIGN_VERT_CENTER);
	void alignTo(const glm::vec2& targetPoint,
				ofAlignHorz thisHorzAnchor = OF_ALIGN_HORZ_CENTER,
				ofAlignVert thisVertAnchor = OF_ALIGN_VERT_CENTER);

	/// \brief Align this ofRectangle to an glm::vec3 in both x- and y dimentions using a shared anchor.
    ///
    /// Aligns the position of the ofRectangle to that of the passed-in
    /// ofRectangle. Can take an ofAlignHorz constant and an ofAlignVert
    /// constant.
    ///
    /// If neither constant is passed in, this will align the centers of the
    /// rectangles.
    ///
    /// If constants are passed in, it will use those constants for both
    /// rectangles.
    ///
    /// \param targetRect The target ofRectangle to align this rectangle to.
    /// \param sharedHorzAnchor The alignment anchor for both rectangles.
    /// \param sharedVertAnchor The alignment anchor for both rectangles.
    void alignTo(const ofRectangle& targetRect,
                 ofAlignHorz sharedHorzAnchor = OF_ALIGN_HORZ_CENTER,
                 ofAlignVert sharedVertAnchor = OF_ALIGN_VERT_CENTER);


    /// \brief Vertically align this ofRectangle to another target ofRectangle.
    ///
    /// Aligns the position of the ofRectangle to that of the passed-in
    /// ofRectangle. Takes two ofAlignHorz constants and two ofAlignVert
    /// constants.
    ///
    /// Will align the chosen anchors in the ofRectangle with the chosen
    /// anchors in the passed-in ofRectangle.
    ///
    /// \param targetRect The target ofRectangle to align this rectangle to.
    /// \param targetHorzAnchor The vertical alignment anchor for the target rectangle.
    /// \param targetVertAnchor The horizontal alignment anchor for the target rectangle.
    /// \param thisHorzAnchor The horizontal alignment anchor for this rectangle.
    /// \param thisVertAnchor The vertical alignment anchor for this rectangle.
    void alignTo(const ofRectangle& targetRect,
                 ofAlignHorz targetHorzAnchor,
                 ofAlignVert targetVertAnchor,
                 ofAlignHorz thisHorzAnchor,
                 ofAlignVert thisVertAnchor);

    /// \}

    /// \name Intersection
    /// \{

    /// \brief Determines if the coordinates (x, y) are within the ofRectangle.
    ///
    /// Note that coordinates on the edge of the ofRectangle are not
    /// considered within the rectangle and will return false.
    ///
    /// \param px The x-coordinate to test.
    /// \param py The y-coordinate to test.
    /// \returns true if px and py are inside this ofRectangle.
    bool inside(float px, float py) const;

	/// \brief Determines if the glm::vec3 is within the ofRectangle.
    ///
    /// Note that points on the edge of the ofRectangle are not
    /// considered within the rectangle and will return false.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
    /// \param p The point to test.
    /// \returns true if the point p is inside this ofRectangle.
	bool inside(const glm::vec3& p) const;
	bool inside(const glm::vec2& p) const;

    /// \brief Determines if another ofRectangle is completely within the ofRectangle.
    ///
    /// Note that rectangles that share an edge with the ofRectangle are not
    /// considered within the rectangle and will return false.
    ///
    /// \param rect The ofRectangle to test.
    /// \returns true if all four corners of the rect are within this rectangle.
    bool inside(const ofRectangle& rect) const;

	/// \brief Determines if both of the passed glm::vec3s are within the ofRectangle or not.
    ///
    /// Note that points on the edge of the ofRectangle are not considered
    /// within the rectangle and will return false.
    ///
	/// \warning The z-components of the passed glm::vec3s are ignored.
    ///
    /// \param p0 The first point to test.
    /// \param p1 The second point to test.
    /// \returns true if both points are inside the rectangle.
	bool inside(const glm::vec3& p0, const glm::vec3& p1) const;
	bool inside(const glm::vec2& p0, const glm::vec2& p1) const;

    /// \brief Determines if another rectangle intersects with this rectangle.
    ///
    /// Rectangles that only share an edge and do not intersect otherwise are
    /// not considered to intersect and will return false.
    ///
    /// \param rect The rectangle to test.
    /// \returns `true` if the area contained within the ofRectangle overlaps
    ///     with the area contained within the passed ofRectangle.
    bool intersects(const ofRectangle& rect) const;

    /// \brief Determines if a line segment intersects with the ofRectangle.
    ///
	/// \warning The z-components of the passed glm::vec3s are ignored.
    ///
    /// \param p0 The first point to test.
    /// \param p1 The second point to test.
	/// \returns `true` if the line segment defined by the two passed glm::vec3s
    ///     either crosses the perimeter of the ofRectangle or is completely
    ///     contained within.
	bool intersects(const glm::vec3& p0, const glm::vec3& p1) const;
	bool intersects(const glm::vec2& p0, const glm::vec2& p1) const;

    /// \brief Grow the ofRectangle to include the given (x, y) coordinates.
    ///
    /// This will potentially change the width, height, x-position, and y-
    /// position of the ofRectangle. If the points are already within the
    /// rectangle, this rectangle will remain unchanged.
    ///
    /// \param px The x-coordinate to include.
    /// \param py The y-coordiante to include.
    void growToInclude(float px, float py);

    /// \brief Grow the ofRectangle to include the given point.
    ///
    /// This will potentially change the width, height, x-position, and y-
    /// position of the ofRectangle.  If the point is already within the
    /// rectangle, this rectangle will remain unchanged.
    ///
	/// \warning The z-component of the passed glm::vec3 is ignored.
    ///
    /// \param p The position to include.
	void growToInclude(const glm::vec3& p);
	void growToInclude(const glm::vec2& p);

    /// \brief Grow the ofRectangle to include the given ofRectangle.
    ///
    /// This will potentially change the width, height, x-position, and y-
    /// position of the ofRectangle.  If the rectangle is already within the
    /// rectangle, this rectangle will remain unchanged.
    ///
    /// \param rect The rectangle to include.
    void growToInclude(const ofRectangle& rect);

    /// \brief Grow the ofRectangle to include the given line segment.
    ///
    /// This will potentially change the width, height, x-position, and
    /// y-position of the ofRectangle.  If the points are already within the
    /// rectangle, this rectangle will remain unchanged.
    ///
	/// \warning The z-components of the passed glm::vec3s are ignored.
    ///
    /// \param p0 The first point to include.
    /// \param p1 The second point to include.
	void growToInclude(const glm::vec3& p0, const glm::vec3& p1);
	void growToInclude(const glm::vec2& p0, const glm::vec2& p1);

    /// \brief Get the intersecting area between this rectangle and another.
    ///
    /// This method will attempt to return the area of overlap between this
    /// rectangle and the passed rectangle.
    ///
    /// If the two rectangles do not overlap, it will return an "empty"
    /// rectangle located (0, 0) with 0 width and 0 height.
    ///
    /// If the two rectangles only share an edge this will return a rectangle
    /// positioned on that edge:
    ///
    /// If the shared edge is vertical, the rectangle will have zero width,
    /// otherwise it will have zero height.
    ///
    /// \param rect The rectangle to intersect.
    /// \returns A new ofRectangle representing the intersecting area or an
    ///          empty rectangle (0, 0, 0, 0) if there is no intersection.
    ofRectangle getIntersection(const ofRectangle& rect) const;

    /// \brief Get the union area between this rectangle and anohter.
    ///
    /// \sa getIntersection(const ofRectangle& rect) const
    /// \param rect The rectangle to unite with.
    /// \returns A new ofRectangle whose area contains both the area of the
    ///          this rectangle and the passed rectangle..
    ofRectangle getUnion(const ofRectangle& rect) const;

    /// \}

    /// \name Standardization
    /// \{

    /// \brief Standardize the rectangle
    ///
    /// "Standardized" rectangles are rectangles whose width and height are positive: width >= 0 and height
    /// >= 0. This method can be used to ensure that the rectangle is
    /// "standardized". If the rectangle is non-standard, it will modify the x /
    /// width and y / height values into their respective standardized versions.
    void standardize();

    /// \brief Get the standardized representation of this rectangle.
    ///
    /// "Standardized" rectangles are rectangles whose width and height are positive. 
    /// For more information about standardized rectangles, see the discussion of the standardize() method.
    ///
    /// \returns the Standardized version of this ofRectangle.
    ofRectangle getStandardized() const;

    /// \brief Returns true if this ofRectangle is standardized.
    ///
    /// "Standardized" rectangles are rectangles whose width and height are positive. 
    /// For more information about standardized rectangles, see the discussion of the standardize() method.
    ///
    /// \returns true if both width >= 0 and height >= 0.
    bool isStandardized() const;

    /// \}

    /// \name Getters
    /// \{

    /// \brief Get the area of the ofRectangle.
    ///
    /// This is the product of the width and height of the recatngle.
    ///
    /// \returns The area of the rectangle as float.
    float getArea() const;


    /// \brief Gets the perimeter of the ofRectangle.
    ///
    /// This is the sum of the lengths of the sides.
    ///
    /// \returns The perimeter of the rectangle as float.
    float getPerimeter() const;

    /// \brief Gets the ratio of width to height of the ofRectangle.
    ///
    /// \returns The aspect ratio of the rectangle.
    float getAspectRatio() const;

    /// \brief Determines if the ofRectangle's area is zero.
    /// \sa getArea().
    /// \returns true if both the width == 0 and height == 0, false if either is non-zero.
    bool isEmpty() const;

	/// \brief Get the minimum x and y coordinates of the ofRectangle as glm::vec3.
    /// \returns The minimum x and y coordinates of the rectangle.
	glm::vec3 getMin() const;

	/// \brief Get the maximum x and y coordinates of the ofRectangle as glm::vec3.
    /// \returns The maximum x and y coordinates of the rectangle.
	glm::vec3 getMax() const;

    /// \brief Get the smallest x position of the ofRectangle as float.
    /// \returns The smallest xposition of the rectangle.
    float getMinX() const;

    /// \brief Get the largest x position of the ofRectangle as float.
    /// \returns The largest x position of the rectangle.
    float getMaxX() const;

    /// \brief Get the smallest y position of the ofRectangle as float.
    /// \returns The smallest y position of the rectangle.
    float getMinY() const;

    /// \brief Get the largest y position of the ofRectangle as float.
    /// \returns The largest y position of the rectangle.
    float getMaxY() const;

    /// \brief Gets the x position of the left edge of the ofRectangle as float.
    /// \sa getMinX()
    /// \returns The x position of the left edge of the rectangle.
    float getLeft() const;

    /// \brief Gets the x position of the right edge of the ofRectangle as float.
    /// \sa getMaxX()
    /// \returns The y position of the right edge of the rectangle.
    float getRight() const;

    /// \brief Gets the y position of the top edge of the ofRectangle as float.
    /// \sa getMinY()
    /// \returns The y position of the top edge of the rectangle.
    float getTop() const;

    /// \brief Gets the y position of the bottom edge of the ofRectangle as float.
    /// \sa getMaxY()
    /// \returns The y position of the bottom edge of the rectangle.
    float getBottom() const;

	/// \brief Get the top-left coordinates of the ofRectangle as glm::vec3.
    /// \sa getMin()
    /// \returns The top-left coordinates of the rectangle.
	glm::vec3 getTopLeft() const;

	/// \brief Get the top-right coordinates of the ofRectangle as glm::vec3.
    /// \returns The top-right coordinates of the rectangle.
	glm::vec3 getTopRight() const;

	/// \brief Get the bottom-left coordinates of the ofRectangle as glm::vec3.
    /// \returns The bottom-left coordinates of the rectangle.
	glm::vec3 getBottomLeft() const;

	/// \brief Get the bottom-right coordinates of the ofRectangle as glm::vec3.
    /// \sa getMax()
    /// \returns The bottom-right coordinates of the rectangle.
	glm::vec3 getBottomRight() const;

    /// \brief A convenience method that returns the value of one of
    /// the horizontal edges of the ofRectangle using the `ofAlignHorz` enum.
    ///
    /// \param anchor The anchor position to query.
    /// \returns the value of the referenced anchor position.
    float getHorzAnchor(ofAlignHorz anchor) const;

    /// \brief A convenience method that returns the value of one of the
    /// vertical edges of the ofRectangle using the ofAlignVert enum.
    ///
    /// \param anchor The anchor position to query.
    /// \returns the value of the referenced anchor position.
    float getVertAnchor(ofAlignVert anchor) const;

    /// \brief Get the ofRectangle's position.
    ///
	/// \warning The z component of the returned glm::vec3 is undefined.
    ///
    /// \returns The rectangle's position.
	const glm::vec3& getPosition() const;

	OF_DEPRECATED_MSG("Use getPosition() instead.", glm::vec3& getPositionRef() );

	/// \brief Get the coordiantes of the ofRectangle's center as glm::vec3.
    ///
	/// \warning The z component of the returned glm::vec3 will always be 0.
    ///
    /// \returns The x and y coordinates of the center of the rectangle (z = 0).
	glm::vec3 getCenter() const;

    /// \brief Gets the x position of the ofRectangle as float.
    /// \returns The x position of the rectangle.
    float getX() const;

    /// \brief Gets the y position of the ofRectangle as float.
    /// \returns the y position of the rectangle.
    float getY() const;

    /// \brief Gets the width of the ofRectangle as float.
    /// \returns The width of the rectangle.
    float getWidth() const;

    /// \brief Gets the height of the ofRectangle as float.
    /// \returns The height of the rectangle.
    float getHeight() const;

    
    /// \brief Maps a normalized coordinate into this rectangle
    /// 
    /// Normalized coordinates range from [0,1] inclusive. It is used to define a ratio
    /// between the coordinates and a unitary rectangle. This ratio is mapped into
    /// this rectangle to scale to real values. If normalized coordinates are out of bounds,
    /// output will be scaled accordingly.
    ///
    /// \param coeff Normalized coordinate to map to this rectangle
    /// \returns The mapped coordinate
    glm::vec2 map(const glm::vec2 & coeff) const;
    
    /// \brief Maps a normalized coordinate into this rectangle
    /// 
    /// Normalized rectangles' position, width and height range from [0,1] inclusive.
    /// It is used to define a ratio between the rectangle and a unitary rectangle.
    /// This ratio is mapped into this rectangle to scale to real values. 
    /// If normalized rectangle is out of bounds, output will be scaled accordingly.
    /// 
    /// \param coeff Normalized rectangle to map to this rectangle
    /// \returns The mapped coordinate
    ofRectangle map(const ofRectangle & coeff) const;
    
    /// \brief Maps a normalized coordinate into this rectangle, clamping if out of bounds
    /// 
    /// Normalized coordinates range from [0,1] inclusive. It is used to define a ratio
    /// between the coordinates and a unitary rectangle. This ratio is mapped into
    /// this rectangle to scale to real values. If normalized coordinates are out of bounds,
    /// output will be clamped to this rectangle's position, width and height.
    /// 
    /// \param coeff Normalized coordinate to map to this rectangle
    /// \returns The mapped coordinate, clamped
    glm::vec2 mapClamp(const glm::vec2 & coeff) const;
    
    /// \brief Maps a normalized rectangle to this rectangle, clamping if out of bounds
    /// 
    /// Normalized rectangles' position, width and height range from [0,1] inclusive.
    /// It is used to define a ratio between the rectangle and a unitary rectangle.
    /// This ratio is mapped into this rectangle to scale to real values. 
    /// If normalized rectangle is out of bounds, output will be clamped to this 
    /// rectangle's position, width and height.
    /// 
    /// \param coeff Normalized rectangle to map to this rectangle
    /// \returns The mapped rectangle
    ofRectangle mapClamp(const ofRectangle & coeff) const;
    
    /// \}

    /// \name Operators
    /// \{

    /// \brief Assignment operator.
    /// \param rect The rectangle to assign.
    /// \returns A reference to this rectangle.
    ofRectangle& operator = (const ofRectangle& rect);

    /// \brief Returns a new ofRectangle where the x and y positions of the
	/// rectangle are offset by the (x, y) coordinates of the glm::vec3.
    /// \param p The point to translate.
    /// \returns The translated ofRectangle.
	ofRectangle operator + (const glm::vec3& p);
	ofRectangle operator + (const glm::vec2& p);

	/// \brief Returns a new ofRectangle where the x and y-positions of the
	/// rectangle are offset by the (x, y) coordinates of the glm::vec3.
	/// \param p The point to translate.
	/// \returns The translated ofRectangle.
	ofRectangle operator - (const glm::vec3& p);
	ofRectangle operator - (const glm::vec2& p);

    /// \brief If both ofRectangles have the same x, y, width, and height,
    /// they are considered equal.
    /// \param rect The rectangle to compare.
    /// \returns True if the rectangles are equal.
    bool operator == (const ofRectangle& rect) const;

    /// \brief If the two ofRectangles differ in x, y, width, or height, they
    /// are considered unequal.
    /// \param rect The rectangle to compare.
    /// \returns True if the rectangles are not equal.
    bool operator != (const ofRectangle& rect) const;
    
    bool isZero() const;


    /// \}

    /// \name Properties
    /// \{


	/// \brief The (x,y) position of the ofRectangle as an glm::vec3.
    ///
    /// \warning The z-component of this position is preserved and can be used
    /// but all ofRectangle operations will ignore the z-component.
	glm::vec3 position;

    /// \brief The x position of the ofRectangle.
    float& x;

    /// \brief The y position of the ofRectangle.
    float& y;

    /// \brief The width of the ofRectangle.
    float width;

    /// \brief The height of the ofRectangle.
    float height;

    /// \}
};

/// \cond INTERNAL
/// \warning The internal z component of the glm::vec3 is preserved even though it
/// is not used.
std::ostream& operator<<(std::ostream& os, const ofRectangle& rect);
/// \warning The internal z component of the glm::vec3 is preserved even though it
/// is not used.
std::istream& operator>>(std::istream& is, ofRectangle& rect);
/// \endcond

#line 0 "../libs/openFrameworks/utils/ofUtils.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "utf8.h" */
#include <bitset> // For ofToBinary.
#include <chrono>
#include <iomanip>  //for setprecision
#include <algorithm>
#include <sstream>

/// \section Elapsed Time
/// \brief Reset the elapsed time counter.
///
/// This method resets the times returned by ofGetElapsedTimef(),
/// ofGetElapsedTimeMillis() and ofGetElapsedTimeMicros() to zero.
///
/// \note This is called on the first frame during app startup.
void ofResetElapsedTimeCounter();

/// \brief Get the elapsed time in seconds.
///
/// This returns the elapsed time since ofResetElapsedTimeCounter() was called.
/// Usually ofResetElapsedTimeCounter() is called automatically once during
/// program startup.
///
/// \returns the floating point elapsed time in seconds.
float ofGetElapsedTimef();


/// \brief Get the elapsed time in milliseconds.
///
/// This returns the elapsed time since ofResetElapsedTimeCounter() was called.
/// Usually ofResetElapsedTimeCounter() is called automatically once during
/// program startup.
///
/// \returns the elapsed time in milliseconds (1000 milliseconds = 1 second).
uint64_t ofGetElapsedTimeMillis();

/// \brief Get the elapsed time in microseconds.
///
/// This returns the elapsed time since ofResetElapsedTimeCounter() was called.
/// Usually ofResetElapsedTimeCounter() is called automatically upon program
/// startup.
///
/// \returns the elapsed time in microseconds (1000000 microseconds = 1 second).
uint64_t ofGetElapsedTimeMicros();

/// \brief Get the number of frames rendered since the program started.
/// \returns the number of frames rendered since the program started.
uint64_t ofGetFrameNum();

/// \section System Time
/// \brief Get the seconds after the minute.
/// \returns the seconds after the minute [0-59].
int ofGetSeconds();

/// \brief Get minutes after the hour.
/// \returns the minutes after the hour [0-59].
int ofGetMinutes();

/// \brief Get the hour of the day.
/// \returns the hour of the day [0-23].
int ofGetHours();

/// \brief Get the number of seconds since Midnight, January 1, 1970.
///
/// Resolution is in seconds.
///
/// \returns the number of seconds since Midnight, January 1, 1970 (epoch time).
unsigned int ofGetUnixTime();

/// \brief Get the system time in milliseconds.
/// \returns the system time in milliseconds.
OF_DEPRECATED_MSG("Use ofGetSystemTimeMillis() instead", uint64_t ofGetSystemTime());

/// \brief Get the system time in milliseconds.
/// \returns the system time in milliseconds.
uint64_t ofGetSystemTimeMillis();

/// \brief Get the system time in microseconds.
/// \returns the system time in microseconds.
uint64_t ofGetSystemTimeMicros();


struct ofTime{
	uint64_t seconds = 0;
	uint64_t nanoseconds = 0;

	enum Mode{
		System,
		FixedRate,
	} mode = System;

	uint64_t getAsMilliseconds() const;
	uint64_t getAsMicroseconds() const;
	uint64_t getAsNanoseconds() const;
	double getAsSeconds() const;
#ifndef TARGET_WIN32
	timespec getAsTimespec() const;
#endif

	std::chrono::time_point<std::chrono::nanoseconds> getAsTimePoint() const;
	std::chrono::nanoseconds operator-(const ofTime&) const;
	bool operator<(const ofTime&) const;
	bool operator>(const ofTime&) const;
	bool operator<=(const ofTime&) const;
	bool operator>=(const ofTime&) const;

	template<typename rep, typename ratio>
	ofTime operator+(const std::chrono::duration<rep,ratio> & duration) const{
		constexpr uint64_t NANOS_PER_SEC = 1000000000ll;
		auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(duration);
		ofTime t = *this;
		t.nanoseconds += ns.count();
		if(this->nanoseconds>NANOS_PER_SEC){
			uint64_t secs = this->nanoseconds / NANOS_PER_SEC;
			t.nanoseconds -= NANOS_PER_SEC*secs;
			t.seconds+=secs;
		}
		return t;
	}

	template<typename rep, typename ratio>
	ofTime &operator+=(const std::chrono::duration<rep,ratio> & duration){
		constexpr uint64_t NANOS_PER_SEC = 1000000000ll;
		auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(duration);
		this->nanoseconds += ns.count();
		if(this->nanoseconds>NANOS_PER_SEC){
			uint64_t secs = this->nanoseconds / NANOS_PER_SEC;
			this->nanoseconds -= NANOS_PER_SEC*secs;
			this->seconds+=secs;
		}
		return *this;
	}
};

/// \brief Get the system time.
/// \returns the system time.
ofTime ofGetCurrentTime();

/// \brief Sleeps the current thread for the specified amount of milliseconds.
/// \param millis The number of millseconds to sleep.
void ofSleepMillis(int millis);

/// \brief Formats the current system time according to the given format.
///
/// The default timestamp format is "%Y-%m-%d-%H-%M-%S-%i" (e.g.
/// 2011-01-15-18-29-35-299).
///
/// \returns the current time as a string with the default format.
std::string ofGetTimestampString();

/// \brief Formats the current system time according to the given format.
///
/// The format string is used as a template to format the date and
/// is copied character by character except for the following special
/// characters, which are replaced by the corresponding value.
///
///   * %w - abbreviated weekday (Mon, Tue, ...)
///   * %W - full weekday (Monday, Tuesday, ...)
///   * %b - abbreviated month (Jan, Feb, ...)
///   * %B - full month (January, February, ...)
///   * %d - zero-padded day of month (01 .. 31)
///   * %e - day of month (1 .. 31)
///   * %f - space-padded day of month ( 1 .. 31)
///   * %m - zero-padded month (01 .. 12)
///   * %n - month (1 .. 12)
///   * %o - space-padded month ( 1 .. 12)
///   * %y - year without century (70)
///   * %Y - year with century (1970)
///   * %H - hour (00 .. 23)
///   * %h - hour (00 .. 12)
///   * %a - am/pm
///   * %A - AM/PM
///   * %M - minute (00 .. 59)
///   * %S - second (00 .. 59)
///   * %s - seconds and microseconds (equivalent to %S.%F)
///   * %i - millisecond (000 .. 999)
///   * %c - centisecond (0 .. 9)
///   * %F - fractional seconds/microseconds (000000 - 999999)
///   * %z - time zone differential in ISO 8601 format (Z or +NN.NN)
///   * %Z - time zone differential in RFC format (GMT or +NNNN)
///   * %% - percent sign
///
/// \param timestampFormat The formatting pattern.
/// \returns the formatted timestamp as a string.
/// \warning an invalid timestampFormat may crash windows apps.
std::string ofGetTimestampString(const std::string& timestampFormat);

/// \brief Get the current year.
/// \returns the current year.
int ofGetYear();

/// \brief Get the current month.
/// \returns the current month [1-12].
int ofGetMonth();

/// \brief Get the current day within the month.
/// \returns the day witin the month [1-31].
int ofGetDay();

/// \brief Get the current weekday.
///
/// Values 0 = Sunday, 1 = Monday, ..., 6 = Saturday.
///
/// \returns the current weekday [0-6].
int ofGetWeekday();

/// \section Data Path
/// \brief Enable the use of the data path.
///
/// This function causes ofToDataPath() to respect the relative path set
/// with ofSetDataPathRoot().  This is enabled by default.
void ofEnableDataPath();

/// \brief Disable the use of the data path.
///
/// This function causes ofToDataPath() to ignore the relative path set
/// with ofSetDataPathRoot().
void ofDisableDataPath();

/// \brief Make a path relative to the location of the data/ folder.
///
/// This funtion returns path unchanged if ofDisableDataPath() was called first.
///
/// By default, a relative path is returned. Users requiring absolute paths for
/// (e.g. for non-openFrameworks functions), can specify that an absolute path
/// be returned.
///
/// \param path The path to make relative to the data/ folder.
/// \param absolute Set to true to return an absolute path.
/// \returns the new path, unless paths were disabled with ofDisableDataPath().
std::string ofToDataPath(const std::filesystem::path & path, bool absolute=false);

/// \brief Reset the working directory to the platform default.
///
/// The default working directory is where the application was started from
/// or the exe directory in case of osx bundles. GLUT might change the default
/// working directory to the resources directory in the bundle in osx. This
/// will restore it to the exe dir or whatever was the current dir when the
/// application was started
bool ofRestoreWorkingDirectoryToDefault();

/// \brief Set the relative path to the data/ folder from the executable.
///
/// This method can be useful when users want to embed the data as a resource
/// folder within an *.app bundle on OSX or perhaps work from a shared data
/// folder in the user's Documents directory.
///
/// \warning The provided path must have a trailing slash (/).
/// \param root The path to the data/ folder relative to the app executable.
void ofSetDataPathRoot(const std::filesystem::path& root);


/// \section Vectors
/// \brief Randomly reorder the values in a vector.
/// \tparam T the type contained by the vector.
/// \param values The vector of values to modify.
/// \sa http://www.cplusplus.com/reference/algorithm/random_shuffle/
template<class T>
void ofRandomize(std::vector<T>& values) {
	random_shuffle(values.begin(), values.end());
}

/// \brief Conditionally remove values from a vector.
///
/// Values are removed if, when passed to the BoolFunction, the BoolFunction
/// function returns true.  The given BoolFunction can be a custom function
/// or a built-in function.
///
/// Example of a custom function to remove odd numbers from a std::vector<int>
/// of integers:
///
/// ~~~~{.cpp}
/// bool IsOdd(int i) {
///     return ((i % 2) == 1);
/// }
/// ~~~~
///
/// To call the function, one might use:
///
/// ~~~~{.cpp}
/// std::vector<int> myInts;
///
/// // Fill the vector with integers.
/// for (int i = 0; i < 10; ++i)
/// {
///     myInts.push_back(i);
/// }
///
/// ofRemove(myInts, IsOdd);
/// ~~~~
///
/// The resulting vector will contain the following values:
///
///    0, 2, 4, 6, 8
///
/// \tparam T the type contained by the vector.
/// \tparam BoolFunction the boolean function used to erase.
/// \param values The vector of values to modify.
/// \param shouldErase A boolean function as described above.
/// \sa http://www.cplusplus.com/reference/algorithm/remove_if/
template<class T, class BoolFunction>
void ofRemove(std::vector<T>& values, BoolFunction shouldErase) {
	values.erase(remove_if(values.begin(), values.end(), shouldErase), values.end());
}

/// \brief Sort a vector of values into ascending order.
///
/// The elements are compared using operator< for the first version.
/// Equivalent elements are not guaranteed to keep their original relative
/// order.
///
/// \tparam T the type contained by the vector.
/// \param values The vector of values to be sorted.
/// \sa http://www.cplusplus.com/reference/algorithm/sort/
template<class T>
void ofSort(std::vector<T>& values) {
	sort(values.begin(), values.end());
}

/// \brief Sort a vector of values into an order defined by a comparator.
///
/// Example of a custom function to sort descending of integers:
///
/// ~~~~{.cpp}
/// bool sortDescending(int i, int j)
/// {
///     return (j < i);
/// }
/// ~~~~
///
/// This binary function must accept two elements in the range as arguments and
/// return a value convertible to bool. The value returned indicates whether the
/// element passed as first argument is considered to go before the second in
/// the specific strict weak ordering it defines.  The function shall not modify
/// any of its arguments.  This can either be a function pointer or a function
/// object.
///
/// To call the function, one might use:
///
/// ~~~~{.cpp}
/// std::vector<int> myInts;
///
/// // Fill the vector with integers.
/// for (int i = 0; i < 10; ++i)
/// {
///     myInts.push_back(i);
/// }
///
/// ofSort(myInts, sortDescending);
/// ~~~~
///
/// The resulting vector will contain the following values:
///
///    9, 8, 7, 6, 5, 4, 3, 2, 1, 0.
///
/// \tparam T the type contained by the vector.
/// \param values The vector of values to be sorted.
/// \param compare The comparison function.
/// \sa http://www.cplusplus.com/reference/algorithm/sort/
template<class T, class BoolFunction>
void ofSort(std::vector<T>& values, BoolFunction compare) {
	std::sort(values.begin(), values.end(), compare);
}

/// \brief Search for a target value in a vector of values.
/// \tparam T the type contained by the vector.
/// \param values The vector of values to be searched.
/// \param target The target value to be found.
/// \returns true the index of the first target value found.
/// \sa http://www.cplusplus.com/reference/iterator/distance/
template <class T>
std::size_t ofFind(const std::vector<T>& values, const T& target) {
	return std::distance(values.begin(), find(values.begin(), values.end(), target));
}

/// \brief Search for a target value in a vector of values.
/// \tparam T the type contained by the vector.
/// \param values The vector of values to be searched.
/// \param target The target value to be found.
/// \returns true if at least one value equal to the target value is found.
template <class T>
bool ofContains(const std::vector<T>& values, const T& target) {
	return ofFind(values, target) != values.size();
}



/// \section String Manipulation
/// \brief Splits a string using a delimiter.
///
/// ofSplitString splits a string and returns the collection of string
/// tokens inside of a std::vector<std::string>.
///
/// A useful application is to use delimiter `" "`:
///
/// ~~~~{.cpp}
/// result = ofSplitString("of rocks", " ");
/// // result[0] = "of"
/// // result[1] = "rocks"
/// ~~~~
///
/// Like this a big string can be "cut" and turned it into a collection of
/// words. The user can also ignore empty tokens.  Empty tokens occur when a
/// there are multiple delimiters in a row (e.g. "of,rocks,,!").  The user can
/// also "trim" the tokens. This will remove whitespace from before and after
/// each token.  This might be useful when a delimted string is padded with
/// with spaces (e.g. "of    ,   rocks   ,!").
///
/// \param source The string to split.
/// \param delimiter The delimiter string.
/// \param ignoreEmpty Set to true to remove empty tokens.
/// \param trim Set to true to trim the resulting tokens.
/// \returns A vector of strings split with the delimiter.
std::vector<std::string> ofSplitString(const std::string& source, const std::string& delimiter, bool ignoreEmpty = false, bool trim = false);

/// \brief Join a vector of strings together into one string.
/// \param stringElements The vector of strings to join.
/// \param delimiter The delimiter to put betweeen each string.
std::string ofJoinString(const std::vector<std::string>& stringElements, const std::string& delimiter);

/// \brief Replace all occurrences of a string with another string.
/// \note The input string is passed by reference, so it will be modified.
/// \param input The string to run the replacement on.
/// \param searchStr The string to be replaced.
/// \param replaceStr The string to put in place.
void ofStringReplace(std::string& input, const std::string& searchStr, const std::string& replaceStr);

/// \brief Check if string contains another string.
///
/// Example:
/// ~~~{.cpp}
///     std::string haystack = "foobar";
///     ofLog() << ofIsStringInString(haystack, "foo"); // Outputs 1.
///     ofLog() << ofIsStringInString(haystack,"bar"); // Outputs 1.
///     ofLog() << ofIsStringInString(haystack, "something else"); // Outputs 0.
/// ~~~
/// \param haystack The string to check for occurrence in.
/// \param needle The string to check for.
bool ofIsStringInString(const std::string& haystack, const std::string& needle);

/// \brief Check how many times a string contains another string.
/// \param haystack The string to check for occurrence in .
/// \param needle The string to check for.
std::size_t ofStringTimesInString(const std::string& haystack, const std::string& needle);

/// \brief Converts all characters in a string to lowercase.
///
/// This function expects a UTF-8 encoded multi-byte string to be passed.
/// Resulting strings will be returned as UTF-8 encoded multi-byte strings.
///
/// ~~~~{.cpp}
///     std::string enthusiasticGreeting = "HELLO, WORLD!";
///     std::string politeGreeting = ofToLower(enthusiasticGreeting);
///     ofLog() << politeGreeting; // Returns "hello, world!"
/// ~~~~
///
/// \param src The UTF-8 encoded string to convert to lowercase.
/// \returns the UTF-8 encoded string as all lowercase characters.
std::string ofToLower(const std::string& src, const std::string & locale="");

/// \brief Converts all characters in the string to uppercase.
///
/// This function expects a UTF-8 encoded multi-byte string to be passed.
/// Resulting strings will be returned as UTF-8 encoded multi-byte strings.
///
/// ~~~~{.cpp}
///     std::string politeGreeting = "Hello, World!";
///     std::string enthusiasticGreeting = ofToUpper(politeGreeting);
///     ofLog() << enthusiasticGreeting; // Returns "HELLO, WORLD!"
/// ~~~~
///
/// \param src The UTF-8 encoded string to convert to uppercase.
/// \returns the UTF-8 encoded string as all uppercase characters.
std::string ofToUpper(const std::string& src, const std::string & locale="");

std::string ofTrimFront(const std::string & src, const std::string & locale = "");
std::string ofTrimBack(const std::string & src, const std::string & locale = "");
std::string ofTrim(const std::string & src, const std::string & locale = "");

OF_DEPRECATED_MSG("Use ofUTF8Append instead", void ofAppendUTF8(std::string & str, uint32_t utf8));

void ofUTF8Append(std::string & str, uint32_t utf8);
void ofUTF8Insert(std::string & str, size_t pos, uint32_t utf8);
void ofUTF8Erase(std::string & str, size_t start, size_t len);
std::string ofUTF8Substring(const std::string & str, size_t start, size_t len);
std::string ofUTF8ToString(uint32_t utf8);
size_t ofUTF8Length(const std::string & str);

/// \brief Convert a variable length argument to a string.
/// \param format a printf-style format string.
/// \returns A string representation of the argument list.
std::string ofVAArgsToString(const char * format, ...);

/// \brief Convert a variable length argument to a string.
/// \param format A printf-style format string.
/// \param args A variable argument list.
/// \returns A string representation of the argument list.
std::string ofVAArgsToString(const char * format, va_list args);

/// \section String Conversion
/// \brief Convert a value to a string.
///
/// ofToString does its best to convert any value to a string. If the data type
/// implements a stream << operator, then it will be converted.
///
/// Example:
/// ~~~~{.cpp}
///		std::string str = "framerate is ";
///		str += ofToString(ofGetFrameRate()) + " fps";
///		// The string now containes something like "framerate is 60 fps".
/// ~~~~
///
/// \tparam T The data type of the value to convert to a string.
/// \param value The value to convert to a string.
/// \returns A string representing the value or an empty string on failure.
template <class T>
std::string ofToString(const T& value){
	std::ostringstream out;
	out << value;
	return out.str();
}

/// \brief Convert a value to a string with a specific precision.
///
/// Like sprintf "%4f" format, in this example precision=4
///
/// \tparam T The data type of the value to convert to a string.
/// \param value The value to convert to a string.
/// \param precision The precision to use when converting to a string.
/// \returns The string representation of the value.
template <class T>
std::string ofToString(const T& value, int precision){
	std::ostringstream out;
	out << std::fixed << std::setprecision(precision) << value;
	return out.str();
}

/// \brief Convert a value to a string with a specific width and fill
///
/// Like sprintf "% 4d" or "% 4f" format, in this example width=4, fill=' '
///
/// \tparam T The data type of the value to convert to a string.
/// \param value The value to convert to a string.
/// \param width The width of the value to use when converting to a string.
/// \param fill The character to use when padding the converted string.
/// \returns The string representation of the value.
template <class T>
std::string ofToString(const T& value, int width, char fill ){
	std::ostringstream out;
	out << std::fixed << std::setfill(fill) << std::setw(width) << value;
	return out.str();
}

/// \brief Convert a value to a string with a specific precision, width and filll
///
/// Like sprintf "%04.2d" or "%04.2f" format, in this example precision=2, width=4, fill='0'
///
/// \tparam T The data type of the value to convert to a string.
/// \param value The value to convert to a string.
/// \param precision The precision to use when converting to a string.
/// \param width The width of the value to use when converting to a string.
/// \param fill The character to use when padding the converted string.
/// \returns The string representation of the value.
template <class T>
std::string ofToString(const T& value, int precision, int width, char fill ){
	std::ostringstream out;
	out << std::fixed << std::setfill(fill) << std::setw(width) << std::setprecision(precision) << value;
	return out.str();
}

/// \brief Convert a vector of values to a comma-delimited string.
///
/// This method will take any vector of values and output a list of the values
/// as a comma-delimited string.
///
/// \tparam T The data type held by the vector.
/// \param values The vector of values to be converted to a string.
/// \returns a comma-delimited string representation of the intput values.
template<class T>
std::string ofToString(const std::vector<T>& values) {
	std::stringstream out;
	int n = values.size();
	out << "{";
	if(n > 0) {
		for(int i = 0; i < n - 1; i++) {
			out << values[i] << ", ";
		}
		out << values[n - 1];
	}
	out << "}";
	return out.str();
}

/// \brief Convert a string represetnation to another type.
///
/// Often, this method will be used to convert a string to a numerical type.
///
/// \tparam T The target data type.
/// \param value The string value to convert to type T.
/// \returns the string converted to the target data type T.
template<class T>
T ofFromString(const std::string & value){
	T data;
	std::stringstream ss;
    ss << value;
    ss >> data;
    return data;
}

/// \brief Convert a string represetnation to another string.
/// \param value The string value to convert to another string.
/// \returns the string converted to another string.
template<>
std::string ofFromString(const std::string & value);

/// \brief Convert a string represetnation to another string.
///
/// Equivalent to calling the `.c_str()` on a std::string.
///
/// \param value The string value to convert to another string.
/// \returns the string converted to a c-style string.
template<>
const char * ofFromString(const std::string & value);

template<typename T> T ofTo(const std::string & str){
	T x;
	std::istringstream cur(str);
	cur >> x;
	return x;
}

/// \section Number Conversion
/// \brief Convert a string to an integer.
///
/// Converts a `std::string` representation of an int (e.g., `"3"`) to an actual
/// `int`.
///
/// \param intString The string representation of the integer.
/// \returns the integer represented by the string or 0 on failure.
int ofToInt(const std::string& intString);

/// \brief Convert a string to a int64_t.
///
/// Converts a `std::string` representation of a long integer
/// (e.g., `"9223372036854775807"`) to an actual `int64_t`.
///
/// \param intString The string representation of the long integer.
/// \returns the long integer represented by the string or 0 on failure.
int64_t ofToInt64(const std::string& intString);

/// \brief Convert a string to a float.
///
/// Converts a std::string representation of a float (e.g., `"3.14"`) to an
/// actual `float`.
///
/// \param floatString string representation of the float.
/// \returns the float represented by the string or 0 on failure.
float ofToFloat(const std::string& floatString);

/// \brief Convert a string to a double.
///
/// Converts a std::string representation of a double (e.g., `"3.14"`) to an
/// actual `double`.
///
/// \param doubleString The string representation of the double.
/// \returns the double represented by the string or 0 on failure.
double ofToDouble(const std::string& doubleString);

/// \brief Convert a string to a boolean.
///
/// Converts a std::string representation of a boolean (e.g., `"TRUE"`) to an
/// actual `bool` using a case-insensitive comparison against the words `"true"`
/// and `"false"`.
///
/// \param boolString The string representation of the boolean.
/// \returns the boolean represented by the string or 0 on failure.
bool ofToBool(const std::string& boolString);

/// \brief Converts any value to its equivalent hexadecimal representation.
///
/// The hexadecimal representation corresponds to the way a number is stored in
/// memory.
///
/// \tparam T The data type of the value to convert to a hexadecimal string.
/// \param value The value to convert to a hexadecimal string.
/// \returns the hexadecimal string representation of the value.
template <class T>
std::string ofToHex(const T& value) {
	std::ostringstream out;
	// pretend that the value is a bunch of bytes
	unsigned char* valuePtr = (unsigned char*) &value;
	// the number of bytes is determined by the datatype
	int numBytes = sizeof(T);
	// the bytes are stored backwards (least significant first)
	for(int i = numBytes - 1; i >= 0; i--) {
		// print each byte out as a 2-character wide hex value
		out << std::setfill('0') << std::setw(2) << std::hex << (int) valuePtr[i];
	}
	return out.str();
}

/// \brief Convert a string to a hexadecimal string.
///
/// Converts a string (e.g., `"abc"`) to its equivalent hexadecimal
/// representation (e.g., `"616263"`).
///
/// \param value The value to convert to a hexadecimal string.
/// \returns a hexadecimal string.
template <>
std::string ofToHex(const std::string& value);

/// \brief Convert a c-style string to a hexadecimal string.
///
/// Converts a string (e.g., `"abc"`) to its equivalent hexadecimal
/// representation (e.g., `"616263"`).
///
/// \param value The value to convert to a hexadecimal string.
/// \returns a hexadecimal string.
std::string ofToHex(const char* value);

/// \brief Convert a string representing an integer in hexadecimal to a string.
///
/// Converts a hexadecimal representation of an int (little-endian, 32-bit,
/// e.g., `"0xbadf00d"` or `"badf00d"`) to an actual `int`.
///
/// \param intHexString The string representing an integer in hexadecimal.
/// \returns the integer represented by the string.
int ofHexToInt(const std::string& intHexString);

/// \brief Convert a string representing an char in hexadecimal to a char.
///
/// Converts a hexadecimal representation of an char (e.g., `"61"`) to an actual
/// `char` (e.g., `a`).
///
/// \param charHexString The string representing an char in hexadecimal.
/// \returns the char represented by the string.
char ofHexToChar(const std::string& charHexString);

/// \brief Convert a string representing an float in hexadecimal to a float.
///
/// Converts a hexadecimal representation of an float (little-endian, 32-bit
/// IEEE 754, e.g., `"43000000"`) to an actual float (e.g., `128.f`).
///
/// \param floatHexString The string representing an float in hexadecimal.
/// \returns the float represented by the string.
float ofHexToFloat(const std::string& floatHexString);

/// \brief Convert a string representing an string in hexadecimal to a string.
///
/// Converts a hexadecimal representation of an string (e.g.,
/// `"61626364656667"`) to an actual string (`"abcdefg"`).
///
/// \param stringHexString The string representing an string in hexadecimal.
/// \returns the string represented by the string.
std::string ofHexToString(const std::string& stringHexString);

/// \brief Convert a string representation of a char to a actual char.
///
/// Converts a string representation of a single char (e.g., `"c"`) to an
/// actual `char`.
///
/// \note Multi-byte chars and multi-char strings are not supported.
///
/// \param charString The char string to convert.
/// \returns The string as a char or 0 on failure.
char ofToChar(const std::string& charString);

/// \brief Converts any datatype value to a string of only 1s and 0s.
///
/// The corresponding string of 1s and 0s corresponds to the way value is stored
/// in memory.
///
/// \tparam T The data type of the value to convert to a binary string.
/// \param value The data to convert to a binary string.
/// \returns a binary string.
template <class T>
std::string ofToBinary(const T& value) {
	return std::bitset<8 * sizeof(T)>(*reinterpret_cast<const uint64_t*>(&value)).to_string();
}

/// \brief Converts a string value to a string of only 1s and 0s.
///
/// The corresponding string of 1s and 0s corresponds to the way value is stored
/// in memory.
///
/// \param value The string to convert to a binary string.
/// \returns a binary string.
template <>
std::string ofToBinary(const std::string& value);

/// \brief Converts a c-style string to a string of only 1s and 0s.
///
/// The corresponding string of 1s and 0s corresponds to the way value is stored
/// in memory.
///
/// \param value The c-style string to convert to a binary string.
/// \returns a binary string.
std::string ofToBinary(const char* value);

/// \brief Convert a binary string to an int.
///
/// Interprets a string consisting only of 1s and 0s as an int (little-endian,
/// 32-bit), and returns the corresponding int value.
///
/// \value The binary string.
/// \returns the integer represented by the string or 0 on failure.
int ofBinaryToInt(const std::string& value);

/// \brief Convert a binary string to an char.
///
/// Interprets a string consisting only of 1s and 0s as an char and returns
/// the corresponding int value.
///
/// \value The binary string.
/// \returns the char represented by the string or 0 on failure.
char ofBinaryToChar(const std::string& value);

/// \brief Convert a binary string to a float.
///
/// Interprets a string consisting only of 1s and 0s as an a float
/// (little-endian, 32-bit IEEE 754), and returns the corresponding float value.
///
/// \value The binary string.
/// \returns the float represented by the string or 0 on failure.
float ofBinaryToFloat(const std::string& value);

/// \brief Convert a binary string to ASCII characters.
///
/// Interprets a string consisting only of 1s and 0s as 8-bit ASCII characters
/// and returns the corresponding string.
///
/// \value The binary string.
/// \returns the ASCII string represented by the string.
std::string ofBinaryToString(const std::string& value);

/// \section openFrameworks Version
/// \brief Get the current version of openFrameworks as a string.
///
/// openFrameworks uses the semantic versioning system.
///
/// \sa http://semver.org/
/// \returns The string representation of the version (e.g. `0.9.0`).
std::string 	ofGetVersionInfo();

/// \brief Get the major version number of openFrameworks.
///
/// openFrameworks uses the semantic versioning system.
///
/// \sa http://semver.org/
/// \returns The major version number.
unsigned int ofGetVersionMajor();

/// \brief Get the minor version number of openFrameworks.
///
/// openFrameworks uses the semantic versioning system.
///
/// \sa http://semver.org/
/// \returns The minor version number.
unsigned int ofGetVersionMinor();

/// \brief Get the patch version number of openFrameworks.
///
/// openFrameworks uses the semantic versioning system.
///
/// \sa http://semver.org/
/// \returns The patch version number.
unsigned int ofGetVersionPatch();

/// \brief Get the pre-release version of openFrameworks.
///
/// openFrameworks uses the semantic versioning system.
///
/// For pre-release versions of openFrameworks, including development versions,
/// this string will describe the pre-release state. Examples might include
/// "master", "rc1", "rc2", etc.  For all stable releases, this string will be
/// empty.
///
/// \sa http://semver.org/
/// \returns The pre-release version string.
std::string ofGetVersionPreRelease();


/// \section Frame Saving
/// \brief Saves the current screen image to a file on disk.
///
/// Example:
/// ~~~~{.cpp}
///		ofSaveScreen("screen.png"); // Will save screen.png in the /data folder.
/// ~~~~
///
/// The output file type will be deduced from the given file name.
///
/// \param filename The image output file.
void ofSaveScreen(const std::string& filename);

/// \brief Saves the current frame as a PNG image.
///
/// The PNG image will be named according to an internal counter in sequence.
/// The count will be restarted each time the program is restarted.
///
/// \param bUseViewport Set to true if the current viewport should be used.
void ofSaveFrame(bool bUseViewport = false);

/// \brief Saves the current viewport as an image.
///
/// The output file type will be deduced from the given file name.
///
/// \param filename The image output file.
void ofSaveViewport(const std::string& filename);


/// \section System
/// \brief Launch the given URL in the default browser.
/// \param url the URL to open.
/// \param uriEncodeQuery true if the query parameters in the given URL have
/// already been URL encoded.
#ifndef TARGET_EMSCRIPTEN
void ofLaunchBrowser(const std::string& url, bool uriEncodeQuery=false);
#endif

/// \brief Executes a system command. Similar to run a command in terminal.
/// \note Will block until the executed program/command has finished.
/// \returns the system command output as string.
std::string ofSystem(const std::string& command);

/// \brief Get the target platform of the current system.
/// \returns the current ofTargetPlatform.
ofTargetPlatform ofGetTargetPlatform();

/// \brief Get the value of a given environment variable.
/// \note The available environment variables differ between operating systems.
/// \returns the environmnt variable's value or an empty string if not found.
std::string ofGetEnv(const std::string & var);

/// Allows to iterate over a string's utf8 codepoints.
/// The easiest way to use it is with a c++11 range style
/// for loop like:
///
/// for(auto c: ofUTF8Iterator(str)){
/// ...
/// }
///
/// which will iterate through all the utf8 codepoints in the
/// string.
class ofUTF8Iterator{
public:
	ofUTF8Iterator(const std::string & str);
	utf8::iterator<std::string::const_iterator> begin() const;
	utf8::iterator<std::string::const_iterator> end() const;
	utf8::iterator<std::string::const_reverse_iterator> rbegin() const;
	utf8::iterator<std::string::const_reverse_iterator> rend() const;

private:
	std::string src_valid;
};



/*! \cond PRIVATE */
namespace of{
namespace priv{
    void setWorkingDirectoryToDefault();
    void initutils();
    void endutils();
}
}
/*! \endcond */

#line 0 "../libs/openFrameworks/utils/ofFileUtils.h"
#pragma once

/* #include "ofConstants.h" */
#include <fstream>

#ifndef TARGET_QT
# if OF_USING_STD_FS
#	if __cplusplus < 201703L
#		include <experimental/filesystem>
		namespace std {
			namespace filesystem = experimental::filesystem;
		}
#	else
#		include <filesystem>
#	endif
# else
#	if !_MSC_VER
#		define BOOST_NO_CXX11_SCOPED_ENUMS
#		define BOOST_NO_SCOPED_ENUMS
#	endif
#	include <boost/filesystem.hpp>
	namespace std {
		namespace filesystem = boost::filesystem;
	}
# endif
#endif // TARGET_QT

//----------------------------------------------------------
// ofBuffer
//----------------------------------------------------------

/// \class ofBuffer
///
/// A buffer of data which can be accessed as simple bytes or text.
///
class ofBuffer{
	
public:
	ofBuffer();
	
	/// Create a buffer and set its contents from a raw byte pointer.
	///
	/// \param buffer pointer to the raw byte buffer to copy data from
	/// \param size the number of bytes to read
	/// \warning buffer *must* not be NULL
	/// \warning size *must* be <= the number of bytes allocated in buffer
    ofBuffer(const char * buffer, std::size_t size);
	
	/// Create a buffer and set its contents from an input stream.
	///
	/// \param ioBlockSize the number of bytes to read from the stream in chunks
	ofBuffer(std::istream & stream, std::size_t ioBlockSize = 1024);

	/// Set the contents of the buffer from a raw byte pointer.
	///
	/// \warning buffer *must* not be NULL
	/// \warning size *must* be <= the number of bytes allocated in buffer
	/// \param buffer pointer to the raw byte buffer to copy data from
	/// \param size the number of bytes to read
	void set(const char * buffer, std::size_t size);
	
	/// Set contents of the buffer from a string.
	///
	/// \param text string to copy data from
	void set(const std::string & text);
	
	/// Set contents of the buffer from an input stream.
	///
	/// \param stream input stream to copy data from
	/// \param ioBlockSize the number of bytes to read from the stream in chunks
	bool set(std::istream & stream, std::size_t ioBlockSize = 1024);
	
	/// Set all bytes in the buffer to a given value.
	///
	/// \param mem byte value to set
	void setall(char mem);
	
	/// Append bytes to the end of buffer from a string.
	///
	/// \param buffer string to copy bytes from
	void append(const std::string& buffer);
	
	/// Append bytes to the end of the buffer from a raw byte pointer.
	///
	/// \warning buffer *must* not be NULL
	/// \warning size *must* be <= the number of bytes allocated in buffer
	/// \param buffer pointer to the raw byte buffer to copy data from
	/// \param size the number of bytes to read
	void append(const char * buffer, std::size_t size);
	
	/// Request that the buffer capacity be at least enough to contain a
	/// specified number of bytes.
	///
	/// \param size number of bytes to reserve space for
	void reserve(std::size_t size);

	/// Write contents of the buffer to an output stream.
	bool writeTo(std::ostream & stream) const;

	/// Remove all bytes from the buffer, leaving a size of 0.
	void clear();

	/// Request that the buffer capacity be at least enough to contain a
	/// specified number of bytes.
	///
	/// \param size number of bytes to reserve space for
	void allocate(std::size_t size);
	
	/// Resize the buffer to contain a specified number of bytes.
	///
	/// If size is < the current buffer size, the contents are reduced to size
	/// bytes & remaining bytes are removed. If size is > the current buffer
	/// size, the buffer's size is increased to size_ bytes.
	///
	/// \param size number of bytes to resize the buffer to
	void resize(std::size_t size);

	/// Access the buffer's contents using a raw byte pointer.
	///
	/// \warning Do not access bytes at indices beyond size()!
	/// \returns pointer to internal raw bytes
	char * getData();
	
	/// access the buffer's contents using a const raw byte pointer.
	///
	/// \warning Do not access bytes at indices beyond size()!
	/// \returns const pointer to internal raw bytes
	const char * getData() const;
	OF_DEPRECATED_MSG("Use getData instead",char * getBinaryBuffer());
	OF_DEPRECATED_MSG("Use getData instead",const char * getBinaryBuffer() const);

	/// get the contents of the buffer as a string.
	///
	/// \returns buffer contents as a string
	std::string getText() const;
	
	/// Use buffer as a string via cast.
	///
	/// \returns buffer contents as a string
	operator std::string() const;
	
	/// set contents of the buffer from a string
	ofBuffer & operator=(const std::string & text);

	/// Check the buffer's size.
	///
	/// \returns the size of the buffer's content in bytes
	std::size_t size() const;

	OF_DEPRECATED_MSG("use a lines iterator instead",std::string getNextLine());
	OF_DEPRECATED_MSG("use a lines iterator instead",std::string getFirstLine());
	OF_DEPRECATED_MSG("use a lines iterator instead",bool isLastLine());
	OF_DEPRECATED_MSG("use a lines iterator instead",void resetLineReader());
	
	friend std::ostream & operator<<(std::ostream & ostr, const ofBuffer & buf);
	friend std::istream & operator>>(std::istream & istr, ofBuffer & buf);

	std::vector<char>::iterator begin();
	std::vector<char>::iterator end();
	std::vector<char>::const_iterator begin() const;
	std::vector<char>::const_iterator end() const;
	std::vector<char>::reverse_iterator rbegin();
	std::vector<char>::reverse_iterator rend();
	std::vector<char>::const_reverse_iterator rbegin() const;
	std::vector<char>::const_reverse_iterator rend() const;

	/// A line of text in the buffer.
	///
	struct Line: public std::iterator<std::forward_iterator_tag,Line>{
		Line(std::vector<char>::iterator _begin, std::vector<char>::iterator _end);
		const std::string & operator*() const;
		const std::string * operator->() const;
		const std::string & asString() const;
		
		/// Increment to the next line.
		Line& operator++();
		
		/// Increment to a number of lines.
		Line operator++(int);
		
		bool operator!=(Line const& rhs) const;
		bool operator==(Line const& rhs) const;
		
		 /// Is this line empty? (aka an empty string "")
		bool empty() const;

	private:
		std::string line;
		std::vector<char>::iterator _current, _begin, _end;
	};

	/// A line of text in the buffer.
	///
	struct RLine: public std::iterator<std::forward_iterator_tag,Line>{
		RLine(std::vector<char>::reverse_iterator _begin, std::vector<char>::reverse_iterator _end);
		const std::string & operator*() const;
		const std::string * operator->() const;
		const std::string & asString() const;

		/// Increment to the next line.
		RLine& operator++();

		/// Increment to a number of lines.
		RLine operator++(int);

		bool operator!=(RLine const& rhs) const;
		bool operator==(RLine const& rhs) const;

		 /// Is this line empty? (aka an empty string "")
		bool empty() const;

	private:
		std::string line;
		std::vector<char>::reverse_iterator _current, _rbegin, _rend;
	};

	/// A series of text lines in the buffer.
	///
	struct Lines{
		Lines(std::vector<char>::iterator begin, std::vector<char>::iterator end);
		
		/// Get the first line in the buffer.
		Line begin();
		
		/// Get the last line in the buffer.
		Line end();

		RLine rbegin();
		RLine rend();

	private:
		std::vector<char>::iterator _begin, _end;
	};


	/// A series of text lines in the buffer.
	///
	struct RLines{
		RLines(std::vector<char>::reverse_iterator rbegin, std::vector<char>::reverse_iterator rend);

		/// Get the first line in the buffer.
		RLine begin();

		/// Get the last line in the buffer.
		RLine end();

	private:
		std::vector<char>::reverse_iterator _rbegin, _rend;
	};

	/// Access the contents of the buffer as a series of text lines.
	///
	/// If the buffer loads a text file with lines separated by an endline
	/// char '\n', you can access each line individually using Line structs.
	///
	/// \returns buffer text lines
	Lines getLines();

	/// Access the contents of the buffer as a series of text lines in reverse
	/// order
	///
	/// If the buffer loads a text file with lines separated by an endline
	/// char '\n' or '\r\n', you can access each line individually using Line structs.
	///
	/// \returns buffer text lines
	RLines getReverseLines();

private:
	std::vector<char> 	buffer;
	Line			currentLine;
};

//--------------------------------------------------
/// Read the contents of a file at path into a buffer.
///
/// Opens as a text file by default.
///
/// \param path file to open
/// \param binary set to false if you are reading a text file & want lines
/// split at endline characters automatically
ofBuffer ofBufferFromFile(const std::filesystem::path & path, bool binary=true);

//--------------------------------------------------
/// Write the contents of a buffer to a file at path.
///
/// Saves as a text file by default.
///
/// \param path file to open
/// \param buffer data source to write from
/// \param binary set to false if you are writing a text file & want lines
/// split at endline characters automatically
bool ofBufferToFile(const std::filesystem::path & path, const ofBuffer& buffer, bool binary=true);

//--------------------------------------------------
/// \class ofFilePath
///
/// Static class for working with file path strings.
///
class ofFilePath{
public:
	
	/// Get the extension of a filename, ie. "duck.jpg" -> "jpg".
	///
	/// \param filename file path
	/// \returns filename extension only
    static std::string getFileExt(const std::filesystem::path& filename);
	
	/// Remove extension from a filename, ie. "duck.jpg" ->"duck".
	///
	/// \param filename file path
	/// \returns filename without extension
    static std::string removeExt(const std::filesystem::path& filename);
	
	/// Prepend path with a slash, ie. "images" -> "/images".
	///
	/// \param path file or directory path
	/// \returns slah + path
    static std::string addLeadingSlash(const std::filesystem::path& path);
	
	/// Append path with a slash, ie. "images" -> "images/".
	///
	/// \param path directory path
	/// \returns path + slash
    static std::string addTrailingSlash(const std::filesystem::path& path);
	
	/// Remove a path's trailing slash (if found),
	/// ie. "images/" -> "images".
	///
	/// \param path directory path
	/// \returns path minus trailing slash
    static std::string removeTrailingSlash(const std::filesystem::path& path);
	
	/// Cleaned up a directory path by adding a trailing slash if needed.
	///
	/// For Windows-style path strings using "\", a "\" will be added.
	/// For Unix-style path strings using "/", a "/" will be added.
	///
	/// \param path directory path
	/// \returns cleaned path + trailing slash (if needed)
    static std::string getPathForDirectory(const std::filesystem::path& path);
	
	/// Get the absolute, full path for a given path,
	/// ie. "images" -> "/Users/mickey/of/apps/myApps/Donald/bin/data/images".
	///
	/// \param path file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder and want the direct path without relative
	/// "../../"
	/// \returns absolute path
    static std::string getAbsolutePath(const std::filesystem::path& path, bool bRelativeToData = true);

	/// Check if a path is an absolute (aka a full path),
	/// ie. "images" -> false,
	/// "/Users/mickey/of/apps/myApps/Donald/bin/data/images" -> true.
	///
	/// \param path file or directory path
	/// \returns true if the path is an absolute path
    static bool isAbsolute(const std::filesystem::path& path);
	
	/// Get the filename of a given path by stripping the parent
	/// directories ie. "images/duck.jpg" -> "duck.jpg", assumes the path is in
	/// the data folder.
	///
	/// \param filePath file path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder and want the direct path without relative
	/// "../../"
	/// \returns filename
    static std::string getFileName(const std::filesystem::path& filePath, bool bRelativeToData = true);
	
	/// Get a file name without its extension,
	/// ie. "images/duck.jpg" -> "duck" and
	/// "images/some/folder" -> "folder"
	///
	/// \param filePath file path
	/// \returns basename
    static std::string getBaseName(const std::filesystem::path& filePath);

	/// Get the enclosing parent directory of a path,
	/// ie. "images/duck.jpg" -> "images", assumes the path is in the data
	/// directory.
	///
	/// \param filePath file path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder and want the direct path without relative
	/// "../../"
	///\returns enclosing directory
    static std::string getEnclosingDirectory(const std::filesystem::path& filePath, bool bRelativeToData = true);
	
	/// Create the enclosing parent directory of a path, ie.
	/// "images" is the enclosing directory of "duck.jpg" = "images/duck.jpg".
	///
	/// Assumes the path is in the data folder & automatically creates nested
	/// directories as required.
	///
	/// \param bRecursive set to false to override automatically nested
	/// directory creation
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder and want the direct path without relative
	/// "../../"
	/// \returns true if the enclosing directory was created
    static bool createEnclosingDirectory(const std::filesystem::path& filePath, bool bRelativeToData = true, bool bRecursive = true);
	
	/// Get the full path to the app's current working directory.
	///
	/// This may be the app's parent directory or the location the app was
	/// launched from (aka on the commandline).
	///
	/// \warning This location *may* change if you or a library calls the cd()
	/// std C function.
	/// \returns current working directory
	static std::string getCurrentWorkingDirectory();
	
	/// Create a single path by joining path1 & path2 using a slash,
	/// ie. "/hello/world" + "foo/bar" -> "/hello/world/foo/bar".
	///
	/// \param path1 left half of the path to join
	/// \param path2 right half of the path to join
	/// \returns joined path
    static std::string join(const std::filesystem::path& path1, const std::filesystem::path& path2);
	
	/// Get the full path to the application's executable file.
	///
	/// Mac: the binary within the application's .app bundle Contents/MacOS dir
	/// Windows: the .exe
	/// Linux: the binary file itself
	///
	/// \returns current executable path
	static std::string getCurrentExePath();
	
	/// Get the full path to the application's parent directory.
	///
	/// Windows & Linux: the application's parent directory
	/// Mac: the Contents/MacOS folder within the application's .app bundle
	///
	/// \returns current executable directory
	static std::string getCurrentExeDir();

	/// Get the absolute path to the user's home directory.
	///
	/// Mac OSX: /Users/<username>
	/// Windows: <root>\Users\<username>
	/// Linux: /home/<username>
	///
	/// \returns home directory path
	static std::string getUserHomeDir();

	/// Make one path relative to another,
	/// ie. the relative path of "images/felines/lions" to
	/// "images/felines/tigers" is "../tigers".
	///
	/// \param from starting path
	/// \param to destination path
	/// \returns relative path
    static std::string makeRelative(const std::filesystem::path & from, const std::filesystem::path & to);
};

/// \class ofFile
///
/// path to a file or directory
///
/// inherits from an fstream so you can read/write using the stream operators
/// once a file path has been opened
class ofFile: public std::fstream{

public:
	
	/// file access mode
	enum Mode{
		Reference,  //<
		ReadOnly,  //< read only from the file, do not write
		WriteOnly, //< write only to the file, do not read
		ReadWrite, //< read from and write to the file
		Append     //< append data to the end of the file, do not overwrite
	};

	/// Create an ofFile instance.
	///
	/// Does not refer to a specific file until you either open a file or create
	/// a file or directory path.
	ofFile();
	
	/// Create a new ofFile instance and attempt to open the path as a
	/// file.
	///
	/// Opens as a binary file with read only access by default.
	///
	/// \param path file path
	/// \param mode file access mode depending on how you plan to use the file
	/// (read only, read write, etc)
	/// \param binary set to false if you are working with a text file & want
	/// lines split at endline characters automatically
	ofFile(const std::filesystem::path & path, Mode mode=ReadOnly, bool binary=true);
	
	/// Create a new file path using the same path & settings of another
	/// file.
	///
	/// \param mom ofFile instance source
	ofFile(const ofFile & mom);
	
	/// Copy the path and settings of an ofFile into this instance.
	///
	/// \param mom ofFile instance source
	ofFile & operator= (const ofFile & mom);
	
	~ofFile();

	/// Open the path as a file.
	///
	/// Opens as a text file with read only access by default.
	///
	/// \param path file path
	/// \param mode file access mode depending on how you plan to use the file
	/// (read only, read write, etc)
	/// \param binary set to false if you are reading a text file & want lines
	/// split at endline characters automatically
	/// \returns true if the path was opened
	bool open(const std::filesystem::path & path, Mode mode=ReadOnly, bool binary=true);

	/// Open the path as a file.
	///
	/// Opens as a text file with read only access by default from the current working directory without internally calling ofToDataPath.
	///
	/// \param path file path
	/// \param mode file access mode depending on how you plan to use the file
	/// (read only, read write, etc)
	/// \param binary set to false if you are reading a text file & want lines
	/// split at endline characters automatically
	/// \returns true if the path was opened
	bool openFromCWD(const std::filesystem::path & path, Mode mode=ReadOnly, bool binary=true);
	
	/// Reopen the current file path with a different access mode.
	///
	/// \param mode file access mode depending on how you plan to use the file
	/// (read only, read write, etc)
	/// \param binary set to false if you are reading a text file & want lines
	/// split at endline characters automatically
	/// \returns true if the file was reopened with the new access mode(s).
	bool changeMode(Mode mode, bool binary=true);
	
	/// Close a currently open file.
	void close();
	
	/// Create a file at the current path.
	///
	/// Creates as a write only binary file by default.
	///
	/// \returns true if the file was created
	bool create();
	
	/// Create a file at a given path.
	///
	/// Creates as a write only binary file by default.
	///
	/// \param path file path
	/// \returns true if the file was created
	bool create(const std::filesystem::path & path);
	
	/// Check if a file exists at the current path.
	///
	/// \returns true if the file exists
	bool exists() const;
	
	/// Get the current path.
	///
	/// \returns current path
	std::string path() const;
	
	/// Get the current path without its extension,
	/// ie. "duck.jpg" ->"duck".
	///
	/// \returns current path file extension
	std::string getExtension() const;
	
	/// Get the filename of the current path by stripping the parent
	/// directories, ie. "images/duck.jpg"  -> "duck.jpg".
	///
	/// \returns current path filename
	std::string getFileName() const;
	
	/// \biref Get the current path without its last component,
	/// ie. "images/duck.jpg" -> "images" and
	/// "images/some/folder" -> "images/some".
	///
	/// \returns current path basename
	std::string getBaseName() const;
	
	/// Get the enclosing parent directory of a path,
	/// ie. "images/duck.jpg" -> "images", assumes the path is in the data
	/// directory.
	///
	/// \returns current path's enclosing directory
	std::string getEnclosingDirectory() const;
	
	/// \biref Get the absolute, full path of the file,
	/// ie. "images" -> "/Users/mickey/of/apps/myApps/Donald/bin/data/images".
	///
	/// \returns current path as an absolute path
	std::string getAbsolutePath() const;

	/// Check if the current path is readable.
	///
	/// \returns true if readable
	bool canRead() const;
	
	/// Check if the current path is writable.
	///
	/// \returns true if writable
	bool canWrite() const;
	
	/// Check if the current path is executable.
	///
	/// \returns true if executable
	bool canExecute() const;

	/// Check if the current path is a file and not a directory.
	///
	/// \returns true if a file
	bool isFile() const;
	
	/// Check if the current path is a system link to another file or
	/// directory.
	///
	/// \returns true if a system link
	bool isLink() const;
	
	/// Check if the current path is a directory and not a file.
	///
	/// \returns true if a directory
	bool isDirectory() const;
	
	/// Check if the current path is a device file.
	///
	/// Works on Mac & Linux which can represent devices as files, however
	/// always returns false on Windows.
	///
	/// \returns true if a device file
	bool isDevice() const;
	
	/// Check if the current path is hidden.
	///
	/// Works on Mac & Linux which denote hidden files by prepending a period
	/// to the filename -> ".hello", however always returns false on Windows.
	///
	/// \returns true if hidden
	bool isHidden() const;

	/// Set the writable flag of the current path.
	void setWriteable(bool writeable=true);

	OF_DEPRECATED_MSG("Use ofFile::setWriteable(!flag).", void setReadOnly(bool flag));
	
	/// Set the readable flag of the current path.
	void setReadable(bool readable=true);
	
	/// Set the executable flag of the current path.
	void setExecutable(bool executable=true);
	
	/// Copy the current file or directory path to a new path.
	///
	/// Copies relative to the data path & does *not* overwrite by default
	/// does not change the current path & assumes the new path is in the data
	/// folder.
	///
	/// \param path destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \returns true if the copy was successful
	bool copyTo(const std::filesystem::path& path, bool bRelativeToData = true, bool overwrite = false) const;
	
	/// Move the current file or directory path to a new path.
	///
	/// Moves relative to the data path & does *not* overwrite by default
	/// does not change the current path & assumes the new path is in the data
	/// folder.
	///
	/// \param path destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \returns true if the copy was successful
	bool moveTo(const std::filesystem::path& path, bool bRelativeToData = true, bool overwrite = false);
	
	/// Rename the current file or directory path to a new path.
	///
	/// Renames relative to the data path & does *not* overwrite by default
	/// does not change the current path & assumes the new path is in the data
	/// folder.
	///
	/// \param path destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \returns true if the copy was successful
	bool renameTo(const std::filesystem::path& path, bool bRelativeToData = true, bool overwrite = false);
	
	/// Removes the file or directory at the current path.
	///
	/// Does not remove non-empty directories by default.
	///
	/// \warning Be careful! This deletes a file or folder. :)
	/// \param recursive set to true to remove a non-empty directory and its
	/// contents
	/// \returns true if the path was removed successfully
	bool remove(bool recursive=false);

	/// get the size of the file at the current file path
	///
	/// \returns size in bytes
	uint64_t getSize() const;

	// this allows to compare files by their paths, also provides sorting
	// and use as key in stl containers
	bool operator==(const ofFile & file) const;
	bool operator!=(const ofFile & file) const;
	bool operator<(const ofFile & file) const;
	bool operator<=(const ofFile & file) const;
	bool operator>(const ofFile & file) const;
	bool operator>=(const ofFile & file) const;

	//------------------
	// stream operations
	//------------------

	// since this class inherits from fstream it can be used as a r/w stream:
	// http://www.cplusplus.com/reference/iostream/fstream/
	
	/// Read the contents of a file at the current path into a buffer.
	///
	/// \returns buffer with file contents
	ofBuffer readToBuffer();
	
	/// Write the contents of a buffer into a file at the current path.
	///
	/// \param buffer source byte buffer
	/// \returns true if buffer's contents written successfully
	bool writeFromBuffer(const ofBuffer & buffer);
	
	/// Read the entire contents of the currently opened file into an
	/// output stream.
	///
	/// This is basically an easy to use equivalent to rdbuf():
	/// ie. ofLogNotice() << file.getFileBuffer();
	///     write_file << file.getFileBuffer();
	///
	/// \return output stream
	std::filebuf * getFileBuffer() const;
	
	operator std::filesystem::path(){
		return myFile;
	}

	operator const std::filesystem::path() const{
		return myFile;
	}

	//-------
	//static helpers
	//-------

	/// Copy source path to destination path.
	///
	/// Copies relative to the data path & does *not* overwrite by default
	/// assumes the source & destination path is in the data directory.
	///
	/// \param pathSrc source file or directory path
	/// \param pathDst destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data directory
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \returns true if the copy was successful
	static bool copyFromTo(const std::filesystem::path& pathSrc, const std::filesystem::path& pathDst, bool bRelativeToData = true,  bool overwrite = false);

	/// Move source path to destination path.
	///
	/// Moves relative to the data path & does *not* overwrite by default
	/// assumes the source & destination path is in the data directory.
	///
	/// \param pathSrc source file or directory path
	/// \param pathDst destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \warning be careful with slashes here, appending a slash when moving a
	/// folder may cause mad headaches in OSX
	/// \returns true if the move was successful
	static bool moveFromTo(const std::filesystem::path& pathSrc, const std::filesystem::path& pathDst, bool bRelativeToData = true, bool overwrite = false);
	
	/// Check if a file or directory exists at a given path.
	///
	/// \param fPath file path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder and want the direct path without relative
	/// "../../"
	/// \returns true if a file or directory exists
	static bool doesFileExist(const std::filesystem::path& fPath,  bool bRelativeToData = true);
	
	/// Remove a file or directory at a given path.
	///
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder and want the direct path without relative
	/// "../../"
	/// \returns true if the path was removed successfully
	static bool removeFile(const std::filesystem::path& path, bool bRelativeToData = true);

private:
	bool isWriteMode();
	bool openStream(Mode _mode, bool binary);
	void copyFrom(const ofFile & mom);
	std::filesystem::path myFile;
	Mode mode;
	bool binary;
};

/// \class ofDirectory
///
/// Path to a directory. Can be used to query file and directory
/// contents.
///
class ofDirectory{

public:

	/// Create an ofDirectory instance
	///
	/// Does not refer to a specific directory until you either open or create
	/// a directory path.
	ofDirectory();
	
	/// Create an ofDirectory instance and attempt to open the path.
	///
	/// \param path directory path
	ofDirectory(const std::filesystem::path & path);

	/// Open a directory path, clears the current file list.
	///
	/// \param path directory path
	void open(const std::filesystem::path & path);
	
	/// Open a directory path relative to the current working directory without calling ofToDataPath internally, clears the current file list.
	///
	/// \param path directory path
	void openFromCWD(const std::filesystem::path & path);
	
	/// Close the currently open path.
	void close();
	
	/// Create a directory at the current path.
	///
	/// \param bRecursive set to true to automatically create nested directories
	/// as required
	bool create(bool recursive = false);

	/// Check if a directory exists at the current path.
	///
	/// \returns true if exists
	bool exists() const;
	
	/// Get the current path.
	///
	/// \returns current path
	std::string path() const;
	
	/// Get the absolute, full path of the directory,
	/// ie. "images" -> "/Users/mickey/of/apps/myApps/Donald/bin/data/images".
	///
	/// \return current path as an absolute path
	std::string getAbsolutePath() const;

	/// Check if the current path is readable.
	///
	/// \returns true if readable
	bool canRead() const;
	
	/// Check if the current path is writeable.
	///
	/// \returns true if writable
	bool canWrite() const;
	
	/// Check if the current path is executable.
	///
	/// \returns true if executable
	bool canExecute() const;
	
	/// Check if the current path is indeed a directory and not a file.
	///
	/// \returns true if a directory
	bool isDirectory() const;
	
	/// Check if the current path is hidden.
	///
	/// Works on Mac & Linux which denote hidden directories by prepending
	/// a period -> ".hello", however always returns false on Windows.
	///
	/// \returns true if hidden
	bool isHidden() const;

	/// Set the writable flag of the current path.
	///
	/// \param writable set to true to make path writable
	void setWriteable(bool writeable=true);

	OF_DEPRECATED_MSG("Use ofDirectory::setWriteable(!flag).", void setReadOnly(bool flag));
	
	/// Set the readable flag of the current path.
	///
	/// \param readable set to true to make path readable
	void setReadable(bool readable=true);
	
	/// Set the executable flag of the current path.
	///
	/// \param executable set to true to make path executable
	void setExecutable(bool executable=true);
	
	/// Show hidden files & directories when listing files?
	///
	/// Mac & Linux denote hidden directories by prepending a period
	/// -> ".hello".
	///
	/// \param showHidden set to true to show hidden files
	void setShowHidden(bool showHidden);

	/// Copy the current file or directory path to a new path.
	///
	/// Copies relative to the data path & does *not* overwrite by default
	/// does not change the current path & assumes the new path is in the data
	/// directory.
	///
	/// \param path destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data directory
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \returns true if the copy was successful
	bool copyTo(const std::filesystem::path& path, bool bRelativeToData = true, bool overwrite = false);
	
	/// Move the current file or directory path to a new path.
	///
	/// Moves relative to the data path & does *not* overwrite by default
	/// does not change the current path & assumes the new path is in the data
	/// directory.
	///
	/// \param path destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data directory
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \returns true if the copy was successful
	bool moveTo(const std::filesystem::path& path, bool bRelativeToData = true, bool overwrite = false);
	
	/// Rename the current file or directory path to a new path.
	///
	/// Renames relative to the data path & does *not* overwrite by default
	/// does not change the current path & assumes the new path is in the data
	/// directory.
	///
	/// \param path destination file or directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data folder
	/// \param overwrite set to true if you want to overwrite the file or
	/// directory at the new path
	/// \returns true if the copy was successful
	bool renameTo(const std::filesystem::path& path, bool bRelativeToData = true, bool overwrite = false);
	
	/// Removes the file or directory at the current path.
	///
	/// Does not remove non-empty directories by default.
	///
	/// \warning Be careful! This deletes a file or folder. :)
	/// \param recursive set to true to remove a non-empty directory and its
	/// contents
	/// \returns true if the path was removed successfully
	bool remove(bool recursive);

	//-------------------
	// dirList operations
	//-------------------
	
	/// Allow a file extension when listing the contents the current
	/// directory path.
	///
	/// Setting an allowed extension enables a whitelist mode which only lists
	/// extensions which have been explicitly allowed.
	///
	/// \param extension file type extension ie. "jpg", "png", "txt", etc
	void allowExt(const std::string& extension);
	
	/// Open and read the contents of a directory.
	///
	/// Uses allowed extension whitelist to ignore unwanted file types if
	/// allowExt() has been called.
	///
	/// \param path directory path
	/// \returns number of paths found
	std::size_t listDir(const std::string& path);
	
	/// Open and read the contents of the current directory.
	///
	/// Uses allowed extension whitelist to ignore unwanted file types if
	/// allowExt() has been called.
	///
	/// \returns number of paths found
	std::size_t listDir();

	/// \returns the current path
	std::string getOriginalDirectory() const;
	
	/// Get the filename at a given position in the directory contents
	/// list, ie. "duck.jpg".
	///
	/// \warning Call listDir() before using this function or the directory
	/// contents list will be empty.
	/// \throws Throws an out of bounds exception if position >= the number of
	/// listed directory contents.
	/// \param position array index in the directory contents list
	/// \returns file or directory name
	std::string getName(std::size_t position) const;
	
	/// Get the full path of the file or directory at a given position in
	/// the directory contents list.
	///
	/// \warning Call listDir() before using this function or the directory
	/// contents list will be empty.
	/// \throws Throws an out of bounds exception if position >= the number of
	/// listed directory contents.
	/// \param position array index in the directory contents list
	/// \returns file or directory name including the current path
	std::string getPath(std::size_t position) const;
	
	/// Open an ofFile instance using the path a given position in the
	/// directory contents list.
	///
	/// Opens as a binary file with readonly access by default.
	///
	/// \warning Call listDir() before using this function or the directory
	/// contents list will be empty.
	/// \throw Throws an out of bounds exception if position >= the number of
	/// listed directory contents.
	/// \param position array index in the directory contents list
	/// \param mode file access mode depending on how you plan to use the file
	/// (read only, read write, etc)
	/// \param binary set to false if you are working with a text file & want
	/// lines split at endline characters automatically
	/// \returns ofFile instance
	ofFile getFile(std::size_t position, ofFile::Mode mode=ofFile::Reference, bool binary=true) const;
	
	/// Get files and directories in the directory contents list.
	///
	/// Directory contents are automatically listed.
	///
	/// \returns vector of files in the directory
	const std::vector<ofFile> & getFiles() const;

	/// Access directory contents via th array operator.
	///
	/// \warning Call listDir() before using this function or the directory
	/// contents list will be empty.
	/// \throw Throws an out of bounds exception if position >= the number of
	/// listed directory contents.
	/// \param position array index in the directory contents list
	/// \returns opened ofFile instance
	ofFile operator[](std::size_t position) const;

	/// Check whether hidden files & directories are included when
	/// listing files.
	///
	/// Mac & Linux denote hidden directories by prepending a period
	/// -> ".hello".
	///
	/// \returns true if hidden files are shown
	bool getShowHidden() const;

	/// Closes the directory.
	///
	/// This is for backwards compatibility with ofxDirList.
	void reset();
	
	/// Sort the directory contents list alphabetically.
	///
	/// \warning Call listDir() before using this function or there will be
	/// nothing to sort.
	void sort();
	
	/// Sort the directory contents list by date.
	///
	/// \warning Call listDir() before using this function or there will be
	/// nothing to sort.
	void sortByDate();

	/// Get a sorted ofDirectory instance using the current path.
	///
	/// \returns sorted ofDirectory instance
	ofDirectory getSorted();

	/// Get the number of paths in the current directory list.
	///
	/// \warning Call listDir() before using this function or it will return 0
	/// since the directory list will be empty.
	/// \returns number of paths
	std::size_t size() const;

	OF_DEPRECATED_MSG("Use size() instead.", int numFiles());

	// this allows to compare directories by their paths, also provides sorting
	// and use as key in stl containers
	bool operator==(const ofDirectory & dir) const;
	bool operator!=(const ofDirectory & dir) const;
	bool operator<(const ofDirectory & dir) const;
	bool operator<=(const ofDirectory & dir) const;
	bool operator>(const ofDirectory & dir) const;
	bool operator>=(const ofDirectory & dir) const;

	operator std::filesystem::path(){
		return myDir;
	}

	operator const std::filesystem::path() const{
		return myDir;
	}

	//-------
	// static helpers
	//-------

	/// Create a directory at a given path.
	///
	/// Creates relative to the data path by default.
	///
	/// \param dirPath directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data directory
	/// \param bRecursive set to true to automatically create nested directories
	/// as required
	/// \returns true if directory was created successfully
	static bool createDirectory(const std::filesystem::path& dirPath, bool bRelativeToData = true, bool recursive = false);
	
	/// Check if a directory at a given path is empty.
	///
	/// Assumes directory path is relative to the data path by default.
	///
	/// \param dirPath directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data directory
	/// \returns true if the directory is empty aka contains no files or
	/// directories
	static bool isDirectoryEmpty(const std::filesystem::path& dirPath, bool bRelativeToData = true );
	
	/// Check if a directory exists at a given path.
	///
	/// Assumes directory path is relative to the data path by default.
	///
	/// \param dirPath directory path
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data directory
	/// \returns true if the directory exists
	static bool doesDirectoryExist(const std::filesystem::path& dirPath, bool bRelativeToData = true);
	
	
	/// remove a directory at a given path
	///
	/// \param deleteIfNotEmpty set to true if you want to recursively delete
	/// the directory *and* its contents
	/// \param bRelativeToData set to false if you are working with paths that
	/// are *not* in the data directory
	/// \returns true if the path was removed successfully
	static bool removeDirectory(const std::filesystem::path& path, bool deleteIfNotEmpty,  bool bRelativeToData = true);

	std::vector<ofFile>::const_iterator begin() const;
	std::vector<ofFile>::const_iterator end() const;
	std::vector<ofFile>::const_reverse_iterator rbegin() const;
	std::vector<ofFile>::const_reverse_iterator rend() const;

private:
	std::filesystem::path myDir;
	std::string originalDirectory;
	std::vector <std::string> extensions;
	std::vector <ofFile> files;
	bool showHidden;

};

#line 0 "../libs/openFrameworks/utils/ofTimer.h"
#pragma once
/* #include "ofConstants.h" */
/* #include "ofUtils.h" */

class ofTimer {
public:
	
	/// \brief Constructs the default ofTimer().
	ofTimer();

	/// \brief  Reset the starting instant of the periodic event to now.
	void reset();
	
	/// \brief Sets the frequency in \p nanoseconds that events happen.
	/// 
	/// The timer will begin calculating the events beginning the moment
	/// the function is called.
	/// \param nanoseconds The number of nanoseconds between events.
	void setPeriodicEvent(uint64_t nanoseconds);
	
	/// \brief Sleep this thread until the next periodic event.
	void waitNext();
private:
	void calculateNextPeriod();
	std::chrono::nanoseconds nanosPerPeriod;
#if defined(TARGET_WIN32)
	LARGE_INTEGER nextWakeTime;
	HANDLE hTimer;
#else
	ofTime nextWakeTime;
#endif
};


#line 0 "../libs/openFrameworks/utils/ofLog.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofFileUtils.h" */
#include <sstream>

/// \file
/// ofLog provides an interface for writing text output from your app.
/// It's basically a more useful version of `std::cout` or `printf` where
/// the output can be filtered and written to the console a file, or even a
/// custom logging module.
///
/// Sometimes you want to be able to see when something has happened inside
/// the code, but don't need to draw something visually. Oftentimes it's
/// more then enough to print out the state of a few variables when debugging.
/// Other times you need to know if a crash happened while your app was
/// running somewhere, so you log messages and variables to a file you can
/// read after the program crashes.
///
/// ### Log Levels
/// You can set the logging level so only messages above a certain level
/// are shown. This is useful if you want see lots of messages when debugging,
/// but then set a higher level so only warnings and errors appear for users.
///
/// See ofSetLogLevel(ofLogLevel level) for more details.
///
/// ### Usage
/// There are 2 ways you can use ofLog:
///
/// #### Functional: as a function taking a message
///
/// ~~~~{.cpp}
/// // Send a single string message, setting the log level.
/// ofLog(OF_LOG_NOTICE, "the number is " + ofToString(10));
/// 
/// // The legacy printf style.
/// ofLog(OF_LOG_NOTICE, "the number is %d", 10); 
/// ~~~~
///
/// #### Stream: as a stream using the << stream operator
///
/// ~~~~{.cpp}
/// // The stream style, setting the log level to OF_LOG_WARNING.
/// ofLog(OF_LOG_WARNING) << "the number is " << 10;
///
/// // This is the same as the last line, except it uses the default OF_LOG_NOTICE.
/// ofLog() << "the number is " << 10;
/// 
/// // There are also log level-specific stream objects, one for each level
/// // except OF_LOG_SILENT.
/// ofLogVerbose() << "A verbose message."
/// ofLogNotice() << "A regular notice message.";
/// ofLogWarning() << "Uh oh, a warning!";
/// ofLogError() << "Oh no, an error occurred!";
/// ofLogFatalError() << "Accckkk, a fatal error!!";
/// ~~~~
/// 
/// **Note**: The log level specific stream objects also take a string argument 
/// for the "module". A module is a string that is added to the beginning of 
/// the log line and can be used to separate logging messages by setting an 
/// independent log level for **that module only**. This module-specific log
/// level has no effect on other modules.
/// 
/// See ofSetLogLevel(string module, ofLogLevel level) for more details.
/// 
/// Example of logging to a specific module:
/// ~~~~{.cpp}
/// // log to a module called "Hello"
/// ofLogWarning("Hello") << "A warning message.";
/// ~~~~
///
/// **Warning**: It is important to understand that the log level specific
/// stream objects take the module name as an argument and the log messages via
/// the << operator. Putting your message as a string argument inside the
/// parentheses uses that message as a *module* and so nothing will be printed:
/// 
/// ~~~~{.cpp}
/// // This prints a warning message.
/// ofLogWarning() << "A warning message.";
///
/// // !!! This does not print a message because the string "a warning print"
/// // is the module argument !!!
/// ofLogWarning("A warning print");
/// 
/// // This prints a warning message to the "Hello" module.
/// ofLogWarning("Hello") << "A warning message.";
/// ~~~~
/// 
/// ####Log Message Redirection
/// 
/// It's useful to be able to record log messages to a file or send them to a 
/// custom destination.
///
/// For log redirection see
/// - ofLogToFile()
/// - ofLogToConsole()
/// - ofSetLoggerChannel()


/// \cond INTERNAL
/// printf annotations for automatic format checking in GCC.
#ifdef __GNUC__
#define OF_PRINTF_ATTR(x, y) __attribute__ ((format (printf, x, y)))
#else
#define OF_PRINTF_ATTR(x, y)
#endif
/// \endcond


//--------------------------------------------------
/// \name Global logging level
/// \{

/// \brief The supported logging levels. Default is `OF_LOG_NOTICE`.
enum ofLogLevel: short{
	OF_LOG_VERBOSE,
	OF_LOG_NOTICE,
	OF_LOG_WARNING,
	OF_LOG_ERROR,
	OF_LOG_FATAL_ERROR,
	OF_LOG_SILENT	// OF_LOG_SILENT can be used to disable _all_ log messages.
					// All logging can be disabled by calling
					/// ofSetLogLevel(OF_LOG_SILENT).
};

//--------------------------------------------
//console colors for our logger - shame this doesn't work with the xcode console
#ifdef TARGET_WIN32

	#define OF_CONSOLE_COLOR_RESTORE (0 | (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE) )
	#define OF_CONSOLE_COLOR_BLACK (0)
	#define OF_CONSOLE_COLOR_RED (FOREGROUND_RED)
	#define OF_CONSOLE_COLOR_GREEN (FOREGROUND_GREEN)
	#define OF_CONSOLE_COLOR_YELLOW (FOREGROUND_RED|FOREGROUND_GREEN)
	#define OF_CONSOLE_COLOR_BLUE (FOREGROUND_BLUE)
	#define OF_CONSOLE_COLOR_PURPLE (FOREGROUND_RED | FOREGROUND_BLUE )
	#define OF_CONSOLE_COLOR_CYAN (FOREGROUND_GREEN | FOREGROUND_BLUE)
	#define OF_CONSOLE_COLOR_WHITE (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)

#else

	#define OF_CONSOLE_COLOR_RESTORE (0)
	#define OF_CONSOLE_COLOR_BLACK (30)
	#define OF_CONSOLE_COLOR_RED (31)
	#define OF_CONSOLE_COLOR_GREEN (32)
	#define OF_CONSOLE_COLOR_YELLOW (33)
	#define OF_CONSOLE_COLOR_BLUE (34)
	#define OF_CONSOLE_COLOR_PURPLE (35)
	#define OF_CONSOLE_COLOR_CYAN (36)
	#define OF_CONSOLE_COLOR_WHITE (37)

#endif


/// \brief Sets the logging level to selectively show log messages.
///
/// This is useful if you want see lots of messages when debugging,
/// but then set a higher level so only warnings and errors appear for users.
///
/// ofLogLevel values in order from lowest to highest level are:
/// - `OF_LOG_VERBOSE` (lowest level)
/// - `OF_LOG_NOTICE`
/// - `OF_LOG_WARNING`
/// - `OF_LOG_ERROR`
/// - `OF_LOG_FATAL_ERROR`
/// - `OF_LOG_SILENT` (highest level)
///
/// Thus, setting a log level of `OF_LOG_ERROR`, means only logging messages
/// marked OF_LOG_ERROR and OF_LOG_FATAL_ERROR will be printed. Conversely,
/// setting OF_LOG_VERBOSE means all log level messages, including
/// OF_LOG_VERBOSE, will be printed.  Finally, setting a log level of
/// OF_LOG_SILENT will prevent any messages from being printed.
///
/// The default ofLogLevel is `OF_LOG_NOTICE`.
///
/// \param level the ofLogLevel (and below) you want to show
void ofSetLogLevel(ofLogLevel level);


/// \brief Set the logging level for a specific module.
///
/// When a module name is supplied to ofSetLogLevel, the provided ofLogLevel
/// is selectively applied only to ofLog messages marked with the specified
/// module.
///
/// This is particularly useful when the user desires to, for example, log at
/// an OF_LOG_VERBOSE level for one module and then log at OF_LOG_ERROR for
/// another module.
///
/// Example of logging to a specific module:
///
/// ~~~~{.cpp}
/// // Set the default log level for all logging.
/// ofSetLogLevel(OF_LOG_ERROR);
///
/// // Selectively enable verbose logging for the MyClass module.
/// ofSetLogLevel("MyClass", OF_LOG_VERBOSE);
///
/// // If we then log the following ...
///
/// // Log a vermose message to a module called "MyClass".
/// ofLogVerbose("MyClass") << "A verbose message from MyClass.";
///
/// // Log a verbose message to a module called "MyOtherClass".
/// ofLogVerbose("MyOtherClass") << "A verbose message from MyOtherClass.";
///
/// // In this case, we will see the verbose message from "MyClass", but not
/// // the message from "MyOtherClass".
/// ~~~~
void ofSetLogLevel(std::string module, ofLogLevel level);

/// \brief Get the currently set global logging level.
/// \returns The currently set global logging level.
ofLogLevel ofGetLogLevel();

/// \brief Get the logging level for a specific module.
/// \param module specific module name.
/// \returns The currently set specific module logging level.
ofLogLevel ofGetLogLevel(std::string module);

/// \brief Get log level name as a string.
/// \param level The ofLogLevel you want as a string.
/// \param pad True if you want all log level names to be the same length.
/// \returns The log level name as a string.
std::string ofGetLogLevelName(ofLogLevel level, bool pad=false);

/// \}

//--------------------------------------------------
/// \name Global logger channel
/// \{

class ofBaseLoggerChannel;

/// \brief Set the logging to output to a file instead of the console.
/// \param path The path to the log file to use.
/// \param append True if you want to append to the existing file.
void ofLogToFile(const std::filesystem::path & path, bool append=false);

/// \brief Set the logging to ouptut to the console.
/// 
/// This is the default state and can be called to reset console logging
/// after ofLogToFile or ofSetLoggerChannel has been called.
void ofLogToConsole();

#ifdef TARGET_WIN32
/// Set the logging to ouptut to windows debug view or visual studio console
/// 
/// This is the default state and can be called to reset console logging
/// after ofLogToFile or ofSetLoggerChannel has been called.
void ofLogToDebugView();
#endif

/// \brief Set the logger to use a custom logger channel.
///
/// Custom logger channels must extend ofBaseLoggerChannel. Custom log channels
/// can be useful for combining logging methods, logging to a server, logging
/// to email or even Twitter.
///
/// \param loggerChannel A shared pointer to the logger channel.
void ofSetLoggerChannel(std::shared_ptr<ofBaseLoggerChannel> loggerChannel);

/// \brief Get the current logger channel.
std::shared_ptr<ofBaseLoggerChannel> ofGetLoggerChannel();

/// \}

/// \class ofLog
/// \brief A C++ stream-style logging interface.
///
/// ofLog accepts variables via the std::ostream operator << and builds a string
/// and logs it when the stream is finished (via the destructor). A newline is
/// printed automatically and all the stream controls (std::endl, std::flush,
/// std::hex, etc) work normally. The default log level is `OF_LOG_NOTICE`.
///
/// Basic usage:
///
/// ~~~~{.cpp}
///
/// ofLog() << "My integer is " << 100 << " and my float is " << 20.234f;
///
/// ~~~~
///
/// It also accepts the legacy ofLog interface:
/// ofLog(ofLogLevel level, string message):
///
/// ~~~~{.cpp}
///
/// ofLog(OF_LOG_ERROR, "Another string.");
///
/// ~~~~
///
/// \author Dan Wilcox <danomatika@gmail.com> danomatika.com

// Class idea from http://www.gamedev.net/community/forums/topic.asp?topic_id=525405&whichpage=1&#3406418
// How to catch std::endl (which is actually a func pointer) http://yvan.seth.id.au/Entries/Technology/Code/std__endl.html

class ofLog{
	public:
	
		/// \name Logging
		/// \{

		/// \brief Start logging on notice level.
		/// 
		/// ofLog provides a streaming log interface by accepting variables via
		/// the `std::ostream` operator `<<` similar to `std::cout` and
		/// `std::cerr`.
		/// 
		/// It builds a string and logs it when the stream is finished. A
		/// newline is printed automatically and all the stream controls
		/// (`std::endl`, `std::flush`, `std::hex`, etc)
		/// work normally.
		/// 
		/// ~~~~{.cpp}
		/// 
		/// // Converts primitive types (int, float, etc) to strings automatically.
		/// ofLog() << "a string " << 100 << 20.234f;
		/// 
		/// ~~~~
		/// 
		/// The log level is `OF_LOG_NOTICE` by default.
		ofLog();
		
		/// \brief Start logging on a specific ofLogLevel.
		/// 
		/// Example:
		/// ~~~~{.cpp}
		/// 
		/// // Set the log level.
		/// ofLog(OF_LOG_WARNING) << "a string " << 100 << 20.234f;
		/// 
		/// ~~~~
		/// 
		/// You can use the derived convenience classes as an alternative for specific log levels: 
		/// 
		/// 	ofLogVerbose()
		/// 	ofLogNotice()
		/// 	ofLogWarning()
		/// 	ofLogError()
		/// 	ofLogFatalError()
		/// 
		/// ~~~~{.cpp}
		/// 
		/// // Set the log level.
		/// ofLog(OF_LOG_WARNING) << "a string " << 100 << 20.234f;
		/// 
		/// // This is the same as above.
		/// ofLogWarning() << "a string " << 100 << 20.234f;
		/// 
		/// ~~~~
		///
		/// \param level The ofLogLevel for this log message.
		ofLog(ofLogLevel level);
	
	
		/// \brief Log a string at a specific log level.
		/// 
		/// Supply the logging message as a parameter to the function
		/// instead of as a stream.
		/// 
		/// The string message can be concatenated using the
		/// ofToString(const T& value) conversion function:
		/// 
		/// ~~~~{.cpp}
		/// 
		/// // Build a single string message.
		/// ofLog(OF_LOG_NOTICE, "the number is " 
		/// + ofToString(10) + " and I have a float too " + ofToString(123.45f));
		/// 
		/// ~~~~
		///
		/// \param level The ofLogLevel for this log message.
		/// \param message The log message.
		ofLog(ofLogLevel level, const std::string & message);

		/// \brief Logs a message at a specific log level using the printf interface.
		///
		/// The message is built using the formatting from the C printf function
		/// and can be used as a direct replacement. Essentially, the second
		/// argument is a string with special formatting specifiers starting
		/// with '%' that specify where the following variables go in the
		/// message. You can have as many variables as you want following the
		/// logLevel and format string, but there must be a % specifier for each
		/// subsequent variable.
		/// 
		/// For quick reference, here are a few of the most useful formatting
		/// specifiers:
		/// 
		/// * `%d`: integer number, `123`
		/// * `%f`: floating point number, `123.45`
		/// * `%s`: a C string ([null terminated](http://en.wikipedia.org/wiki/Null-terminated_string)); 
		/// this is not a C++ string, use [string::c_str()](http://www.cplusplus.com/reference/string/string/c_str/) 
		/// to get a C string from a C++ string
		/// * `%c`: a single character
		/// * `%x`: unsigned integer as a [hexidecimal](http://en.wikipedia.org/wiki/Hexadecimal) 
		/// number; `x` uses lower-case letters and `X` uses upper-case
		/// * `%%`: prints a `%` character
		/// 
		/// The specifier should match the variable type as it is used to tell
		/// the function how to convert that primitive type (int, float,
		/// character, etc) into a string.
		/// 
		/// For instance, let's say we want to print two messages, a salutation
		/// and the value of an int, a float, and a string variable:
		/// 
		/// ~~~~{.cpp}
		/// 
		/// // Print a simple message with no variables.
		/// ofLog(OF_LOG_WARNING, "Welcome to the jungle.");
		/// 
		/// // Our variables.
		/// float fun = 11.11;
		/// int games = 100;
		/// string theNames = "Dan, Kyle, & Golan";
		/// 
		/// // Print a message with variables, sets the message format in the
		/// // format string.
		/// ofLog(OF_LOG_NOTICE, "we've got %d & %f, we got everything you want honey, we know %s", fun, games, theNames.c_str());
		/// 
		/// ~~~~
		/// 
		/// Note: `theNames.c_str()` returns a C string from theNames which is
		/// a C++ string object.
		/// 
		/// There are other formatting options such as setting the decimal
		/// precision of float objects and the forward padding of numbers
		/// (i.e. 0001 instead of 1). See the [Wikipedia printf format string
		/// article](http://en.wikipedia.org/wiki/Printf_format_string) for more
		/// detailed information.
		///
		/// \param level The ofLogLevel for this log message.
		/// \param format The printf-style format string.
		ofLog(ofLogLevel level, const char* format, ...) OF_PRINTF_ATTR(3, 4);
		
		/// \}
	
		//--------------------------------------------------
		/// \name Logging configuration
		/// \{

		/// \brief Let the logger automaticly add spaces between messages.
		///
		/// Default is `false`.
		///
		/// \param autoSpace Set to true to add spaces between messages
		static void setAutoSpace(bool autoSpace);
	
		/// \brief Set the logging channel destinations for messages.
		///
		/// This can be used to output to files instead of stdout.
		///
		/// \sa ofFileLoggerChannel ofConsoleLoggerChannel
		/// \param channel The channel to log to.
		static void setChannel(std::shared_ptr<ofBaseLoggerChannel> channel);
	
		/// \brief Get the current logging channel.
		static std::shared_ptr<ofBaseLoggerChannel> getChannel();
	
		/// \}

	
		/// \cond INTERNAL
	
		/// \brief Destroy the ofLog.
		///
		/// This destructor does the actual printing via std::ostream.
		virtual ~ofLog();
		
		/// \brief Define flexible stream operator.
		///
		/// This allows the class to use the << std::ostream to read data of
		/// almost any type.
		///
		/// \tparam T the data type to be streamed.
		/// \param value the data to be streamed.
		/// \returns A reference to itself.
		template <class T> 
		ofLog& operator<<(const T& value){
			message << value << getPadding();
			return *this;
		}
	
		/// \brief Define flexible stream operator.
		///
		/// This allows the class to use the << std::ostream to catch function
		/// pointers such as std::endl and std::hex.
		///
		/// \param func A function pointer that takes a std::ostream as an argument.
		/// \returns A reference to itself.
		ofLog& operator<<(std::ostream& (*func)(std::ostream&)){
			func(message);
			return *this;
		}
	
		/// \endcond
	
	

	
	protected:
		/// \cond INTERNAL

		ofLogLevel level; ///< Log level.
		bool bPrinted;	  ///< Has the message been printed in the constructor?
		std::string module;    ///< The destination module for this message.
		
		/// \brief Print a log line.
		/// \param level The log level.
		/// \param module The target module.
		/// \param message The log message.
		void _log(ofLogLevel level, const std::string & module, const std::string & message);
	
		/// \brief Determine if the given module is active at the given log level.
		/// \param level The log level.
		/// \param module The target module.
		/// \returns true if the given module is active at the given log level.
		bool checkLog(ofLogLevel level, const std::string & module);
	
		static std::shared_ptr<ofBaseLoggerChannel> & channel();	///< The target channel.
	
		/// \endcond
	
	private:
		std::stringstream message;	///< Temporary buffer.
		
		static bool bAutoSpace; ///< Should space be added between messages?
		
		ofLog(ofLog const&) {}        					// not defined, not copyable
		ofLog& operator=(ofLog& from) {return *this;}	// not defined, not assignable
		
		static std::string & getPadding(); ///< The padding between std::ostream calls.
};


/// \brief Derived log class for easy verbose logging.
///
/// Example: `ofLogVerbose("Log message")`.
class ofLogVerbose : public ofLog{
	public:
		/// \brief Create a verbose log message.
		/// \param module The target module.
		ofLogVerbose(const std::string &module="");

		/// \brief Create a verbose log message.
		/// \param module The target module.
		/// \param message The log message.
		ofLogVerbose(const std::string & module, const std::string & message);

		/// \brief Create a verbose log message.
		/// \param module The target module.
		/// \param format The printf-style format string.
		ofLogVerbose(const std::string & module, const char* format, ...) OF_PRINTF_ATTR(3, 4);
};

/// \brief Derived log class for easy notice logging.
///
/// Example: `ofLogNotice("Log message")`.
class ofLogNotice : public ofLog{
	public:
		/// \brief Create a notice log message.
		/// \param module The target module.
		ofLogNotice(const std::string & module="");

		/// \brief Create a notice log message.
		/// \param module The target module.
		/// \param message The log message.
		ofLogNotice(const std::string & module, const std::string & message);

		/// \brief Create a notice log message.
		/// \param module The target module.
		/// \param format The printf-style format string.
		ofLogNotice(const std::string & module, const char* format, ...) OF_PRINTF_ATTR(3, 4);
};

/// \brief Derived log class for easy warning logging.
///
/// Example: `ofLogWarning("Log message")`.
class ofLogWarning : public ofLog{
	public:
	/// \brief Create a verbose log message.
	/// \param module The target module.
		ofLogWarning(const std::string & module="");
	/// \brief Create a verbose log message.
	/// \param module The target module.
	/// \param message The log message.
		ofLogWarning(const std::string & module, const std::string & message);
	
	/// \brief Create a verbose log message.
	/// \param module The target module.
	/// \param format The printf-style format string.
		ofLogWarning(const std::string & module, const char* format, ...) OF_PRINTF_ATTR(3, 4);
};

/// \brief Derived log class for easy error logging.
///
/// Example: `ofLogError("Log message")`.
class ofLogError : public ofLog{
	public:
		/// \brief Create a error log message.
		/// \param module The target module.
		ofLogError(const std::string & module="");
	
		/// \brief Create a error log message.
		/// \param module The target module.
		/// \param message The log message.
		ofLogError(const std::string & module, const std::string & message);
	
		/// \brief Create a error log message.
		/// \param module The target module.
		/// \param format The printf-style format string.
		ofLogError(const std::string & module, const char* format, ...) OF_PRINTF_ATTR(3, 4);
};

/// \brief Derived log class for easy fatal error logging.
///
/// Example: `ofLogFatalError("Log message")`.
class ofLogFatalError : public ofLog{
	public:
		/// \brief Create a fatal error log message.
		/// \param module The target module.
		ofLogFatalError(const std::string & module="");

		/// \brief Create a fatal error log message.
		/// \param module The target module.
		/// \param message The log message.
		ofLogFatalError(const std::string & module, const std::string & message);
	
		/// \brief Create a fatal error log message.
		/// \param module The target module.
		/// \param format The printf-style format string.
		ofLogFatalError(const std::string & module, const char* format, ...) OF_PRINTF_ATTR(3, 4);
};


/// \cond INTERNAL

//--------------------------------------------------------------
// Logger Channels

/// \brief The base class representing a logger channel.
///
/// Users can derive their own logging channels from ofBaseLoggerChannel or use
/// default channels.
class ofBaseLoggerChannel{
public:
	/// \brief Destroy the channel.
	virtual ~ofBaseLoggerChannel(){};
	
	/// \brief Log a message.
	/// \param level The log level.
	/// \param module The target module.
	/// \param message The log message.
	virtual void log(ofLogLevel level, const std::string & module, const std::string & message)=0;

	/// \brief Log a message.
	/// \param level The log level.
	/// \param module The target module.
	/// \param format The printf-style format string.
	virtual void log(ofLogLevel level, const std::string & module, const char* format, ...)  OF_PRINTF_ATTR(4, 5) =0;

	/// \brief Log a message.
	/// \param level The log level.
	/// \param module The target module.
	/// \param format The printf-style format string.
	/// \param args the list of printf-style arguments.
	virtual void log(ofLogLevel level, const std::string & module, const char* format, va_list args)=0;
};

/// \brief A logger channel that logs its messages to the console.
class ofConsoleLoggerChannel: public ofBaseLoggerChannel{
public:
	/// \brief Destroy the console logger channel.
	virtual ~ofConsoleLoggerChannel(){};
	void log(ofLogLevel level, const std::string & module, const std::string & message);
	void log(ofLogLevel level, const std::string & module, const char* format, ...) OF_PRINTF_ATTR(4, 5);
	void log(ofLogLevel level, const std::string & module, const char* format, va_list args);
};

#ifdef TARGET_WIN32
/// A logger channel that logs its messages to windows debug view and visual studio output.
class ofDebugViewLoggerChannel : public ofBaseLoggerChannel {
public:
	/// \brief Destroy the console logger channel.
	virtual ~ofDebugViewLoggerChannel() {};
	void log(ofLogLevel level, const std::string & module, const std::string & message);
	void log(ofLogLevel level, const std::string & module, const char* format, ...) OF_PRINTF_ATTR(4, 5);
	void log(ofLogLevel level, const std::string & module, const char* format, va_list args);
};
#endif

/// \brief A logger channel that logs its messages to a log file.
class ofFileLoggerChannel: public ofBaseLoggerChannel{
public:
	/// \brief Create an ofFileLoggerChannel.
	ofFileLoggerChannel();
	
	/// \brief Create an ofFileLoggerChannel with parameters.
	/// \param path The file path for the log file.
	/// \param append True if the log data should be added to an existing file.
    ofFileLoggerChannel(const std::filesystem::path & path, bool append);

	/// \brief Destroy the file logger channel.
	virtual ~ofFileLoggerChannel();

	/// \brief Set the log file.
	/// \param path The file path for the log file.
	/// \param append True if the log data should be added to an existing file.
    void setFile(const std::filesystem::path & path,bool append=false);

	void log(ofLogLevel level, const std::string & module, const std::string & message);
	void log(ofLogLevel level, const std::string & module, const char* format, ...) OF_PRINTF_ATTR(4, 5);
	void log(ofLogLevel level, const std::string & module, const char* format, va_list args);

	/// \brief CLose the log file.
	void close();

private:
	ofFile file; ///< The location of the log file.
	
};

/// \endcond

#line 0 "../libs/openFrameworks/utils/ofFpsCounter.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofUtils.h" */
#include <queue>

class ofFpsCounter {
public:
	ofFpsCounter();
	ofFpsCounter(double targetFps);
	void newFrame();

	// no need to call it usually, useful if
	// the update rate of the source is not very
	// consistent. calling update from the main
	// loop for example will make the measurement
	// update more often
	void update();
	double getFps() const;
	uint64_t getNumFrames() const;
	uint64_t getLastFrameNanos() const;
	double getLastFrameSecs() const;
	uint64_t getLastFrameFilteredNanos() const;
	double getLastFrameFilteredSecs() const;
	void setFilterAlpha(float alpha);

private:
	void update(double now);
	uint64_t nFrameCount;
	ofTime then;
	double fps;
	std::chrono::nanoseconds lastFrameTime;
	std::chrono::nanoseconds filteredTime;
	double filterAlpha;
	std::queue<double> timestamps;
};

#line 0 "../libs/openFrameworks/events/ofEvent.h"
#pragma once

#include <vector>
#include <functional>
#include <mutex>
#include <thread>
#include <memory>
#include <iterator>
#include <atomic>
#include <stddef.h>
#include <functional>
#include <deque>


/*! \cond PRIVATE */
namespace of{
namespace priv{
	// Helper classes and methods, only for internal use of ofEvent

	// -------------------------------------
	class NoopMutex{
	public:
		void lock(){}
		void unlock(){}
	};

	// -------------------------------------
	class AbstractEventToken{
		public:
			virtual ~AbstractEventToken();
	};


	// -------------------------------------
	class BaseFunctionId{
	public:
		BaseFunctionId(){}
		BaseFunctionId(const BaseFunctionId &) = delete;
		BaseFunctionId & operator=(const BaseFunctionId &) = delete;
		virtual ~BaseFunctionId();
		virtual bool operator==(const BaseFunctionId &) const = 0;
		virtual BaseFunctionId * clone() const = 0;
	};

	// -------------------------------------
	class StdFunctionId: public BaseFunctionId{
		static std::atomic<uint_fast64_t> nextId;
		uint64_t id;

		StdFunctionId(uint64_t id)
		:id(id){}
	public:
		StdFunctionId(){
			id = nextId++;
		}

		virtual ~StdFunctionId();

		bool operator==(const BaseFunctionId & otherid) const{
			const auto * other = dynamic_cast<const StdFunctionId*>(&otherid);
			return other && id == other->id;
		}

		BaseFunctionId * clone() const{
			return new StdFunctionId(id);
		}
	};


	// -------------------------------------
	inline std::unique_ptr<StdFunctionId> make_function_id(){
		return std::make_unique<StdFunctionId>();
	}

	// -------------------------------------
	template<typename T, class Mutex>
	class Function{
	public:
		Function(int priority, std::function<bool(const void*,T&)> function,  std::unique_ptr<BaseFunctionId>&& id )
		:priority(priority)
		,id(std::move(id))
		,function(function){}

		bool operator==(const Function<T,Mutex> & f) const{
			return f.priority == priority && *id == *f.id;
		}

		inline bool notify(const void*s,T&t){
			std::unique_lock<Mutex> lck(mtx);
			try{
				return function(s,t);
			}catch(std::bad_function_call &){
				return false;
			}
		}

		inline void disable(){
			std::unique_lock<Mutex> lck(mtx);
			function = nullptr;
		}

		int priority;
		std::unique_ptr<BaseFunctionId> id;

	private:
		std::function<bool(const void*,T&)> function;
		Mutex mtx;
	};

	// -------------------------------------
	template<class Mutex>
	class Function<void,Mutex>{
	public:
		Function(int priority, std::function<bool(const void*)> function,  std::unique_ptr<BaseFunctionId> && id )
		:priority(priority)
		,id(std::move(id))
		,function(function){}

		bool operator==(const Function<void,Mutex> & f) const{
			return f.priority == priority && *id == *f.id;
		}

		inline bool notify(const void*s){
			std::unique_lock<Mutex> lck(mtx);
			try{
				return function(s);
			}catch(std::bad_function_call &){
				return false;
			}
		}

		inline void disable(){
			std::unique_lock<Mutex> lck(mtx);
			function = nullptr;
		}

		int priority;
		std::unique_ptr<BaseFunctionId> id;
	private:
		std::function<bool(const void*)> function;
		Mutex mtx;
	};


	// -------------------------------------
	template<typename Function, typename Mutex=std::recursive_mutex>
	class BaseEvent{
	public:
		BaseEvent(){}

		BaseEvent(const BaseEvent & mom){
			std::unique_lock<Mutex> lck(const_cast<BaseEvent&>(mom).self->mtx);
			self->functions = mom.self->functions;
		}

		BaseEvent & operator=(const BaseEvent & mom){
			if(&mom==this){
				return *this;
			}
			std::unique_lock<Mutex> lck(const_cast<BaseEvent&>(mom).self->mtx);
			std::unique_lock<Mutex> lck2(self->mtx);
			self->functions = mom.self->functions;
			self->enabled = mom.self->enabled;
			return *this;
		}

		BaseEvent(BaseEvent && mom){
			std::unique_lock<Mutex> lck(const_cast<BaseEvent&>(mom).self->mtx);
			self->functions = std::move(mom.self->functions);
			self->enabled = std::move(mom.self->enabled);
		}

		BaseEvent & operator=(BaseEvent && mom){
			if(&mom==this){
				return *this;
			}
			std::unique_lock<Mutex> lck(const_cast<BaseEvent&>(mom).self->mtx);
			std::unique_lock<Mutex> lck2(self->mtx);
			self->functions = mom.self->functions;
			self->enabled = mom.self->enabled;
			return *this;
		}

		void enable() {
			self->enabled = true;
		}

		void disable() {
			self->enabled = false;
		}

		bool isEnabled() const {
			return self->enabled;
		}

		std::size_t size() const {
			return self->functions.size();
		}

	protected:

		struct Data{
			Mutex mtx;
			std::vector<std::shared_ptr<Function>> functions;
			bool enabled = true;

			void remove(const BaseFunctionId & id){
				std::unique_lock<Mutex> lck(mtx);
				auto it = functions.begin();
				for(; it!=functions.end(); ++it){
					auto f = *it;
					if(*f->id == id){
						f->disable();
						functions.erase(it);
						break;
					}
				}
			}
		};
		std::shared_ptr<Data> self{new Data};

		class EventToken: public AbstractEventToken{
			public:
				EventToken() {};
				template<typename Id>
				EventToken(std::shared_ptr<Data> & event, const Id & id)
				:event(event)
				,id(id.clone()){

				}

				~EventToken(){
					auto event = this->event.lock();
					if(event){
						event->remove(*id);
					}
				}

			private:
				std::weak_ptr<Data> event;
				std::unique_ptr<BaseFunctionId> id;
		};

		std::unique_ptr<EventToken> make_token(const Function & f){
			return std::make_unique<EventToken>(self,*f.id);
		}

		template<typename TFunction>
		void addNoToken(TFunction && f){
			std::unique_lock<Mutex> lck(self->mtx);
			auto it = self->functions.begin();
			for(; it!=self->functions.end(); ++it){
				if((*it)->priority>f->priority) break;
			}
			self->functions.emplace(it, f);
		}

		template<typename TFunction>
		std::unique_ptr<EventToken> addFunction(TFunction && f){
			std::unique_lock<Mutex> lck(self->mtx);
			auto it = self->functions.begin();
			for(; it!=self->functions.end(); ++it){
				if((*it)->priority>f->priority) break;
			}
			self->functions.emplace(it, f);
			return make_token(*f);
		}
	};




	// -------------------------------------
	// Helper functions to disambiguate parameters
	// https://github.com/sth/callable.hpp
	namespace detail {

	/** Count the number of types given to the template */
	template<typename... Types>
	struct tva_count;

	template<>
	struct tva_count<> {
		static const size_t value = 0;
	};

	template<typename Type, typename... Types>
	struct tva_count<Type, Types...> {
		static const size_t value = tva_count<Types...>::value + 1;
	};


	/** Get the nth type given to the template */
	template<size_t n, typename... Types>
	struct tva_n;

	template<size_t N, typename Type, typename... Types>
	struct tva_n<N, Type, Types...> : tva_n<N-1, Types...> {
	};

	template<typename Type, typename... Types>
	struct tva_n<0, Type, Types...> {
		typedef Type type;
	};


	/** Define traits for a function type */
	template<typename Fun>
	struct callable_traits_fn;

	template<typename Ret, typename... Args>
	struct callable_traits_fn<Ret (Args...)> {
		typedef Ret (*function_ptr)(Args...);
		typedef Ret function_type(Args...);
		typedef Ret return_type;
		static const size_t argc;

		template<size_t N>
		using argument_type = typename tva_n<N, Args...>::type;
	};

	template<typename Ret, typename... Args>
	const size_t callable_traits_fn<Ret (Args...)>::argc = tva_count<Args...>::value;


	/** Define traits for a operator() member function pointer type */
	template<typename MemFun>
	struct callable_traits_memfn;

	template<typename Class, typename Ret, typename... Args>
	struct callable_traits_memfn<Ret (Class::*)(Args...)> : callable_traits_fn<Ret (Args...)> {
	};

	template<typename Class, typename Ret, typename... Args>
	struct callable_traits_memfn<Ret (Class::*)(Args...) const> : callable_traits_fn<Ret (Args...)> {
	};


	// classes with operator()
	template<typename Callable>
	struct callable_traits_d : detail::callable_traits_memfn<decltype(&Callable::operator())> {
	};

	// functions
	template<typename Ret, typename... Args>
	struct callable_traits_d<Ret (Args...)> : detail::callable_traits_fn<Ret (Args...)> {
	};

	// function pointers
	template<typename Ret, typename... Args>
	struct callable_traits_d<Ret (*)(Args...)> : detail::callable_traits_fn<Ret (Args...)> {
	};

	// std::function specializations
	template<typename Ret, typename... Args>
	struct callable_traits_d<std::function<Ret (Args...)>> : detail::callable_traits_fn<Ret (Args...)> {
	};

	} // namespace detail


	// Main template

	template<typename Callable>
	struct callable_traits : detail::callable_traits_d<typename std::remove_reference<Callable>::type> {
	};
}
}
/*! \endcond */

// -------------------------------------
enum ofEventOrder{
	OF_EVENT_ORDER_BEFORE_APP=0,
	OF_EVENT_ORDER_APP=100,
	OF_EVENT_ORDER_AFTER_APP=200
};

// -------------------------------------
class ofEventListener{
public:
	ofEventListener(){}
	ofEventListener(const ofEventListener &) = delete;
	ofEventListener(ofEventListener &&) = delete;
	ofEventListener & operator=(const ofEventListener&) = delete;
	ofEventListener & operator=(ofEventListener&&) = delete;

	ofEventListener(std::unique_ptr<of::priv::AbstractEventToken> && token)
		:token(std::move(token)){}

	ofEventListener & operator=(std::unique_ptr<of::priv::AbstractEventToken> && token){
		std::swap(this->token, token);
		return *this;
	}

	void unsubscribe(){
		token.reset();
	}
private:
	std::unique_ptr<of::priv::AbstractEventToken> token;
};



// -------------------------------------
class ofEventListeners{
public:
	ofEventListeners(){};
	ofEventListeners(const ofEventListeners &) = delete;
	ofEventListeners(ofEventListeners &&) = delete;
	ofEventListeners & operator=(const ofEventListeners&) = delete;
	ofEventListeners & operator=(ofEventListeners&&) = delete;


	void push(std::unique_ptr<of::priv::AbstractEventToken> && listener){
		listeners.emplace_back(std::move(listener));
	}

	void unsubscribe(std::size_t pos){
		listeners[pos].unsubscribe();
	}

	void unsubscribeAll(){
		listeners.clear();
	}

private:
	std::deque<ofEventListener> listeners;
};


// -------------------------------------
// ofEvent main implementation
template<typename T, typename Mutex=std::recursive_mutex>
class ofEvent: public of::priv::BaseEvent<of::priv::Function<T,Mutex>,Mutex>{
protected:
	typedef of::priv::Function<T,Mutex> Function;
	typedef std::shared_ptr<Function> FunctionPtr;

	template<class TObj, typename TMethod>
	class FunctionId: public of::priv::BaseFunctionId{
	public:
		TObj * listener;
		TMethod method;

		FunctionId(TObj * listener, TMethod method)
		:listener(listener)
		,method(method){

		}

		BaseFunctionId * clone() const{
			return new FunctionId<TObj,TMethod>(listener, method);
		}

		template<typename F>
		bool operator==(const F & f1) const{
			return f1.listener == this->listener && f1.method == this->method;
		}

		bool operator==(const BaseFunctionId & f) const{
			const auto * other = dynamic_cast<const FunctionId<TObj,TMethod>*>(&f);
			return other && other->listener == this->listener && other->method == this->method;
		}
	};

	template<class TObj, typename TMethod>
	std::unique_ptr<FunctionId<TObj,TMethod>> make_function_id(TObj * listener, TMethod method){
		return std::make_unique<FunctionId<TObj,TMethod>>(listener,method);
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, bool (TObj::*method)(T&), int priority){
		return std::make_shared<Function>(priority, std::bind(method,listener,std::placeholders::_2), make_function_id(listener,method));
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, void (TObj::*method)(T&), int priority){
		return std::make_shared<Function>(priority, [listener, method](const void*, T&t){
			((listener)->*(method))(t);
			return false;
		}, make_function_id(listener,method));
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, bool (TObj::*method)(const void*, T&), int priority){
		return std::make_shared<Function>(priority, std::bind(method,listener,std::placeholders::_1,std::placeholders::_2), make_function_id(listener,method));
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, void (TObj::*method)(const void*, T&), int priority){
		return std::make_shared<Function>(priority, [listener, method](const void*s, T&t){
			std::bind(method,listener,std::placeholders::_1,std::placeholders::_2)(s,t);
			return false;
		}, make_function_id(listener,method));
	}

	template<typename F>
	std::unique_ptr<of::priv::BaseFunctionId> make_std_function_id(const F & f){
		auto function = f.template target<typename of::priv::callable_traits<F>::function_ptr>();
		if(function){
			return make_function_id((ofEvent<T>*)nullptr,*function);
		}else{
			return of::priv::make_function_id();
		}
	}

	FunctionPtr make_function(std::function<bool(T&)> f, int priority) {
		return std::make_shared<Function>(priority, [f](const void*, T&t) {return f(t); }, make_std_function_id(f));
	}

	FunctionPtr make_function(std::function<bool(const void*, T&)> f, int priority) {
		return std::make_shared<Function>(priority, f, make_std_function_id(f));
	}

	FunctionPtr make_function(std::function<void(T&)> f, int priority) {
		return std::make_shared<Function>(priority, [f](const void*, T&t) {f(t); return false; }, make_std_function_id(f));
	}

	FunctionPtr make_function(std::function<void(const void*, T&)> f, int priority) {
		return std::make_shared<Function>(priority, [f](const void*s, T&t) {f(s, t); return false; }, make_std_function_id(f));
	}


	using of::priv::BaseEvent<of::priv::Function<T,Mutex>,Mutex>::addFunction;
	using of::priv::BaseEvent<of::priv::Function<T,Mutex>,Mutex>::addNoToken;

public:
	template<class TObj, typename TMethod>
	std::unique_ptr<of::priv::AbstractEventToken> newListener(TObj * listener, TMethod method, int priority = OF_EVENT_ORDER_AFTER_APP){
		return addFunction(make_function(listener,method,priority));
	}

	template<class TObj, typename TMethod>
	void add(TObj * listener, TMethod method, int priority){
		addNoToken(make_function(listener,method,priority));
	}

	template<class TObj, typename TMethod>
	void remove(TObj * listener, TMethod method, int priority){
		 ofEvent<T,Mutex>::self->remove(*make_function_id(listener,method));
	}

	template<typename TFunction>
	std::unique_ptr<of::priv::AbstractEventToken> newListener(TFunction function, int priority = OF_EVENT_ORDER_AFTER_APP) {
		return addFunction(make_function(std::function<typename of::priv::callable_traits<TFunction>::function_type>(function), priority));
	}

	template<typename TFunction>
	void add(TFunction function, int priority){
		addNoToken(make_function(std::function<typename of::priv::callable_traits<TFunction>::function_type>(function),priority));
	}

	template<typename TFunction>
	void remove(TFunction function, int priority){
		 ofEvent<T,Mutex>::self->remove(*make_function(std::function<typename of::priv::callable_traits<TFunction>::function_type>(function), priority)->id);
	}

	inline bool notify(const void* sender, T & param){
		if(ofEvent<T,Mutex>::self->enabled && !ofEvent<T,Mutex>::self->functions.empty()){
			std::unique_lock<Mutex> lck(ofEvent<T,Mutex>::self->mtx);
			auto functions_copy = ofEvent<T,Mutex>::self->functions;
			lck.unlock();
			for(auto & f: functions_copy){
                if(f->notify(sender,param)){
					return true;
                }
			}
		}
		return false;
	}

	inline bool notify(T & param){
		if(ofEvent<T,Mutex>::self->enabled && !ofEvent<T,Mutex>::self->functions.empty()){
			std::unique_lock<Mutex> lck(ofEvent<T,Mutex>::self->mtx);
			auto functions_copy = ofEvent<T,Mutex>::self->functions;
			lck.unlock();
			for(auto & f: functions_copy){
				if(f->notify(nullptr,param)){
					return true;
				}
			}
		}
		return false;
	}
};



// -------------------------------------
// void event template specialization,
template<typename Mutex>
class ofEvent<void,Mutex>: public of::priv::BaseEvent<of::priv::Function<void,Mutex>,Mutex>{
protected:
	typedef of::priv::Function<void,Mutex> Function;
	typedef std::shared_ptr<Function> FunctionPtr;

	template<class TObj, typename TMethod>
	class FunctionId: public of::priv::BaseFunctionId{
	public:
		TObj * listener;
		TMethod method;

		FunctionId(TObj * listener, TMethod method)
		:listener(listener)
		,method(method){

		}

		BaseFunctionId * clone() const{
			return new FunctionId<TObj,TMethod>(listener, method);
		}

		template<typename F>
		bool operator==(const F & f1) const{
			return f1.listener == this->listener && f1.method == this->method;
		}

		bool operator==(const BaseFunctionId & f) const{
			const auto * other = dynamic_cast<const FunctionId<TObj,TMethod>*>(&f);
			return other && other->listener == this->listener && other->method == this->method;
		}
	};


	template<class TObj, typename TMethod>
	std::unique_ptr<FunctionId<TObj,TMethod>> make_function_id(TObj * listener, TMethod method){
		return std::unique_ptr<FunctionId<TObj,TMethod>>(new FunctionId<TObj,TMethod>(listener,method));
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, bool (TObj::*method)(), int priority){
		return std::make_shared<Function>(priority, std::bind(method,listener), make_function_id(listener,method));
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, void (TObj::*method)(), int priority){
		return std::make_shared<Function>(priority,[listener, method](const void*){
			std::bind(method,listener)();
			return false;
		}, make_function_id(listener,method));
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, bool (TObj::*method)(const void*), int priority){
		return std::make_shared<Function>(priority,std::bind(method,listener,std::placeholders::_1), make_function_id(listener,method));
	}

	template<class TObj>
	FunctionPtr make_function(TObj * listener, void (TObj::*method)(const void*), int priority){
		return std::make_shared<Function>(priority,[listener, method](const void* sender){
			std::bind(method,listener,std::placeholders::_1)(sender);
			return false;
		}, make_function_id(listener,method));
	}

	template<typename F>
	std::unique_ptr<of::priv::BaseFunctionId> make_std_function_id(const F & f){
		auto function = f.template target<typename of::priv::callable_traits<F>::function_ptr>();
		if(function){
			return make_function_id((ofEvent<void>*)nullptr,*function);
		}else{
			return of::priv::make_function_id();
		}
	}

	FunctionPtr make_function(std::function<bool()> f, int priority) {
		return std::make_shared<Function>(priority, [f](const void*) {return f(); }, make_std_function_id(f));
	}

	FunctionPtr make_function(std::function<bool(const void*)> f, int priority) {
		return std::make_shared<Function>(priority, f, make_std_function_id(f));
	}

	FunctionPtr make_function(std::function<void()> f, int priority) {
		return std::make_shared<Function>(priority, [f](const void*) {f(); return false; }, make_std_function_id(f));
	}

	FunctionPtr make_function(std::function<void(const void*)> f, int priority) {
		return std::make_shared<Function>(priority, [f](const void*s) {f(s); return false; }, make_std_function_id(f));
	}

	using of::priv::BaseEvent<of::priv::Function<void,Mutex>,Mutex>::addFunction;
	using of::priv::BaseEvent<of::priv::Function<void,Mutex>,Mutex>::addNoToken;

public:
	template<class TObj, typename TMethod>
	void add(TObj * listener, TMethod method, int priority){
		addNoToken(make_function(listener,method,priority));
	}

	template<class TObj, typename TMethod>
	std::unique_ptr<of::priv::AbstractEventToken> newListener(TObj * listener, TMethod method, int priority = OF_EVENT_ORDER_AFTER_APP){
		return addFunction(make_function(listener,method,priority));
	}

	template<class TObj, typename TMethod>
	void remove(TObj * listener, TMethod method, int priority){
		ofEvent<void,Mutex>::self->remove(*make_function_id(listener,method));
	}

	template<typename TFunction>
	void add(TFunction function, int priority){
		addNoToken(make_function(std::function<typename of::priv::callable_traits<TFunction>::function_type>(function),priority));
	}

	template<typename TFunction>
	std::unique_ptr<of::priv::AbstractEventToken> newListener(TFunction function, int priority = OF_EVENT_ORDER_AFTER_APP) {
		return addFunction(make_function(std::function<typename of::priv::callable_traits<TFunction>::function_type>(function), priority));
	}

	template<typename TFunction>
	void remove(TFunction function, int priority){
		 ofEvent<void,Mutex>::self->remove(*make_function(std::function<typename of::priv::callable_traits<TFunction>::function_type>(function),priority)->id);
	}

	bool notify(const void* sender){
		if(ofEvent<void,Mutex>::self->enabled && !ofEvent<void,Mutex>::self->functions.empty()){
			std::unique_lock<Mutex> lck(ofEvent<void,Mutex>::self->mtx);
			auto functions_copy = ofEvent<void,Mutex>::self->functions;
			lck.unlock();
			for(auto & f: functions_copy){
				if(f->notify(sender)){
					return true;
				}
			}
		}
		return false;
	}

	bool notify(){
		if(ofEvent<void,Mutex>::self->enabled && !ofEvent<void,Mutex>::self->functions.empty()){
			std::unique_lock<Mutex> lck(ofEvent<void,Mutex>::self->mtx);
			auto functions_copy = ofEvent<void,Mutex>::self->functions;
			lck.unlock();
			for(auto & f: functions_copy){
				if(f->notify(nullptr)){
					return true;
				}
			}
		}
		return false;
	}
};

// -------------------------------------
/// Non thread safe event that avoids locks and copies of the listeners
/// making it faster than a plain ofEvent
template<typename T>
class ofFastEvent: public ofEvent<T,of::priv::NoopMutex>{
public:
	inline bool notify(const void* sender, T & param){
		if(this->isEnabled()){
			for(auto & f: ofFastEvent<T>::self->functions){
				if(f->notify(sender, param)){
					return true;
				}
			}
		}
		return false;
	}
};


#line 0 "../libs/openFrameworks/events/ofEvents.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofEventUtils.h" */
/* #include "ofTimer.h" */
/* #include "ofFpsCounter.h" */
#include <set>
#include "glm/vec2.hpp"

//-------------------------- mouse/key query
bool ofGetMousePressed(int button=-1); //by default any button
bool ofGetKeyPressed(int key=-1); //by default any key

int	ofGetMouseX();
int	ofGetMouseY();

int	ofGetPreviousMouseX();
int	ofGetPreviousMouseY();



//--------------------------------------------
//
// 	Keyboard definitions
//
// 	ok -- why this?
// 	glut key commands have some annoying features,
// 	in that some normal keys have the same value as special keys,
// 	but we want ONE key routine, so we need to redefine several,
// 	so that we get some normalacy across keys routines
//
// 	(everything that comes through "glutSpecialKeyFunc" will get 256 added to it,
// 	to avoid conflicts, before, values like "left, right up down" (ie, 104, 105, 106) were conflicting with
// 	letters.. now they will be 256 + 104, 256 + 105....)

enum ofKey{
	OF_KEY_RETURN	=	13,
	OF_KEY_ESC		=	27,
	OF_KEY_TAB      =    9,


	OF_KEY_BACKSPACE =	8,
	OF_KEY_DEL		 =	127,


	// For legacy reasons we are mixing up control keys
	// and unicode codepoints when sending key events,
	// for the modifiers that need to be usable as bitmask
	// we are using some control codes that have nothing to do
	// with the keys being represented and then 0x0ee0.. and 0x0e60...
	// which are free in the unicode table

	OF_KEY_SHIFT	=	 0x1,
	OF_KEY_CONTROL	=	 0x2,
	OF_KEY_ALT		=	 0x4,
	OF_KEY_SUPER	=	 0x10,
	OF_KEY_COMMAND  =    OF_KEY_SUPER,
	OF_KEY_LEFT_SHIFT    =	 0xe60,
	OF_KEY_RIGHT_SHIFT   =	 0xe61,
	OF_KEY_LEFT_CONTROL  =	 0xe62,
	OF_KEY_RIGHT_CONTROL = 0xe63,
	OF_KEY_LEFT_ALT		= 0xe64,
	OF_KEY_RIGHT_ALT	= 0xe65,
	OF_KEY_LEFT_SUPER	= 0xe66,
	OF_KEY_RIGHT_SUPER	= 0xe67,
	OF_KEY_LEFT_COMMAND = OF_KEY_LEFT_SUPER,
	OF_KEY_RIGHT_COMMAND = OF_KEY_RIGHT_SUPER,

	// Use values from the Unicode private use codepoint range E000 - F8FF. 
	// See https://www.unicode.org/faq/private_use.html
	OF_KEY_F1        = 0xe000,
	OF_KEY_F2        = 0xe001,
	OF_KEY_F3        = 0xe002,
	OF_KEY_F4        = 0xe003,
	OF_KEY_F5        = 0xe004,
	OF_KEY_F6        = 0xe005,
	OF_KEY_F7        = 0xe006,
	OF_KEY_F8        = 0xe007,
	OF_KEY_F9        = 0xe008,
	OF_KEY_F10       = 0xe009,
	OF_KEY_F11       = 0xe00A,
	OF_KEY_F12       = 0xe00B,
	OF_KEY_LEFT      = 0xe00C,
	OF_KEY_UP        = 0xe00D,
	OF_KEY_RIGHT     = 0xe00E,
	OF_KEY_DOWN      = 0xe00F,
	OF_KEY_PAGE_UP   = 0xe010,
	OF_KEY_PAGE_DOWN = 0xe011,
	OF_KEY_HOME      = 0xe012,
	OF_KEY_END       = 0xe013,
	OF_KEY_INSERT    = 0xe014,

	OF_MOUSE_BUTTON_1 =    0,
	OF_MOUSE_BUTTON_2 =    1,
	OF_MOUSE_BUTTON_3 =    2,
	OF_MOUSE_BUTTON_4 =    3,
	OF_MOUSE_BUTTON_5 =    4,
	OF_MOUSE_BUTTON_6 =    5,
	OF_MOUSE_BUTTON_7 =    6,
	OF_MOUSE_BUTTON_8 =    7,
	OF_MOUSE_BUTTON_LAST   = OF_MOUSE_BUTTON_8,
	OF_MOUSE_BUTTON_LEFT   = OF_MOUSE_BUTTON_1,
	OF_MOUSE_BUTTON_MIDDLE = OF_MOUSE_BUTTON_2,
	OF_MOUSE_BUTTON_RIGHT  = OF_MOUSE_BUTTON_3,
};

//-----------------------------------------------
class ofDragInfo{
	public:
		std::vector <std::string> files;
		glm::vec2 position;
};


//-----------------------------------------------
// event arguments, this are used in oF to pass
// the data when notifying events

class ofEventArgs{};

class ofKeyEventArgs : public ofEventArgs {
public:
	enum Type{
		Pressed,
		Released,
	};

	ofKeyEventArgs()
  	:type(Pressed)
  	,key(0)
	,keycode(0)
	,scancode(0)
	,codepoint(0)
	,isRepeat(false){}

	ofKeyEventArgs(Type type, int key, int keycode, int scancode, unsigned int codepoint, int modifiers)
	:type(type)
	,key(key)
	,keycode(keycode)
	,scancode(scancode)
	,codepoint(codepoint)
	,isRepeat(false)
	,modifiers(modifiers){

	}

	ofKeyEventArgs(Type type, int key)
	:type(type)
	,key(key)
	,keycode(0)
	,scancode(0)
	,codepoint(0)
	,isRepeat(false){

	}

	Type type;
	/// For special keys, one of OF_KEY_* (@see ofConstants.h). For all other keys, the Unicode code point you'd expect if this key combo (including modifier keys that may be down) was pressed in a text editor (same as codepoint).
	int key;
	/// The keycode returned by the windowing system, independent of any modifier keys or keyboard layout settings. For ofAppGLFWWindow this value is one of GLFW_KEY_* (@see glfw3.h) - typically, ASCII representation of the symbol on the physical key, so A key always returns 0x41 even if shift, alt, ctrl are down.
	int keycode;
	/// The raw scan code returned by the keyboard, OS and hardware specific.
	int scancode;
	/// The Unicode code point you'd expect if this key combo (including modifier keys) was pressed in a text editor, or 0 for non-printable characters.
	uint32_t codepoint;
	/// If this is a repeat event
	bool isRepeat;
	/// Key modifiers
	int modifiers = 0;

	bool hasModifier(int modifier) const {
		return modifiers & modifier;
	}
};

class ofMouseEventArgs : public ofEventArgs, public glm::vec2 {
  public:
	enum Type{
		Pressed,
		Moved,
		Released,
		Dragged,
		Scrolled,
		Entered,
		Exited
	};

	ofMouseEventArgs()
	:type(Pressed)
	,button(OF_MOUSE_BUTTON_LEFT)
	,scrollX(0.f)
	,scrollY(0.f)
	{}

	ofMouseEventArgs(Type type, float x, float y, int button)
	:glm::vec2(x,y)
	,type(type)
	,button(button)
	,scrollX(0.f)
	,scrollY(0.f)
	{}

	ofMouseEventArgs(Type type, float x, float y, int button, int modifiers)
	:glm::vec2(x,y)
	,type(type)
	,button(button)
	,scrollX(0.f)
	,scrollY(0.f)
	,modifiers(modifiers)
	{}

	ofMouseEventArgs(Type type, float x, float y)
	:glm::vec2(x,y)
	,type(type)
	,button(0)
	,scrollX(0.f)
	,scrollY(0.f)
	{}

	Type type;
	int button;
	float scrollX;
	float scrollY;
	/// Key modifiers
	int modifiers = 0;

	bool hasModifier(int modifier){
		return modifiers & modifier;
	}
};

class ofTouchEventArgs : public ofEventArgs, public glm::vec2 {
  public:
	enum Type{
		down,
		up,
		move,
		doubleTap,
		cancel
	};

	ofTouchEventArgs()
	:type(down)
	,id(0)
	,time(0)
	,numTouches(0)
	,width(0)
	,height(0)
	,angle(0)
	,minoraxis(0)
	,majoraxis(0)
	,pressure(0)
	,xspeed(0)
	,yspeed(0)
	,xaccel(0)
	,yaccel(0)
	{

	}

	ofTouchEventArgs(Type type, float x, float y, int id)
	:glm::vec2(x,y)
	,type(type)
	,id(id)
	,time(0)
	,numTouches(0)
	,width(0)
	,height(0)
	,angle(0)
	,minoraxis(0)
	,majoraxis(0)
	,pressure(0)
	,xspeed(0)
	,yspeed(0)
	,xaccel(0)
	,yaccel(0){}

	Type type;
	int id;
	int time;
	int numTouches;
	float width, height;
	float angle;
	float minoraxis, majoraxis;
	float pressure;
	float xspeed, yspeed;
	float xaccel, yaccel;
};

class ofResizeEventArgs : public ofEventArgs {
public:
	ofResizeEventArgs()
  	:width(0)
	,height(0){}

	ofResizeEventArgs(int width, int height)
	:width(width)
	,height(height){}

	int width;
	int height;
};

class ofWindowPosEventArgs : public ofEventArgs, public glm::vec2  {
public:
	ofWindowPosEventArgs(){}

	ofWindowPosEventArgs(int x, int y)
	:glm::vec2(x,y){}
};

class ofMessage : public ofEventArgs{
	public:
		ofMessage( std::string msg ){
			message = msg;
		}
		std::string message;
};

enum ofTimeMode{
	System,
	FixedRate,
	Filtered,
};

class ofCoreEvents {
  public:
	ofCoreEvents();
	ofEvent<ofEventArgs> 		setup;
	ofEvent<ofEventArgs> 		update;
	ofEvent<ofEventArgs> 		draw;
	ofEvent<ofEventArgs> 		exit;

	ofEvent<ofResizeEventArgs> 	windowResized;
	ofEvent<ofWindowPosEventArgs> 	windowMoved;

	ofEvent<ofKeyEventArgs> 	keyPressed;
	ofEvent<ofKeyEventArgs> 	keyReleased;

	ofEvent<ofMouseEventArgs> 	mouseMoved;
	ofEvent<ofMouseEventArgs> 	mouseDragged;
	ofEvent<ofMouseEventArgs> 	mousePressed;
	ofEvent<ofMouseEventArgs> 	mouseReleased;
	ofEvent<ofMouseEventArgs> 	mouseScrolled;
	ofEvent<ofMouseEventArgs> 	mouseEntered;
	ofEvent<ofMouseEventArgs> 	mouseExited;

	ofEvent<ofTouchEventArgs>	touchDown;
	ofEvent<ofTouchEventArgs>	touchUp;
	ofEvent<ofTouchEventArgs>	touchMoved;
	ofEvent<ofTouchEventArgs>	touchDoubleTap;
	ofEvent<ofTouchEventArgs>	touchCancelled;

	ofEvent<ofMessage>			messageEvent;
	ofEvent<ofDragInfo>			fileDragEvent;
	ofEvent<uint32_t>			charEvent;

	void disable();
	void enable();

	void setTimeModeSystem();
	void setTimeModeFixedRate(uint64_t nanosecsPerFrame);
	void setTimeModeFiltered(float alpha);

	void setFrameRate(int _targetRate);
	float getFrameRate() const;
	float getTargetFrameRate() const;
	double getLastFrameTime() const;
	uint64_t getFrameNum() const;

	bool getMousePressed(int button=-1) const;
	bool getKeyPressed(int key=-1) const;
	int getMouseX() const;
	int getMouseY() const;
	int getPreviousMouseX() const;
	int getPreviousMouseY() const;
	int getModifiers() const;

	//  event notification only for internal OF use
	bool notifySetup();
	bool notifyUpdate();
	bool notifyDraw();

	bool notifyKeyPressed(int key, int keycode=-1, int scancode=-1, uint32_t codepoint=0);
	bool notifyKeyReleased(int key, int keycode=-1, int scancode=-1, uint32_t codepoint=0);
	bool notifyKeyEvent(ofKeyEventArgs & keyEvent);

	bool notifyMousePressed(int x, int y, int button);
	bool notifyMouseReleased(int x, int y, int button);
	bool notifyMouseDragged(int x, int y, int button);
	bool notifyMouseMoved(int x, int y);
	bool notifyMouseScrolled(int x, int y, float scrollX, float scrollY);
	bool notifyMouseEntered(int x, int y);
	bool notifyMouseExited(int x, int y);
	bool notifyMouseEvent(ofMouseEventArgs & mouseEvent);

	void notifyTouchDown(int x, int y, int touchID);
	void notifyTouchUp(int x, int y, int touchID);
	void notifyTouchMoved(int x, int y, int touchID);
	void notifyTouchCancelled(int x, int y, int touchID);
	void notifyTouchDoubleTap(int x, int y, int touchID);
	void notifyTouchEvent(ofTouchEventArgs & touchEvent);

	bool notifyExit();
	bool notifyWindowResized(int width, int height);
	bool notifyWindowMoved(int x, int y);

	bool notifyDragEvent(ofDragInfo info);

private:
	float targetRate;
	bool bFrameRateSet;
	ofTimer timer;
	ofFpsCounter fps;

	int	currentMouseX, currentMouseY;
	int	previousMouseX, previousMouseY;
	bool bPreMouseNotSet;
	std::set<int> pressedMouseButtons;
	std::set<int> pressedKeys;
	int modifiers = 0;

	enum TimeMode{
		System,
		FixedRate,
		Filtered,
	} timeMode = System;
	std::chrono::nanoseconds fixedRateTimeNanos;
};

bool ofSendMessage(ofMessage msg);
bool ofSendMessage(std::string messageString);

ofCoreEvents & ofEvents();

template<class ListenerClass>
void ofRegisterMouseEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofAddListener(ofEvents().mouseDragged,listener,&ListenerClass::mouseDragged,prio);
	ofAddListener(ofEvents().mouseMoved,listener,&ListenerClass::mouseMoved,prio);
	ofAddListener(ofEvents().mousePressed,listener,&ListenerClass::mousePressed,prio);
	ofAddListener(ofEvents().mouseReleased,listener,&ListenerClass::mouseReleased,prio);
	ofAddListener(ofEvents().mouseScrolled,listener,&ListenerClass::mouseScrolled,prio);
	ofAddListener(ofEvents().mouseEntered,listener,&ListenerClass::mouseEntered,prio);
	ofAddListener(ofEvents().mouseExited,listener,&ListenerClass::mouseExited,prio);
}

template<class ListenerClass>
void ofRegisterKeyEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofAddListener(ofEvents().keyPressed, listener, &ListenerClass::keyPressed,prio);
	ofAddListener(ofEvents().keyReleased, listener, &ListenerClass::keyReleased,prio);
}

template<class ListenerClass>
void ofRegisterTouchEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofAddListener(ofEvents().touchDoubleTap, listener, &ListenerClass::touchDoubleTap,prio);
	ofAddListener(ofEvents().touchDown, listener, &ListenerClass::touchDown,prio);
	ofAddListener(ofEvents().touchMoved, listener, &ListenerClass::touchMoved,prio);
	ofAddListener(ofEvents().touchUp, listener, &ListenerClass::touchUp,prio);
	ofAddListener(ofEvents().touchCancelled, listener, &ListenerClass::touchCancelled,prio);
}

template<class ListenerClass>
void ofRegisterGetMessages(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofAddListener(ofEvents().messageEvent, listener, &ListenerClass::gotMessage,prio);
}

template<class ListenerClass>
void ofRegisterDragEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofAddListener(ofEvents().fileDragEvent, listener, &ListenerClass::dragEvent,prio);
}

template<class ListenerClass>
void ofUnregisterMouseEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofRemoveListener(ofEvents().mouseDragged,listener,&ListenerClass::mouseDragged,prio);
	ofRemoveListener(ofEvents().mouseMoved,listener,&ListenerClass::mouseMoved,prio);
	ofRemoveListener(ofEvents().mousePressed,listener,&ListenerClass::mousePressed,prio);
	ofRemoveListener(ofEvents().mouseReleased,listener,&ListenerClass::mouseReleased,prio);
	ofRemoveListener(ofEvents().mouseScrolled,listener,&ListenerClass::mouseScrolled,prio);
	ofRemoveListener(ofEvents().mouseEntered,listener,&ListenerClass::mouseEntered,prio);
	ofRemoveListener(ofEvents().mouseExited,listener,&ListenerClass::mouseExited,prio);
}

template<class ListenerClass>
void ofUnregisterKeyEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofRemoveListener(ofEvents().keyPressed, listener, &ListenerClass::keyPressed,prio);
	ofRemoveListener(ofEvents().keyReleased, listener, &ListenerClass::keyReleased,prio);
}

template<class ListenerClass>
void ofUnregisterTouchEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofRemoveListener(ofEvents().touchDoubleTap, listener, &ListenerClass::touchDoubleTap,prio);
	ofRemoveListener(ofEvents().touchDown, listener, &ListenerClass::touchDown,prio);
	ofRemoveListener(ofEvents().touchMoved, listener, &ListenerClass::touchMoved,prio);
	ofRemoveListener(ofEvents().touchUp, listener, &ListenerClass::touchUp,prio);
	ofRemoveListener(ofEvents().touchCancelled, listener, &ListenerClass::touchCancelled,prio);
}

template<class ListenerClass>
void ofUnregisterGetMessages(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofRemoveListener(ofEvents().messageEvent, listener, &ListenerClass::gotMessage,prio);
}

template<class ListenerClass>
void ofUnregisterDragEvents(ListenerClass * listener, int prio=OF_EVENT_ORDER_AFTER_APP){
	ofRemoveListener(ofEvents().fileDragEvent, listener, &ListenerClass::dragEvent,prio);
}

#line 0 "../libs/openFrameworks/events/ofEventUtils.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofEvent.h" */

#include <stdio.h>
#include <stdlib.h>

//----------------------------------------------------
/// register any method of any class to an event.
///
/// the method must provide one of the following
/// signatures:
///     void method(ArgumentsType & args)
///     void method(const void * sender, ArgumentsType &args)
/// ie:
///     ofAddListener(addon.newIntEvent, this, &Class::method)

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofAddListener(EventType & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofAddListener(EventType & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofAddListener(ofEvent<void> & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofAddListener(ofEvent<void> & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofAddListener(EventType & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofAddListener(EventType & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofAddListener(ofEvent<void> & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofAddListener(ofEvent<void> & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
    event.add(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType>
void ofAddListener(EventType & event, void (*listenerFunction)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
    event.add(listenerFunction, prio);
}

template <class EventType,typename ArgumentsType>
void ofAddListener(EventType & event, void (*listenerFunction)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
    event.add(listenerFunction, prio);
}

inline void ofAddListener(ofEvent<void> & event, void (*listenerFunction)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
    event.add(listenerFunction, prio);
}

inline void ofAddListener(ofEvent<void> & event, void (*listenerFunction)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
    event.add(listenerFunction, prio);
}

template <class EventType,typename ArgumentsType>
void ofAddListener(EventType & event, bool (*listenerFunction)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
    event.add(listenerFunction, prio);
}

template <class EventType,typename ArgumentsType>
void ofAddListener(EventType & event, bool (*listenerFunction)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(*listenerFunction, prio);
    event.add(*listenerFunction, prio);
}

inline void ofAddListener(ofEvent<void> & event, bool (*listenerFunction)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(*listenerFunction, prio);
    event.add(*listenerFunction, prio);
}

inline void ofAddListener(ofEvent<void> & event, bool (*listenerFunction)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
    event.add(listenerFunction, prio);
}
//----------------------------------------------------
/// unregister any method of any class to an event.
///
/// the method must provide one the following
/// signatures:
///     void method(ArgumentsType & args)
///     void method(const void * sender, ArgumentsType &args)
/// ie:
///     ofAddListener(addon.newIntEvent, this, &Class::method)

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofRemoveListener(EventType & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofRemoveListener(EventType & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofRemoveListener(ofEvent<void> & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofRemoveListener(ofEvent<void> & event, ListenerClass  * listener, void (ListenerClass::*listenerMethod)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofRemoveListener(EventType & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType, class ListenerClass>
void ofRemoveListener(EventType & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofRemoveListener(ofEvent<void> & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class ListenerClass>
void ofRemoveListener(ofEvent<void> & event, ListenerClass  * listener, bool (ListenerClass::*listenerMethod)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listener, listenerMethod, prio);
}

template <class EventType,typename ArgumentsType>
void ofRemoveListener(EventType & event, void (*listenerFunction)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}

template <class EventType,typename ArgumentsType>
void ofRemoveListener(EventType & event, void (*listenerFunction)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}

inline void ofRemoveListener(ofEvent<void> & event, void (*listenerFunction)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}

inline void ofRemoveListener(ofEvent<void> & event, void (*listenerFunction)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}

template <class EventType,typename ArgumentsType>
void ofRemoveListener(EventType & event, bool (*listenerFunction)(const void*, ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}

template <class EventType,typename ArgumentsType>
void ofRemoveListener(EventType & event, bool (*listenerFunction)(ArgumentsType&), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}

inline void ofRemoveListener(ofEvent<void> & event, bool (*listenerFunction)(const void*), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}

inline void ofRemoveListener(ofEvent<void> & event, bool (*listenerFunction)(), int prio=OF_EVENT_ORDER_AFTER_APP){
    event.remove(listenerFunction, prio);
}
//----------------------------------------------------
/// notifies an event so all the registered listeners
/// get called
///
/// ie:
///	ofNotifyEvent(addon.newIntEvent, intArgument, this)
///
/// or in case there's no sender:
///	ofNotifyEvent(addon.newIntEvent, intArgument)
///
/// @returns: true in case any listener attended the event

template <class EventType,typename ArgumentsType, typename SenderType>
inline bool ofNotifyEvent(EventType & event, ArgumentsType & args, SenderType * sender){
	return event.notify(sender,args);
}

template <class EventType,typename ArgumentsType>
inline bool ofNotifyEvent(EventType & event, ArgumentsType & args){
	return event.notify(args);
}

template <class EventType, typename ArgumentsType, typename SenderType>
inline bool ofNotifyEvent(EventType & event, const ArgumentsType & args, SenderType * sender){
	return event.notify(sender,args);
}

template <class EventType,typename ArgumentsType>
inline bool ofNotifyEvent(EventType & event, const ArgumentsType & args){
	return event.notify(args);
}

template <typename SenderType>
inline bool ofNotifyEvent(ofEvent<void> & event, SenderType * sender){
	return event.notify(sender);
}

inline bool ofNotifyEvent(ofEvent<void> & event){
	return event.notify();
}


#line 0 "../libs/openFrameworks/graphics/ofGraphicsConstants.h"
#pragma once

/* #include "ofMathConstants.h" */

template<typename T>
class ofColor_;
typedef ofColor_<float> ofFloatColor;
using ofDefaultVertexType = ofDefaultVec3;
using ofDefaultNormalType = ofDefaultVec3;
using ofDefaultColorType = ofFloatColor;
using ofDefaultTexCoordType = ofDefaultVec2;

enum ofPolyRenderMode{
	OF_MESH_POINTS,
	OF_MESH_WIREFRAME,
	OF_MESH_FILL
};


enum ofPrimitiveMode{
	OF_PRIMITIVE_TRIANGLES,
	OF_PRIMITIVE_TRIANGLE_STRIP,
	OF_PRIMITIVE_TRIANGLE_FAN,
	OF_PRIMITIVE_LINES,
	OF_PRIMITIVE_LINE_STRIP,
	OF_PRIMITIVE_LINE_LOOP,
	OF_PRIMITIVE_POINTS,
#ifndef TARGET_OPENGLES
	OF_PRIMITIVE_LINES_ADJACENCY,
	OF_PRIMITIVE_LINE_STRIP_ADJACENCY,
	OF_PRIMITIVE_TRIANGLES_ADJACENCY,
	OF_PRIMITIVE_TRIANGLE_STRIP_ADJACENCY,
	OF_PRIMITIVE_PATCHES
#endif
};


/// \brief Used to represent the available fill modes.
///
/// \sa ofBaseRenderer
enum ofFillFlag{
	/// \brief Draw shapes as outlines, unfilled.
	OF_OUTLINE=	0,
	/// \brief Draw shapes filled with the current draw color.
	OF_FILLED = 1,
};

#define		OF_MAX_STYLE_HISTORY	32

/// \deprecated Not currently used in the OF codebase.
#define		OF_MAX_VIEWPORT_HISTORY	32

/// \deprecated Not currently used in the OF codebase.
#define		OF_MAX_CIRCLE_PTS 1024

/// \brief Used to represent the available blending modes for drawing.
enum ofBlendMode{
	/// \brief Blend mode is disabled.
	OF_BLENDMODE_DISABLED = 0,
	/// \brief Blend mode used for alpha blending.
	OF_BLENDMODE_ALPHA 	  = 1,
	/// \brief Blend mode used for additive blending.
	OF_BLENDMODE_ADD 	  = 2,
	/// \brief Blend mode used for subtractive blending.
	OF_BLENDMODE_SUBTRACT = 3,
	/// \brief Blend mode used for multiplicative blending.
	OF_BLENDMODE_MULTIPLY = 4,
	/// \brief Blend mode used for screen blending.
	OF_BLENDMODE_SCREEN   = 5
};


/// \brief Represents the gradient types available to ofBackgroundGradient().
enum ofGradientMode {
	/// \brief Represents a top-to-bottom linear gradient.
	OF_GRADIENT_LINEAR = 0,
	/// \brief Represents a circular gradient beginning at the screen's center.
	OF_GRADIENT_CIRCULAR,
	/// \brief Represents a horizontal bar gradient.
	///
	///  This is a horizontal gradient starting across the screen's center,
	///  and extending both to the top and bottom of the screen.
	OF_GRADIENT_BAR
};

/// \brief represents the available polygon winding modes.
///
/// These are straight out of glu, but renamed and included here
/// for convenience.  We don't mean to wrap the whole glu library
/// (or any other library for that matter), but these defines are useful
/// to give people flexibility over the polygonizer.
///
/// \sa ofPath::tessellate()
/// \sa ofTessellator::performTessellation()
/// \sa http://glprogramming.com/red/images/Image128.gif
/// \sa http://glprogramming.com/red/chapter11.html
enum ofPolyWindingMode{
	/// \brief Fill odd winding numbers.
	OF_POLY_WINDING_ODD 	        ,
	/// \brief Fill all non-zero winding numbers.
	OF_POLY_WINDING_NONZERO         ,
	/// \brief Fill all winding numbers greater than zero.
	OF_POLY_WINDING_POSITIVE        ,
	/// \brief Fill all winding numbers less than zero.
	OF_POLY_WINDING_NEGATIVE        ,
	/// \brief Fill all winding numbers greater than 1 or less than -1.
	///
	/// This stands for "Fill ABSolute values Greater than EQual to TWO".
	OF_POLY_WINDING_ABS_GEQ_TWO
};

/// \brief represents the available matrix coordinate system handednesses.
///
/// \sa ofMatrixStack
/// \sa http://seanmiddleditch.com/matrices-handedness-pre-and-post-multiplication-row-vs-column-major-and-notations/
enum ofHandednessType {OF_LEFT_HANDED, OF_RIGHT_HANDED};

/// \brief represents the available matrix types used internally in ::ofMatrixStack.
enum ofMatrixMode {OF_MATRIX_MODELVIEW=0, OF_MATRIX_PROJECTION, OF_MATRIX_TEXTURE};



/// \brief Sets the bitmap drawing mode for text.
/// \sa ofSetDrawBitmapMode()
enum ofDrawBitmapMode{
	OF_BITMAPMODE_SIMPLE = 0,
	OF_BITMAPMODE_SCREEN,
	OF_BITMAPMODE_VIEWPORT,
	OF_BITMAPMODE_MODEL,
	OF_BITMAPMODE_MODEL_BILLBOARD
};


/// \brief Used to represent the available rectangle drawing modes.
///
/// \sa ofRectangle
/// \sa ofTexture
/// \sa ofImage
enum ofRectMode{
	/// \brief Represents the mode where rectangles draw from the top left.
	OF_RECTMODE_CORNER=0,
	/// \brief Represents the mode where rectangles draw from the center.
	OF_RECTMODE_CENTER=1
};


/// \brief Used to represent the available channel types in ofImage.
///
/// These represent an abstraction of both CPU pixels (ofPixels) and GPU pixels
/// (ofTexture). In most cases, developers should prefer ::ofPixelFormat over
/// ::ofImageType for a more precise description of channel types.
///
/// \sa ofImage
enum ofImageType: short{
	/// \brief A single channel (or monochrome) image.
	///
	/// \sa OF_PIXELS_GRAY
	OF_IMAGE_GRAYSCALE		= 0x00,
	/// \brief A three channel (or RGB) image.
	///
	/// \sa OF_PIXELS_RGB
	OF_IMAGE_COLOR			= 0x01,
	/// \brief A four channel (or RGBA) image.
	///
	/// \sa OF_PIXELS_RGBA
	OF_IMAGE_COLOR_ALPHA	= 0x02,
	/// \brief An unknown and unsupported image type.
	///
	/// \sa OF_PIXELS_UNKNOWN
	OF_IMAGE_UNDEFINED		= 0x03
};

#line 0 "../libs/openFrameworks/graphics/ofGraphicsBaseTypes.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofGraphicsConstants.h" */
#include "glm/fwd.hpp"
/* #include "ofColor.h" */

class ofRectangle;

template<typename T>
class ofPixels_;

typedef ofPixels_<unsigned char> ofPixels;
typedef ofPixels_<float> ofFloatPixels;
typedef ofPixels_<unsigned short> ofShortPixels;
typedef ofPixels& ofPixelsRef;

template<typename T>
class ofImage_;

typedef ofImage_<unsigned char> ofImage;
typedef ofImage_<float> ofFloatImage;
typedef ofImage_<unsigned short> ofShortImage;

class ofPath;
class of3dPrimitive;
class ofLight;
class ofMaterial;
class ofBaseMaterial;
class ofCamera;
class ofTrueTypeFont;
class ofNode;
class of3dGraphics;
class ofVbo;
class ofVboMesh;
class ofSoundBuffer;
class ofFbo;
class ofBaseVideoDraws;

template<class T>
class ofPolyline_;
using ofPolyline = ofPolyline_<ofDefaultVertexType>;

template<class V, class N, class C, class T>
class ofMesh_;
using ofMesh = ofMesh_<ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType>;

enum ofFboMode: short;
enum ofLoopType: short;
enum ofOrientation: short;

/// \brief Contains general information about the style of ofGraphics
/// elements such as color, line width and others.
class ofStyle{
	public:
		/// \brief Create a default ofStyle.
		ofStyle(){
			bFill				= true;
			blendingMode		= OF_BLENDMODE_ALPHA;
			smoothing			= false;
			circleResolution	= 20;
			sphereResolution	= 20;
			curveResolution		= 20;
			lineWidth			= 1.0;
			polyMode			= OF_POLY_WINDING_ODD;
			rectMode			= OF_RECTMODE_CORNER;
			#ifdef TARGET_OPENGLES
				drawBitmapMode		= OF_BITMAPMODE_SIMPLE;
			#else
				drawBitmapMode		= OF_BITMAPMODE_MODEL_BILLBOARD;
			#endif
			bgColor.set(200,200,200);
			//depthTest = false;
		}

		/// \brief Destroy the ofStyle.
		virtual ~ofStyle(){}

		/// \brief The color used when rendering.
		///
		/// This style depends on the state of the ofStyle::bFill.
		ofColor color;

		/// \brief The background color used when rendering.
		ofColor bgColor;

		/// \brief The current rendering mode for polygons.
		///
		/// ofPolyWindingMode determines how ovelapping parts of the same
		/// polygon are rendered.
		///
		/// \sa ofPolyWindingMode
		ofPolyWindingMode polyMode;

		/// \brief Determine how some shapes are anchored (e.g. ofDrawEllipse).
		///
		/// The rectMode applies to several shapes, including ofDrawRectangle
		/// and ofDrawEllipse.  If the current rectMode is `OF_RECTMODE_CENTER`,
		/// the rendered shape will be drawn with x, y in the center of the
		/// shape. If the current rectMode is `OF_RECTMODE_CORNER`, the
		/// rendered shape will be drawn with the x, y in the upper-left-hand
		/// corner of the shape.
		ofRectMode rectMode;

		/// \brief True if the renderer should fill a rendered shape.
		///
		/// If true, the renderer will fill the rendered shape.  If false, the
		/// renderer will draw the outline of the rendered shape.
		bool bFill;

		/// \brief The render mode for bitmaps (e.g. ofDrawBitmapString).
		///
		/// \sa ofDrawBitmapString(const T& textString, float x, float y)
		ofDrawBitmapMode drawBitmapMode;

		/// \brief The blending mode.
		ofBlendMode blendingMode;

		/// \brief True if anti-aliasing is enabled.
		bool smoothing;

		// \brief The resolution of rendered circles and arcs (e.g. ofCircle).
		int circleResolution;

		// \brief The resolution of rendered spheres (e.g. ofSphere).
		int sphereResolution;

		// \brief The resolution of rendered curves.
		int curveResolution;

		/// \brief The width of rendered lines.
		/// \warning This is not currently implemented in modern OF renderers.
		float lineWidth;

		//bool depthTest; removed since it'll break old projects setting depth test through glEnable
};

//----------------------------------------------------------
// ofBaseDraws
//----------------------------------------------------------

class ofBaseDraws{
public:
	/// \brief Destroy the abstract object.
	virtual ~ofBaseDraws(){}

	/// \brief Draw at a position at the native size.
	///
	/// Native size is determined by getWidth() and getHeight().
	///
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	virtual void draw(float x, float y) const {
		draw(x, y, getWidth(), getHeight());
	}

	/// \brief Draw at a position with the specified size.
	///
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	/// \param w Draw width.
	/// \param h Draw height.
	virtual void draw(float x, float y, float w, float h) const = 0;

	/// \brief Draw at a position at the native size.
	///
	/// Native size is determined by getWidth() and getHeight().
	///
	/// \param point Draw position.
	virtual void draw(const glm::vec2 & point) const;

	/// \brief Draw at a position and size specified by a rectangle.
	///
	/// \param rect Draw position and size.
	virtual void draw(const ofRectangle & rect) const;

	/// \brief Draw at a position.
	///
	/// \param point Draw position.
	/// \param w Draw width.
	/// \param h Draw height.
	virtual void draw(const glm::vec2 & point, float w, float h) const;

	/// \brief Get the height.
	/// \returns the height.
	virtual float getHeight() const = 0;

	/// \brief Get the width.
	/// \returns the width.
	virtual float getWidth() const = 0;

	/// \brief Set the anchor point the item is drawn around as a percentage.
	///
	/// This can be useful if you want to rotate an image around a particular
	/// point.
	///
	/// \param xPct Horizontal position as a percentage (0 - 1).
	/// \param yPct Vertical position as a percentage (0 - 1).
	virtual void setAnchorPercent(float xPct, float yPct){};

	/// \brief Set the anchor point the item is drawn around in pixels.
	///
	/// This can be useful if you want to rotate an image around a particular
	/// point.
	///
	/// \param x Horizontal texture position in pixels.
	/// \param y Vertical texture position in pixels.
	virtual void setAnchorPoint(float x, float y){};

	/// \brief Reset the anchor point to (0, 0).
	virtual void resetAnchor(){};

};

/// \brief An abstract class representing an object that can be updated.
class ofBaseUpdates{
public:
	/// \brief Destroy the ofBaseUpdates.
	virtual ~ofBaseUpdates(){}

	/// \brief Update the object's state.
	virtual void update()=0;
};

/// \brief An abstract class representing an object that has pixels.
///
/// This empty class primarily exists to allow templated subclasses of different
/// types to be stored as raw or shared pointers in collections such as
/// std::vector.
///
/// Example:
/// \code{.cpp}
///
/// std::vector<ofAbstractHasPixels> pixelProviders;
///
/// ofPixels pixels;
/// ofFloatPixels floatPixels;
/// ofShortPixels shortPixels;
///
/// // ...
///
/// pixelProviders.push_back(&pixels);
/// pixelProviders.push_back(&floatPixels);
/// pixelProviders.push_back(&shortPixels);
///
/// \endcode
class ofAbstractHasPixels{
public:
	/// \brief Destroy the ofAbstractHasPixels.
	virtual ~ofAbstractHasPixels(){}
};


/// \brief A base class represeting an object that has pixels.
/// \tparam T The pixel data type.
template<typename T>
class ofBaseHasPixels_: public ofAbstractHasPixels{
public:
	/// \brief Destroy the ofAbstractHasPixels.
	virtual ~ofBaseHasPixels_<T>(){}

	/// \brief Get a reference to the underlying ofPixels.
	/// \returns a reference the underlying ofPixels.
	virtual ofPixels_<T> & getPixels()=0;

	/// \brief Get a const reference to the underlying ofPixels.
	/// \returns a const reference the underlying ofPixels.
	virtual const ofPixels_<T> & getPixels() const=0;
};

/// \brief A typedef for an unsigned char ofBaseHasPixels_.
typedef ofBaseHasPixels_<unsigned char> ofBaseHasPixels;

/// \brief A typedef for an float ofBaseHasPixels_.
typedef ofBaseHasPixels_<float> ofBaseHasFloatPixels;

/// \brief A typedef for an unsigned short ofBaseHasPixels_.
typedef ofBaseHasPixels_<unsigned short> ofBaseHasShortPixels;


/// \brief The base renderer interface.
class ofBaseRenderer{
public:
	virtual ~ofBaseRenderer(){}

	/// \brief Get the string representation of the renderer type.
	///
	/// For example, this method may return "GL", "ProgrammableGL", or another
	/// type depending on the renderer being used.
	///
	/// \returns The string representation of the renderer type.
	virtual const std::string & getType()=0;

	/// \brief Starts using this renderer as the rendering surface.
	virtual void startRender() = 0;
	/// \brief Stop using this renderer as the rendering surface.
	virtual void finishRender() = 0;

	/// \brief Draw a polyline with this renderer.
	/// \param poly The polyline to draw with this renderer.
	virtual void draw(const ofPolyline & poly) const=0;
	/// \brief Draw a path with this renderer.
	/// \param shape The path to draw with this renderer.
	virtual void draw(const ofPath & shape) const=0;
	/// \brief Draw a path with this renderer at \p x and \p y.
	/// \param shape The path to draw with this renderer.
	/// \param x The x coordinate to use to draw \p shape.
	/// \param y The y coordinate to use to draw \p shape.
	virtual void draw(const ofPath & shape, float x, float y) const{
		const_cast<ofBaseRenderer*>(this)->pushMatrix();
		const_cast<ofBaseRenderer*>(this)->translate(x,y);
		draw(shape);
		const_cast<ofBaseRenderer*>(this)->popMatrix();
	}
	/// \brief Draw a \p mesh with this renderer using the \p renderType.
	///
	/// \p renderType defines how the \p mesh will be rendered and may be:
	/// 	OF_MESH_POINTS,
	///		OF_MESH_WIREFRAME,
	///		OF_MESH_FILL
	///
	/// \param mesh The mesh to draw with this renderer.
	/// \param renderType The render mode to use to draw \p mesh with this
	/// renderer.
	/// \sa ofPolyRenderMode
	virtual void draw(const ofMesh & mesh, ofPolyRenderMode renderType) const;

	/// \brief Draw a mesh with this renderer.
	///
	/// \p renderType defines how the \p mesh will be rendered and may be:
	/// 	OF_MESH_POINTS,
	///		OF_MESH_WIREFRAME,
	///		OF_MESH_FILL
	///
	/// \param vertexData The mesh to draw with this renderer.
	/// \param renderType The render mode to use to draw \p vertexData to
	/// this renderer.
	/// \param useColors True to use per-vertex coloring to draw the
	/// \p vertexData.
	/// \param useTextures True to use texture coordinates to draw the \p
	/// vertexData.
	/// \param useNormals True to use normals to draw the \p vertexData.
	/// \sa ofPolyRenderMode
	virtual void draw(const ofMesh & vertexData, ofPolyRenderMode renderType, bool useColors, bool useTextures, bool useNormals) const=0;

	/// \brief Draw a \p model with this renderer using the \p renderType.
	///
	/// \p renderType defines how the \p model will be rendered and may be:
	/// 	OF_MESH_POINTS,
	///		OF_MESH_WIREFRAME,
	///		OF_MESH_FILL
	///
	/// \param model The model to draw with this renderer.
	/// \param renderType The render mode to use when drawing the \p model
	/// with this renderer.
	/// \sa ofPolyRenderMode
	virtual void draw(const of3dPrimitive& model, ofPolyRenderMode renderType) const=0;

	/// \brief Draw a node with this renderer using ofNode::customDraw().
	/// \param model The node to draw with this renderer.
	/// \sa ofNode::customDraw()
	virtual void draw(const ofNode& model) const=0;

	/// \brief Draw an \p image with this renderer.
	/// \param image The image to draw with this renderer.
	/// \param x The x coordinate to use when drawing \p image with this
	/// renderer.
	/// \param y The y coordinate to use to draw \p image with this renderer.
	/// \param z The z coordinate to use to drawing \p image with this renderer.
	/// \param w The width to use to draw the \p image with this renderer.
	/// \param h The height to use to draw the \p image with this renderer.
	/// \param sx The subsection x axis offset within the image texture.
	/// \param sy The subsection y axis offset within the image texture.
	/// \param sw The subsection width offset within the image texture.
	/// \param sh The subsection height offset within the image texture.
	virtual void draw(const ofImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const=0;

	/// \brief Draw an \p image with this renderer.
	/// \param image The image to draw with this renderer.
	/// \param x The x coordinate to use to draw \p image with this renderer.
	/// \param y The y coordinate to use to draw \p image with this renderer.
	/// \param z The z coordinate to use to draw \p image with this renderer.
	/// \param w The width to use to draw \p image with this renderer.
	/// \param h The height to use to draw \p image with this renderer.
	/// \param sx The subsection x axis offset within the image texture.
	/// \param sy The subsection y axis offset within the image texture.
	/// \param sw The subsection width offset within the image texture.
	/// \param sh The subsection height offset within the image texture.
	virtual void draw(const ofFloatImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const=0;

	/// \brief Draw an \p image with this renderer.
	/// \param image The image to draw with this renderer.
	/// \param x The x coordinate to use to draw \p image with this renderer.
	/// \param y The y coordinate to use to draw \p image with this renderer.
	/// \param z The z coordinate to use to draw \p image with this renderer.
	/// \param w The width to use when drawing the image with this renderer.
	/// \param h The height to use when drawing the image with this renderer.
	/// \param sx The subsection x axis offset within the image texture.
	/// \param sy The subsection y axis offset within the image texture.
	/// \param sw The subsection width offset within the image texture.
	/// \param sh The subsection height offset within the image texture.
	virtual void draw(const ofShortImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const=0;

	/// \brief Draw a \p video with this renderer.
	/// \param video The video with draw with this renderer.
	/// \param x The x coordinate to use to draw \p video with this renderer.
	/// \param y The y coordinate to use to draw \p video with this renderer.
	/// \param w The width to use to draw the video with this renderer.
	/// \param h The height to use to draw the video with this renderer.
	virtual void draw(const ofBaseVideoDraws & video, float x, float y, float w, float h) const=0;

	//--------------------------------------------
	// transformations
	/// \brief Push the current viewport into the renderer's viewport stack.
	///
	/// pushViewport() save the current viewport to the renderer's viewport
	/// history stack allowing new viewport operations to effect only the new
	/// viewport created by this method. Should be paired with popView.
	///
	/// \sa viewport()
	virtual void pushView()=0;

	/// \brief Pop the current viewport from the renderer's view stack.
	///
	/// popView() restores the renderer's viewport to the state it was last
	/// saved with with a call to pushView().
	///
	/// \sa viewport()
	virtual void popView()=0;

	/// \brief Set this renderer's viewport using a rectangle.
	///
	/// This method uses the ofGetWidth() and ofGetHeight() to set the width and
	/// height of the viewport. It also automatically creates near and far
	/// clipping planes based on this width and height.
	virtual void viewport(ofRectangle viewport)=0;

	/// \brief Set this renderer's viewport manually using x, y, width, and
	/// height.
	/// \param x The x coordinate of the viewport. Defaults to 0.
	/// \param y The y coordinate of the viewport. Defaults to 0.
	/// \param w The width of the viewport. Defaults to -1 setting its width
	/// according to the rendering surface's width.
	/// \param h The height of the viewport. Defaults to -1 setting its height
	/// according to the rendering surface's height.
	virtual void viewport(float x = 0, float y = 0, float width = -1, float height = -1, bool vflip=true)=0;

	/// \brief Setup the renderer to use a perspective matrix.
	/// \param width The width of the desired perspective matrix. Defaults to -1
	/// setting its width according to the rendering surface's width.
	/// \param height The height of the desired perspective matrix. Defaults to
	/// Defaults to -1 setting its width according to the rendering surface's
	/// width.
	/// \param fov The field of view to use with the perspective matrix.
	/// Defaults to 60.
	/// \param nearDist The near clipping distance to use with the perspective
	/// matrix. Setting this value to 0 uses the default near distance. Defaults
	/// to 0.
	/// \param farDist The far clipping distance to use with the perspective
	/// matrix. Setting this value to 0 uses the default near distance. Defaults
	/// to 0.
	virtual void setupScreenPerspective(float width = -1, float height = -1, float fov = 60, float nearDist = 0, float farDist = 0)=0;

	/// \brief Setup the renderer to use an orthographic matrix.
	/// \param width The width of the desired orthographic matrix. Defaults to
	/// -1 setting its width according to the rendering surface's width.
	/// \param height The height of the desired orthographic matrix. Defaults to
	/// -1 setting its height according to the rendering surface's height.
	/// \param nearDist The near clipping distance to use with the orthographic
	/// matrix. Setting this value to 0 uses the defualt near distance. Defaults
	/// to 0.
	/// \param farDist The far clipping distance to use with the orthographic
	/// matrix. Setting this value to 0 uses the defualt near distance. Defaults
	/// to 0.
	virtual void setupScreenOrtho(float width = -1, float height = -1, float nearDist = -1, float farDist = 1)=0;

	/// \brief set this renderer's orientation.
	///
	/// Possible orientation values include:
	/// 	OF_ORIENTATION_DEFAULT
	///		OF_ORIENTATION_180
	///		OF_ORIENTATION_90_LEFT
	///		OF_ORIENTATION_90_RIGHT
	///		OF_ORIENTATION_UNKNOWN
	///
	/// \param orientation The orientation to use with this renderer.
	/// \param vFlip True if the orientation should be vertically flipped.
	/// \sa ofOrientation
	virtual void setOrientation(ofOrientation orientation, bool vFlip)=0;

	/// \brief Get this renderer's current viewport.
	///
	/// Unlike getNativeViewport(), this method gets this renderer's current
	/// viewport with orientation and vertical flipping applied.
	///
	/// \returns This renderer's viewport as a rectangle.
	/// \sa getNativeViewport()
	virtual ofRectangle getCurrentViewport() const=0;

	/// \brief Get this renderer's current native viewport.
	///
	/// Unlike getViewport(), this method gets this renderer's current viewport
	/// without orientation and vertical flipping applied.
	///
	/// \returns This renderer's native viewport as a rectangle.
	/// \sa getViewport()
	virtual ofRectangle getNativeViewport() const=0;

	/// \brief Get the renderer's current viewport width.
	/// \returns The renderer's current viewport width.
	virtual int getViewportWidth() const=0;

	/// \brief Get the renderer's current viewport width.
	/// \returns The renderer's current viewport width.
	virtual int getViewportHeight() const=0;

	/// \brief Returns true if the renderer's current viewport is vertically
	/// flipped.
	/// \returns True if the renderer's current viewport is vertically flipped.
	virtual bool isVFlipped() const=0;

	/// \brief Set the coordinate handidness of this renderer.
	///
	/// Possible handednesses include OF_LEFT_HANDED and OF_RIGHT_HANDED.
	/// In a left handed coordinate system positive x, y and z axes point right,
	/// up and forward, respectively and positive rotation is clockwise about
	/// the axis of rotation. In a right handed coordinate system the positive x
	/// and y axes point right and up, and the negative z axis points forward
	/// and positive rotation is counterclockwise about the axis of rotation.
	///
	/// \param handedness The handedness to set this renderer to use.
	/// \sa http://seanmiddleditch.com/matrices-handedness-pre-and-post-multiplication-row-vs-column-major-and-notations/
	/// \sa https://www.evl.uic.edu/ralph/508S98/coordinates.html
	virtual void setCoordHandedness(ofHandednessType handedness)=0;

	/// \brief Get the coordinate handidness of this renderer.
	///
	/// Possible handednesses include OF_LEFT_HANDED and OF_RIGHT_HANDED.
	/// In a left handed coordinate system positive x, y and z axes point right,
	/// up and forward, respectively and positive rotation is clockwise about
	/// the axis of rotation. In a right handed coordinate system the positive x
	/// and y axes point right and up, and the negative z axis points forward
	/// and positive rotation is counterclockwise about the axis of rotation.
	///
	/// \returns The handedness this renderer is using.
	/// \sa http://seanmiddleditch.com/matrices-handedness-pre-and-post-multiplication-row-vs-column-major-and-notations/
	/// \sa https://www.evl.uic.edu/ralph/508S98/coordinates.html
	virtual ofHandednessType getCoordHandedness() const=0;

	//our openGL wrappers

	/// \brief Pushes this renderer's matrix stack down by one.
	///
	/// pushMatrix() saves the renderer's current matrix allowing new
	/// transformations and scales to effect only the new matrix created by
	/// this method. Should be paired with a call to popMatrix().
	///
	virtual void pushMatrix()=0;
	/// \brief Pops this renderer's current matrix stack.
	///
	/// popMatrix() restores the renderer's matrix to the state it was last
	/// saved with with a call to pushMatrix().
	///
	virtual void popMatrix()=0;

	/// \brief Get this renderer's current matrix for particular a matrix mode.
	///
	/// Possible matrix modes include:
	///		OF_MATRIX_MODELVIEW
	///		OF_MATRIX_PROJECTION
	///		OF_MATRIX_TEXTURE
	///
	/// \param matrixMode_ The matrix mode to get the current matrix of.
	/// \returns The current matrix specified by \p matrixMode_
	/// \sa ofMatrixMode
	virtual glm::mat4 getCurrentMatrix(ofMatrixMode matrixMode_) const=0;

	/// \brief Get this renderer's current orientation matrix.
	/// \returns This renderer's current orientation matrix.
	virtual glm::mat4 getCurrentOrientationMatrix() const=0;

	/// \brief Translate this renderer's current matrix by x, y, and z.
	/// \param x The x coordinate to translate this renderer's current matrix
	/// by.
	/// \param y The y coordinate to translate this renderer's current matrix
	/// by.
	/// \param z The z coordinate to translate this renderer's current matrix
	/// by. Defaults to 0.
	virtual void translate(float x, float y, float z = 0)=0;

	/// \brief Translate this renderer's current matrix by a point.
	/// \param p The 3D point to translate this renderer's current matrix by.
	virtual void translate(const glm::vec3 & p)=0;

	/// \brief Scale this renderer's current matrix by xAmnt, yAmnt, and zAmnt.
	/// \param xAmnt The amount to scale this renderer's current matrix's x
	/// axis by.
	/// \param yAmnt The amount to scale this renderer's current matrix's y
	/// axis by.
	/// \param zAmnt The amount to scale this renderer's current matrix's z
	/// axis by. Defaults to 1.
	virtual void scale(float xAmnt, float yAmnt, float zAmnt = 1)=0;

	/// \brief Rotate this renderer's current matrix by \p degrees about a euler.
	/// \param degrees Degrees to rotate about vecX, vecY, and vecZ.
	/// \param vecX The x axis to rotate about.
	/// \param vecY The y axis to rotate about.
	/// \param vecZ The z axis to rotate about.
	virtual void rotateDeg(float degrees, float vecX, float vecY, float vecZ);

	/// \brief Rotate this renderer's current matrix by \p degrees about the x
	/// axis.
	/// \param degrees Degrees to rotate about the x axis.
	virtual void rotateXDeg(float degrees);

	/// \brief Rotate this renderer's current matrix by \p degrees about the y
	/// axis.
	/// \param degrees Degrees to rotate about the y axis.
	virtual void rotateYDeg(float degrees);

	/// \brief Rotate this renderer's current matrix by \p degrees about the z
	/// axis.
	/// \param degrees Degrees to rotate about the z axis.
	virtual void rotateZDeg(float degrees);

	/// \brief Rotate this renderer's current matrix by \p degrees about the z
	/// axis.
	///
	/// This method is an alias of rotateZ().
	///
	/// \param degrees Degrees to rotate about the z axis.
	/// \sa rotateZ()
	virtual void rotateDeg(float degrees);

	/// \brief Rotate this renderer's current matrix by \p degrees about a euler.
	/// \param degrees Degrees to rotate about vecX, vecY, and vecZ.
	/// \param vecX The x axis to rotate about.
	/// \param vecY The y axis to rotate about.
	/// \param vecZ The z axis to rotate about.
	virtual void rotateRad(float degrees, float vecX, float vecY, float vecZ)=0;

	/// \brief Rotate this renderer's current matrix by \p degrees about the x
	/// axis.
	/// \param degrees Degrees to rotate about the x axis.
	virtual void rotateXRad(float degrees)=0;

	/// \brief Rotate this renderer's current matrix by \p degrees about the y
	/// axis.
	/// \param degrees Degrees to rotate about the y axis.
	virtual void rotateYRad(float degrees)=0;

	/// \brief Rotate this renderer's current matrix by \p degrees about the z
	/// axis.
	/// \param degrees Degrees to rotate about the z axis.
	virtual void rotateZRad(float degrees)=0;

	/// \brief Rotate this renderer's current matrix by \p degrees about the z
	/// axis.
	///
	/// This method is an alias of rotateZ().
	///
	/// \param degrees Degrees to rotate about the z axis.
	/// \sa rotateZ()
	virtual void rotateRad(float degrees)=0;

	/// \brief Sets this renderer's current matrix mode.
	///
	/// The possible matrix modes include:
	///		OF_MATRIX_MODELVIEW
	///		OF_MATRIX_PROJECTION
	///		OF_MATRIX_TEXTURE
	///
	/// \param mode The matrix mode this renderer's matrix should use.
	virtual void matrixMode(ofMatrixMode mode)=0;

	/// \brief Load this renderer's identity matrix.
	///
	/// This identity matrix is an mat4 matrix with 1s on the main
	/// diagonal and 0s elsewhere.
	/// [
	///		[1, 0, 0, 0],
	///		[0, 1, 0, 0],
	///		[0, 0, 1, 0],
	///		[0, 0, 0, 1]
	///	]
	///
	/// Matrix multiplications using this matrix as the multiplier will yield no
	/// change in the multiplicand matrix.
	virtual void loadIdentityMatrix (void)=0;

	/// \brief Load a matrix as this renderer's current matrix.
	/// \param m The matrix to load into this renderer.
	virtual void loadMatrix (const glm::mat4 & m)=0;

	/// \brief Load m as this renderer's current matrix.
	///
	/// \p m can be passed to loadMatrix() in this way from raw data
	///
	/// \param m Float pointer to an 4x4 matrix.
	virtual void loadMatrix (const float *m)=0;

	/// \brief Multiply this renderer's current matrix by \p m.
	/// \param m The matrix to multiply this renderer's current matrix by.
	virtual void multMatrix (const glm::mat4 & m)=0;

	/// \brief Multiply this renderer's current matrix by \p m.
	///
	/// \p m can be passed to loadMatrix() in this way with raw data
	///
	/// \param m Float pointer to an mat4 to multiply this renderer's
	/// current matrix by.
	virtual void multMatrix (const float *m)=0;

	/// \brief Load \p m into this renderer's matrix stack as a view matrix.
	/// \param m The view matrix to load into this renderer's matrix stack.
	virtual void loadViewMatrix(const glm::mat4 & m)=0;

	/// \brief Multiply this renderer's view matrix by \p m.
	/// \param m The matrix to multiply this renderer's view matrix by.
	virtual void multViewMatrix(const glm::mat4 & m)=0;

	/// \brief Get this renderer's current view matrix.
	/// \returns This renderer's current view matrix.
	virtual glm::mat4 getCurrentViewMatrix() const=0;

	/// \brief Get this renderer's current normal matrix.
	/// \returns This renderer's current normal matrix.
	virtual glm::mat4 getCurrentNormalMatrix() const=0;


	/// \brief Bind \p camera's matrices to this renderer's matrix stack.
	///
	/// Bind's the \p camera's modelview and projection matrices to this
	/// renderer's matrix stack using \p viewport. Should be followed with a
	/// call to unbind().
	///
	/// \param camera The camera to bind to this renderer.
	/// \param viewport The viewport to use when binding \p camera to this
	/// renderer.
	virtual void bind(const ofCamera & camera, const ofRectangle & viewport)=0;
	/// \brief Unbind the camera from this renderer.
	/// \param camera The camera to unbind from this renderer.
	virtual void unbind(const ofCamera & camera)=0;


	/// \brief setup the default graphics settings for this renderer.
	virtual void setupGraphicDefaults()=0;
	/// \brief setup the default screen settings for this renderer.
	virtual void setupScreen()=0;

	// drawing modes
	/// \brief Set this renderer's rect mode.
	///
	/// Possible rect modes include OF_RECTMODE_CORNER and OF_RECTMODE_CENTER.
	///
	/// \param mode The rect mode to request this renderer to use.
	/// \sa ofRectMode
	virtual void setRectMode(ofRectMode mode)=0;
	/// \brief Get this renderer's current rect mode.
	///
	/// Possible rect modes include OF_RECTMODE_CORNER and OF_RECTMODE_CENTER.
	///
	/// \returns The renderer's current rect mode.
	/// \sa ofRectMode
	virtual ofRectMode getRectMode()=0;
	/// \brief set this renderer's fill flag.
	///
	/// Possible fill flags include OF_OUTLINE and OF_FILLED.
	///
	/// \param fill The fill flag to request this renderer to use.
	/// \sa ofFillFlag
	virtual void setFillMode(ofFillFlag fill)=0;
	/// \brief Get this renderer's current fill flag.
	///
	/// Possible fill flags include OF_OUTLINE and OF_FILLED.
	///
	/// \returns The fill flag this render is currently using.
	/// \sa ofFillFlag
	virtual ofFillFlag getFillMode()=0;
	/// \brief Set the line width this renderer should use when drawing lines.
	/// \param lineWidth The line width to request this renderer to use.
	virtual void setLineWidth(float lineWidth)=0;
	/// \brief Enable/disable depth testing with this renderer.
	///
	/// When depth testing is enabled the order shapes are drawn with the
	/// renderer is dependent on their distance from the camera rather than the
	/// order their drawing methods were called. This should be enabled when
	/// expecting normal behavior when drawing 3D scenes.
	///
	/// \param depthTest True to enable depth testing.
	virtual void setDepthTest(bool depthTest)=0;
	/// \brief Set this renderer's current blend mode.
	///
	/// Possible blend modes include:
	/// \brief Rotate this renderer's current matrix by \p degrees about the z
	/// axis.
	///
	/// This method is an alias of rotateZ().
	///
	/// \param degrees Degrees to rotate about the z axis.
	/// \sa rotateZ()
	///		OF_BLENDMODE_DISABLED
	///		OF_BLENDMODE_ALPHA
	///		OF_BLENDMODE_ADD
	///		OF_BLENDMODE_SUBTRACT
	///		OF_BLENDMODE_MULTIPLY
	///		OF_BLENDMODE_SCREEN
	///
	/// \param blendMode The blend mode to request this renderer to use.
	/// \sa ofBlendMode
	/// \sa https://helpx.adobe.com/photoshop/using/blending-modes.html
	virtual void setBlendMode(ofBlendMode blendMode)=0;
	/// \brief Enable/disable line smoothing for this renderer if it's supported.
	/// \param smooth True to enable line smoothing for this renderer if it's
	/// supported.
	virtual void setLineSmoothing(bool smooth)=0;
	/// \brief Set the resolution to use when drawing ellipses with this
	/// renderer.
	/// \param res The number of points to use when drawing circles and ellipses
	/// with this renderer.
	virtual void setCircleResolution(int res)=0;
	/// \brief Enable this renderer to use anti-aliasing if it is supported.
	virtual void enableAntiAliasing()=0;
	/// \brief Disable this renderer from using anti-aliasing.
	virtual void disableAntiAliasing()=0;

	/// \brief Set the global color this renderer will use when drawing.
	///
	/// The renderer will continue using a color set by setColor() until another
	/// call to setColor() changes the drawing color.
	///
	/// \param r The red value between 0 and 255 to use when drawing.
	/// \param g The green value between 0 and 255 to use when drawing.
	/// \param b The blue value between 0 and 255 to use when drawing.
	virtual void setColor(int r, int g, int b)=0;
	/// \brief Set the global color this renderer will use when drawing.
	///
	/// The renderer will continue using a color set by setColor() until another
	/// call to setColor() changes the drawing color.
	///
	/// \param r The red value between 0 and 255 to use when drawing.
	/// \param g The green value between 0 and 255 to use when drawing.
	/// \param b The blue value between 0 and 255 to use when drawing.
	/// \param a The alpha value between 0 and 255 to use when drawing.
	virtual void setColor(int r, int g, int b, int a)=0;
	/// \brief Set the global color this renderer will use when drawing.
	///
	/// The renderer will continue using a color set by setColor() until another
	/// call to setColor() changes the drawing color.
	///
	/// \param color The color to use when drawing.
	virtual void setColor(const ofColor & color)=0;
	/// \brief Set the global color this renderer will use when drawing.
	///
	/// The renderer will continue using a color set by setColor() until another
	/// call to setColor() changes the drawing color.
	///
	/// \param color The color to use when drawing.
	/// \param _a The alpha value between 0 and 255 to use when drawing.
	virtual void setColor(const ofColor & color, int _a)=0;
	/// \brief Set the global color this renderer will use when drawing.
	///
	/// The renderer will continue using a color set by setColor() until another
	/// call to setColor() changes the drawing color.
	///
	/// \param gray The grayscale value to use when drawing.
	virtual void setColor(int gray)=0;
	/// \brief Set the global color this renderer will use when drawing.
	///
	/// The renderer will continue using a color set by setColor() until another
	/// call to setColor() changes the drawing color.
	///
	/// \param hexColor The hexidecimal representation of the color to use when
	/// drawing.
	virtual void setHexColor( int hexColor )=0;

	/// \brief Set this renderer's bitmap text mode.
	///
	/// Possible bitmap texture modes include:
	///		OF_BITMAPMODE_SIMPLE
	///		OF_BITMAPMODE_SCREEN
	///		OF_BITMAPMODE_VIEWPORT
	///		OF_BITMAPMODE_MODEL
	///		OF_BITMAPMODE_MODEL_BILLBOARD
	///
	/// \param mode The bitmap mode to request this renderer to use.
	/// \sa ofDrawBitmapMode
	virtual void setBitmapTextMode(ofDrawBitmapMode mode)=0;

	/// \brief Get this renderer's current background color.
	/// \returns This renderer's current background color.
	virtual ofColor getBackgroundColor()=0;
	/// \brief Set this renderer's background color.
	/// \param c The color to request this renderer to use.
	virtual void setBackgroundColor(const ofColor & c)=0;

	/// \brief Immediately paint a background color to the screen.
	///
	/// If automatic background drawing is enabled (which it is by default) this
	/// method called from ofApp::setup() will also repaint the background with
	/// this color each frame.
	///
	/// \param c The color to paint the background with.
	virtual void background(const ofColor & c)=0;
	/// \brief Immediately paint a grayscale background color to the screen.
	///
	/// If automatic background drawing is enabled (which it is by default) this
	/// method called from ofApp::setup() will also repaint the background with
	/// this color each frame.
	///
	/// \param brightness The grayscale value between 0 and 255 to paint the
	/// background with.
	virtual void background(float brightness)=0;
	/// \brief Immediately paint a grayscale background color to the screen.
	///
	/// If automatic background drawing is enabled (which it is by default) this
	/// method called from ofApp::setup() will also repaint the background with
	/// this color each frame.
	///
	/// \param hexColor The 24-bit hex representation of the color to paint the
	/// background with.
	/// \param _a The alpha value between 0 and 255 to apply to \p hexColor when
	/// when painting the background.
	virtual void background(int hexColor, float _a=255.0f)=0;
	/// \brief Immediately paint a background color to the screen.
	///
	/// \param r The red value between 0 and 255 to use for the background.
	/// \param g The green value between 0 and 255 to use for the background.
	/// \param b The blue value between 0 and 255 to use for the background.
	/// \param a The alpha value between 0 and 255 to use for the background.
	virtual void background(int r, int g, int b, int a=255)=0;

	/// \brief Enable/disable automatic redrawing of the background each frame.
	/// \param bManual False to disable automatic background redrawing.
	virtual void setBackgroundAuto(bool bManual)=0;
	/// \brief Get the current auto redraw background setting for this renderer.
	/// \returns True if this renderer is set to redraw the background each
	/// frame.
	virtual bool getBackgroundAuto()=0;

	/// \brief Clear this renderer's current color and bit depths.
	///
	/// clear() will clear the screen entirely.
	///
	virtual void clear()=0;
	/// \brief Clear this renderer's color and bit depths and replace them.
	///
	/// clear() will clear the screen entirely.
	///
	/// \param r The red value between 0 and 255 to use when clearing the
	/// screen.
	/// \param g The green value between 0 and 255 to use when clearing the
	/// screen.
	/// \param b The blue value between 0 and 255 use when clearing the screen.
	/// \param a The alpha value between 0 and 255 use when clearing the screen.
	/// Defaults to 0.
	virtual void clear(float r, float g, float b, float a=0)=0;
	/// \brief Clear this renderer's color and bit depths replacing them.
	///
	/// clear() will clear the screen entirely.
	///
	/// \param brightness The grayscale value between 0 and 255 to use when
	/// clearing the screen.
	/// \param a The alpha value between 0 and 255 to use when clearing the
	/// screen. Defaults to 0.
	virtual void clear(float brightness, float a=0)=0;
	/// \brief Restore the alpha color to its full opacity value.
	virtual void clearAlpha()=0;

	/// \brief Draw a line between two 3D points.
	/// \param x1 The x coordinate of the first point.
	/// \param y1 The y coordinate of the first point.
	/// \param z1 The z coordinate of the first point.
	/// \param x2 The x coordinate of the second point.
	/// \param y2 The y coordinate of the second point.
	/// \param z2 The z coordinate of the second point.
	virtual void drawLine(float x1, float y1, float z1, float x2, float y2, float z2) const=0;
	/// \brief Draw a rectangle using a 3D point and a width and height.
	/// \param x The x coordinate of the rectangle.
	/// \param y The y coordinate of the rectangle.
	/// \param z The z coordinate of the rectangle.
	/// \param w The width of the rectangle.
	/// \param h The height of the rectangle.
	/// \sa ofRectMode
	virtual void drawRectangle(float x, float y, float z, float w, float h) const=0;
	/// \brief Draw a triangle using three 3D points.
	/// \param x1 The x coordinate of the first point.
	/// \param y1 The y coordinate of the first point.
	/// \param z1 The z coordinate of the first point.
	/// \param x2 The x coordinate of the second point.
	/// \param y2 The y coordinate of the second point.
	/// \param z2 The z coordinate of the second point.
	/// \param x3 The x coordinate of the third point.
	/// \param y3 The y coordinate of the third point.
	/// \param z3 The z coordinate of the third point.
	virtual void drawTriangle(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) const=0;
	/// \brief Draw a circle using a 3D point and a radius.
	/// \param x The x coordinate of the center of the circle.
	/// \param y The y coordinate of the center of the circle.
	/// \param z The z coordinate of the center of the circle.
	/// \param radius The length of the radius of the circle.
	virtual void drawCircle(float x, float y, float z, float radius) const=0;
	/// \brief Draw an ellipse using a 3D point, width, and height.
	/// \param x The x coordinate of the center of the circle.
	/// \param y The y coordinate of the center of the circle.
	/// \param z The z coordinate of the center of the circle.
	/// \param width The width of the circle.
	/// \param height The height of the circle.
	virtual void drawEllipse(float x, float y, float z, float width, float height) const=0;
	/// \brief Draw text with this renderer using the current bitmap text mode.
	///
	/// When using the OF_BITMAPMODE_SIMPLE bitmap text strings are drawn with
	/// their origin at the bottom left corner of the text. However,
	/// setBitmapTextMode() can transform this default behavior with modes like:
	///		OF_BITMAPMODE_SIMPLE
	///		OF_BITMAPMODE_SCREEN
	///		OF_BITMAPMODE_VIEWPORT
	///		OF_BITMAPMODE_MODEL
	///		OF_BITMAPMODE_MODEL_BILLBOARD
	///
	/// \param text The text to draw with the renderer.
	/// \param x The x position for the bottom of \p text.
	/// \param y The y position for the left alignment of \p text.
	/// \param z The z position of the text.
	virtual void drawString(std::string text, float x, float y, float z) const=0;
	/// \brief Draw text with this renderer using an ofTrueType font.
	/// \param font The font to use when drawing \p text.
	/// \param text The text to draw with the renderer.
	/// \param x The x position for the bottom of \p text.
	/// \param y The y position for the left alignment of \p text.
	virtual void drawString(const ofTrueTypeFont & font, std::string text, float x, float y) const=0;


	// returns true an ofPath to draw with, this allows to keep
	// immediate mode rendering working in multiwindow with multiple
	// contexts without reimplementing the logic on every renderer
	/// \brief Get a reference to the path used internally by this renderer.
	/// \returns A reference to the path used internally by this renderer.
	virtual ofPath & getPath()=0;

	/// \brief Get this renderer's current style object.
	/// \returns This renderer's current style object.
	virtual ofStyle getStyle() const=0;
	/// \brief Set this renderer's current style object.
	/// \param style The style object to set this renderer to use.
	virtual void setStyle(const ofStyle & style) = 0;
	/// \brief Push this renderer's current style into its internal style stack.
	///
	/// This creates a new style object used by this renderer internally until
	/// popStyle() is called.
	///
	virtual void pushStyle()=0;
	/// \brief Pop this renderer's current style from its internal style stack.
	///
	/// This restores the style that was last saved with pushStyle().
	///
	virtual void popStyle()=0;

	/// \brief Set the resolution used when drawing curves with this renderer.
	/// \param resolution The resolution to request this renderer to use when
	/// drawing curves.
	virtual void setCurveResolution(int resolution)=0;

	/// \brief Set this renderer's poly winding mode.
	///
	/// Possible poly winding modes include:
	///		OF_POLY_WINDING_ODD
	///		OF_POLY_WINDING_NONZERO
	///		OF_POLY_WINDING_POSITIVE
	///		OF_POLY_WINDING_NEGATIVE
	///		OF_POLY_WINDING_ABS_GEQ_TWO
	///
	/// \param mode The poly winding mode to request this renderer to use.
	/// \sa ofPolyWindingMode
	virtual void setPolyMode(ofPolyWindingMode mode)=0;

	/// \brief Get a const reference of this renderer's 3D graphics object.
	/// \returns The 3D graphics object currently being used by this renderer.
	virtual const of3dGraphics & get3dGraphics() const=0;
	/// \brief Get a reference with this renderer's 3D graphics object.
	/// \returns the 3D graphics object currently being used by this renderer.
	virtual of3dGraphics & get3dGraphics()=0;


	/// \brief Set this renderer's plane resolution using \p column and \p rows.
	/// \param columns The number of columns to use when drawing planes with
	/// this renderer.
	/// \param rows The number of rows to use when drawing planes with this
	/// renderer.
	virtual void setPlaneResolution( int columns, int rows );
	/// \brief Get this renderer's current plane resolution as a 2D vector.
	///
	/// The resulting vector's x and y values corresponds to the current column
	/// and row resolutions of this renderer's plane resolution respectively.
	///
	/// \returns A 2D vector representing this renderer's plane resolution in
	/// columns and rows.
	virtual glm::vec2 getPlaneResolution() const;
	/// \brief Draw a plane with the renderer using x, y, width, and height.
	///
	/// The number of rows and columns this plane will have is dependent on this
	/// renderer's current plane resolution set with setPlaneResolution().
	///
	/// \param x The x coordinate to use when drawing the plane with this
	/// renderer.
	/// \param y The y coordinate to use when drawing the plane with this
	/// renderer.
	/// \param width The width to use when drawing the plane with this renderer.
	/// \param height The height to use when drawing the plane with this
	/// renderer.
	virtual void drawPlane(float x, float y, float width, float height) const;
	/// \brief Draw a plane with the renderer using x, y, z, width, and height.
	///
	/// The number of rows and columns this plane will have is dependent on this
	/// renderer's current plane resolution set with setPlaneResolution().
	///
	/// \param x The x coordinate to use when drawing the plane with this
	/// renderer.
	/// \param y The y coordinate to use when drawing the plane with this
	/// renderer.
	/// \param z The z coordinate to use when drawing the plane with this
	/// renderer.
	/// \param width The width to use when drawing the plane with this renderer.
	/// \param height The height to use when drawing the plane with this
	/// renderer.
	virtual void drawPlane(float x, float y, float z, float width, float height) const;
	/// \brief Draw a plane with the renderer using a 3D point, width, and height.
	///
	/// The number of rows and columns this plane will have is dependent on this
	/// renderer's current plane resolution set with setPlaneResolution().
	///
	/// \param position A 3D point to use as the position to draw the plane with
	/// this renderer.
	/// \param width The width to use when drawing the plane with this renderer.
	/// \param height The height to use when drawing the plane with this
	/// renderer.
	virtual void drawPlane(glm::vec3& position, float width, float height) const;
	/// \brief Draw a plane with the renderer at the origin.
	///
	/// The number of rows and columns this plane will have is dependent on this
	/// renderer's current plane resolution set with setPlaneResolution().
	///
	/// \param width The width of the plane to use when drawing the plane with
	/// this renderer.
	/// \param height The height to use when drawing the plane with this
	/// renderer.
	virtual void drawPlane( float width, float height ) const;

	/// UV Sphere
	/// \brief Set the point resolution to use when drawing a sphere with this
	/// renderer.
	/// \param res The desired sphere resolution to use with this renderer.
	virtual void setSphereResolution(int res);
	/// \brief Get this renderer's current sphere resolution.
	/// \returns This renderer's current sphere resolution.
	virtual int getSphereResolution() const;
	/// \brief Draw a sphere with this renderer using x, y, and radius.
	///
	/// Spheres are drawn with x, y, and z coordinates representing the center
	/// of the sphere.
	///
	/// \param x The x coordinate to use when drawing this sphere.
	/// \param y The y coordinate to use when drawing this sphere.
	/// \param radius The radius to use when drawing this sphere.
	virtual void drawSphere(float x, float y, float radius) const;
	/// \brief Draw a sphere with this renderer using x, y, z, and radius.
	///
	/// Spheres are drawn with x, y, and z coordinates representing the center
	/// of the sphere.
	///
	/// \param x The x coordinate to use when drawing this sphere.
	/// \param y The y coordinate to use when drawing this sphere.
	/// \param z The z coordinate to use when drawing this sphere.
	/// \param radius The radius to use when drawing this sphere.
	virtual void drawSphere(float x, float y, float z, float radius) const;
	/// \brief Draw a sphere with this renderer using a position point and
	/// radius.
	///
	/// Spheres are drawn with x, y, and z coordinates representing the center
	/// of the sphere.
	///
	/// \param position The 3D position point to use when drawing the sphere.
	/// \param radius The radius to use when drawing this sphere.
	virtual void drawSphere(const glm::vec3& position, float radius) const;
	/// \brief Draw a sphere with the renderer at the defualt origin using
	/// radius.
	/// \param radius The radius to use when drawing the sphere with this
	/// renderer.
	virtual void drawSphere(float radius) const;

	// Ico Sphere
	/// \brief Set the point resolution to use when drawing an icosphere with
	/// this renderer.
	/// \param res The desired icosphere resolution to use with this renderer.
	virtual void setIcoSphereResolution( int res );
	/// \brief Get this renderer's current icosphere resolution.
	/// \returns This renderer's current icosphere resolution.
	virtual int getIcoSphereResolution() const;
	/// \brief Draw an icosphere with this renderer using x, y, and radius.
	///
	/// Spheres are drawn with x, y, and z coordinates representing the center
	/// of the icosphere.
	///
	/// \param x The x coordinate to use when drawing this icosphere.
	/// \param y The y coordinate to use when drawing this icosphere.
	/// \param z The z coordinate to use when drawing this icosphere.
	/// \param radius The radius to use when drawing this icosphere.
	virtual void drawIcoSphere(float x, float y, float z, float radius) const;
	/// \brief Draw an icosphere with this renderer using x, y, and radius.
	///
	/// Spheres are drawn with x, y, and z coordinates representing the center
	/// of the icosphere.
	///
	/// \param x The x coordinate to use when drawing this icosphere.
	/// \param y The y coordinate to use when drawing this icosphere.
	/// \param radius The radius to use when drawing this icosphere.
	virtual void drawIcoSphere(float x, float y, float radius) const;
	/// \brief Draw an icosphere with this renderer using x, y, and radius.
	///
	/// Icospheres are drawn with x, y, and z coordinates representing the
	/// center of the icosphere.
	///
	/// \param position The 3D position point to use when drawing the icosphere.
	/// \param radius The radius to use when drawing this icosphere.
	virtual void drawIcoSphere(const glm::vec3& position, float radius) const;
	/// \brief Draw an icosphere with the renderer at the origin using radius.
	/// \param radius The radius to use when drawing the icosphere with this
	/// renderer.
	virtual void drawIcoSphere(float radius) const;

	/// \brief Set this renderer's cylinder resolution.
	/// \param radiusSegments The number of facets (subdivisions) around the
	/// icosphere's circular footprint. A larger number yields a higher
	/// resolution.
	/// \param heightSegments The number of subdivisions from the cylinder's top
	/// to bottom.
	/// \param capSegments The number of annular (ring-shaped) subdivisions of
	/// the cylinder's endcap. Defaults to 2.
	virtual void setCylinderResolution( int radiusSegments, int heightSegments, int capSegments=2 );
	/// \brief Get this renderer's cylinder resolution as a 3D vector.
	///
	/// The resulting vector's x, y, and z properties correspond to the radius
	/// segments, height segments, and cap segments of this renderer's cylinder
	/// resolution respectively.
	///
	/// \returns A 3D vector representing this renderer's current cylinder
	/// resolution.
	virtual glm::vec3 getCylinderResolution() const;
	/// \brief Draw a cylinder with this renderer using x, y, radius, and
	/// height.
	///
	/// Cyliners are drawn with x, y, and z coordinates representing the
	/// centroid of the cylinder. Radius is the radius of the cylinder's
	/// circular footprint and height representing the height of the cylinder.
	///
	/// \param x The x coordinate to use when drawing this cylinder.
	/// \param y The y coordinate to use when drawing this cylinder.
	/// \param radius The radius to use when drawing this cylinder's circular
	/// footprint.
	/// \param height The height to use when drawing this cylinder.
	virtual void drawCylinder(float x, float y, float radius, float height) const;
	/// \brief Draw a cylinder with this renderer using x, y, z, radius, and
	/// height.
	///
	/// Cyliners are drawn with x, y, and z coordinates representing the
	/// centroid of the cylinder. Radius is the radius of the cylinder's
	/// circular footprint and height representing the height of the cylinder.
	///
	/// \param x The x coordinate to use when drawing this cylinder.
	/// \param y The y coordinate to use when drawing this cylinder.
	/// \param z The z coordinate to use when drawing this cylinder.
	/// \param radius The radius to use when drawing this cylinder's circular
	/// footprint.
	/// \param height The height to use when drawing this cylinder.
	virtual void drawCylinder(float x, float y, float z, float radius, float height) const;
	/// \brief Draw a cylinder with this renderer using position, radius, and
	/// height.
	///
	/// Cyliners are drawn with x, y, and z coordinates representing the
	/// centroid of the cylinder. Radius is the radius of the cylinder's
	/// circular footprint and height representing the height of the cylinder.
	///
	/// \param position The 3D point to use as a position coordinate when
	/// drawing this cylinder.
	///
	/// \param radius The radius to use when drawing this cylinder's circular
	/// footprint.
	/// \param height The height to use when drawing this cylinder.
	virtual void drawCylinder(const glm::vec3& position, float radius, float height) const;
	/// \brief Draw a cylinder at the origin using radius and height.
	///
	/// A cylinder drawn in this way will be positioned at the origin. Radius is
	/// the radius of the cylinder's circular footprint and height representing
	/// the height of the cylinder.
	///
	/// \param radius The radius to use when drawing this cylinder's circular
	/// footprint.
	/// \param height The height to use when drawing this cylinder.
	virtual void drawCylinder(float radius, float height) const;

	/// \brief Set the resolution of a polygonized cone.
	///
	/// Allows you to set the polygonization resolution of any cones you
	/// subsequently draw with ofDrawCone().
	///
	/// \param radiusSegments The number of facets (subdivisions) around the
	/// cone's circular footprint.
	/// \param heightSegments The number of subdivisions from the cone's top to
	/// bottom.
	/// \param capSegments The number of annular (ring-shaped) subdivisions of
	/// the cone's endcap.
	virtual void setConeResolution( int radiusSegments, int heightSegments, int capSegments=2);

	/// \brief Get this renderer's cone resolution as a 3D vector.
	///
	/// The resulting vector's x, y, and z properties correspond to the radius
	/// segments, height segments, and cap segments of this renderer's cone
	/// resolution respectively.
	///
	/// \returns A 3D vector representing this renderer's current cone
	/// resolution.
	virtual glm::vec3 getConeResolution() const;

	/// \brief Draw a cone with this renderer using x, y, z, radius, and
	/// height.
	///
	/// Cones are drawn with x, y, and z coordinates representing the centroid
	/// of the cone. Radius is the radius of the cone's circular
	/// footprint and height representing the height of the cone.
	///
	/// \param x The x coordinate to use when drawing this cone.
	/// \param y The y coordinate to use when drawing this cone.
	/// \param z The z coordinate to use when drawing this cone.
	/// \param radius The radius to use when drawing this cone's circular
	/// footprint.
	/// \param height The height to use when drawing this cone.
	virtual void drawCone(float x, float y, float z, float radius, float height) const;
	/// \brief Draw a cone with this renderer using x, y, z, radius, and
	/// height.
	///
	/// Cones are drawn with x, y, and z coordinates representing the centroid
	/// of the cylinder. Radius is the radius of the cone's circular
	/// footprint and height representing the height of the cone's.
	///
	/// \param x The x coordinate to use when drawing this cone.
	/// \param y The y coordinate to use when drawing this cone.
	/// \param radius The radius to use when drawing this cone's circular
	/// footprint.
	/// \param height The height to use when drawing this cone.
	virtual void drawCone(float x, float y, float radius, float height) const;
	/// \brief Draw a cone with this renderer using x, y, z, radius, and
	/// height.
	///
	/// Cones are drawn with x, y, and z coordinates representing the centroid
	/// of the cone. \p Radius is the radius of the cone's circular
	/// footprint and \p height representing the height of the cone's.
	///
	/// \param position The 3D point representing this cone's position.
	/// \param radius The radius to use when drawing this cone's circular
	/// footprint.
	/// \param height The height to use when drawing this cone.
	virtual void drawCone(const glm::vec3& position, float radius, float height) const;
	/// \brief Draw a cone at the origin using radius and height.
	///
	/// This cone will be drawn with its position at the coordinate system's
	/// origin. \p Radius is the radius of the cone's circular footprint and
	/// \p height representing the height of the cone.
	///
	/// \param radius The radius to use when drawing this cone's circular
	/// footprint.
	/// \param height The height to use when drawing this cone.
	virtual void drawCone(float radius, float height) const;

	// Box
	/// \brief Set the resolution this renderer uses when drawing boxes.
	/// \param res The resolution to use for box widths, heights, and depths.
	virtual void setBoxResolution( int res );
	/// \brief Set the resolution this renderer uses when drawing boxes.
	/// \param resWidth The width resolution this renderer uses when drawing
	/// boxes.
	/// \param resHeight The height resolution this renderer uses when drawing
	/// boxes.
	/// \param resDepth The depth resolution this renderer uses when drawing
	/// boxes.
	virtual void setBoxResolution( int resWidth, int resHeight, int resDepth );
	/// \brief Get this renderer's current box resolution as a 3D vector.
	///
	/// The returned vector's x, y, and z properties represent this renderer's
	/// current resolution width, resolution height, and resolution depth
	/// respectively.
	///
	/// \returns This renderer's current box resolution as a 3D vector.
	virtual glm::vec3 getBoxResolution() const;

	/// \brief Draws a rectangular box using x, y, z, width, height, and depth.
	///
	/// A box is a rectangular solid: an extruded rectangle.
	/// It is drawn starting from a 3D reference coordinate.
	/// It has a width (in x), a height (in y), and a depth (in z).
	/// The box is drawn with the current color, e.g. set with ofSetColor().
	/// The box is drawn filled by default; change this with ofFill();
	///
	/// \param x The x-coordinate of the box's origin.
	/// \param y The y-coordinate of the box's origin.
	/// \param z The z-coordinate of the box's origin.
	/// \param width The width of the box.
	/// \param height The height of the box.
	/// \param depth The depth of the box.
	virtual void drawBox( float x, float y, float z, float width, float height, float depth) const;

	/// \brief Draws a cube using x, y, z, and size.
	/// coordinates.
	///
	/// A cube is a rectangular solid bounded by six square faces of equal size.
	/// It is also known as a regular hexahedron, a square parallelepiped, an
	/// equilateral cuboid and a right rhombohedron. It is a regular square
	/// prism in three orientations.
	///
	/// It is drawn starting from a 3D reference coordinate, with the specified
	/// size. The cube is drawn with the current color, e.g. set with
	/// ofSetColor(). The cube is drawn filled by default; change this with
	/// ofFill().
	///
	/// \param x The x-coordinate of the cube's origin.
	/// \param y The y-coordinate of the cube's origin.
	/// \param z The z-coordinate of the cube's origin.
	/// \param size The size of the cube.
	virtual void drawBox(float x, float y, float z, float size) const;

	/// \brief Draws a rectangular box using position, width, height and depth.
	///
	/// A box is a rectangular solid: an extruded rectangle.
	/// It is drawn starting from a 3D reference coordinate.
	/// It has a width (in x), a height (in y), and a depth (in z).
	/// The box is drawn with the current color, e.g. set with ofSetColor().
	/// The box is drawn filled by default; change this with ofFill();
	///
	/// \param position an glm::vec3 which contains the (x,y,z) coordinates for the box's reference corner.
	/// \param width The width of the box.
	/// \param height The height of the box.
	/// \param depth The depth of the box.
	virtual void drawBox(const glm::vec3& position, float width, float height, float depth) const;

	/// \brief Draws a cube with the specified size, starting from the specified
	/// position.
	///
	/// A cube is drawn starting from a 3D reference position, with the
	/// specified size. The cube is drawn with the current color, e.g. set with
	/// ofSetColor(). The cube is drawn filled by default; change this with
	/// ofFill().
	///
	/// \param position an glm::vec3 which contains the (x,y,z) coordinates for
	/// the cube's reference corner.
	/// \param size The size of the cube.
	virtual void drawBox(const glm::vec3& position, float size) const;

	/// \brief Draws a cube with the specified size at the origin.
	///
	/// The cube is drawn with the current color, e.g. set with ofSetColor().
	/// The cube is drawn filled by default; change this with ofFill();
	///
	/// \param size The size of the cube.
	virtual void drawBox(float size) const;

	/// \brief Draws a rectangular box with the specified dimensions, starting from the origin.
	///
	/// A box is a rectangular solid: an extruded rectangle.
	/// It is drawn starting from the origin of the current reference frame.
	/// It has a width (in x), a height (in y), and a depth (in z).
	/// The box is drawn with the current color, e.g. set with ofSetColor().
	/// The box is drawn filled by default; change this with ofFill();
	///
	/// \param width The width of the box.
	/// \param height The height of the box.
	/// \param depth The depth of the box.
	virtual void drawBox( float width, float height, float depth ) const;
	/// \brief Draw the coordinate system's axes with the renderer.
	///
	/// This draws a red, green, and blue lines for the x, y, and z axes
	/// respectively. This can be helpful when trying to orient other objects
	/// in respect to the coordinate system.
	///
	/// \param size The length to draw each axis line.
	virtual void drawAxis(float size) const;
	/// \brief Draw the coordinate system's axes as a grid with the renderer.
	/// \param stepSize The size of each row/column in each axis grid.
	/// \param numberOfSteps The number of rows/columns in each axis grid.
	/// \param labels True to draw the name and values of the axis as a bitmap
	/// string.
	/// \param x True to draw the x axis.
	/// \param y True to draw the y axis.
	/// \param z True to draw the z axis.
	virtual void drawGrid(float stepSize, size_t numberOfSteps, bool labels, bool x, bool y, bool z) const;
	/// \brief Draw a coordinate system plane using the y and z axes.
	/// \param stepSize The size of each row/column on the axis grid.
	/// \param numberOfSteps The number of rows/columns on the axis grid.
	/// \param labels True to draw the names and values of the axes.
	virtual void drawGridPlane(float stepSize, size_t numberOfSteps, bool labels) const;
	/// \brief Draw an arrow between two 3D points.
	/// \brief start The 3D vector to use as the first point.
	/// \brief end The 3D vector to use as the second point.
	/// \float headSize The size of the arrowhead.
	virtual void drawArrow(const glm::vec3& start, const glm::vec3& end, float headSize) const;
	/// \brief Draw the coordinate system's axes with the renderer.
	///
	/// This draws red, green, and blue lines for the x, y, and z rotation
	/// axes respectively. This can be helpful when trying to orient other
	/// object's rotation in respect to the coordinate system.
	///
	/// \param radius The radius to draw the rotation axes with.
	/// \param stripWidth The width of each axis line.
	/// \param circleRes The circle resolution to use when drawing the axes.
	virtual void drawRotationAxes(float radius, float stripWidth, int circleRes) const;
};

#line 0 "../libs/openFrameworks/graphics/ofPixels.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofUtils.h" */
/* #include "ofColor.h" */
/* #include "ofLog.h" */
/* #include "ofMath.h" */
#include <limits>


/// \file
/// ofPixels is an object for working with blocks of pixels, those pixels can
/// be copied from an image that you've loaded, something that you've drawn
/// using ofGraphics, or a ofVideoGrabber instance.
///
/// You can create an image from pixels, using on ofPixels object like so:
///
/// ~~~~{.cpp}
/// ofPixels p;
/// ofLoadImage(p, "pathToImage.jpg");
/// ~~~~
///
/// ofPixels represents pixels data on the CPU as opposed to an ofTexture
/// which represents pixel data on the GPU. They can easily be made inter-
/// operational though:
///
/// ~~~~{.cpp}
/// ofTexture tex;
/// // do some stuff with tex
/// ofPixels pix;
/// tex.readToPixels(pix); // now all the pixels from tex are in pix
/// ~~~~
///
/// You can access the pixels in an ofPixels object with the `[]` operator.
///
/// ~~~~{.cpp}
/// ofPixels pix;
/// // put some stuff in the pixels
/// size_t i = 0;
/// while( i < pix.size()) {
/// 	char c = pix[i];
/// 	i++;
/// }
/// ~~~~
///
/// You can think of the ofPixels as the CPU side representation of pixel data
/// that can be sent to the GPU as an ofTexture object. To draw pixels, you
/// need to put them into an ofTexture and to manipulate an ofTextures pixel
/// data you need an ofPixels object.


enum ofInterpolationMethod {
	OF_INTERPOLATE_NEAREST_NEIGHBOR =1,
	OF_INTERPOLATE_BILINEAR			=2,
	OF_INTERPOLATE_BICUBIC			=3
};


/// \brief Used to represent the available pixel formats.
///
/// \sa ofPixels
enum ofPixelFormat: short{
	/// \brief A single-channel pixel, typically used for greyscale images.
	///
	/// This has 1 channel and a type-dependent number of bits per-pixel.
	OF_PIXELS_GRAY = 0,
	/// \brief A single-channel pixel with an alpha channel.
	///
	/// This has 2 channels and a type-dependent number of bits per-pixel.
	OF_PIXELS_GRAY_ALPHA = 1,

	/// \brief An RGB pixel with no alpha channel.
	///
	/// This has 3 channels and a type-dependent number of bits per-pixel.
	///
	/// \sa http://www.fourcc.org/rgb.php#BI_RGB
	OF_PIXELS_RGB=2,
	/// \brief A pixel used for color data with a blue/green/red channel order.
	///
	/// This has 3 channels and a type-dependent number of bits per-pixel.
	OF_PIXELS_BGR=3,
	/// \brief An RGBA pixel. This is typically used for color with transparency.
	///
	/// This has 4 channels and a type-dependent number of bits per-pixel.
	///
	/// \sa http://www.fourcc.org/rgb.php#RGBA
	OF_PIXELS_RGBA=4,
	/// \brief A pixel used for color/transparency with a blue/green/red/alpha channel order.
	///
	/// This has 4 channels and a type-dependent number of bits per-pixel.
	OF_PIXELS_BGRA=5,

	// \brief A 16-bit color pixel with 5-bit red and blue channels and a 6-bit green channel.
	OF_PIXELS_RGB565=6,

	/// \brief A 12-bit YUV 4:2:0 pixel with an interleaved U/V plane.
	///
	/// YUV 4:2:0 image with a plane of 8-bit Y samples followed by an
	/// interleaved U/V plane containing 8-bit 2x2 subsampled color difference
	/// samples.
	///
	/// \sa http://www.fourcc.org/yuv.php#NV12
	OF_PIXELS_NV12=7,
	/// \brief A 12-bit YUV 4:2:0 pixel with an interleaved V/U plane.
	///
	/// YUV 4:2:0 image with a plane of 8-bit Y samples followed by an
	/// interleaved V/U plane containing 8-bit 2x2 subsampled chroma samples.
	/// The same as NV12 except the interleave order of U and V is reversed.
	///
	/// \sa http://www.fourcc.org/yuv.php#NV21
	OF_PIXELS_NV21=8,
	/// \brief A 12-bit YUV NxM Y plane followed by (N/2)x(M/2) V and U planes.
	///
	/// \sa http://www.fourcc.org/yuv.php#YV12
	OF_PIXELS_YV12=9,
	/// \brief A 12-bit YUV format similar to ::OF_PIXELS_YV12, but with U & V reversed.
	///
	/// Note that IYUV and I420 appear to be identical.
	///
	/// \sa http://www.fourcc.org/yuv.php#IYUV
	OF_PIXELS_I420=10,
	/// \brief A 16-bit YUV 4:2:2 format.
	///
	/// \sa http://www.fourcc.org/yuv.php#YUY2
	OF_PIXELS_YUY2=11,
	/// \brief A 16-bit YUV 4:2:2 format.
	///
	/// \sa http://www.fourcc.org/yuv.php#UYVY
	OF_PIXELS_UYVY=12,

	/// \brief A single channel pixel, typically used for the luma component of YUV.
	OF_PIXELS_Y,
	/// \brief A single channel pixel, typically used (with V) for the chroma component of YUV.
	OF_PIXELS_U,
	/// \brief A single channel pixel, typically used (with U) for the chroma component of YUV.
	OF_PIXELS_V,
	/// \brief A two channel pixel, with U first, representing both chroma components of YUV.
	OF_PIXELS_UV,
	/// \brief A two channel pixel, with V first, representing both chroma components of YUV.
	OF_PIXELS_VU,

	/// \brief This is a placeholder to indicate the last valid enum.
	OF_PIXELS_NUM_FORMATS,

	/// \brief This indicates an unknown pixel type.
	OF_PIXELS_UNKNOWN=-1,
	/// \brief This indicates an unknown, native pixel type.
	OF_PIXELS_NATIVE=-2
};

#define OF_PIXELS_MONO OF_PIXELS_GRAY
#define OF_PIXELS_R OF_PIXELS_GRAY
#define OF_PIXELS_RG OF_PIXELS_GRAY_ALPHA

template<typename T>
std::string ofToString(const T & v);
template<>
std::string ofToString(const ofPixelFormat & pixelType);

enum ofImageType: short;

/// \brief A class representing a collection of pixels.
template <typename PixelType>
class ofPixels_ {
public:

	/// \name Construction And Allocation
	/// \{
	ofPixels_();
	~ofPixels_();
	ofPixels_(const ofPixels_<PixelType> & mom);
	ofPixels_(ofPixels_<PixelType> && mom);

	template<typename SrcType>
	ofPixels_(const ofPixels_<SrcType> & mom);


	/// \brief Allocates space for pixel data
	/// \param w Width of pixel array
	/// \param h Height of pixel array
	/// \param channels Number of channels per pixel
	void allocate(size_t w, size_t h, size_t channels);

	/// \brief Allocates space for pixel data
	///
	/// The pixelFormat can be one of the following:
	///
	///     OF_PIXELS_RGB
	///     OF_PIXELS_RGBA
	///     OF_PIXELS_BGRA
	///     OF_PIXELS_MONO
	///
	/// \param w Width of pixel array
	/// \param h Height of pixel array
	/// \param pixelFormat ofPixelFormat defining number of channels per pixel
	void allocate(size_t w, size_t h, ofPixelFormat pixelFormat);

	/// \brief Allocates space for pixel data
	///
	/// The imageType can be one of the following:
	///
	///     OF_IMAGE_GRAYSCALE
	///     OF_IMAGE_COLOR
	///     OF_IMAGE_COLOR_ALPHA
	///
	/// \param w Width of pixel array
	/// \param h Height of pixel array
	/// \param imageType ofImageType defining number of channels per pixel
	void allocate(size_t w, size_t h, ofImageType imageType);

	/// \brief Get whether memory has been allocated for an ofPixels object or not
	///
	/// Many operations like copying pixels, etc, automatically allocate
	/// the memory needed, but it's sometimes good to check.
	bool isAllocated() const;

	/// \brief Clear all the data from the ofPixels objects.
	/// After calling this you'll need to allocate()
	/// the ofPixels object again to use it.
	void clear();

	ofPixels_<PixelType>& operator=(const ofPixels_<PixelType> & mom);
	ofPixels_<PixelType>& operator=(ofPixels_<PixelType> && mom);

	template<typename SrcType>
	ofPixels_<PixelType>& operator=(const ofPixels_<SrcType> & mom);

	/// \}
	/// \name Set Pixel Data
	/// \{

	void set(PixelType val);
	void set(size_t channel,PixelType val);
	void setFromPixels(const PixelType * newPixels,size_t w, size_t h, size_t channels);
	void setFromPixels(const PixelType * newPixels,size_t w, size_t h, ofPixelFormat pixelFormat);
	void setFromPixels(const PixelType * newPixels,size_t w, size_t h, ofImageType type);
	void setFromExternalPixels(PixelType * newPixels,size_t w, size_t h, size_t channels);
	void setFromExternalPixels(PixelType * newPixels,size_t w, size_t h, ofPixelFormat pixelFormat);
	void setFromAlignedPixels(const PixelType * newPixels, size_t width, size_t height, size_t channels, size_t stride);
	void setFromAlignedPixels(const PixelType * newPixels, size_t width, size_t height, ofPixelFormat pixelFormat, size_t stride);
	/// \brief used to copy i420 pixels from gstreamer when (width % 4) != 0
	void setFromAlignedPixels(const PixelType * newPixels, size_t width, size_t height, ofPixelFormat pixelFormat, std::vector<size_t> strides);

	void swap(ofPixels_<PixelType> & pix);

	/// \}
	/// \name Modify Existing Data
	/// \{

	/// \brief Crop the pixels to a new width and height.
	///
	/// As a word of caution this reallocates memory and can be a bit
	/// expensive if done a lot.
	void crop(size_t x, size_t y, size_t width, size_t height);

	/// \brief Crop the pixels into the ofPixels reference passed in by `toPix.
	/// at the `x` and `y` and width the new width and height.
	///
	/// As a word of caution this reallocates memory and can be a bit
	/// expensive if done a lot.
	void cropTo(ofPixels_<PixelType> &toPix, size_t x, size_t y, size_t width, size_t height) const;

	// crop to a new width and height, this reallocates memory.
	void rotate90(int nClockwiseRotations);
	void rotate90To(ofPixels_<PixelType> & dst, int nClockwiseRotations) const;
	void mirrorTo(ofPixels_<PixelType> & dst, bool vertically, bool horizontal) const;

	/// \brief Mirror the pixels across the vertical and/or horizontal axis.
	/// \param vertically Set to true to mirror vertically
	/// \param horizontal Set to true to mirror horizontal
	void mirror(bool vertically, bool horizontal);

	/// \brief Resize the ofPixels instance to the dstHeight and dstWidth.
	///
	/// The options for the interpolation methods are as follows:
	///
	///     OF_INTERPOLATE_NEAREST_NEIGHBOR
	///     OF_INTERPOLATE_BILINEAR
	///     OF_INTERPOLATE_BICUBIC
	bool resize(size_t dstWidth, size_t dstHeight, ofInterpolationMethod interpMethod=OF_INTERPOLATE_NEAREST_NEIGHBOR);

	/// \brief Resize the ofPixels instance to the size of the ofPixels object passed in dst.
	///
	/// The options for the interpolation methods are as follows:
	///
	///     OF_INTERPOLATE_NEAREST_NEIGHBOR
	///     OF_INTERPOLATE_BILINEAR
	///     OF_INTERPOLATE_BICUBIC
	bool resizeTo(ofPixels_<PixelType> & dst, ofInterpolationMethod interpMethod=OF_INTERPOLATE_NEAREST_NEIGHBOR) const;

	/// \brief Paste the ofPixels object into another ofPixels object at the
	/// specified index, copying data from the ofPixels that the method is
	/// being called on to the ofPixels object at `&dst`. If the data being
	/// copied doesn't fit into the destination then the image is cropped.
	bool pasteInto(ofPixels_<PixelType> &dst, size_t x, size_t y) const;

	bool blendInto(ofPixels_<PixelType> &dst, size_t x, size_t y) const;

	/// \brief Swaps the R and B channels of an
	/// image, leaving the G and A channels as is.
	void swapRgb();

	/// \}
	/// \name Pixels Access
	/// \{

	/// \brief Retrieves pixel data from the ofPixel object.
	///
	/// \returns A raw pointer to the pixel data.
	PixelType * getData();
	const PixelType * getData() const;
	OF_DEPRECATED_MSG("Use getData instead",PixelType * getPixels());
	OF_DEPRECATED_MSG("Use getData instead",const PixelType * getPixels() const);

	/// \brief Get the pixel index at a x,y position
	///
	/// ~~~~{.cpp}
	/// ofColor yellow = ofColor::yellow;
	/// size_t ind = pix.getPixelIndex(mouseX, mouseY);
	/// pix.setPixel(ind, yellow);
	/// ~~~~
	size_t getPixelIndex(size_t x, size_t y) const;

	/// \brief Get the color at a x,y position
	ofColor_<PixelType> getColor(size_t x, size_t y) const;

	/// \brief Get the color at a specific index
	ofColor_<PixelType> getColor(size_t index) const;

	/// \brief Set the color of the pixel at the x,y location
	void setColor(size_t x, size_t y, const ofColor_<PixelType>& color);

	/// \brief Set the color of the pixel at a specific index
	void setColor(size_t index, const ofColor_<PixelType>& color);

	/// \brief Set the color of all pixels
	void setColor(const ofColor_<PixelType>& color);

	/// \brief Provides access to each channel of each pixel. If you have RGB pixel
	/// data, then you'll have 3 values for each pixel, if you have RGBA,
	/// you'll have 4
	const PixelType& operator[](size_t pos) const;
	PixelType& operator[](size_t pos);

	/// \}
	/// \name Getters
	/// \{

	/// \brief Get the width of the pixel array.
	size_t getWidth() const;

	/// \brief Get the height of the pixel array.
	size_t getHeight() const;

	/// \brief Get the number of bytes per pixel
	size_t getBytesPerPixel() const;

	/// \brief Get number of bits per pixel
	///
	/// If you have RGB pixel data, this will return 24, if you have RGBA,
	/// you'll have 32, if you have grayscale, this will return 8.
	size_t getBitsPerPixel() const;

	/// \brief Get how large each channel of a pixel is
	///
	/// ofPixels objects that store pixel data as unsigned char are smaller
	/// than  ofPixels objects that store pixel data as floats.
	///
	/// \note This returns bytes, not bits, so you should see ofPixels<float>
	/// return 4 and ofPixels<unsigned char> return 1.
	size_t getBytesPerChannel() const;

	/// \brief Get how large each channel of a pixels is.
	///
	/// ofPixels objects that store pixel data as `unsigned char` are smaller
	/// than ofPixels objects that store pixel data as 'float`.
	///
	/// \note This returns bits, not bytes, so you should see ofPixels<float>
	/// return 32 and ofPixels<unsigned char> return 8.
	size_t getBitsPerChannel() const;
	size_t getBytesStride() const;

	/// \brief Get the number of channels that the ofPixels object contains.
	/// RGB is 3 channels, RGBA is 4, and grayscale is 1.
	size_t getNumChannels() const;

	size_t getTotalBytes() const;

	size_t getNumPlanes() const;

	ofPixels_<PixelType> getPlane(size_t plane);

	/// \brief Get all values of one channel
	///
	/// For instance, the Red pixel values, from the
	/// ofPixels object, this gives you a grayscale representation of the
	/// specific channel
	///
	/// ~~~~{.cpp}
	///     // Get red pixels
	/// 	ofPixels rpix = pix.getChannel(0);
	///     // Get green pixels
	/// 	ofPixels gpix = pix.getChannel(1);
	///     // Get blue pixels
	/// 	ofPixels bpix = pix.getChannel(2);
	/// ~~~~
	ofPixels_<PixelType> getChannel(size_t channel) const;

	ofPixelFormat getPixelFormat() const;

	/// \brief Get the number of values that the ofPixels object
	/// contains, so an RGB data 400x400 would be 480,000, whereas RGBA data
	/// of the same dimensions would be 640,000.
	size_t size() const;

	/// \brief Get the type of the image
	/// \returns One of the following types: `OF_IMAGE_GRAYSCALE`,
	/// `OF_IMAGE_COLOR`, `OF_IMAGE_COLOR_ALPHA`
	ofImageType getImageType() const;

	/// \}
	/// \name Setters
	/// \{

	/// \brief Set all the pixel data for a single channel, for instance, the
	/// Red pixel values, from an ofPixels object assumed to be a grayscale
	/// representation of the data that should go into that one channel.
	void setChannel(size_t channel, const ofPixels_<PixelType> channelPixels);

	/// \brief Changes the image type for the ofPixels object
	///
	/// \param imageType Can be one of the following: OF_IMAGE_GRAYSCALE, OF_IMAGE_COLOR, OF_IMAGE_COLOR_ALPHA
	void setImageType(ofImageType imageType);

	void setNumChannels(size_t numChannels);

    static size_t pixelBitsFromPixelFormat(ofPixelFormat format);
    static size_t bytesFromPixelFormat(size_t w, size_t h, ofPixelFormat format);

	/// \}
	/// \name Iterator
	/// \{

	typedef PixelType * iterator;
	typedef const PixelType * const_iterator;
	typedef PixelType * reverse_iterator;
	typedef const PixelType * const_reverse_iterator;
	iterator begin();
	iterator end();
	const_iterator begin() const;
	const_iterator end() const;
	reverse_iterator rbegin();
	reverse_iterator rend();
	const_reverse_iterator rbegin() const;
	const_reverse_iterator rend() const;

	/// \}

    /// \cond INTERNAL

    struct ConstPixel: public std::iterator<std::forward_iterator_tag,ConstPixel>{
        ConstPixel(const PixelType * pixel, size_t bytesPerPixel, ofPixelFormat pixelFormat);
        const ConstPixel& operator*() const;
        const ConstPixel* operator->() const;
        ConstPixel& operator++();
        ConstPixel operator++(int);
        ConstPixel operator+(size_t) const;
        ConstPixel operator-(size_t) const;
        ConstPixel operator+=(size_t);
        bool operator!=(ConstPixel const& rhs) const;
        bool operator<(ConstPixel const& rhs) const;
        const PixelType & operator[](size_t idx) const;
        size_t getComponentsPerPixel() const;
        ofPixelFormat getPixelFormat() const;
        ofColor_<PixelType> getColor() const;

    private:
        const PixelType * pixel;
        size_t componentsPerPixel;
        ofPixelFormat pixelFormat;
    };

	struct Pixel: public std::iterator<std::forward_iterator_tag,Pixel>{
		Pixel(PixelType * pixel, size_t bytesPerPixel, ofPixelFormat pixelFormat);
        const Pixel& operator*() const;
        const Pixel* operator->() const;
        Pixel& operator++();
        Pixel operator++(int);
        Pixel& operator--();
        Pixel operator--(int);
        Pixel operator+(size_t) const;
        Pixel operator-(size_t) const;
        Pixel operator+=(size_t);
        bool operator!=(Pixel const& rhs) const;
        bool operator<(Pixel const& rhs) const;
        Pixel & operator=(Pixel const& rhs);
        Pixel & operator=(ConstPixel const& rhs);
        PixelType & operator[](size_t idx);
        const PixelType & operator[](size_t idx) const;
		size_t getComponentsPerPixel() const;
		ofPixelFormat getPixelFormat() const;
		ofColor_<PixelType> getColor() const;

	private:
		PixelType * pixel;
		size_t componentsPerPixel;
		ofPixelFormat pixelFormat;
	};

	struct Pixels{
		Pixels(PixelType * begin, PixelType * end, size_t componentsPerPixel, ofPixelFormat pixelFormat);
		Pixels(Pixel begin, Pixel end);
		Pixel begin();
		Pixel end();
	private:
		PixelType * _begin;
		PixelType * _end;
		size_t componentsPerPixel;
		ofPixelFormat pixelFormat;
	};

	struct Line: public std::iterator<std::forward_iterator_tag,Line>{
		Line(PixelType * _begin, size_t stride, size_t componentsPerPixel, size_t lineNum, ofPixelFormat pixelFormat);
        const Line& operator*() const;
        const Line* operator->() const;
        Line& operator++();
        Line operator++(int);
        Line& operator--();
        Line operator--(int);
        Line operator+(size_t) const;
        Line operator+=(size_t);
        bool operator!=(Line const& rhs) const;
        bool operator<(Line const& rhs) const;
        bool operator>(Line const& rhs) const;
        bool operator>=(Line const& rhs) const;
        PixelType * begin();
        PixelType * end();
        const PixelType * begin() const;
        const PixelType * end() const;
		size_t getLineNum() const;
		ofPixels_<PixelType> asPixels();
		const ofPixels_<PixelType> asPixels() const;
		size_t getStride() const;
		Pixel getPixel(size_t pixel);
		Pixels getPixels();
        Pixels getPixels(size_t first, size_t numPixels);

	private:
		PixelType * _begin;
		PixelType * _end;
		size_t stride;
		size_t componentsPerPixel;
		size_t lineNum;
		ofPixelFormat pixelFormat;
	};

	struct Lines{
		Lines(PixelType * _begin, PixelType * _end, size_t stride, size_t componentsPerPixel, size_t lines, ofPixelFormat pixelFormat);

        Line begin();

        Line end();


	private:
        PixelType * _begin;
		PixelType * _end;
		size_t stride;
		size_t componentsPerPixel;
		size_t lines;
		ofPixelFormat pixelFormat;
	};

	struct ConstPixels{
		ConstPixels(const PixelType * begin, const PixelType * end, size_t componentsPerPixel, ofPixelFormat pixelFormat);
		ConstPixels(const ConstPixel & begin, const ConstPixel & end);
		ConstPixel begin() const;
		ConstPixel end() const;
	private:
		const PixelType * _begin;
		const PixelType * _end;
		size_t componentsPerPixel;
		ofPixelFormat pixelFormat;
	};

	struct ConstLine: public std::iterator<std::forward_iterator_tag,Line>{
		ConstLine(const PixelType * _begin, size_t stride, size_t componentsPerPixel, size_t lineNum, ofPixelFormat pixelFormat);
		const ConstLine& operator*() const;
		const ConstLine* operator->() const;
		ConstLine& operator++();
		ConstLine operator++(int);
		ConstLine operator+(size_t) const;
		ConstLine operator+=(size_t);
		bool operator!=(ConstLine const& rhs) const;
		bool operator<(ConstLine const& rhs) const;
		const PixelType * begin() const;
		const PixelType * end() const;
		size_t getLineNum() const;
		size_t getStride() const;
        ConstPixel getPixel(size_t pixel) const;
		ConstPixels getPixels() const;
		ConstPixels getPixels(size_t first, size_t numPixels) const;

	private:
		const PixelType * _begin;
		const PixelType * _end;
		size_t stride;
		size_t componentsPerPixel;
		size_t lineNum;
		ofPixelFormat pixelFormat;
	};

	struct ConstLines{
		ConstLines(const PixelType * _begin, const PixelType * _end, size_t stride, size_t componentsPerPixel, size_t lines, ofPixelFormat pixelFormat);

		ConstLine begin() const;

		ConstLine end() const;

	private:
		const PixelType * _begin;
		const PixelType * _end;
		size_t stride;
		size_t componentsPerPixel;
		size_t lines;
		ofPixelFormat pixelFormat;
	};

	Line getLine(size_t line);
	Lines getLines();
    Lines getLines(size_t first, size_t numLines);
	Pixels getPixelsIter();
	ConstLine getConstLine(size_t line) const;
	ConstLines getConstLines() const;
	ConstLines getConstLines(size_t first, size_t numLines) const;
	ConstPixels getConstPixelsIter() const;

    /// \endcond

private:
	static float bicubicInterpolate(const float *patch, float x,float y, float x2,float y2, float x3,float y3);

	void copyFrom( const ofPixels_<PixelType>& mom );

	template<typename SrcType>
	void copyFrom( const ofPixels_<SrcType>& mom );

	PixelType * pixels = nullptr;
	size_t 	width = 0;
	size_t 	height = 0;

	//int 	channels; // 1, 3, 4 channels per pixel (grayscale, rgb, rgba)
	size_t 	pixelsSize = 0;
	bool	bAllocated = false;
	bool	pixelsOwner = true;			// if set from external data don't delete it
	ofPixelFormat pixelFormat = OF_PIXELS_UNKNOWN;

};


typedef ofPixels_<unsigned char> ofPixels;
typedef ofPixels_<float> ofFloatPixels;
typedef ofPixels_<unsigned short> ofShortPixels;


typedef ofPixels& ofPixelsRef;
typedef ofFloatPixels& ofFloatPixelsRef;
typedef ofShortPixels& ofShortPixelsRef;

// sorry for these ones, being templated functions inside a template i needed to do it in the .h
// they allow to do things like:
//
// ofPixels pix;
// ofFloatPixels pixf;
// pix = pixf;

template<typename PixelType>
template<typename SrcType>
ofPixels_<PixelType>::ofPixels_(const ofPixels_<SrcType> & mom){
	bAllocated = false;
	pixelsOwner = false;
	pixelsSize = 0;
	pixels = nullptr;
	width = 0;
	height = 0;
	pixelFormat = OF_PIXELS_UNKNOWN;
	copyFrom( mom );
}

template<typename PixelType>
template<typename SrcType>
ofPixels_<PixelType>& ofPixels_<PixelType>::operator=(const ofPixels_<SrcType> & mom){
	copyFrom( mom );
	return *this;
}

template<typename PixelType>
template<typename SrcType>
void ofPixels_<PixelType>::copyFrom(const ofPixels_<SrcType> & mom){
	if(mom.isAllocated()){
		allocate(mom.getWidth(),mom.getHeight(),mom.getNumChannels());

		const float srcMax = ( (sizeof(SrcType) == sizeof(float) ) ? 1.f : std::numeric_limits<SrcType>::max() );
		const float dstMax = ( (sizeof(PixelType) == sizeof(float) ) ? 1.f : std::numeric_limits<PixelType>::max() );
		const float factor = dstMax / srcMax;

		if(sizeof(SrcType) == sizeof(float)) {
			// coming from float we need a special case to clamp the values
			for(size_t i = 0; i < mom.size(); i++){
				pixels[i] = ofClamp(mom[i], 0, 1) * factor;
			}
		} else{
			// everything else is a straight scaling
			for(size_t i = 0; i < mom.size(); i++){
				pixels[i] = mom[i] * factor;
			}
		}
	}
}
//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::iterator ofPixels_<PixelType>::begin(){
	return pixels;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::iterator ofPixels_<PixelType>::end(){
	return pixels + size();
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_iterator ofPixels_<PixelType>::begin() const{
	return pixels;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_iterator ofPixels_<PixelType>::end() const{
	return pixels + size();
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::reverse_iterator ofPixels_<PixelType>::rbegin(){
	return pixels + (size() - 1);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::reverse_iterator ofPixels_<PixelType>::rend(){
	return pixels - 1;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_reverse_iterator ofPixels_<PixelType>::rbegin() const{
	return pixels + (size() - 1);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_reverse_iterator ofPixels_<PixelType>::rend() const{
	return pixels - 1;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::Pixel::Pixel(PixelType * pixel, size_t componentsPerPixel, ofPixelFormat pixelFormat)
:pixel(pixel)
,componentsPerPixel(componentsPerPixel)
,pixelFormat(pixelFormat){

}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::Pixel& ofPixels_<PixelType>::Pixel::operator*() const{
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::Pixel* ofPixels_<PixelType>::Pixel::operator->() const{
	return this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel& ofPixels_<PixelType>::Pixel::operator++(){
	pixel += componentsPerPixel;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Pixel::operator++(int){
	Pixel tmp(*this);
	operator++();
	return tmp;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel& ofPixels_<PixelType>::Pixel::operator--(){
	pixel -= componentsPerPixel;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Pixel::operator--(int){
	Pixel tmp(*this);
	operator--();
	return tmp;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Pixel::operator+(size_t i) const{
	return Pixel(pixel + componentsPerPixel * i, componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Pixel::operator-(size_t i) const{
	return Pixel(pixel - componentsPerPixel * i, componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Pixel::operator+=(size_t i){
	pixel += componentsPerPixel * i;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::Pixel::operator!=(Pixel const& rhs) const{
	return pixel != rhs.pixel;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::Pixel::operator<(Pixel const& rhs) const{
	return pixel < rhs.pixel;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel & ofPixels_<PixelType>::Pixel::operator=(Pixel const& rhs){
    for(size_t i=0;i<componentsPerPixel;++i){
        pixel[i] = rhs[i];
    }
    return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel & ofPixels_<PixelType>::Pixel::operator=(ConstPixel const& rhs){
    for(size_t i=0;i<componentsPerPixel;++i){
        pixel[i] = rhs[i];
    }
    return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline PixelType & ofPixels_<PixelType>::Pixel::operator[](size_t idx){
	return pixel[idx];
}

//----------------------------------------------------------------------
template<typename PixelType>
inline const PixelType & ofPixels_<PixelType>::Pixel::operator[](size_t idx) const{
	return pixel[idx];
}

//----------------------------------------------------------------------
template<typename PixelType>
inline size_t ofPixels_<PixelType>::Pixel::getComponentsPerPixel() const{
	return componentsPerPixel;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixelFormat ofPixels_<PixelType>::Pixel::getPixelFormat() const{
	return pixelFormat;
}

//----------------------------------------------------------------------
template<typename PixelType>
ofColor_<PixelType> ofPixels_<PixelType>::Pixel::getColor() const{
	ofColor_<PixelType> c;
	switch(pixelFormat){
		case OF_PIXELS_RGB:
			c.set( pixel[0], pixel[1], pixel[2] );
			break;
		case OF_PIXELS_BGR:
			c.set( pixel[2], pixel[1], pixel[0] );
			break;
		case OF_PIXELS_RGBA:
			c.set( pixel[0], pixel[1], pixel[2], pixel[3] );
			break;
		case OF_PIXELS_BGRA:
			c.set( pixel[2], pixel[1], pixel[0], pixel[3] );
			break;
		case OF_PIXELS_GRAY:
			c.set( pixel[0] );
			break;
		case OF_PIXELS_GRAY_ALPHA:
			c.set( pixel[0], pixel[0], pixel[0], pixel[1] );
			break;
		case OF_PIXELS_RGB565:
		case OF_PIXELS_NV12:
		case OF_PIXELS_NV21:
		case OF_PIXELS_YV12:
		case OF_PIXELS_I420:
		case OF_PIXELS_YUY2:
		case OF_PIXELS_UYVY:
		case OF_PIXELS_Y:
		case OF_PIXELS_U:
		case OF_PIXELS_V:
		case OF_PIXELS_UV:
		case OF_PIXELS_VU:
		case OF_PIXELS_UNKNOWN:
		default:
			ofLogWarning() << "returning color not supported yet for " << ofToString(pixelFormat) << " format";
			return 0;
			break;
	}

	return c;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::Pixels::Pixels(PixelType * begin, PixelType * end, size_t componentsPerPixel, ofPixelFormat pixelFormat)
:_begin(begin)
,_end(end)
,componentsPerPixel(componentsPerPixel)
,pixelFormat(pixelFormat){}


//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::Pixels::Pixels(Pixel begin, Pixel end)
:_begin(&begin[0])
,_end(&end[0])
,componentsPerPixel(begin.getComponentsPerPixel())
,pixelFormat(begin.getPixelFormat()){}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Pixels::begin(){
	return Pixel(_begin,componentsPerPixel,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Pixels::end(){
	return Pixel(_end,componentsPerPixel,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::Line::Line(PixelType * _begin, size_t stride, size_t componentsPerPixel, size_t lineNum, ofPixelFormat pixelFormat)
:_begin(_begin)
,_end(_begin+stride)
,stride(stride)
,componentsPerPixel(componentsPerPixel)
,lineNum(lineNum)
,pixelFormat(pixelFormat){}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::Line& ofPixels_<PixelType>::Line::operator*() const{
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::Line* ofPixels_<PixelType>::Line::operator->() const{
	return this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line& ofPixels_<PixelType>::Line::operator++(){
	_begin = _end;
	_end = _begin + stride;
	++lineNum;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line ofPixels_<PixelType>::Line::operator++(int) {
	Line tmp(*this);
	operator++();
	return tmp;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line& ofPixels_<PixelType>::Line::operator--(){
	_end = _begin;
	_begin = _end - stride;
	--lineNum;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line ofPixels_<PixelType>::Line::operator--(int) {
	Line tmp(*this);
	operator--();
	return tmp;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line  ofPixels_<PixelType>::Line::operator+(size_t i) const{
	return Line(_begin+stride*i,stride,componentsPerPixel,lineNum+i,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line  ofPixels_<PixelType>::Line::operator+=(size_t i){
	_begin = _begin+stride*i;
	_end = _begin + stride;
	lineNum += i;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::Line::operator!=(typename ofPixels_<PixelType>::Line const& rhs) const{
	return rhs._begin != _begin || rhs._end != _end || rhs.stride != stride || rhs.lineNum!=lineNum;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::Line::operator<(typename ofPixels_<PixelType>::Line const& rhs) const{
	return _begin < rhs._begin;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::Line::operator>(typename ofPixels_<PixelType>::Line const& rhs) const{
	return _begin > rhs._begin;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::Line::operator>=(typename ofPixels_<PixelType>::Line const& rhs) const{
	return _begin >= rhs._begin;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::iterator ofPixels_<PixelType>::Line::begin(){
	return _begin;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::iterator ofPixels_<PixelType>::Line::end(){
	return _end;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_iterator ofPixels_<PixelType>::Line::begin() const{
	return _begin;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_iterator ofPixels_<PixelType>::Line::end() const{
	return _end;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline size_t ofPixels_<PixelType>::Line::getLineNum() const{
	return lineNum;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType> ofPixels_<PixelType>::Line::asPixels(){
	ofPixels_<PixelType> pixels;
	pixels.setFromExternalPixels(_begin,stride/componentsPerPixel,1,pixelFormat);
	return std::move(pixels);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline const ofPixels_<PixelType> ofPixels_<PixelType>::Line::asPixels() const{
	ofPixels_<PixelType> pixels;
	pixels.setFromExternalPixels(_begin,stride/componentsPerPixel,1,pixelFormat);
	return std::move(pixels);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline size_t ofPixels_<PixelType>::Line::getStride() const{
	return stride;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixel ofPixels_<PixelType>::Line::getPixel(size_t pixel){
    return Pixel(_begin + (pixel*componentsPerPixel), componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixels ofPixels_<PixelType>::Line::getPixels(){
	return Pixels(_begin,_end,componentsPerPixel,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixels ofPixels_<PixelType>::Line::getPixels(size_t first, size_t numPixels){
    return Pixels(&getPixel(first)[0], &getPixel(first+numPixels)[0], componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::Lines::Lines(PixelType * _begin, PixelType * _end, size_t stride, size_t componentsPerPixel, size_t lines, ofPixelFormat pixelFormat)
:_begin(_begin)
,_end(_end)
,stride(stride)
,componentsPerPixel(componentsPerPixel)
,lines(lines)
,pixelFormat(pixelFormat){}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line ofPixels_<PixelType>::Lines::begin(){
	return Line(_begin,stride,componentsPerPixel,0,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line ofPixels_<PixelType>::Lines::end(){
	return Line(_end,stride,componentsPerPixel,lines,pixelFormat);
}


//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Line ofPixels_<PixelType>::getLine(size_t line){
	return Line(pixels+(width*getNumChannels()*line), width*getNumChannels(), getNumChannels(), line,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Lines ofPixels_<PixelType>::getLines(){
	return Lines(begin(),end(),width*getNumChannels(),getNumChannels(),getHeight(),pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Lines ofPixels_<PixelType>::getLines(size_t first, size_t numLines){
    return Lines(getLine(first).begin(),getLine(first+numLines).begin(),width*getNumChannels(),getNumChannels(),numLines,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::Pixels ofPixels_<PixelType>::getPixelsIter(){
	return Pixels(begin(),end(),getNumChannels(),pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::ConstPixel::ConstPixel(const PixelType * pixel, size_t componentsPerPixel, ofPixelFormat pixelFormat)
:pixel(pixel)
,componentsPerPixel(componentsPerPixel)
,pixelFormat(pixelFormat){

}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::ConstPixel& ofPixels_<PixelType>::ConstPixel::operator*() const{
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::ConstPixel* ofPixels_<PixelType>::ConstPixel::operator->() const{
	return this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel& ofPixels_<PixelType>::ConstPixel::operator++(){
	pixel += componentsPerPixel;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel ofPixels_<PixelType>::ConstPixel::operator++(int){
	ConstPixel tmp(*this);
	operator++();
	return tmp;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel ofPixels_<PixelType>::ConstPixel::operator+(size_t i) const{
	return ConstPixel(pixel + componentsPerPixel * i, componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel ofPixels_<PixelType>::ConstPixel::operator-(size_t i) const{
	return ConstPixel(pixel - componentsPerPixel * i, componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel ofPixels_<PixelType>::ConstPixel::operator+=(size_t i){
	pixel += componentsPerPixel * i;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::ConstPixel::operator!=(ConstPixel const& rhs) const{
	return pixel != rhs.pixel;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::ConstPixel::operator<(ConstPixel const& rhs) const{
	return pixel < rhs.pixel;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline const PixelType & ofPixels_<PixelType>::ConstPixel::operator[](size_t idx) const{
	return pixel[idx];
}

//----------------------------------------------------------------------
template<typename PixelType>
inline size_t ofPixels_<PixelType>::ConstPixel::getComponentsPerPixel() const{
	return componentsPerPixel;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixelFormat ofPixels_<PixelType>::ConstPixel::getPixelFormat() const{
	return pixelFormat;
}

//----------------------------------------------------------------------
template<typename PixelType>
ofColor_<PixelType> ofPixels_<PixelType>::ConstPixel::getColor() const{
	ofColor_<PixelType> c;
	switch(pixelFormat){
		case OF_PIXELS_RGB:
			c.set( pixel[0], pixel[1], pixel[2] );
			break;
		case OF_PIXELS_BGR:
			c.set( pixel[2], pixel[1], pixel[0] );
			break;
		case OF_PIXELS_RGBA:
			c.set( pixel[0], pixel[1], pixel[2], pixel[3] );
			break;
		case OF_PIXELS_BGRA:
			c.set( pixel[2], pixel[1], pixel[0], pixel[3] );
			break;
		case OF_PIXELS_GRAY:
			c.set( pixel[0] );
			break;
		case OF_PIXELS_GRAY_ALPHA:
			c.set( pixel[0], pixel[0], pixel[0], pixel[1] );
			break;
		case OF_PIXELS_RGB565:
		case OF_PIXELS_NV12:
		case OF_PIXELS_NV21:
		case OF_PIXELS_YV12:
		case OF_PIXELS_I420:
		case OF_PIXELS_YUY2:
		case OF_PIXELS_UYVY:
		case OF_PIXELS_Y:
		case OF_PIXELS_U:
		case OF_PIXELS_V:
		case OF_PIXELS_UV:
		case OF_PIXELS_VU:
		case OF_PIXELS_UNKNOWN:
		default:
			ofLogWarning() << "returning color not supported yet for " << ofToString(pixelFormat) << " format";
			return 0;
			break;
	}

	return c;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::ConstPixels::ConstPixels(const PixelType * begin, const PixelType * end, size_t componentsPerPixel, ofPixelFormat pixelFormat)
:_begin(begin)
,_end(end)
,componentsPerPixel(componentsPerPixel)
,pixelFormat(pixelFormat){}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::ConstPixels::ConstPixels(const ConstPixel & begin, const ConstPixel & end)
:_begin(&begin[0])
,_end(&end[0])
,componentsPerPixel(begin.getComponentsPerPixel())
,pixelFormat(begin.getPixelFormat()){}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel ofPixels_<PixelType>::ConstPixels::begin() const{
	return ConstPixel(_begin,componentsPerPixel,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel ofPixels_<PixelType>::ConstPixels::end() const{
	return ConstPixel(_end,componentsPerPixel,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::ConstLine::ConstLine(const PixelType * _begin, size_t stride, size_t componentsPerPixel, size_t lineNum, ofPixelFormat pixelFormat)
:_begin(_begin)
,_end(_begin+stride)
,stride(stride)
,componentsPerPixel(componentsPerPixel)
,lineNum(lineNum)
,pixelFormat(pixelFormat){}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::ConstLine& ofPixels_<PixelType>::ConstLine::operator*() const{
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline const typename ofPixels_<PixelType>::ConstLine* ofPixels_<PixelType>::ConstLine::operator->() const{
	return this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLine& ofPixels_<PixelType>::ConstLine::operator++(){
	_begin = _end;
	_end = _begin + stride;
	++lineNum;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLine ofPixels_<PixelType>::ConstLine::operator++(int) {
	ConstLine tmp(*this);
	operator++();
	return tmp;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLine  ofPixels_<PixelType>::ConstLine::operator+(size_t i) const{
	return ConstLine(_begin+stride*i,stride,componentsPerPixel,lineNum+i,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLine  ofPixels_<PixelType>::ConstLine::operator+=(size_t i){
	_begin = _begin+stride*i;
	_end = _begin + stride;
	lineNum += i;
	return *this;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::ConstLine::operator!=(typename ofPixels_<PixelType>::ConstLine const& rhs) const{
	return rhs._begin != _begin || rhs._end != _end || rhs.stride != stride || rhs.lineNum!=lineNum;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline bool ofPixels_<PixelType>::ConstLine::operator<(typename ofPixels_<PixelType>::ConstLine const& rhs) const{
	return _begin < rhs._begin || _end < rhs._end;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_iterator ofPixels_<PixelType>::ConstLine::begin() const{
	return _begin;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::const_iterator ofPixels_<PixelType>::ConstLine::end() const{
	return _end;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline size_t ofPixels_<PixelType>::ConstLine::getLineNum() const{
	return lineNum;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline size_t ofPixels_<PixelType>::ConstLine::getStride() const{
	return stride;
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixel ofPixels_<PixelType>::ConstLine::getPixel(size_t pixel) const{
    return ConstPixel(_begin + (pixel*componentsPerPixel), componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixels ofPixels_<PixelType>::ConstLine::getPixels() const{
	return ConstPixels(_begin,_end,componentsPerPixel,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixels ofPixels_<PixelType>::ConstLine::getPixels(size_t first, size_t numPixels) const{
    return ConstPixels(&getPixel(first)[0], &getPixel(first+numPixels)[0], componentsPerPixel, pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline ofPixels_<PixelType>::ConstLines::ConstLines(const PixelType * _begin, const PixelType * _end, size_t stride, size_t componentsPerPixel, size_t lines, ofPixelFormat pixelFormat)
:_begin(_begin)
,_end(_end)
,stride(stride)
,componentsPerPixel(componentsPerPixel)
,lines(lines)
,pixelFormat(pixelFormat){}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLine ofPixels_<PixelType>::ConstLines::begin() const{
	return ConstLine(_begin,stride,componentsPerPixel,0,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLine ofPixels_<PixelType>::ConstLines::end() const{
	return ConstLine(_end,stride,componentsPerPixel,lines,pixelFormat);
}


//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLine ofPixels_<PixelType>::getConstLine(size_t line) const{
	return ConstLine(pixels+(width*getNumChannels()*line), width*getNumChannels(), getNumChannels(), line,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLines ofPixels_<PixelType>::getConstLines() const{
	return ConstLines(begin(),end(),width*getNumChannels(),getNumChannels(),getHeight(),pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstLines ofPixels_<PixelType>::getConstLines(size_t first, size_t numLines) const{
    return ConstLines(getConstLine(first).begin(),getConstLine(first+numLines).begin(),width*getNumChannels(),getNumChannels(),numLines,pixelFormat);
}

//----------------------------------------------------------------------
template<typename PixelType>
inline typename ofPixels_<PixelType>::ConstPixels ofPixels_<PixelType>::getConstPixelsIter() const{
	return ConstPixels(begin(),end(),getNumChannels(),pixelFormat);
}

namespace std{
template<typename PixelType>
void swap(ofPixels_<PixelType> & src, ofPixels_<PixelType> & dst){
	src.swap(dst);
}
}

#line 0 "../libs/openFrameworks/gl/ofGLBaseTypes.h"
#pragma once


#include <vector>
/* #include "ofGraphicsBaseTypes.h" */

class ofTexture;
class ofShader;

/// \brief An abstract class representing an object that can have an ofTexture.
class ofBaseHasTexture{
public:
	/// \brief Destroy the ofBaseHasTexture.
	virtual ~ofBaseHasTexture(){}

	/// \returns a reference to the ofTexture.
	virtual ofTexture & getTexture()=0;

	/// \returns a const reference to the ofTexture.
	virtual const ofTexture & getTexture() const=0;

	/// \brief Enable or disable internal ofTexture use.
	/// \param bUseTex true if an ofTexture should be used.
	virtual void setUseTexture(bool bUseTex)=0;

	/// \returns true if an internal ofTexture is being used.
	virtual bool isUsingTexture() const=0;
};


/// \brief An abstract class representing an object that ofTexture planes.
class ofBaseHasTexturePlanes: public ofBaseHasTexture{
public:
	/// \brief Destroy the ofBaseHasTexturePlanes.
	virtual ~ofBaseHasTexturePlanes(){}

	/// \returns a reference to a std::vector containing the ofTexture planes.
	virtual std::vector<ofTexture> & getTexturePlanes()=0;

	/// \returns a const reference to a std::vector containing the ofTexture planes.
	virtual const std::vector<ofTexture> & getTexturePlanes() const=0;
};


/// \brief An abstract class representing an image.
///
/// This empty class primarily exists to allow templated subclasses of different
/// types to be stored as raw or shared pointers in collections such as
/// std::vector.
///
/// Example:
/// \code{.cpp}
///
/// std::vector<ofAbstractImage*> imageProviders;
///
/// ofImage image;
/// ofFloatImage floatImage;
/// ofShortImage shortImage;
///
/// // ...
///
/// imageProviders.push_back(&image);
/// imageProviders.push_back(&floatImage);
/// imageProviders.push_back(&shortImage);
///
/// \endcode
class ofAbstractImage: public ofBaseDraws, public ofBaseHasTexture{
public:
	/// \brief Destroy the ofAbstractImage.
	virtual ~ofAbstractImage(){}
};

/// \brief A base class represeting an image.
/// \tparam T The pixel data type.
template<typename T>
class ofBaseImage_: public ofAbstractImage, virtual public ofBaseHasPixels_<T>{
public:
	/// \brief Destroy the ofBaseImage_.
	virtual ~ofBaseImage_<T>(){};
};


/// \brief A typedef for an unsigned char ofBaseImage_.
typedef ofBaseImage_<unsigned char> ofBaseImage;

/// \brief A typedef for an float ofBaseImage_.
typedef ofBaseImage_<float> ofBaseFloatImage;

/// \brief A typedef for an unsigned short ofBaseImage_.
typedef ofBaseImage_<unsigned short> ofBaseShortImage;

class of3dPrimitive;


class ofBaseGLRenderer: public ofBaseRenderer{
public:
	using ofBaseRenderer::draw;
	virtual void draw(const ofTexture & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const=0;
	virtual void draw(const ofVbo & vbo, GLuint drawMode, int first, int total) const=0;
	virtual void drawElements(const ofVbo & vbo, GLuint drawMode, int amt, int offsetelements) const=0;
	virtual void drawInstanced(const ofVbo & vbo, GLuint drawMode, int first, int total, int primCount) const=0;
	virtual void drawElementsInstanced(const ofVbo & vbo, GLuint drawMode, int amt, int primCount) const=0;
	virtual void draw(const ofVboMesh & mesh, ofPolyRenderMode renderType) const=0;
	virtual void drawInstanced(const ofVboMesh & mesh, ofPolyRenderMode renderType, int primCount) const=0;


	virtual void enableTextureTarget(const ofTexture & tex, int textureLocation)=0;
	virtual void disableTextureTarget(int textureTarget, int textureLocation)=0;
	virtual void setAlphaMaskTex(const ofTexture & tex)=0;
	virtual void disableAlphaMask()=0;
	virtual void enablePointSprites()=0;
	virtual void disablePointSprites()=0;

	// lighting
	virtual void enableLighting()=0;
	virtual void disableLighting()=0;
	virtual void enableSeparateSpecularLight()=0;
	virtual void disableSeparateSpecularLight()=0;
	virtual bool getLightingEnabled()=0;
	virtual void setSmoothLighting(bool b)=0;
	virtual void setGlobalAmbientColor(const ofColor& c)=0;
	virtual void enableLight(int lightIndex)=0;
	virtual void disableLight(int lightIndex)=0;
	virtual void setLightSpotlightCutOff(int lightIndex, float spotCutOff)=0;
	virtual void setLightSpotConcentration(int lightIndex, float exponent)=0;
	virtual void setLightAttenuation(int lightIndex, float constant, float linear, float quadratic )=0;
	virtual void setLightAmbientColor(int lightIndex, const ofFloatColor& c)=0;
	virtual void setLightDiffuseColor(int lightIndex, const ofFloatColor& c)=0;
	virtual void setLightSpecularColor(int lightIndex, const ofFloatColor& c)=0;
	virtual void setLightPosition(int lightIndex, const glm::vec4 & position)=0;
	virtual void setLightSpotDirection(int lightIndex, const glm::vec4 & direction)=0;

	virtual int getGLVersionMajor()=0;
	virtual int getGLVersionMinor()=0;

	virtual void saveScreen(int x, int y, int w, int h, ofPixels & pixels)=0;
	virtual void saveFullViewport(ofPixels & pixels)=0;

	// bindings
	using ofBaseRenderer::bind;
	using ofBaseRenderer::unbind;
	virtual void bind(const ofBaseMaterial & material)=0;
	virtual void bind(const ofShader & shader)=0;
	virtual void bind(const ofTexture & texture, int location)=0;
	virtual void bind(const ofBaseVideoDraws & video)=0;
	virtual void unbind(const ofBaseMaterial & material)=0;
	virtual void unbind(const ofShader & shader)=0;
	virtual void unbind(const ofTexture & texture, int location)=0;
	virtual void unbind(const ofBaseVideoDraws & video)=0;
	virtual void bind(const ofFbo & fbo)=0;
	virtual void unbind(const ofFbo & fbo)=0;
#ifndef TARGET_OPENGLES
	virtual void bindForBlitting(const ofFbo & fboSrc, ofFbo & fboDst, int attachmentPoint=0)=0;
#endif
	virtual void begin(const ofFbo & fbo, ofFboMode mode)=0;
	virtual void end(const ofFbo & fbo)=0;

};

#line 0 "../libs/openFrameworks/gl/ofGLUtils.h"
/*
 * ofGLUtils.h
 *
 *  Created on: 02/03/2011
 *      Author: arturo
 */

#pragma once

/* #include "ofConstants.h" */
/* #include "ofGraphicsConstants.h" */

class ofShader;
class ofGLProgrammableRenderer;
class ofBaseGLRenderer;
class ofTexture;

template<typename T>
class ofPixels_;

typedef ofPixels_<unsigned char> ofPixels;
typedef ofPixels_<float> ofFloatPixels;
typedef ofPixels_<unsigned short> ofShortPixels;
typedef ofPixels & ofPixelsRef;

enum ofImageType: short;
enum ofPixelFormat: short;

int ofGetGLInternalFormat(const ofPixels & pixels);
int ofGetGLInternalFormat(const ofShortPixels & pixels);
int ofGetGLInternalFormat(const ofFloatPixels & pixels);

OF_DEPRECATED_MSG("Use ofGetGLInternalFormat() instead", int ofGetGlInternalFormat(const ofPixels & pixels));
OF_DEPRECATED_MSG("Use ofGetGLInternalFormat() instead", int ofGetGlInternalFormat(const ofShortPixels & pixels));
OF_DEPRECATED_MSG("Use ofGetGLInternalFormat() instead", int ofGetGlInternalFormat(const ofFloatPixels & pixels));

//---------------------------------
// this is helpful for debugging ofTexture

std::string ofGetGLInternalFormatName(int glInternalFormat);
int ofGetGLFormatFromInternal(int gInternalFormat);
int ofGetGLTypeFromInternal(int glInternalFormat);

OF_DEPRECATED_MSG("Use ofGetGLInternalFormatName() instead", std::string ofGetGlInternalFormatName(int glInternalFormat));
OF_DEPRECATED_MSG("Use ofGetGLTypeFromInternal() instead", int ofGetGlTypeFromInternal(int glInternalFormat));

std::shared_ptr<ofBaseGLRenderer> ofGetGLRenderer();

int ofGetGLType(const ofPixels & pixels);
int ofGetGLType(const ofShortPixels & pixels);
int ofGetGLType(const ofFloatPixels & pixels);

OF_DEPRECATED_MSG("Use ofGetGLType() instead", int ofGetGlType(const ofPixels & pixels));
OF_DEPRECATED_MSG("Use ofGetGLType() instead", int ofGetGlType(const ofShortPixels & pixels));
OF_DEPRECATED_MSG("Use ofGetGLType() instead", int ofGetGlType(const ofFloatPixels & pixels));

ofImageType ofGetImageTypeFromGLType(int glType);

GLuint ofGetGLPolyMode(ofPolyRenderMode m);
ofPolyRenderMode ofGetOFPolyMode(GLuint m);

GLuint ofGetGLPrimitiveMode(ofPrimitiveMode mode);
ofPrimitiveMode ofGetOFPrimitiveMode(GLuint mode);

int ofGetGLInternalFormatFromPixelFormat(ofPixelFormat pixelFormat);
int ofGetGLFormatFromPixelFormat(ofPixelFormat pixelFormat);
int ofGetBytesPerChannelFromGLType(int glType);
int ofGetNumChannelsFromGLFormat(int glFormat);
void ofSetPixelStoreiAlignment(GLenum pname, int w, int bpc, int numChannels);
void ofSetPixelStoreiAlignment(GLenum panme, int stride);

std::vector<std::string> ofGLSupportedExtensions();
bool ofGLCheckExtension(std::string searchName);
bool ofGLSupportsNPOTTextures();

bool ofIsGLProgrammableRenderer();

template<class T>
OF_DEPRECATED_MSG("Use ofGetGLFormat() instead", int ofGetGlFormat(const ofPixels_<T> & pixels));

template<class T>
int ofGetGlFormat(const ofPixels_<T> & pixels) {
	return ofGetGLFormatFromPixelFormat(pixels.getPixelFormat());
}

template<class T>
int ofGetGLFormat(const ofPixels_<T> & pixels) {
    return ofGetGLFormatFromPixelFormat(pixels.getPixelFormat());
}

std::string ofGLSLVersionFromGL(int major, int minor);

#ifndef TARGET_OPENGLES
void ofEnableGLDebugLog();
void ofDisableGLDebugLog();
#endif

#ifndef TARGET_OPENGLES
	#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS			GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT
	#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS				GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT

	#ifndef GL_UNSIGNED_INT_24_8
		#define GL_UNSIGNED_INT_24_8						GL_UNSIGNED_INT_24_8_EXT
	#endif
#else
    // ES1 - check if GL_FRAMEBUFFER is defined, if not assume ES1 is running.
	#ifndef GL_FRAMEBUFFER
		#define GL_FRAMEBUFFER									GL_FRAMEBUFFER_OES
		#define GL_RENDERBUFFER									GL_RENDERBUFFER_OES
		#define GL_DEPTH_ATTACHMENT								GL_DEPTH_ATTACHMENT_OES
		#define GL_STENCIL_ATTACHMENT							GL_STENCIL_ATTACHMENT_OES
		//#define GL_DEPTH_STENCIL_ATTACHMENT					GL_DEPTH_STENCIL_ATTACHMENT_OES
		#define GL_DEPTH_COMPONENT								GL_DEPTH_COMPONENT16_OES
		#define GL_STENCIL_INDEX								GL_STENCIL_INDEX8_OES
		#define GL_FRAMEBUFFER_BINDING							GL_FRAMEBUFFER_BINDING_OES
		#define GL_MAX_COLOR_ATTACHMENTS						GL_MAX_COLOR_ATTACHMENTS_OES
		#define GL_MAX_SAMPLES									GL_MAX_SAMPLES_OES
		#define GL_READ_FRAMEBUFFER								GL_READ_FRAMEBUFFER_OES
		#define GL_DRAW_FRAMEBUFFER								GL_DRAW_FRAMEBUFFER_OES
		#define GL_WRITE_FRAMEBUFFER							GL_WRITE_FRAMEBUFFER_OES
		#define GL_COLOR_ATTACHMENT0							GL_COLOR_ATTACHMENT0_OES
		#define GL_FRAMEBUFFER_COMPLETE							GL_FRAMEBUFFER_COMPLETE_OES
		#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT			GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES
		#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT	GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES
		#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS			GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES
		#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER			GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES
		#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER			GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES
		#define GL_FRAMEBUFFER_UNSUPPORTED						GL_FRAMEBUFFER_UNSUPPORTED_OES
		#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE			GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_OES
		#define GL_DEPTH_COMPONENT16							GL_DEPTH_COMPONENT16_OES
	#endif

    // ES2 + ES3 - GL_STENCIL_INDEX has been removed from gl header, and now replaced with GL_STENCIL_INDEX8.
    #ifndef GL_STENCIL_INDEX
        #ifdef GL_STENCIL_INDEX8
            #define GL_STENCIL_INDEX                        GL_STENCIL_INDEX8
        #endif
    #endif

	#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS				GL_FRAMEBUFFER_INCOMPLETE_FORMATS_OES
	#define GL_UNSIGNED_INT_24_8							GL_UNSIGNED_INT_24_8_OES

	#define GL_DEPTH24_STENCIL8								GL_DEPTH24_STENCIL8_OES
	#define GL_DEPTH_STENCIL								GL_DEPTH24_STENCIL8_OES
	#define GL_DEPTH_COMPONENT24							GL_DEPTH_COMPONENT24_OES
	#ifdef GL_DEPTH_COMPONENT32_OES
        #define GL_DEPTH_COMPONENT32						GL_DEPTH_COMPONENT32_OES
    #endif
    #ifdef TARGET_OPENGLES
        #ifndef GL_UNSIGNED_INT
            #define GL_UNSIGNED_INT                         GL_UNSIGNED_INT_OES
        #endif
        #ifndef GL_HALF_FLOAT
            #define GL_HALF_FLOAT                           GL_HALF_FLOAT_OES
        #endif
    #endif
#endif

#line 0 "../libs/openFrameworks/utils/ofURLFileLoader.h"
#pragma once
/* #include "ofConstants.h" */
/* #include "ofEvents.h" */
/* #include "ofFileUtils.h" */
#include <map>

class ofHttpResponse;

/// \class ofHttpRequest
/// \brief an HTTP GET or POST request
class ofHttpRequest{
public:
	ofHttpRequest();
	ofHttpRequest(const std::string& url, const std::string& name,bool saveTo=false);

	std::string				url; //< request url
	std::string				name; //< optional name key for sorting
	bool				saveTo; //< save to a file once the request is finised?
	std::map<std::string,std::string>	headers; //< HTTP header keys & values
	std::string				body; //< POST body data
	std::string				contentType; //< POST data mime type
	std::function<void(const ofHttpResponse&)> done;
    size_t              timeoutSeconds = 0;

	/// \return the unique id for this request
	int getId() const;
	OF_DEPRECATED_MSG("Use getId().", int getID());

	/// HTTP request type
	enum Method{
		GET, //< request data from a specified resource (via url)
		POST //< submit data to be processed to a specified resource (via url)
	} method;

private:
	int					id; //< unique id for this request
	static int			nextID; //< global for computing next unique id
};

/// \class ofHttpResponse
/// \brief an HTTP response to a GET or POST request
class ofHttpResponse{
public:
	ofHttpResponse();
	ofHttpResponse(const ofHttpRequest& request, const ofBuffer& data, int status, const std::string& error);
	ofHttpResponse(const ofHttpRequest& request, int status, const std::string& error);

	operator ofBuffer&();

	ofHttpRequest	    request; //< matching HTTP request for this response
	ofBuffer		    data; //< response raw data
	int					status; //< HTTP response status (200: OK, 404: Not Found, etc)
	std::string				error; //< HTTP error string, if any (OK, Not Found, etc)
};

/// \brief make an HTTP GET request
/// blocks until a response is returned or the request times out
/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
/// \returns HTTP response
ofHttpResponse ofLoadURL(const std::string& url);

/// \brief make an asynchronous HTTP GET request
/// will not block, placed in a queue and run using a background thread
/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
/// \param name optional key to use when sorting requests
/// \return unique id for the active HTTP request
int ofLoadURLAsync(const std::string& url, const std::string& name=""); // returns id

/// \brief make an HTTP GET request and save the response data to a file
/// blocks until a response is returned or the request times out
/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
/// \param path file path to save to
/// \return HTTP response on success or failure
ofHttpResponse ofSaveURLTo(const std::string& url, const std::filesystem::path& path);

/// make an asynchronous HTTP request for a url and save the response to a file at path
/// \returns unique request id for the active HTTP request

/// \brief make an asynchronous HTTP request and save the response data to a file
/// will not block, placed in a queue and run using a background thread
/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
/// \param path file path to save to
/// \returns unique id for the active HTTP request
int ofSaveURLAsync(const std::string& url, const std::filesystem::path& path);

/// \brief remove an active HTTP request from the queue
/// \param unique HTTP request id
void ofRemoveURLRequest(int id);

/// \brief remove all active HTTP requests from the queue
void ofRemoveAllURLRequests();

/// \brief stop & remove all active and waiting HTTP requests
void ofStopURLLoader();

ofEvent<ofHttpResponse> & ofURLResponseEvent();

template<class T>
void ofRegisterURLNotification(T * obj){
	ofAddListener(ofURLResponseEvent(),obj,&T::urlResponse);
}

template<class T>
void ofUnregisterURLNotification(T * obj){
	ofRemoveListener(ofURLResponseEvent(),obj,&T::urlResponse);
}

class ofBaseURLFileLoader;

/// \class ofURLFileLoader
/// \brief loads a file from a URL using an HTTP request
class ofURLFileLoader  {
    public:
	
        ofURLFileLoader();	
	
		/// \brief make an HTTP request
		/// blocks until a response is returned or the request times out
		/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
		/// \return HTTP response on success or failure
		ofHttpResponse get(const std::string& url);
	
		/// \brief make an asynchronous HTTP request
		/// will not block, placed in a queue and run using a background thread
		/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
		/// \param name optional key to use when sorting requests
		/// \return unique id for the active HTTP request
        int getAsync(const std::string& url, const std::string& name="");
	
		/// \brief make an HTTP request and save the response data to a file
		/// blocks until a response is returned or the request times out
		/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
		/// \param path file path to save to
		/// \return HTTP response on success or failure
        ofHttpResponse saveTo(const std::string& url, const std::filesystem::path& path);
	
		/// \brief make an asynchronous HTTP request and save the response data to a file
		/// will not block, placed in a queue and run using a background thread
		/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
		/// \param path file path to save to
		/// \returns unique id for the active HTTP request
        int saveAsync(const std::string& url, const std::filesystem::path& path);
	
		/// \brief remove an active HTTP request from the queue
		/// \param unique HTTP request id
		void remove(int id);
	
		/// \brief clear all active HTTP requests from the queue
		void clear();
	
		/// \brief stop & remove all active and waiting HTTP requests
		void stop();
	
		// \brief low level HTTP request implementation
		/// blocks until a response is returned or the request times out
		/// \return HTTP response on success or failure
        ofHttpResponse handleRequest(const ofHttpRequest & request);
	
		// \brief low level HTTP request implementation
		/// this is a non-blocking version of handleRequest that will return a response in the urlResponse callback
		/// \return unique id of the active HTTP request
        int handleRequestAsync(const ofHttpRequest& request);

    private:
	std::shared_ptr<ofBaseURLFileLoader> impl;
};


/// \class ofBaseURLFileLoader
/// \brief loads a file from a URL using an HTTP request
class ofBaseURLFileLoader{
public:

	virtual ~ofBaseURLFileLoader(){};

	/// \brief make an HTTP request
	/// blocks until a response is returned or the request times out
	/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
	/// \return HTTP response on success or failure
	virtual ofHttpResponse get(const std::string& url)=0;

	/// \brief make an asynchronous HTTP request
	/// will not block, placed in a queue and run using a background thread
	/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
	/// \param name optional key to use when sorting requests
	/// \return unique id for the active HTTP request
	virtual int getAsync(const std::string& url, const std::string& name="")=0;

	/// \brief make an HTTP request and save the response data to a file
	/// blocks until a response is returned or the request times out
	/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
	/// \param path file path to save to
	/// \return HTTP response on success or failure
	virtual ofHttpResponse saveTo(const std::string& url, const std::filesystem::path& path)=0;

	/// \brief make an asynchronous HTTP request and save the response data to a file
	/// will not block, placed in a queue and run using a background thread
	/// \param url HTTP url to request, ie. "http://somewebsite.com/someapi/someimage.jpg"
	/// \param path file path to save to
	/// \returns unique id for the active HTTP request
	virtual int saveAsync(const std::string& url, const std::filesystem::path& path)=0;

	/// \brief remove an active HTTP request from the queue
	/// \param unique HTTP request id
	virtual void remove(int id)=0;

	/// \brief clear all active HTTP requests from the queue
	virtual void clear()=0;

	/// \brief stop & remove all active and waiting HTTP requests
	virtual void stop()=0;

	/// \brief low level HTTP request implementation
	/// blocks until a response is returned or the request times out
	/// \return HTTP response on success or failure
	virtual ofHttpResponse handleRequest(const ofHttpRequest & request) = 0;
	virtual int handleRequestAsync(const ofHttpRequest& request)=0; // returns id

};

#line 0 "../libs/openFrameworks/types/ofBaseTypes.h"
#pragma once

/* #include "ofGLBaseTypes.h" */
/* #include "ofGraphicsBaseTypes.h" */
/* #include "ofSoundBaseTypes.h" */
/* #include "ofVideoBaseTypes.h" */

#line 0 "../libs/openFrameworks/types/ofPoint.h"
#pragma once

/* #include "ofVec3f.h" */

/// \file 
/// ofPoint is a typedef (alias) of ofVec3f

/// \brief Look at ofVec3f for documentation
typedef ofVec3f ofPoint;

#line 0 "../libs/openFrameworks/types/ofParameter.h"
#pragma once

/* #include "ofEvents.h" */
/* #include "ofConstants.h" */
/* #include "ofPoint.h" */
/* #include "ofColor.h" */
/* #include "ofLog.h" */
#include <map>

template<typename ParameterType>
class ofParameter;

template<typename ParameterType, typename Friend>
class ofReadOnlyParameter;

class ofParameterGroup;



//----------------------------------------------------------------------
/// Base class for ofParameter, ofReadOnlyParameter and ofParameterGroup
class ofAbstractParameter{
public:
	virtual ~ofAbstractParameter(){}
	virtual std::string getName() const = 0;
	virtual void setName(const std::string & name) = 0;
	virtual std::string toString() const = 0;
	virtual void fromString(const std::string & str) = 0;

	virtual std::string type() const;
	virtual std::string getEscapedName() const;
	virtual std::string valueType() const = 0;

	virtual void setParent(ofParameterGroup & _parent) = 0;
	std::vector<std::string> getGroupHierarchyNames() const;

	template<typename ParameterType>
	ofParameter<ParameterType> & cast(){
		return static_cast<ofParameter<ParameterType> &>(*this);
	}

	template<typename ParameterType>
	const ofParameter<ParameterType> & cast() const{
		return static_cast<const ofParameter<ParameterType> &>(*this);
	}

	template<typename ParameterType, typename Friend>
	ofReadOnlyParameter<ParameterType, Friend> & castReadOnly(){
		return static_cast<ofReadOnlyParameter<ParameterType, Friend> &>(*this);
	}

	template<typename ParameterType, typename Friend>
	const ofReadOnlyParameter<ParameterType, Friend> & castReadOnly() const{
		return static_cast<const ofReadOnlyParameter<ParameterType, Friend> &>(*this);
	}

	ofParameterGroup & castGroup();
	const ofParameterGroup & castGroup() const;

	friend std::ostream& operator<<(std::ostream& os, const ofAbstractParameter& p);
	friend std::istream& operator>>(std::istream& is, ofAbstractParameter& p);

	virtual bool isSerializable() const = 0;
	virtual bool isReadOnly() const = 0;
	virtual std::shared_ptr<ofAbstractParameter> newReference() const = 0;

	virtual bool isReferenceTo(const ofAbstractParameter& other) const;

protected:
	virtual const ofParameterGroup getFirstParent() const = 0;
	virtual void setSerializable(bool serializable)=0;
	virtual std::string escape(const std::string& str) const;
	virtual const void* getInternalObject() const = 0;
};




//----------------------------------------------------------------------
/// A collection of parameters with events to notify if a parameter changed
/// and serialization facilities
class ofParameterGroup: public ofAbstractParameter {
public:
	ofParameterGroup();

	template<typename ...Args>
	ofParameterGroup(const std::string & name)
	:obj(std::make_shared<Value>()){
		setName(name);
	}

	template<typename ...Args>
	ofParameterGroup(const std::string & name, Args&... p)
	:obj(std::make_shared<Value>()){
		add(p...);
		setName(name);
	}

	template<typename ...Args>
	void add(ofAbstractParameter & p, Args&... parameters){
		add(p);
		add(parameters...);
	}

	void add(ofAbstractParameter & param);
	std::string valueType() const;

	void remove(ofAbstractParameter & param);
	void remove(std::size_t index);
	void remove(const std::string& name);

	void clear();

	const ofParameter<void> & getVoid(const std::string& name) const;
	const ofParameter<bool> & getBool(const std::string& name) const;
	const ofParameter<int> & getInt(const std::string& name) const;
	const ofParameter<float> & getFloat(const std::string& name) const;
	const ofParameter<char> & getChar(const std::string& name) const;
	const ofParameter<std::string> & getString(const std::string& name) const;
	const ofParameter<ofPoint> & getPoint(const std::string& name) const;
	const ofParameter<ofDefaultVec2> & getVec2f(const std::string& name) const;
	const ofParameter<ofDefaultVec3> & getVec3f(const std::string& name) const;
	const ofParameter<ofDefaultVec4> & getVec4f(const std::string& name) const;
	const ofParameter<ofColor> & getColor(const std::string& name) const;
	const ofParameter<ofShortColor> & getShortColor(const std::string& name) const;
	const ofParameter<ofFloatColor> & getFloatColor(const std::string& name) const;
	const ofParameterGroup & getGroup(const std::string& name) const;


	const ofParameter<void> & getVoid(std::size_t pos) const;
	const ofParameter<bool> & getBool(std::size_t pos) const;
	const ofParameter<int> & getInt(std::size_t pos) const;
	const ofParameter<float> & getFloat(std::size_t pos) const;
	const ofParameter<char> & getChar(std::size_t pos) const;
	const ofParameter<std::string> & getString(std::size_t pos) const;
	const ofParameter<ofPoint> & getPoint(std::size_t pos) const;
	const ofParameter<ofDefaultVec2> & getVec2f(std::size_t pos) const;
	const ofParameter<ofDefaultVec3> & getVec3f(std::size_t pos) const;
	const ofParameter<ofDefaultVec4> & getVec4f(std::size_t pos) const;
	const ofParameter<ofColor> & getColor(std::size_t pose) const;
	const ofParameter<ofShortColor> & getShortColor(std::size_t pos) const;
	const ofParameter<ofFloatColor> & getFloatColor(std::size_t pos) const;
	const ofParameterGroup & getGroup(std::size_t pos) const;

	ofParameter<void> & getVoid(const std::string& name);
	ofParameter<bool> & getBool(const std::string& name);
	ofParameter<int> & getInt(const std::string& name);
	ofParameter<float> & getFloat(const std::string& name);
	ofParameter<char> & getChar(const std::string& name);
	ofParameter<std::string> & getString(const std::string& name);
	ofParameter<ofPoint> & getPoint(const std::string& name);
	ofParameter<ofDefaultVec2> & getVec2f(const std::string& name);
	ofParameter<ofDefaultVec3> & getVec3f(const std::string& name);
	ofParameter<ofDefaultVec4> & getVec4f(const std::string& name);
	ofParameter<ofColor> & getColor(const std::string& name);
	ofParameter<ofShortColor> & getShortColor(const std::string& name);
	ofParameter<ofFloatColor> & getFloatColor(const std::string& name);
	ofParameterGroup & getGroup(const std::string& name);


	ofParameter<void> & getVoid(std::size_t pos);
	ofParameter<bool> & getBool(std::size_t pos);
	ofParameter<int> & getInt(std::size_t pos);
	ofParameter<float> & getFloat(std::size_t pos);
	ofParameter<char> & getChar(std::size_t pos);
	ofParameter<std::string> & getString(std::size_t pos);
	ofParameter<ofPoint> & getPoint(std::size_t pos);
	ofParameter<ofDefaultVec2> & getVec2f(std::size_t pos);
	ofParameter<ofDefaultVec3> & getVec3f(std::size_t pos);
	ofParameter<ofDefaultVec4> & getVec4f(std::size_t pos);
	ofParameter<ofColor> & getColor(std::size_t pose);
	ofParameter<ofShortColor> & getShortColor(std::size_t pos);
	ofParameter<ofFloatColor> & getFloatColor(std::size_t pos);
	ofParameterGroup & getGroup(std::size_t pos);

	const ofAbstractParameter & get(const std::string& name) const;
	const ofAbstractParameter & get(std::size_t pos) const;

	const ofAbstractParameter & operator[](const std::string& name) const;
	const ofAbstractParameter & operator[](std::size_t pos) const;

	ofAbstractParameter & get(const std::string& name);
	ofAbstractParameter & get(std::size_t pos);

	ofAbstractParameter & operator[](const std::string& name);
	ofAbstractParameter & operator[](std::size_t pos);

	template<typename ParameterType>
	const ofParameter<ParameterType> & get(const std::string& name) const;

	template<typename ParameterType>
	const ofParameter<ParameterType> & get(std::size_t pos) const;

	template<typename ParameterType>
	ofParameter<ParameterType> & get(const std::string& name);

	template<typename ParameterType>
	ofParameter<ParameterType> & get(std::size_t pos);

	template<typename ParameterType, typename Friend>
	const ofReadOnlyParameter<ParameterType, Friend> & getReadOnly(const std::string& name) const;

	template<typename ParameterType, typename Friend>
	const ofReadOnlyParameter<ParameterType, Friend> & getReadOnly(std::size_t pos) const;

	template<typename ParameterType, typename Friend>
	ofReadOnlyParameter<ParameterType, Friend> & getReadOnly(const std::string& name);

	template<typename ParameterType, typename Friend>
	ofReadOnlyParameter<ParameterType, Friend> & getReadOnly(std::size_t pos);

	std::size_t size() const;
	std::string getName(std::size_t position) const;
	std::string getType(std::size_t position) const;
	bool getIsReadOnly(int position) const;
	int getPosition(const std::string& name) const;

	friend std::ostream& operator<<(std::ostream& os, const ofParameterGroup& group);

	std::string getName() const;
	void setName(const std::string& name);
	std::string getEscapedName() const;
	std::string toString() const;
	void fromString(const std::string& name);

	bool contains(const std::string& name) const;

	ofAbstractParameter & back();
	ofAbstractParameter & front();
	const ofAbstractParameter & back() const;
	const ofAbstractParameter & front() const;

	void setSerializable(bool serializable);
	bool isSerializable() const;
	bool isReadOnly() const;
	std::shared_ptr<ofAbstractParameter> newReference() const;

	void setParent(ofParameterGroup & parent);

	operator bool() const;

	ofEvent<ofAbstractParameter> & parameterChangedE();

	std::vector<std::shared_ptr<ofAbstractParameter> >::iterator begin();
	std::vector<std::shared_ptr<ofAbstractParameter> >::iterator end();
	std::vector<std::shared_ptr<ofAbstractParameter> >::const_iterator begin() const;
	std::vector<std::shared_ptr<ofAbstractParameter> >::const_iterator end() const;
	std::vector<std::shared_ptr<ofAbstractParameter> >::reverse_iterator rbegin();
	std::vector<std::shared_ptr<ofAbstractParameter> >::reverse_iterator rend();
	std::vector<std::shared_ptr<ofAbstractParameter> >::const_reverse_iterator rbegin() const;
	std::vector<std::shared_ptr<ofAbstractParameter> >::const_reverse_iterator rend() const;

protected:
	const void* getInternalObject() const;

private:
	class Value{
	public:
		Value()
		:serializable(true){}

		void notifyParameterChanged(ofAbstractParameter & param);

		std::map<std::string,std::size_t> parametersIndex;
		std::vector<std::shared_ptr<ofAbstractParameter> > parameters;
		std::string name;
		bool serializable;
		std::vector<std::weak_ptr<Value>> parents;
		ofEvent<ofAbstractParameter> parameterChangedE;
	};
	std::shared_ptr<Value> obj;
	ofParameterGroup(std::shared_ptr<Value> obj)
	:obj(obj){}

	template<typename T>
	friend class ofParameter;

	template<typename T, typename F>
	friend class ofReadOnlyParameter;

	const ofParameterGroup getFirstParent() const;
};

template<typename ParameterType>
const ofParameter<ParameterType> & ofParameterGroup::get(const std::string& name) const{
	return static_cast<const ofParameter<ParameterType>& >(get(name));
}

template<typename ParameterType>
const ofParameter<ParameterType> & ofParameterGroup::get(std::size_t pos) const{
	return static_cast<const ofParameter<ParameterType>& >(get(pos));
}

template<typename ParameterType>
ofParameter<ParameterType> & ofParameterGroup::get(const std::string& name){
	return static_cast<ofParameter<ParameterType>& >(get(name));
}

template<typename ParameterType>
ofParameter<ParameterType> & ofParameterGroup::get(std::size_t pos){
	return static_cast<ofParameter<ParameterType>& >(get(pos));
}


template<typename ParameterType, typename Friend>
const ofReadOnlyParameter<ParameterType, Friend> & ofParameterGroup::getReadOnly(const std::string& name) const{
	return static_cast<const ofReadOnlyParameter<ParameterType,Friend>& >(get(name));
}

template<typename ParameterType, typename Friend>
const ofReadOnlyParameter<ParameterType, Friend> & ofParameterGroup::getReadOnly(std::size_t pos) const{
	return static_cast<const ofReadOnlyParameter<ParameterType,Friend>& >(get(pos));
}

template<typename ParameterType, typename Friend>
ofReadOnlyParameter<ParameterType, Friend> & ofParameterGroup::getReadOnly(const std::string& name){
	return static_cast<const ofReadOnlyParameter<ParameterType,Friend>& >(get(name));
}

template<typename ParameterType, typename Friend>
ofReadOnlyParameter<ParameterType, Friend> & ofParameterGroup::getReadOnly(std::size_t pos){
	return static_cast<const ofReadOnlyParameter<ParameterType,Friend>& >(get(pos));
}


/*! \cond PRIVATE */
namespace of{
namespace priv{
	//----------------------------------------------------------------------
	// Mechanism to provide min and max default values for types where it makes sense
	template<typename T, bool B>
	struct TypeInfo_ {
	};

	// Types with numeric_limits resolve to this template specialization:
	template<typename T>
	struct TypeInfo_<T, true> {
		static T min() { return std::numeric_limits<T>::lowest(); }
		static T max() { return std::numeric_limits<T>::max(); }
	};

	template<>
	struct TypeInfo_<float, true> {
		static float min() { return 0; }
		static float max() { return 1; }
	};

	template<>
	struct TypeInfo_<double, true> {
		static float min() { return 0; }
		static float max() { return 1; }
	};

	// Types without numeric_limits resolve to this template specialization:
	template<typename T>
	struct TypeInfo_<T, false> {
		static T min() { return T(); }
		static T max() { return T(); }
	};

	template<typename T>
	struct TypeInfo : public of::priv::TypeInfo_<T, std::numeric_limits<T>::is_specialized> {
	};

	// Here we provide some of our own specializations:
	template<>
	struct TypeInfo <ofVec2f> {
		static ofVec2f min() { return ofVec2f(0); }
		static ofVec2f max() { return ofVec2f(1); }
	};

	template<>
	struct TypeInfo <glm::vec2> {
		static glm::vec2 min() { return glm::vec2(0); }
		static glm::vec2 max() { return glm::vec2(1); }
	};

	template<>
	struct TypeInfo <ofVec3f> {
		static ofVec3f min() { return ofVec3f(0); }
		static ofVec3f max() { return ofVec3f(1); }
	};

	template<>
	struct TypeInfo <glm::vec3> {
		static glm::vec3 min() { return glm::vec3(0); }
		static glm::vec3 max() { return glm::vec3(1); }
	};

	template<>
	struct TypeInfo <ofVec4f> {
		static ofVec4f min() { return ofVec4f(0); }
		static ofVec4f max() { return ofVec4f(1); }
	};

	template<>
	struct TypeInfo <glm::vec4> {
		static glm::vec4 min() { return glm::vec4(0); }
		static glm::vec4 max() { return glm::vec4(1); }
	};

	template<typename T>
	struct TypeInfo <ofColor_<T>> {
		static ofColor_<T> min() { return ofColor_<T>(0,0); }
		static ofColor_<T> max() { return ofColor_<T>(ofColor_<T>::limit(),ofColor_<T>::limit()); }
	};


	// detection of stream operators
	typedef char yes;
	typedef char (&no)[2];

	struct anyx { template <class T> anyx(const T &); };

	no operator << (const anyx &, const anyx &);
	no operator >> (const anyx &, const anyx &);

	
	template <class T> yes check_op(T const&);
	no check_op(no);

	template <typename T>
	struct has_loading_support {
		static std::istream & stream;
		static T & x;
		static constexpr bool value = sizeof(check_op(stream >> x)) == sizeof(yes);
	};

	template <typename T>
	struct has_saving_support {
		static std::ostream & stream;
		static T & x;
		static constexpr bool value = sizeof(check_op(stream << x)) == sizeof(yes);
	};

	template <typename T>
	struct has_stream_operators {
		static constexpr bool can_load = has_loading_support<T>::value;
		static constexpr bool can_save = has_saving_support<T>::value;
		static constexpr bool value = can_load && can_save;
	};

	template<typename ParameterType>
	typename std::enable_if<of::priv::has_saving_support<ParameterType>::value, std::string>::type toStringImpl(const ParameterType & value){
		return ofToString(value);
	}

	template<typename ParameterType>
	typename std::enable_if<!of::priv::has_saving_support<ParameterType>::value, std::string>::type toStringImpl(const ParameterType &){
		throw std::exception();
	}

	template<typename ParameterType>
	typename std::enable_if<of::priv::has_loading_support<ParameterType>::value, ParameterType>::type fromStringImpl(const std::string & str){
		return ofFromString<ParameterType>(str);
	}

	template<typename ParameterType>
	typename std::enable_if<!of::priv::has_loading_support<ParameterType>::value, ParameterType>::type fromStringImpl(const std::string &){
		throw std::exception();

	}
}
}
/*! \endcond */



/// \brief ofParameter holds a value and notifies its listeners when it changes.
///
/// ofParameter can be used as the value itself. For example an `ofParameter<int>`
/// can be added, multiplied, substracted, etc with another number.
///
/// For an ofParameter with a custom object such as `ofParameter<MyObject> myObject`,
/// `MyObject`'s methods can be accessed using pointer syntax,
/// e.g. `myObject->myMethod();`.
///
/// \tparam ParameterType The data wrapped by the ofParameter.
template<typename ParameterType>
class ofParameter: public ofAbstractParameter{
public:
	ofParameter();
	ofParameter(const ofParameter<ParameterType> & v);
	ofParameter(const ParameterType & v);
	ofParameter(const std::string& name, const ParameterType & v);
	ofParameter(const std::string& name, const ParameterType & v, const ParameterType & min, const ParameterType & max);

	const ParameterType & get() const;
	const ParameterType * operator->() const;
	operator const ParameterType & () const;

	void setName(const std::string & name);
	std::string getName() const;

	ParameterType getMin() const;

	ParameterType getMax() const;


	std::string toString() const;
	void fromString(const std::string & name);

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method, int prio=OF_EVENT_ORDER_AFTER_APP){
		ofAddListener(obj->changedE,listener,method,prio);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method, int prio=OF_EVENT_ORDER_AFTER_APP){
		ofRemoveListener(obj->changedE,listener,method,prio);
	}

	template<typename... Args>
	std::unique_ptr<of::priv::AbstractEventToken> newListener(Args...args) {
		return obj->changedE.newListener(args...);
	}

	void enableEvents();
	void disableEvents();
	bool isSerializable() const;
	bool isReadOnly() const;
	std::string valueType() const;

	void makeReferenceTo(ofParameter<ParameterType> & mom);

	ofParameter<ParameterType> & operator=(const ofParameter<ParameterType> & v);
	const ParameterType & operator=(const ParameterType & v);

	ParameterType operator++(int v);
	ofParameter<ParameterType> & operator++();

	ParameterType operator--(int v);
	ofParameter<ParameterType> & operator--();

	template<typename OtherType>
	ofParameter<ParameterType> & operator+=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator-=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator*=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator/=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator%=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator&=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator|=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator^=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator<<=(const OtherType & v);
	template<typename OtherType>
	ofParameter<ParameterType> & operator>>=(const OtherType & v);


	ofParameter<ParameterType> & set(const ParameterType & v);
	ofParameter<ParameterType> & set(const std::string& name, const ParameterType & v);
	ofParameter<ParameterType> & set(const std::string& name, const ParameterType & v, const ParameterType & min, const ParameterType & max);

	ofParameter<ParameterType> & setWithoutEventNotifications(const ParameterType & v);

	void setMin(const ParameterType & min);
	void setMax(const ParameterType & max);

	void setSerializable(bool serializable);
	std::shared_ptr<ofAbstractParameter> newReference() const;

	void setParent(ofParameterGroup & _parent);

	const ofParameterGroup getFirstParent() const{
		obj->parents.erase(std::remove_if(obj->parents.begin(),obj->parents.end(),
						   [](std::weak_ptr<ofParameterGroup::Value> p){return p.lock()==nullptr;}),
						obj->parents.end());
		if(!obj->parents.empty()){
			return obj->parents.front().lock();
		}else{
			return std::shared_ptr<ofParameterGroup::Value>(nullptr);
		}
	}

	size_t getNumListeners() const;
	const void* getInternalObject() const;

protected:

private:
	class Value{
	public:
		Value()
		:min(of::priv::TypeInfo<ParameterType>::min())
		,max(of::priv::TypeInfo<ParameterType>::max())
		,bInNotify(false)
		,serializable(true){}

		Value(ParameterType v)
		:value(v)
		,min(of::priv::TypeInfo<ParameterType>::min())
		,max(of::priv::TypeInfo<ParameterType>::max())
		,bInNotify(false)
		,serializable(true){}

		Value(std::string name, ParameterType v)
		:name(name)
		,value(v)
		,min(of::priv::TypeInfo<ParameterType>::min())
		,max(of::priv::TypeInfo<ParameterType>::max())
		,bInNotify(false)
		,serializable(true){}

		Value(std::string name, ParameterType v, ParameterType min, ParameterType max)
		:name(name)
		,value(v)
		,min(min)
		,max(max)
		,bInNotify(false)
		,serializable(true){}

		std::string name;
		ParameterType value;
		ParameterType min, max;
		ofEvent<ParameterType> changedE;
		bool bInNotify;
		bool serializable;
		std::vector<std::weak_ptr<ofParameterGroup::Value>> parents;
	};

	std::shared_ptr<Value> obj;
	std::function<void(const ParameterType & v)> setMethod;

	void eventsSetValue(const ParameterType & v);
	void noEventsSetValue(const ParameterType & v);

	template<typename T, typename F>
	friend class ofReadOnlyParameter;
};


template<typename ParameterType>
ofParameter<ParameterType>::ofParameter()
:obj(std::make_shared<Value>())
,setMethod(std::bind(&ofParameter<ParameterType>::eventsSetValue, this, std::placeholders::_1)){}

template<typename ParameterType>
ofParameter<ParameterType>::ofParameter(const ofParameter<ParameterType> & v)
:obj(v.obj)
,setMethod(std::bind(&ofParameter<ParameterType>::eventsSetValue, this, std::placeholders::_1)) {}

template<typename ParameterType>
ofParameter<ParameterType>::ofParameter(const ParameterType & v)
:obj(std::make_shared<Value>(v))
,setMethod(std::bind(&ofParameter<ParameterType>::eventsSetValue, this, std::placeholders::_1)) {}

template<typename ParameterType>
ofParameter<ParameterType>::ofParameter(const std::string& name, const ParameterType & v)
:obj(std::make_shared<Value>(name, v))
,setMethod(std::bind(&ofParameter<ParameterType>::eventsSetValue, this, std::placeholders::_1)){}

template<typename ParameterType>
ofParameter<ParameterType>::ofParameter(const std::string& name, const ParameterType & v, const ParameterType & min, const ParameterType & max)
:obj(std::make_shared<Value>(name, v, min, max))
,setMethod(std::bind(&ofParameter<ParameterType>::eventsSetValue, this, std::placeholders::_1)){}


template<typename ParameterType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator=(const ofParameter<ParameterType> & v){
	set(v);
	return *this;
}

template<typename ParameterType>
inline const ParameterType & ofParameter<ParameterType>::operator=(const ParameterType & v){
	set(v);
	return obj->value;
}

template<typename ParameterType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::set(const ParameterType & v){
	setMethod(v);
	return *this;
}

template<typename ParameterType>
ofParameter<ParameterType> & ofParameter<ParameterType>::set(const std::string& name, const ParameterType & value, const ParameterType & min, const ParameterType & max){
	setName(name);
	set(value);
	setMin(min);
	setMax(max);
	return *this;
}

template<typename ParameterType>
ofParameter<ParameterType> & ofParameter<ParameterType>::set(const std::string& name, const ParameterType & value){
	setName(name);
	set(value);
	return *this;
}

template<typename ParameterType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::setWithoutEventNotifications(const ParameterType & v){
	noEventsSetValue(v);
	return *this;
}

template<typename ParameterType>
inline const ParameterType & ofParameter<ParameterType>::get() const{
	return obj->value;
}
template<typename ParameterType>
inline const ParameterType * ofParameter<ParameterType>::operator->() const{
	return &obj->value;
}

template<typename ParameterType>
inline void ofParameter<ParameterType>::eventsSetValue(const ParameterType & v){

	// If the object is notifying its parents, just set the value without triggering an event.
	if(obj->bInNotify)
	{
		noEventsSetValue(v);
	}
	else
	{
		// Mark the object as in its notification loop.
		obj->bInNotify = true;

		// Set the value.
		obj->value = v;

		// Notify any local subscribers.
		ofNotifyEvent(obj->changedE,obj->value,this);

		// Notify all parents, if there are any.
		if(!obj->parents.empty())
		{
			// Erase each invalid parent
			obj->parents.erase(std::remove_if(obj->parents.begin(),
											  obj->parents.end(),
											  [this](const std::weak_ptr<ofParameterGroup::Value> & p){ return p.expired(); }),
							   obj->parents.end());

			// notify all leftover (valid) parents of this object's changed value.
			// this can't happen in the same iterator as above, because a notified listener
			// might perform similar cleanups that would corrupt our iterator
			// (which appens for example if the listener calls getFirstParent on us)
			for(auto & parent: obj->parents){
				auto p = parent.lock();
				if(p){
					p->notifyParameterChanged(*this);
				}
			}
		}
		obj->bInNotify = false;
	}
}

template<typename ParameterType>
inline void ofParameter<ParameterType>::noEventsSetValue(const ParameterType & v){
	obj->value = v;
}


template<typename ParameterType>
void ofParameter<ParameterType>::setSerializable(bool serializable){
	obj->serializable = serializable;
}

template<typename ParameterType>
bool ofParameter<ParameterType>::isSerializable() const{
	return of::priv::has_stream_operators<ParameterType>::value && obj->serializable;
}

template<typename ParameterType>
bool ofParameter<ParameterType>::isReadOnly() const{
	return false;
}

template<typename ParameterType>
std::string ofParameter<ParameterType>::valueType() const{
	return typeid(ParameterType).name();
}

template<typename ParameterType>
void ofParameter<ParameterType>::setMin(const ParameterType & min){
	obj->min = min;
}

template<typename ParameterType>
ParameterType ofParameter<ParameterType>::getMin() const {
	return obj->min;
}

template<typename ParameterType>
void ofParameter<ParameterType>::setMax(const ParameterType & max){
	obj->max = max;
}

template<typename ParameterType>
ParameterType ofParameter<ParameterType>::getMax() const {
	return obj->max;
}

template<typename ParameterType>
inline ofParameter<ParameterType>::operator const ParameterType & () const{
	return obj->value;
}

template<typename ParameterType>
void ofParameter<ParameterType>::setName(const std::string & name){
	obj->name = name;
}

template<typename ParameterType>
std::string ofParameter<ParameterType>::getName() const{
	return obj->name;
}

template<typename ParameterType>
inline std::string ofParameter<ParameterType>::toString() const{
	try{
		return of::priv::toStringImpl(obj->value);
	}catch(...){
		ofLogError("ofParameter") << "Trying to serialize non-serializable parameter";
		return "";
	}
}

template<typename ParameterType>
inline void ofParameter<ParameterType>::fromString(const std::string & str){
	try{
		set(of::priv::fromStringImpl<ParameterType>(str));
	}catch(...){
		ofLogError("ofParameter") << "Trying to de-serialize non-serializable parameter";
	}
}

template<typename ParameterType>
void ofParameter<ParameterType>::enableEvents(){
	setMethod = std::bind(&ofParameter<ParameterType>::eventsSetValue, this, std::placeholders::_1);
}

template<typename ParameterType>
void ofParameter<ParameterType>::disableEvents(){
	setMethod = std::bind(&ofParameter<ParameterType>::noEventsSetValue, this, std::placeholders::_1);
}

template<typename ParameterType>
inline ParameterType ofParameter<ParameterType>::operator++(int){
	ParameterType r = obj->value;
	obj->value++;
	set(obj->value);
	return r;
}

template<typename ParameterType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator++(){
	++obj->value;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
inline ParameterType ofParameter<ParameterType>::operator--(int){
	ParameterType r = obj->value;
	obj->value--;
	set(obj->value);
	return r;
}

template<typename ParameterType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator--(){
	--obj->value;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator+=(const OtherType & v){
	obj->value+=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator-=(const OtherType & v){
	obj->value-=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator*=(const OtherType & v){
	obj->value*=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator/=(const OtherType & v){
	obj->value/=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator%=(const OtherType & v){
	obj->value%=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator&=(const OtherType & v){
	obj->value&=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
ofParameter<ParameterType> & ofParameter<ParameterType>::operator|=(const OtherType & v){
	obj->value|=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator^=(const OtherType & v){
	obj->value^=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator<<=(const OtherType & v){
	obj->value<<=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
template<typename OtherType>
inline ofParameter<ParameterType> & ofParameter<ParameterType>::operator>>=(const OtherType & v){
	obj->value>>=v;
	set(obj->value);
	return *this;
}

template<typename ParameterType>
void ofParameter<ParameterType>::makeReferenceTo(ofParameter<ParameterType> & mom){
	obj = mom.obj;
}

template<typename ParameterType>
std::shared_ptr<ofAbstractParameter> ofParameter<ParameterType>::newReference() const{
	return std::make_shared<ofParameter<ParameterType>>(*this);
}

template<typename ParameterType>
void ofParameter<ParameterType>::setParent(ofParameterGroup & parent){
	obj->parents.emplace_back(parent.obj);
}

template<typename ParameterType>
size_t ofParameter<ParameterType>::getNumListeners() const{
	return obj->changedE.size();
}

template<typename ParameterType>
const void* ofParameter<ParameterType>::getInternalObject() const{
	return obj.get();
}

template<>
class ofParameter<void>: public ofAbstractParameter{
public:
	ofParameter();
	ofParameter(const std::string& name);

	ofParameter<void>& set(const std::string & name);

	void setName(const std::string & name);
	std::string getName() const;

	std::string toString() const;
	void fromString(const std::string & name);

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method, int prio=OF_EVENT_ORDER_AFTER_APP){
		ofAddListener(obj->changedE,listener,method,prio);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method, int prio=OF_EVENT_ORDER_AFTER_APP){
		ofRemoveListener(obj->changedE,listener,method,prio);
	}

	template<typename... Args>
	std::unique_ptr<of::priv::AbstractEventToken> newListener(Args...args) {
		return obj->changedE.newListener(args...);
	}

	void trigger();
	void trigger(const void * sender);

	void enableEvents();
	void disableEvents();
	bool isSerializable() const;
	bool isReadOnly() const;
	std::string valueType() const;

	void makeReferenceTo(ofParameter<void> & mom);

	void setSerializable(bool serializable);
	std::shared_ptr<ofAbstractParameter> newReference() const;

	void setParent(ofParameterGroup & _parent);

	const ofParameterGroup getFirstParent() const{
		auto first = std::find_if(obj->parents.begin(),obj->parents.end(),[](std::weak_ptr<ofParameterGroup::Value> p){return p.lock()!=nullptr;});
		if(first!=obj->parents.end()){
			return first->lock();
		}else{
			return std::shared_ptr<ofParameterGroup::Value>(nullptr);
		}
	}
	size_t getNumListeners() const;

	const void* getInternalObject() const{
		return obj.get();
	}
protected:

private:
	class Value{
	public:
		Value()
		:serializable(false){}

		Value(std::string name)
		:name(name)
		,serializable(false){}

		std::string name;
		ofEvent<void> changedE;
		bool serializable;
		std::vector<std::weak_ptr<ofParameterGroup::Value>> parents;
	};
	std::shared_ptr<Value> obj;
};



/// \brief ofReadOnlyParameter holds a value and notifies its listeners when it changes.
///
/// ofReadOnlyParameter is a "read only" version of `ofPareameter`.  "Friend"
/// classes specified in the template arguments allow other classes
/// write-access to the internal data.  Otherwise, all other access is
/// "read only".
///
/// \sa ofParameter
/// \tparam ParameterType The data wrapped by the ofParameter.
/// \tparam Friend The type of the "friend" class with write access.
template<typename ParameterType,typename Friend>
class ofReadOnlyParameter: public ofAbstractParameter{
public:
	ofReadOnlyParameter();
//	ofReadOnlyParameter(ofParameter<ParameterType> & p);
//	ofReadOnlyParameter(ofReadOnlyParameter<ParameterType,Friend> & p);
	ofReadOnlyParameter(const ParameterType & v);
	ofReadOnlyParameter(const std::string& name, const ParameterType & v);
	ofReadOnlyParameter(const std::string& name, const ParameterType & v, const ParameterType & min, const ParameterType & max);

	const ParameterType & get() const;
	const ParameterType * operator->() const;
	operator const ParameterType & () const;

	std::string getName() const;

	ParameterType getMin() const;

	ParameterType getMax() const;

	std::string toString() const;

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method, int prio=OF_EVENT_ORDER_AFTER_APP);

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method, int prio=OF_EVENT_ORDER_AFTER_APP);

	std::shared_ptr<ofAbstractParameter> newReference() const;

	template<typename... Args>
	std::unique_ptr<of::priv::AbstractEventToken> newListener(Args...args);

	bool isSerializable() const;
	bool isReadOnly() const;
	std::string valueType() const;

protected:
	void setName(const std::string & name);
	void enableEvents();
	void disableEvents();
	void setSerializable(bool s);

	template<typename OtherFriend>
	void makeReferenceTo(ofReadOnlyParameter<ParameterType,OtherFriend> mom);
	void makeReferenceTo(ofParameter<ParameterType> mom);

	ofReadOnlyParameter<ParameterType,Friend> & operator=(const ofReadOnlyParameter<ParameterType,Friend>& v);
	ofReadOnlyParameter<ParameterType,Friend> & operator=(const ofParameter<ParameterType>& v);
	const ParameterType & operator=(const ParameterType & v);

	ParameterType operator++(int v);
	ofReadOnlyParameter<ParameterType,Friend>& operator++();

	ParameterType operator--(int v);
	ofReadOnlyParameter<ParameterType,Friend>& operator--();

	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator+=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator-=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator*=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator/=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator%=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator&=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator|=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator^=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator<<=(const OtherType & v);
	template<typename OtherType>
	ofReadOnlyParameter<ParameterType,Friend>& operator>>=(const OtherType & v);


	ofReadOnlyParameter<ParameterType,Friend>& set(const ParameterType & v);
	
	ofReadOnlyParameter<ParameterType,Friend>& set(const std::string& name, const ParameterType & value);
	ofReadOnlyParameter<ParameterType,Friend>& set(const std::string& name, const ParameterType & value, const ParameterType & min, const ParameterType & max);

	void setMin(const ParameterType & min);
	void setMax(const ParameterType & max);

	void fromString(const std::string & str);

	void setParent(ofParameterGroup & _parent);

	const ofParameterGroup getFirstParent() const{
		return parameter.getFirstParent();
	}

	const void* getInternalObject() const{
		return parameter.getInternalObject();
	}

	ofParameter<ParameterType> parameter;

	template<typename T>
	friend class ofParameter;
	friend class ofParameterGroup;
	friend Friend;
	template<typename T, typename OtherFriend>
	friend class ofReadOnlyParameter;
};


template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend>::ofReadOnlyParameter(){}

//template<typename ParameterType,typename Friend>
//inline ofReadOnlyParameter<ParameterType,Friend>::ofReadOnlyParameter(ofParameter<ParameterType> & p)
//:parameter(p){}

//template<typename ParameterType,typename Friend>
//inline ofReadOnlyParameter<ParameterType,Friend>::ofReadOnlyParameter(ofReadOnlyParameter<ParameterType,Friend> & p)
//:parameter(p){}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend>::ofReadOnlyParameter(const ParameterType & v)
:parameter(v){}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend>::ofReadOnlyParameter(const std::string& name, const ParameterType & v)
:parameter(name,v){}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend>::ofReadOnlyParameter(const std::string& name, const ParameterType & v, const ParameterType & min, const ParameterType & max)
:parameter(name,v,min,max){}


template<typename ParameterType,typename Friend>
inline const ParameterType & ofReadOnlyParameter<ParameterType,Friend>::get() const{
	return parameter.get();
}

template<typename ParameterType,typename Friend>
inline const ParameterType * ofReadOnlyParameter<ParameterType,Friend>::operator->() const{
	return &parameter.get();
}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend>::operator const ParameterType & () const{
	return parameter.get();
}


template<typename ParameterType,typename Friend>
inline std::string ofReadOnlyParameter<ParameterType,Friend>::getName() const{
	return parameter.getName();
}


template<typename ParameterType,typename Friend>
inline ParameterType ofReadOnlyParameter<ParameterType,Friend>::getMin() const{
	return parameter.getMin();
}


template<typename ParameterType,typename Friend>
inline ParameterType ofReadOnlyParameter<ParameterType,Friend>::getMax() const{
	return parameter.getMax();
}


template<typename ParameterType,typename Friend>
inline std::string ofReadOnlyParameter<ParameterType,Friend>::toString() const{
	return parameter.toString();
}

template<typename ParameterType,typename Friend>
std::string ofReadOnlyParameter<ParameterType,Friend>::valueType() const{
	return typeid(ParameterType).name();
}


template<typename ParameterType,typename Friend>
template<class ListenerClass, typename ListenerMethod>
inline void ofReadOnlyParameter<ParameterType,Friend>::addListener(ListenerClass * listener, ListenerMethod method, int prio){
	parameter.addListener(listener,method,prio);
}


template<typename ParameterType,typename Friend>
template<class ListenerClass, typename ListenerMethod>
inline void ofReadOnlyParameter<ParameterType,Friend>::removeListener(ListenerClass * listener, ListenerMethod method, int prio){
	parameter.removeListener(listener,method,prio);
}


template<typename ParameterType,typename Friend>
template<typename... Args>
inline std::unique_ptr<of::priv::AbstractEventToken> ofReadOnlyParameter<ParameterType,Friend>::newListener(Args...args) {
	return parameter.newListener(args...);
}

template<typename ParameterType,typename Friend>
inline void ofReadOnlyParameter<ParameterType,Friend>::setName(const std::string & name){
	parameter.setName(name);
}

template<typename ParameterType,typename Friend>
inline void ofReadOnlyParameter<ParameterType,Friend>::enableEvents(){
	parameter.enableEvents();
}

template<typename ParameterType,typename Friend>
inline void ofReadOnlyParameter<ParameterType,Friend>::disableEvents(){
	parameter.disableEvents();
}

template<typename ParameterType,typename Friend>
inline bool ofReadOnlyParameter<ParameterType,Friend>::isSerializable() const{
	return parameter.isSerializable();
}

template<typename ParameterType,typename Friend>
inline bool ofReadOnlyParameter<ParameterType,Friend>::isReadOnly() const{
	return true;
}

template<typename ParameterType,typename Friend>
inline void ofReadOnlyParameter<ParameterType,Friend>::setSerializable(bool s){
	parameter.setSerializable(s);
}

template<typename ParameterType,typename Friend>
template<typename OtherFriend>
inline void ofReadOnlyParameter<ParameterType,Friend>::makeReferenceTo(ofReadOnlyParameter<ParameterType,OtherFriend> mom){
	parameter.makeReferenceTo(mom.parameter);
}

template<typename ParameterType,typename Friend>
void ofReadOnlyParameter<ParameterType,Friend>::makeReferenceTo(ofParameter<ParameterType> mom){
	parameter.makeReferenceTo(mom);
}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator=(const ofReadOnlyParameter<ParameterType,Friend> & v){
	parameter = v.parameter;
	return *this;
}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator=(const ofParameter<ParameterType>& v){
	parameter = v;
	return *this;
}

template<typename ParameterType,typename Friend>
inline const ParameterType & ofReadOnlyParameter<ParameterType,Friend>::operator=(const ParameterType & v){
	parameter = v;
	return v;
}


template<typename ParameterType,typename Friend>
inline ParameterType ofReadOnlyParameter<ParameterType,Friend>::operator++(int){
	return parameter++;
}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator++(){
	return ++parameter;
}


template<typename ParameterType,typename Friend>
inline ParameterType ofReadOnlyParameter<ParameterType,Friend>::operator--(int){
	return parameter--;
}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator--(){
	return --parameter;
}


template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator+=(const OtherType & v){
	parameter+=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator-=(const OtherType & v){
	parameter-=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator*=(const OtherType & v){
	parameter*=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator/=(const OtherType & v){
	parameter/=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator%=(const OtherType & v){
	parameter%=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator&=(const OtherType & v){
	parameter&=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator|=(const OtherType & v){
	parameter|=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator^=(const OtherType & v){
	parameter^=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator<<=(const OtherType & v){
	parameter<<=v;
	return *this;
}

template<typename ParameterType,typename Friend>
template<typename OtherType>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::operator>>=(const OtherType & v){
	parameter>>=v;
	return *this;
}



template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::set(const ParameterType & v){
	parameter.set(v);
	return *this;
}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::set(const std::string& name, const ParameterType & value){
	parameter.set(name,value);
	return *this;
}

template<typename ParameterType,typename Friend>
inline ofReadOnlyParameter<ParameterType,Friend> & ofReadOnlyParameter<ParameterType,Friend>::set(const std::string& name, const ParameterType & value, const ParameterType & min, const ParameterType & max){
	parameter.set(name,value,min,max);
	return *this;
}


template<typename ParameterType,typename Friend>
inline void ofReadOnlyParameter<ParameterType,Friend>::setMin(const ParameterType & min){
	parameter.setMin(min);
}

template<typename ParameterType,typename Friend>
inline void ofReadOnlyParameter<ParameterType,Friend>::setMax(const ParameterType & max){
	parameter.setMax(max);
}


template<typename ParameterType,typename Friend>
inline void ofReadOnlyParameter<ParameterType,Friend>::fromString(const std::string & str){
	parameter.fromString(str);
}

template<typename ParameterType,typename Friend>
std::shared_ptr<ofAbstractParameter> ofReadOnlyParameter<ParameterType,Friend>::newReference() const{
	return std::make_shared<ofReadOnlyParameter<ParameterType,Friend>>(*this);
}

template<typename ParameterType,typename Friend>
void ofReadOnlyParameter<ParameterType,Friend>::setParent(ofParameterGroup & _parent){
	parameter.setParent(_parent);
}

#line 0 "../libs/openFrameworks/types/ofParameterGroup.h"
/*
 * ofxParameterGroup.h
 *
 *  Created on: 10/07/2012
 *      Author: arturo
 */

#ifndef OFXPARAMETERGROUP_H_
#define OFXPARAMETERGROUP_H_

/* #include "ofParameter.h" */

#endif /* OFXPARAMETERGROUP_H_ */

#line 0 "../libs/openFrameworks/utils/ofJson.h"
#pragma once

/* #include "json.hpp" */
/* #include "ofParameter.h" */

// for convenience
using ofJson = nlohmann::json;


/// \brief Load Json from the given path.
/// \param filename The file to load from.
/// \returns loaded json, or an empty json object on failure.
inline ofJson ofLoadJson(const std::filesystem::path& filename){
	ofJson json;
	ofFile jsonFile(filename);
	if(jsonFile.exists()){
		try{
			jsonFile >> json;
		}catch(std::exception & e){
			ofLogError("ofLoadJson") << "Error loading json from " << filename.string() << ": " << e.what();
		}catch(...){
			ofLogError("ofLoadJson") << "Error loading json from " << filename.string();
		}
	}else{
		ofLogError("ofLoadJson") << "Error loading json from " << filename.string() << ": file doesn't exist";
	}
	return json;
}

/// \brief Save minified Json to the given path.
/// \param filename The destination path.
/// \param json The Json to save.
/// \returns true if the json was saved successfully.
inline bool ofSaveJson(const std::filesystem::path& filename, const ofJson & json){
	ofFile jsonFile(filename, ofFile::WriteOnly);
	try{
		jsonFile << json;
	}catch(std::exception & e){
		ofLogError("ofLoadJson") << "Error saving json to " << filename.string() << ": " << e.what();
		return false;
	}catch(...){
		ofLogError("ofLoadJson") << "Error saving json to " << filename.string();
		return false;
	}
	return true;
}

/// \brief Save "pretty" indented Json to the given path.
/// \param filename The destination path.
/// \param json The Json to save.
/// \returns true if the json was saved successfully.
inline bool ofSavePrettyJson(const std::filesystem::path& filename, const ofJson & json){
    ofFile jsonFile(filename, ofFile::WriteOnly);
    try{
        jsonFile << json.dump(4);
    }catch(std::exception & e){
        ofLogError("ofLoadJson") << "Error saving json to " << filename.string() << ": " << e.what();
        return false;
    }catch(...){
        ofLogError("ofLoadJson") << "Error saving json to " << filename.string();
        return false;
    }
    return true;
}

inline void ofSerialize(ofJson & js, const ofAbstractParameter & parameter){
	if(!parameter.isSerializable()){
		return;
	}
	std::string name = parameter.getEscapedName();
	if(name == ""){
		name = "UnknownName";
	}
	if(parameter.type() == typeid(ofParameterGroup).name()){
		const ofParameterGroup & group = static_cast <const ofParameterGroup &>(parameter);
		auto jsonGroup = js[name];
		for(auto & p: group){
			ofSerialize(jsonGroup, *p);
		}
		js[name] = jsonGroup;
	}else{
		std::string value = parameter.toString();
		js[name] = value;
	}
}

inline void ofDeserialize(const ofJson & json, ofAbstractParameter & parameter){
	if(!parameter.isSerializable()){
		return;
	}
	std::string name = parameter.getEscapedName();
	if(json.find(name) != json.end()){
		if(parameter.type() == typeid(ofParameterGroup).name()){
			ofParameterGroup & group = static_cast <ofParameterGroup &>(parameter);
			for(auto & p: group){
				ofDeserialize(json[name], *p);
			}
		}else{
			if(parameter.type() == typeid(ofParameter <int> ).name() && json[name].is_number_integer()){
				parameter.cast <int>() = json[name].get<int>();
			}else if(parameter.type() == typeid(ofParameter <float> ).name() && json[name].is_number_float()){
				parameter.cast <float>() = json[name].get<float>();
			}else if(parameter.type() == typeid(ofParameter <bool> ).name() && json[name].is_boolean()){
				parameter.cast <bool>() = json[name].get<bool>();
			}else if(parameter.type() == typeid(ofParameter <int64_t> ).name() && json[name].is_number_integer()){
				parameter.cast <int64_t>() = json[name].get<int64_t>();
			}else if(parameter.type() == typeid(ofParameter <std::string> ).name()){
				parameter.cast <std::string>() = json[name].get<std::string>();
			}else{
				parameter.fromString(json[name]);
			}
		}
	}
}

#line 0 "../libs/openFrameworks/utils/ofXml.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "pugixml.hpp" */
/* #include "ofParameter.h" */

template<typename It>
class ofXmlIterator;
class ofXmlAttributeIterator;
class ofXmlSearchIterator;

class ofXml{
public:
	class Search{
	public:
		Search(){}

		// Get collection type
		pugi::xpath_node_set::type_t type() const;

		// Get collection size
		size_t size() const;

		// Indexing operator
		ofXml operator[](size_t index) const;

		// Collection iterators
		ofXmlSearchIterator begin() const;
		ofXmlSearchIterator end() const;

		// Sort the collection in ascending/descending order by document order
		void sort(bool reverse = false);

		// Get first node in the collection by document order
		ofXml getFirst() const;

		// Check if collection is empty
		bool empty() const;
	private:
		Search(std::shared_ptr<pugi::xml_document> doc, pugi::xpath_node_set set);
		std::shared_ptr<pugi::xml_document> doc;
		pugi::xpath_node_set search;
		friend class ofXml;
	};

	class Attribute{
	public:
		Attribute(){}
		std::string getValue() const;

		void setName(const std::string & name);
		std::string getName() const;

		int getIntValue() const;
		unsigned int getUintValue() const;
		float getFloatValue() const;
		double getDoubleValue() const;
		bool getBoolValue() const;
		operator bool() const;

		Attribute getNextAttribute() const;
		Attribute getPreviousAttribute() const;

		template<typename T>
		ofXml::Attribute & operator=(const T & value){
			this->attr = ofToString(value);
			return *this;
		}

		template<typename T>
		Attribute & set(const T & value){
			this->attr.set_value(ofToString(value).c_str());
			return *this;
		}
	private:
		Attribute(const pugi::xml_attribute & attr);
		pugi::xml_attribute attr;
		friend class ofXml;
	};

	template<class It>
	class Range{
	public:
		It begin() const {
			if(range.begin() != range.end()){
				return It(doc, *range.begin());
			}else{
				return It(doc, typename It::Node());
			}
		}
		It end() const { return It(doc, typename It::Node()); }

	private:
		Range(std::shared_ptr<pugi::xml_document> doc, pugi::xml_object_range<typename It::Base> range)
			:doc(doc), range(range){}
		std::shared_ptr<pugi::xml_document> doc;
		pugi::xml_object_range<typename It::Base> range;
		friend class ofXml;
	};

	ofXml();

	bool load(const std::filesystem::path & file);
	bool load(const ofBuffer & buffer);
	bool parse(const std::string & xmlStr);
	bool save(const std::filesystem::path & file) const;
	std::string toString(const std::string & indent = "\t") const;

	ofXml getChild(const std::string & name) const;
	Range<ofXmlIterator<pugi::xml_node_iterator>> getChildren() const;
	Range<ofXmlIterator<pugi::xml_named_node_iterator>> getChildren(const std::string & name) const;

	ofXml appendChild(const ofXml & xml);
	ofXml prependChild(const ofXml & xml);
	bool removeChild(const ofXml & node);

#if PUGIXML_VERSION>=170
	ofXml appendChild(ofXml && xml);
	ofXml prependChild(ofXml && xml);
	bool removeChild(ofXml && node);
#endif

	ofXml appendChild(const std::string & name);
	ofXml prependChild(const std::string & name);
	bool removeChild(const std::string & name);

	ofXml insertChildAfter(const std::string & name, const ofXml & after);
	ofXml insertChildBefore(const std::string & name, const ofXml & after);

	ofXml getNextSibling() const;
	ofXml getPreviousSibling() const;
	ofXml getNextSibling(const std::string & name) const;
	ofXml getPreviousSibling(const std::string & name) const;

	ofXml getFirstChild() const;
	ofXml getLastChild() const;


	Attribute getAttribute(const std::string & name) const;
	Range<ofXmlAttributeIterator> getAttributes() const;
	Attribute getFirstAttribute() const;
	Attribute getLastAttribute() const;
	Attribute appendAttribute(const std::string & name);
	Attribute prependAttribute(const std::string & name);
	bool removeAttribute(const std::string & name);
	bool removeAttribute(const Attribute & attr);
	bool removeAttribute(Attribute && attr);

	template<typename T>
	Attribute setAttribute(const std::string & name, const T & value){
		auto attr = getAttribute(name);
		if(!attr){
			attr = appendAttribute(name);
		}
		attr.set(value);
		return attr;
	}

	ofXml findFirst(const std::string & path) const;
	Search find(const std::string & path) const;

	template<typename T>
	T getValue() const{
		return ofFromString<T>(this->xml.text().as_string());
	}

	std::string getValue() const;
	std::string getName() const;

	template<typename T>
	void set(const T & value){
		if(!xml){
			xml = doc->append_child(pugi::node_element);
		}
		auto child = this->xml.first_child();
		if(!child){
			child = this->xml.append_child(pugi::node_pcdata);
		}
		if(child.type() == pugi::node_pcdata || child.type() == pugi::node_cdata){
			child.set_value(ofToString(value).c_str());
		}
	}

	void set(const unsigned char & value){
		if(!xml){
			xml = doc->append_child(pugi::node_element);
		}
		auto child = this->xml.first_child();
		if(!child){
			child = this->xml.append_child(pugi::node_pcdata);
		}
		if(child.type() == pugi::node_pcdata || child.type() == pugi::node_cdata){
			child.set_value(ofToString(int(value)).c_str());
		}
	}


	void setName(const std::string & name);

	int getIntValue() const;
	unsigned int getUintValue() const;
	float getFloatValue() const;
	double getDoubleValue() const;
	bool getBoolValue() const;

	operator bool() const;

private:
	ofXml(std::shared_ptr<pugi::xml_document> doc, const pugi::xml_node & xml);
	std::shared_ptr<pugi::xml_document> doc;
	pugi::xml_node xml;

	template<typename It>
	friend class ofXmlIterator;
	friend class ofXmlAttributeIterator;
	friend class ofXmlSearchIterator;
};

template<typename It>
class ofXmlIterator{
public:
	ofXmlIterator(){}

	// Iterator operators
	bool operator==(const ofXmlIterator& rhs) const{
		return this->xml.xml == rhs.xml.xml;
	}

	bool operator!=(const ofXmlIterator& rhs) const{
		return this->xml.xml != rhs.xml.xml;
	}

	const ofXml& operator*() const{
		return this->xml;
	}

	const ofXml* operator->() const{
		return &this->xml;
	}

	ofXml& operator*(){
		return this->xml;
	}

	ofXml* operator->(){
		return &this->xml;
	}

	const ofXmlIterator& operator++(){
		this->xml = xml.getNextSibling();
		return *this;
	}

	ofXmlIterator operator++(int){
		auto now = xml;
		this->xml = xml.getNextSibling();
		return now;
	}

	const ofXmlIterator& operator--(){
		this->xml = xml.getPreviousSibling();
		return *this;
	}

	ofXmlIterator operator--(int){
		auto now = xml;
		this->xml = xml.getPreviousSibling();
		return now;
	}
	typedef It Base;
	typedef pugi::xml_node Node;
private:

	// Construct an iterator which points to the specified node
	ofXmlIterator(std::shared_ptr<pugi::xml_document> doc, const pugi::xml_node & xml)
	:xml(doc, xml){

	}

	// Construct an iterator which points to the specified node
	ofXmlIterator(ofXml && xml)
	:xml(xml){

	}
	mutable ofXml xml;
	friend class ofXml;
};

class ofXmlAttributeIterator{
public:
	ofXmlAttributeIterator(){}

	// Iterator operators
	bool operator==(const ofXmlAttributeIterator& rhs) const{
		return this->attr == rhs.attr;
	}

	bool operator!=(const ofXmlAttributeIterator& rhs) const{
		return this->attr != rhs.attr;
	}

	const ofXml::Attribute & operator*() const{
		return this->attr;
	}

	const ofXml::Attribute* operator->() const{
		return &this->attr;
	}

	ofXml::Attribute & operator*(){
		return this->attr;
	}

	ofXml::Attribute* operator->(){
		return &this->attr;
	}

	const ofXmlAttributeIterator& operator++(){
		this->attr = attr.getNextAttribute();
		return *this;
	}

	ofXmlAttributeIterator operator++(int){
		auto now = attr;
		this->attr = attr.getNextAttribute();
		return now;
	}

	const ofXmlAttributeIterator& operator--(){
		this->attr = attr.getPreviousAttribute();
		return *this;
	}

	ofXmlAttributeIterator operator--(int){
		auto now = attr;
		this->attr = attr.getPreviousAttribute();
		return now;
	}

	typedef pugi::xml_attribute_iterator Base;
	typedef pugi::xml_attribute Node;
private:

	// Construct an iterator which points to the specified node
	ofXmlAttributeIterator(std::shared_ptr<pugi::xml_document>, const ofXml::Attribute & attr)
	:attr(attr){

	}

	ofXmlAttributeIterator(const ofXml::Attribute & attr)
	:attr(attr){

	}
	ofXml::Attribute attr;
	friend class ofXml;
};


class ofXmlSearchIterator{
public:
	ofXmlSearchIterator();

	// Iterator operators
	bool operator==(const ofXmlSearchIterator& rhs) const;
	bool operator!=(const ofXmlSearchIterator& rhs) const;

	ofXml & operator*() const;
	ofXml * operator->() const;

	const ofXmlSearchIterator& operator++();
	ofXmlSearchIterator operator++(int);

	const ofXmlSearchIterator& operator--();
	ofXmlSearchIterator operator--(int);

private:
	ofXmlSearchIterator(std::shared_ptr<pugi::xml_document> doc, const pugi::xpath_node * node)
		:node(node)
	{
		if(node){
			xml = ofXml(doc, node->node());
		}
	}
	const pugi::xpath_node * node = nullptr;
	mutable ofXml xml;
	friend ofXml::Search;
};
// serializer
void ofSerialize(ofXml & xml, const ofAbstractParameter & parameter);
void ofDeserialize(const ofXml & xml, ofAbstractParameter & parameter);

#line 0 "../libs/openFrameworks/utils/ofMatrixStack.h"
/*
 * ofMatrixStack.h
 *
 *  Created on: Apr 3, 2013
 *      Author: arturo
 */

#ifndef OFMATRIXSTACK_H_
#define OFMATRIXSTACK_H_

#include <stack>
/* #include "ofConstants.h" */
/* #include "ofRectangle.h" */
#include "glm/mat4x4.hpp"
/* #include "ofGraphicsConstants.h" */

class ofBaseDraws;
class ofAppBaseWindow;
class ofFbo;
enum ofOrientation: short;

class ofMatrixStack {
public:
	ofMatrixStack(const ofAppBaseWindow * window);

	void setRenderSurface(const ofBaseDraws & fbo);
	void setRenderSurfaceNoMatrixFlip(const ofBaseDraws & fbo);
	void setRenderSurface(const ofAppBaseWindow & window);

	void setOrientation(ofOrientation orientation, bool vFlip);
	ofOrientation getOrientation() const;

	void viewport(float x, float y, float width, float height, bool vflip);
	void nativeViewport(ofRectangle viewport);
	ofRectangle getCurrentViewport() const;
	ofRectangle getNativeViewport() const;
	ofRectangle getFullSurfaceViewport() const;
	float getViewportPixelCoordScale() const;

	const glm::mat4 & getProjectionMatrix() const;
	const glm::mat4 & getViewInverse() const;
	const glm::mat4 & getViewMatrix() const;
	const glm::mat4 & getModelMatrix() const;
	const glm::mat4 & getModelViewMatrix() const;
	const glm::mat4 & getModelViewProjectionMatrix() const;
	const glm::mat4 & getTextureMatrix() const;
	const glm::mat4 & getCurrentMatrix() const;
	const glm::mat4 & getProjectionMatrixNoOrientation() const;
	const glm::mat4 & getOrientationMatrix() const;
	const glm::mat4 & getOrientationMatrixInverse() const;

	ofMatrixMode getCurrentMatrixMode() const;

	ofHandednessType getHandedness() const;

	bool isVFlipped() const;
	bool customMatrixNeedsFlip() const;

	void pushView();
    void popView();

	void pushMatrix();
	void popMatrix();
	void translate(float x, float y, float z = 0);
	void scale(float xAmnt, float yAmnt, float zAmnt = 1);
	void rotateRad(float radians, float vecX, float vecY, float vecZ);
	void matrixMode(ofMatrixMode mode);
	void loadIdentityMatrix (void);
	
	void loadMatrix (const glm::mat4 & m);
	void multMatrix (const glm::mat4 & m);

	void loadViewMatrix(const glm::mat4 & matrix);
	void multViewMatrix(const glm::mat4 & matrix);

	void clearStacks();
	bool doesHardwareOrientation() const;

private:
	bool vFlipped;
    ofOrientation orientation;
	ofRectangle currentViewport;
	ofHandednessType handedness;
	ofBaseDraws * currentRenderSurface;
	ofAppBaseWindow * currentWindow;

    ofMatrixMode currentMatrixMode;

	glm::mat4 modelMatrix;
	glm::mat4 viewMatrix;
	glm::mat4 viewInverse;
	glm::mat4 modelViewMatrix;
	glm::mat4 projectionMatrix;
	glm::mat4 textureMatrix;
	glm::mat4 modelViewProjectionMatrix;
	glm::mat4 orientedProjectionMatrix;
	glm::mat4 orientationMatrix;
	glm::mat4 orientationMatrixInverse;

	glm::mat4 * currentMatrix;

	std::stack <ofRectangle> viewportHistory;
	std::stack <glm::mat4> viewMatrixStack;
	std::stack <glm::mat4> modelViewMatrixStack;
	std::stack <glm::mat4> projectionMatrixStack;
	std::stack <glm::mat4> textureMatrixStack;
	std::stack <std::pair<ofOrientation,bool> > orientationStack;
	bool flipRenderSurfaceMatrix;

	int getRenderSurfaceWidth() const;
	int getRenderSurfaceHeight() const;
	bool doesHWOrientation() const;
	inline void updatedRelatedMatrices();

};

#endif /* OFMATRIXSTACK_H_ */

#line 0 "../libs/openFrameworks/utils/ofNoise.h"
#pragma once


/*
 * Mesa 3-D graphics library
 * Version:  6.5
 *
 * Copyright (C) 2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * SimplexNoise1234
 * Copyright (c) 2003-2005, Stefan Gustavson
 *
 * Contact: stegu@itn.liu.se
 */

/** \file
    \brief C implementation of Perlin Simplex Noise over 1,2,3, and 4 dimensions.
    \author Stefan Gustavson (stegu@itn.liu.se)
*/

/*
 * This implementation is "Simplex Noise" as presented by
 * Ken Perlin at a relatively obscure and not often cited course
 * session "Real-Time Shading" at Siggraph 2001 (before real
 * time shading actually took on), under the title "hardware noise".
 * The 3D function is numerically equivalent to his Java reference
 * code available in the PDF course notes, although I re-implemented
 * it from scratch to get more readable code. The 1D, 2D and 4D cases
 * were implemented from scratch by me from Ken Perlin's text.
 *
 * This file has no dependencies on any other file, not even its own
 * header file. The header file is made for use by external code only.
 */

#define OFNOISE_FASTFLOOR(x) ( ((x)>0) ? ((int)x) : (((int)x)-1) )

/*
 * ---------------------------------------------------------------------
 * inline data
 */

/*
 * Permutation table. This is just a random jumble of all numbers 0-255,
 * repeated twice to avoid wrapping the index at 255 for each lookup.
 * This needs to be exactly the same for all instances on all platforms,
 * so it's easiest to just keep it as inline explicit data.
 * This also removes the need for any initialisation of this class.
 *
 * Note that making this an int[] instead of a char[] might make the
 * code run faster on platforms with a high penalty for unaligned single
 * byte addressing. Intel x86 is generally single-byte-friendly, but
 * some other CPUs are faster with 4-aligned reads.
 * However, a char[] is smaller, which avoids cache trashing, and that
 * is probably the most important aspect on most architectures.
 * This array is accessed a *lot* by the noise functions.
 * A vector-valued noise over 3D accesses it 96 times, and a
 * float-valued 4D noise 64 times. We want this to fit in the cache!
 */
namespace{
unsigned char perm[512] = {151,160,137,91,90,15,
  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,
  151,160,137,91,90,15,
  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 
};
}

/*
 * ---------------------------------------------------------------------
 */

/*
 * Helper functions to compute gradients-dot-residualvectors (1D to 4D)
 * Note that these generate gradients of more than unit length. To make
 * a close match with the value range of classic Perlin noise, the final
 * noise values need to be rescaled to fit nicely within [-1,1].
 * (The simplex noise functions as such also have different scaling.)
 * Note also that these noise functions are the most practical and useful
 * signed version of Perlin noise. To return values according to the
 * RenderMan specification from the SL noise() and pnoise() functions,
 * the noise values need to be scaled and offset to [0,1], like this:
 * float SLnoise = (SimplexNoise1234::noise(x,y,z) + 1.0) * 0.5;
 */

inline float  grad1( int hash, float x ) {
    int h = hash & 15;
	float grad = 1.0f + (h & 7);   /* Gradient value 1.0, 2.0, ..., 8.0 */
    if (h&8) grad = -grad;         /* Set a random sign for the gradient */
    return ( grad * x );           /* Multiply the gradient with the distance */
}

inline float  grad2( int hash, float x, float y ) {
    int h = hash & 7;      /* Convert low 3 bits of hash code */
	float u = h<4 ? x : y;  /* into 8 simple gradient directions, */
	float v = h<4 ? y : x;  /* and compute the dot product with (x,y). */
    return ((h&1)? -u : u) + ((h&2)? -2.0f*v : 2.0f*v);
}

inline float  grad3( int hash, float x, float y , float z ) {
    int h = hash & 15;     /* Convert low 4 bits of hash code into 12 simple */
	float u = h<8 ? x : y; /* gradient directions, and compute dot product. */
	float v = h<4 ? y : h==12||h==14 ? x : z; /* Fix repeats at h = 12 to 15 */
    return ((h&1)? -u : u) + ((h&2)? -v : v);
}

inline float  grad4( int hash, float x, float y, float z, float t ) {
    int h = hash & 31;      /* Convert low 5 bits of hash code into 32 simple */
	float u = h<24 ? x : y; /* gradient directions, and compute dot product. */
	float v = h<16 ? y : z;
	float w = h<8 ? z : t;
    return ((h&1)? -u : u) + ((h&2)? -v : v) + ((h&4)? -w : w);
}

  /* A lookup table to traverse the simplex around a given point in 4D. */
  /* Details can be found where this table is used, in the 4D noise method. */
  /* TODO: This should not be required, backport it from Bill's GLSL code! */
namespace{
  unsigned char simplex[64][4] = {
    {0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},
    {0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},
    {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
    {1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},
    {1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},
    {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
    {2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},
    {2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}};
}
/* 1D simplex noise */
inline float _slang_library_noise1 (float x)
{
  int i0 = OFNOISE_FASTFLOOR(x);
  int i1 = i0 + 1;
  float x0 = x - i0;
  float x1 = x0 - 1.0f;
  float t1 = 1.0f - x1*x1;
  float n0, n1;

  float t0 = 1.0f - x0*x0;
/*  if(t0 < 0.0f) t0 = 0.0f; // this never happens for the 1D case */
  t0 *= t0;
  n0 = t0 * t0 * grad1(perm[i0 & 0xff], x0);

/*  if(t1 < 0.0f) t1 = 0.0f; // this never happens for the 1D case */
  t1 *= t1;
  n1 = t1 * t1 * grad1(perm[i1 & 0xff], x1);
  /* The maximum value of this noise is 8*(3/4)^4 = 2.53125 */
  /* A factor of 0.395 would scale to fit exactly within [-1,1], but */
  /* we want to match PRMan's 1D noise, so we scale it down some more. */
  return 0.25f * (n0 + n1);
}

/* 2D simplex noise */
inline float _slang_library_noise2 (float x, float y)
{
	constexpr float F2 = 0.366025403f; /* F2 = 0.5*(sqrt(3.0)-1.0) */
	constexpr float G2 = 0.211324865f; /* G2 = (3.0-Math.sqrt(3.0))/6.0 */

	float n0, n1, n2; /* Noise contributions from the three corners */

    /* Skew the input space to determine which simplex cell we're in */
	float s = (x+y)*F2; /* Hairy factor for 2D */
	float xs = x + s;
	float ys = y + s;
	int i = OFNOISE_FASTFLOOR(xs);
	int j = OFNOISE_FASTFLOOR(ys);

	float t = (float)(i+j)*G2;
	float X0 = i-t; /* Unskew the cell origin back to (x,y) space */
	float Y0 = j-t;
	float x0 = x-X0; /* The x,y distances from the cell origin */
	float y0 = y-Y0;

	float x1, y1, x2, y2;
    int ii, jj;
	float t0, t1, t2;

    /* For the 2D case, the simplex shape is an equilateral triangle. */
    /* Determine which simplex we are in. */
    int i1, j1; /* Offsets for second (middle) corner of simplex in (i,j) coords */
    if(x0>y0) {i1=1; j1=0;} /* lower triangle, XY order: (0,0)->(1,0)->(1,1) */
    else {i1=0; j1=1;}      /* upper triangle, YX order: (0,0)->(0,1)->(1,1) */

    /* A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and */
    /* a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where */
    /* c = (3-sqrt(3))/6 */

    x1 = x0 - i1 + G2; /* Offsets for middle corner in (x,y) unskewed coords */
    y1 = y0 - j1 + G2;
    x2 = x0 - 1.0f + 2.0f * G2; /* Offsets for last corner in (x,y) unskewed coords */
    y2 = y0 - 1.0f + 2.0f * G2;

    /* Wrap the integer indices at 256, to avoid indexing perm[] out of bounds */
    ii = i % 256;
    jj = j % 256;

    /* Calculate the contribution from the three corners */
    t0 = 0.5f - x0*x0-y0*y0;
    if(t0 < 0.0f) n0 = 0.0f;
    else {
      t0 *= t0;
      n0 = t0 * t0 * grad2(perm[ii+perm[jj]], x0, y0); 
    }

    t1 = 0.5f - x1*x1-y1*y1;
    if(t1 < 0.0f) n1 = 0.0f;
    else {
      t1 *= t1;
      n1 = t1 * t1 * grad2(perm[ii+i1+perm[jj+j1]], x1, y1);
    }

    t2 = 0.5f - x2*x2-y2*y2;
    if(t2 < 0.0f) n2 = 0.0f;
    else {
      t2 *= t2;
      n2 = t2 * t2 * grad2(perm[ii+1+perm[jj+1]], x2, y2);
    }

    /* Add contributions from each corner to get the final noise value. */
    /* The result is scaled to return values in the interval [-1,1]. */
    return 40.0f * (n0 + n1 + n2); /* TODO: The scale factor is preliminary! */
}

/* 3D simplex noise */
inline float _slang_library_noise3 (float x, float y, float z)
{
	/* Simple skewing factors for the 3D case */
	constexpr float F3 = 0.333333333f;
	constexpr float G3 = 0.166666667f;

	float n0, n1, n2, n3; /* Noise contributions from the four corners */

    /* Skew the input space to determine which simplex cell we're in */
	float s = (x+y+z)*F3; /* Very nice and simple skew factor for 3D */
	float xs = x+s;
	float ys = y+s;
	float zs = z+s;
	int i = OFNOISE_FASTFLOOR(xs);
	int j = OFNOISE_FASTFLOOR(ys);
	int k = OFNOISE_FASTFLOOR(zs);

	float t = (float)(i+j+k)*G3;
	float X0 = i-t; /* Unskew the cell origin back to (x,y,z) space */
	float Y0 = j-t;
	float Z0 = k-t;
	float x0 = x-X0; /* The x,y,z distances from the cell origin */
	float y0 = y-Y0;
	float z0 = z-Z0;

	float x1, y1, z1, x2, y2, z2, x3, y3, z3;
    int ii, jj, kk;
	float t0, t1, t2, t3;

    /* For the 3D case, the simplex shape is a slightly irregular tetrahedron. */
    /* Determine which simplex we are in. */
    int i1, j1, k1; /* Offsets for second corner of simplex in (i,j,k) coords */
    int i2, j2, k2; /* Offsets for third corner of simplex in (i,j,k) coords */

/* This code would benefit from a backport from the GLSL version! */
    if(x0>=y0) {
      if(y0>=z0)
        { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } /* X Y Z order */
        else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } /* X Z Y order */
        else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } /* Z X Y order */
      }
    else { /* x0<y0 */
      if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } /* Z Y X order */
      else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } /* Y Z X order */
      else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } /* Y X Z order */
    }

    /* A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), */
    /* a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and */
    /* a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where */
    /* c = 1/6. */

    x1 = x0 - i1 + G3; /* Offsets for second corner in (x,y,z) coords */
    y1 = y0 - j1 + G3;
    z1 = z0 - k1 + G3;
    x2 = x0 - i2 + 2.0f*G3; /* Offsets for third corner in (x,y,z) coords */
    y2 = y0 - j2 + 2.0f*G3;
    z2 = z0 - k2 + 2.0f*G3;
    x3 = x0 - 1.0f + 3.0f*G3; /* Offsets for last corner in (x,y,z) coords */
    y3 = y0 - 1.0f + 3.0f*G3;
    z3 = z0 - 1.0f + 3.0f*G3;

    /* Wrap the integer indices at 256, to avoid indexing perm[] out of bounds */
    ii = i % 256;
    jj = j % 256;
    kk = k % 256;

    /* Calculate the contribution from the four corners */
    t0 = 0.6f - x0*x0 - y0*y0 - z0*z0;
    if(t0 < 0.0f) n0 = 0.0f;
    else {
      t0 *= t0;
      n0 = t0 * t0 * grad3(perm[ii+perm[jj+perm[kk]]], x0, y0, z0);
    }

    t1 = 0.6f - x1*x1 - y1*y1 - z1*z1;
    if(t1 < 0.0f) n1 = 0.0f;
    else {
      t1 *= t1;
      n1 = t1 * t1 * grad3(perm[ii+i1+perm[jj+j1+perm[kk+k1]]], x1, y1, z1);
    }

    t2 = 0.6f - x2*x2 - y2*y2 - z2*z2;
    if(t2 < 0.0f) n2 = 0.0f;
    else {
      t2 *= t2;
      n2 = t2 * t2 * grad3(perm[ii+i2+perm[jj+j2+perm[kk+k2]]], x2, y2, z2);
    }

    t3 = 0.6f - x3*x3 - y3*y3 - z3*z3;
    if(t3<0.0f) n3 = 0.0f;
    else {
      t3 *= t3;
      n3 = t3 * t3 * grad3(perm[ii+1+perm[jj+1+perm[kk+1]]], x3, y3, z3);
    }

    /* Add contributions from each corner to get the final noise value. */
    /* The result is scaled to stay just inside [-1,1] */
    return 32.0f * (n0 + n1 + n2 + n3); /* TODO: The scale factor is preliminary! */
}

/* 4D simplex noise */
inline float _slang_library_noise4 (float x, float y, float z, float w)
{
	/* The skewing and unskewing factors are hairy again for the 4D case */
	constexpr float F4 = 0.309016994f; /* F4 = (Math.sqrt(5.0)-1.0)/4.0 */
	constexpr float G4 = 0.138196601f; /* G4 = (5.0-Math.sqrt(5.0))/20.0 */

	float n0, n1, n2, n3, n4; /* Noise contributions from the five corners */

    /* Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in */
	float s = (x + y + z + w) * F4; /* Factor for 4D skewing */
	float xs = x + s;
	float ys = y + s;
	float zs = z + s;
	float ws = w + s;
	int i = OFNOISE_FASTFLOOR(xs);
	int j = OFNOISE_FASTFLOOR(ys);
	int k = OFNOISE_FASTFLOOR(zs);
	int l = OFNOISE_FASTFLOOR(ws);

	float t = (i + j + k + l) * G4; /* Factor for 4D unskewing */
	float X0 = i - t; /* Unskew the cell origin back to (x,y,z,w) space */
	float Y0 = j - t;
	float Z0 = k - t;
	float W0 = l - t;

	float x0 = x - X0;  /* The x,y,z,w distances from the cell origin */
	float y0 = y - Y0;
	float z0 = z - Z0;
	float w0 = w - W0;

    /* For the 4D case, the simplex is a 4D shape I won't even try to describe. */
    /* To find out which of the 24 possible simplices we're in, we need to */
    /* determine the magnitude ordering of x0, y0, z0 and w0. */
    /* The method below is a good way of finding the ordering of x,y,z,w and */
    /* then find the correct traversal order for the simplex we're in. */
    /* First, six pair-wise comparisons are performed between each possible pair */
    /* of the four coordinates, and the results are used to add up binary bits */
    /* for an integer index. */
    int c1 = (x0 > y0) ? 32 : 0;
    int c2 = (x0 > z0) ? 16 : 0;
    int c3 = (y0 > z0) ? 8 : 0;
    int c4 = (x0 > w0) ? 4 : 0;
    int c5 = (y0 > w0) ? 2 : 0;
    int c6 = (z0 > w0) ? 1 : 0;
    int c = c1 + c2 + c3 + c4 + c5 + c6;

    int i1, j1, k1, l1; /* The integer offsets for the second simplex corner */
    int i2, j2, k2, l2; /* The integer offsets for the third simplex corner */
    int i3, j3, k3, l3; /* The integer offsets for the fourth simplex corner */

	float x1, y1, z1, w1, x2, y2, z2, w2, x3, y3, z3, w3, x4, y4, z4, w4;
    int ii, jj, kk, ll;
	float t0, t1, t2, t3, t4;

    /* simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order. */
    /* Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w */
    /* impossible. Only the 24 indices which have non-zero entries make any sense. */
    /* We use a thresholding to set the coordinates in turn from the largest magnitude. */
    /* The number 3 in the "simplex" array is at the position of the largest coordinate. */
    i1 = simplex[c][0]>=3 ? 1 : 0;
    j1 = simplex[c][1]>=3 ? 1 : 0;
    k1 = simplex[c][2]>=3 ? 1 : 0;
    l1 = simplex[c][3]>=3 ? 1 : 0;
    /* The number 2 in the "simplex" array is at the second largest coordinate. */
    i2 = simplex[c][0]>=2 ? 1 : 0;
    j2 = simplex[c][1]>=2 ? 1 : 0;
    k2 = simplex[c][2]>=2 ? 1 : 0;
    l2 = simplex[c][3]>=2 ? 1 : 0;
    /* The number 1 in the "simplex" array is at the second smallest coordinate. */
    i3 = simplex[c][0]>=1 ? 1 : 0;
    j3 = simplex[c][1]>=1 ? 1 : 0;
    k3 = simplex[c][2]>=1 ? 1 : 0;
    l3 = simplex[c][3]>=1 ? 1 : 0;
    /* The fifth corner has all coordinate offsets = 1, so no need to look that up. */

    x1 = x0 - i1 + G4; /* Offsets for second corner in (x,y,z,w) coords */
    y1 = y0 - j1 + G4;
    z1 = z0 - k1 + G4;
    w1 = w0 - l1 + G4;
    x2 = x0 - i2 + 2.0f*G4; /* Offsets for third corner in (x,y,z,w) coords */
    y2 = y0 - j2 + 2.0f*G4;
    z2 = z0 - k2 + 2.0f*G4;
    w2 = w0 - l2 + 2.0f*G4;
    x3 = x0 - i3 + 3.0f*G4; /* Offsets for fourth corner in (x,y,z,w) coords */
    y3 = y0 - j3 + 3.0f*G4;
    z3 = z0 - k3 + 3.0f*G4;
    w3 = w0 - l3 + 3.0f*G4;
    x4 = x0 - 1.0f + 4.0f*G4; /* Offsets for last corner in (x,y,z,w) coords */
    y4 = y0 - 1.0f + 4.0f*G4;
    z4 = z0 - 1.0f + 4.0f*G4;
    w4 = w0 - 1.0f + 4.0f*G4;

    /* Wrap the integer indices at 256, to avoid indexing perm[] out of bounds */
    ii = i % 256;
    jj = j % 256;
    kk = k % 256;
    ll = l % 256;

    /* Calculate the contribution from the five corners */
    t0 = 0.6f - x0*x0 - y0*y0 - z0*z0 - w0*w0;
    if(t0 < 0.0f) n0 = 0.0f;
    else {
      t0 *= t0;
      n0 = t0 * t0 * grad4(perm[ii+perm[jj+perm[kk+perm[ll]]]], x0, y0, z0, w0);
    }

   t1 = 0.6f - x1*x1 - y1*y1 - z1*z1 - w1*w1;
    if(t1 < 0.0f) n1 = 0.0f;
    else {
      t1 *= t1;
      n1 = t1 * t1 * grad4(perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]], x1, y1, z1, w1);
    }

   t2 = 0.6f - x2*x2 - y2*y2 - z2*z2 - w2*w2;
    if(t2 < 0.0f) n2 = 0.0f;
    else {
      t2 *= t2;
      n2 = t2 * t2 * grad4(perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]], x2, y2, z2, w2);
    }

   t3 = 0.6f - x3*x3 - y3*y3 - z3*z3 - w3*w3;
    if(t3 < 0.0f) n3 = 0.0f;
    else {
      t3 *= t3;
      n3 = t3 * t3 * grad4(perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]], x3, y3, z3, w3);
    }

   t4 = 0.6f - x4*x4 - y4*y4 - z4*z4 - w4*w4;
    if(t4 < 0.0f) n4 = 0.0f;
    else {
      t4 *= t4;
      n4 = t4 * t4 * grad4(perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]], x4, y4, z4, w4);
    }

    /* Sum up and scale the result to cover the range [-1,1] */
    return 27.0f * (n0 + n1 + n2 + n3 + n4); /* TODO: The scale factor is preliminary! */
}

#line 0 "../libs/openFrameworks/utils/ofSystemUtils.h"
#pragma once
/* #include "ofConstants.h" */

/// \class ofFileDialogResult
/// \brief file dialog box selection or save result
class ofFileDialogResult{
	public:
		ofFileDialogResult();
		
		/// \return the name of the selected file or directory, if set
		/// currently returns only 1 file, this may change in the future
		std::string getName();
	
		/// \return the full path of the selected file or directory, if set
		std::string getPath();
	
		std::string filePath; //< full path to selected file or directory
		std::string fileName; //< selected file or directory name
		bool bSuccess; //< true if the dialog action was successful, aka file select not cancel
};

/// \brief show an error message in an alert dialog box
void ofSystemAlertDialog(std::string errorMessage);

/// \brief show a file load dialog box
/// \param windowTitle optional window title string, ie. "Load background image"
/// \param bFolderSelection set to true to allow folder selection
/// \param defaultPath optional default directory path to start the dialog in, ie. ofFilePath::getUserHomeDir()
/// \return dialog result with selection (if any)
ofFileDialogResult ofSystemLoadDialog(std::string windowTitle="", bool bFolderSelection = false, std::string defaultPath="");

/// \brief show a file save dialog box
/// \param defaultName suggested filename to start dialog, ie "screenshot.png"
/// \param messageName descriptive text for the save action, ie. "Saving screenshot as"
/// \return dialog result with selection (if any)
ofFileDialogResult ofSystemSaveDialog(std::string defaultName, std::string messageName);

/// \brief show a text entry dialog box
/// \param question descriptive text for the text entry, ie. "What's your favorite color?"
/// \param text optional default text entry string, ie. "blue"
std::string ofSystemTextBoxDialog(std::string question, std::string text="");

#line 0 "../libs/openFrameworks/utils/ofThread.h"
#pragma once
/* #include "ofConstants.h" */
#ifndef TARGET_NO_THREADS

#include <atomic>
#include <thread>
#include <mutex>
#include <condition_variable>


/// \class ofThread
/// \brief A threaded base class with a built in mutex for convenience.
///
/// Users can extend this base class by public inheritance like this:
///
///     class MyThreadedClass: public ofThread
///     {
///         public:
///         /// ...
///         void threadedFunction()
///         {
///             while(isThreadRunning())
///             {
///                 /// Threaded function here.
///             }
///         }
///     };
///
/// ofThread is a convenient wrapper for Poco::Thread, Poco::Runnable and
/// Poco::Mutex.  It represents a simplified (sometimes overly simplified -
/// or simplified in ways that might not make sense for your project)
/// pathway for quickly writing threaded classes.  Poco::Runnable represents
/// a class that can be "run" via its void run() method.  Poco::Thread is
/// able to spawn a thread and "run" the contents of a class that extends
/// the Poco::Runnable interface (which ofThread does).  Poco::FastMutex,
/// (aka ofMutex) is a "mutual exclusion" object that prevents two threads
/// from accessing the same data at the same time.  It is important to know
/// that Poco::FastMutex (aka ofMutex) is not "recursive" while Poco::Mutex
/// is. This means that if the same thread attempts to lock a thread while
/// it ALREADY has a lock on the mutex, the program will lock up and go
/// nowhere.  Thus, it is important that ofThread subclasses carefully
/// their use of the mutex.  Currently ofThread does not lock its own mutex
/// at any point (e.g. ofThread's internal variables are not thread safe).
/// This is a somewhat dangerous convenience that is (theoretically)
/// supposed to make it easier for subclasses to avoid the recursive mutex
/// "problem". The situation that arises from two threads simultanously
/// reading or writing from the same shared data (shared data
/// occupies the same physical location in memory) leads to something
/// called a "race condition", which can lead to deadlocks.
/// A deadlock is as bad as it sounds.  It means your program
/// just stops.  ofMutex prevents race conditions, deadlocks and crashes by
/// permitting only one thread access to shared data at a time.  When using
/// mutexes to protect data, the trick is to always be sure to unlock the
/// mutex when finished.  This problem can often be avoided by using
/// an Poco::FastMutex::ScopedLock (aka ofScopedLock).  See the
/// the documentation for more information.  Finally, there are many cases
/// where it might make more sense to use Poco::Thread, Poco::Runnable and
/// Poco::FastMutex directly rather than using ofThread.  Further, cross
/// platform thread management will be alleviated with the std::thread
/// support library included with C++11.
///
/// Uncaught Exceptions throw from within ofThread will cause the thread to stop
/// and the Exception will be delivered to the default ofBaseThreadErrorHandler.
/// The ofBaseThreadErrorHandler will print the exception details, if available.
/// The ofBaseThreadErrorHandler offers no opportunity to take corrective action
/// and only allows the user to receive more valuable debugging information
/// about the uncaught exception.  Users should design ofThread subclasses to
/// catch and respond to all anticipated exceptions.
class ofThread {
public:
    /// \brief Create an ofThread.
    ofThread();

    /// \brief Check the running status of the thread.
    /// \returns true iff the thread is currently running.
    bool isThreadRunning() const;

    /// \brief Get the unique thread id.
    /// \note This is NOT the the same as the operating thread id!
    std::thread::id getThreadId() const;

    /// \brief Get the unique thread name, in the form of "Thread id#"
    /// \returns the Thread ID string.
    std::string getThreadName() const;

	void setThreadName(const std::string & name);

	/// \brief Start the thread.
    /// \note Subclasses can directly access the mutex and employ thier
    ///       own locking strategy.
	void startThread();

	/// \brief Start the thread with options.
	/// \param mutexBlocks Set blocking to true if you want the mutex to
	///        block when lock() is called.
	/// \note Subclasses can directly access the mutex and employ thier
	///       own locking strategy.
	OF_DEPRECATED_MSG("Use tryLock instead of setting the type of lock on startThread",
				  void startThread(bool mutexBlocks));

	/// \brief Lock the mutex.
    ///
    /// If the thread was started startThread(true), then this call will wait
    /// until the mutex is available and return true.  If the thread was started
    /// startThread(false), this call will return true iff the mutex is
    /// was successfully acquired.
    ///
	/// \returns true if the lock was successfully acquired.
    bool lock();

	/// \brief Tries to lock the mutex.
	///
	/// If the thread was started startThread(true), then this call will wait
	/// until the mutex is available and return true.  If the thread was started
	/// startThread(false), this call will return true iff the mutex is
	/// was successfully acquired.
	///
	/// \returns true if the lock was successfully acquired.
	bool tryLock();

    /// \brief Unlock the mutex.
    ///
    /// This will only unlocks the mutex if it was previously by the same
    /// calling thread.
    void unlock();

    /// \brief Stop the thread.
    ///
    /// This does immediately stop the thread from processing, but
    /// will only set a flag that must be checked from within your
    /// threadedFunction() by calling isThreadRunning().  If the user wants
    /// to both stop the thread AND wait for the thread to finish
    /// processing, the user should call waitForThread(true, ...).
    void stopThread();

    /// \brief Wait for the thread to exit (aka "joining" the thread).
    ///
    /// This method waits for a thread will "block" and wait for the
    /// thread (aka "join" the thread) before it returns.  This allows the
    /// user to be sure that the thread is properly cleaned up.  An example
    /// of when this might be particularly important is if the
    /// threadedFunction() is opening a set of network sockets, or
    /// downloading data from the web.  Destroying an ofThread subclass
    /// without releasing those sockets (or other resources), may result in
    /// segmentation faults, error signals or other undefined behaviors.
    ///
    /// \param callStopThread Set stop to true if you want to signal the thread
    ///     to exit before waiting.  This is the equivalent to calling
    ///     stopThread(). If you your threadedFunction uses a while-loop that
    ///     depends on isThreadRunning() and you do not call stopThread() or set
    ///     stop == true, waitForThread will hang indefinitely.  Set stop ==
    ///     false ONLY if you have already called stopThread() and you simply
    ///     need to be sure your thread has finished its tasks.
    ///
    /// \param milliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the
    ///     waitForThread will wait indefinitely for the thread to complete.  If
    ///     milliseconds is set to a lower number (e.g. 10000 for 10 seconds),
    ///     waitForThread will wait for 10000 milliseconds and if the thread has
    ///     not yet stopped it will return and log an error message.  Users are
    ///     encouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is
    ///     unhappy with the amount of time it takes to join a thread, the user
    ///     is encouraged to seek more expedient ways of signalling their desire
    ///     for a thread to complete via other signalling methods such as
    ///     Poco::Event, Poco::Condition, or Poco::Semaphore.
    /// \sa http://pocoproject.org/slides/090-NotificationsEvents.pdf
    /// \sa http://pocoproject.org/docs/Poco.Condition.html
    /// \sa http://pocoproject.org/docs/Poco.Event.html
    /// \sa http://pocoproject.org/docs/Poco.Semaphore.html
    void waitForThread(bool callStopThread = true,
                       long milliseconds = INFINITE_JOIN_TIMEOUT);

    /// \brief Tell the thread to sleep for a certain amount of milliseconds.
    ///
    /// This is useful inside the threadedFunction() when a thread is waiting
    /// for input to process:
    ///
    ///     void MyThreadedClass::threadedFunction()
    ///     {
    ///		    // start
    ///		    while(isThreadRunning())
    ///         {
    ///             // bReadyToProcess can be set from outside the threadedFuntion.
    ///             // perhaps by another thread that downloads data, or loads
    ///             // some media, etc.
    ///
    ///		    	if(bReadyToProcess == true)
    ///             {
    ///		    		// do some time intensive processing
    ///		    		bReadyToProcess = false;
    ///		    	}
    ///             else
    ///             {
    ///		    		// sleep the thread to give up some cpu
    ///		    		sleep(20);
    ///		    	}
    ///		    }
    ///		    // done
    ///     }
    ///
    /// If the user does not give the thread a chance to sleep, the
    /// thread may take 100% of the CPU core while it's looping as it
    /// waits for something to do.  This may lead to poor application
    /// performance.
    ///
    /// \param milliseconds The number of milliseconds to sleep.
    void sleep(long milliseconds);

    /// \brief Tell the thread to give up its CPU time other threads.
    ///
    /// This method is similar to sleep() and can often be used in
    /// the same way.  The main difference is that 1 millisecond
    /// (the minimum sleep time available with sleep()) is a very
    /// long time on modern processors and yield() simply gives up
    /// processing time to the next thread, instead of waiting for
    /// number of milliseconds. In some cases, this behavior will
    /// be preferred.
    void yield();

    /// \brief Query whether the current thread is active.
    ///
    /// In multithreaded situations, it can be useful to know which
    /// thread is currently running some code in order to make sure
    /// only certain threads can do certain things.  For example,
    /// OpenGL can only run in the main execution thread.  Thus,
    /// situations where a thread is responsible for interacting
    /// with graphics resources may need to prevent graphics updates
    /// unless the main thread is accessing or updating resources
    /// shared with this ofThread (or its subclass).
    ///
    ///     if(myThread.isCurrentThread())
    ///     {
    ///         // do some myThread things,
    ///         // but keep your hands off my resources!
    ///     }
    ///     else if(ofThread::isMainThread())
    ///     {
    ///         // pheew! ok, update those graphics resources
    ///     }
    ///
    /// By way of another example, a subclass of ofThread may have
    /// an update() method that is called from ofBaseApp during the
    /// execution of the main application thread.  In these cases,
    /// the ofThread subclass might want to ask itself whether it
    /// can, for instance, call update() on an ofImage, in order to
    /// send copy some ofPixels to an ofTexture on the graphics
    /// card.
    ///
    /// \returns True iff this ofThread the currently active thread.
    bool isCurrentThread() const;

    /// \brief Get a reference to the underlying Poco thread.
    ///
    /// Poco::Thread provides a clean cross-platform wrapper for
    /// threads.  On occasion, it may be useful to interact with the
    /// underlying Poco::Thread directly.
    ///
    /// \returns A reference to the backing Poco thread.
    std::thread& getNativeThread();

    /// \brief Get a const reference to the underlying Poco thread.
    ///
    /// Poco::Thread provides a clean cross-platform wrapper for
    /// threads.  On occasion, it may be useful to interact with the
    /// underlying Poco::Thread directly.
    ///
    /// \returns A reference to the backing Poco thread.
    const std::thread & getNativeThread() const;


    enum {
        INFINITE_JOIN_TIMEOUT = -1
            ///< \brief A sentinal value for an infinite join timeout.
            ///<
            ///< Primarily used with the waitForThread() method.
    };

protected:
    /// \brief The thread's run function.
    ///
    /// Users must overide this in your their derived class
    /// and then implement their threaded activity inside the loop.
    /// If the the users's threadedFunction does not have a loop,
    /// the contents of the threadedFunction will be executed once
    /// and the thread will then exit.
    ///
    /// For tasks that must be repeated, the user can use a while
    /// loop that will run repeatedly until the thread's
    /// threadRunning is set to false via the stopThread() method.
    ///
    ///     void MyThreadedClass::threadedFunction()
    ///     {
    ///         // Start the loop and continue until
    ///         // isThreadRunning() returns false.
    ///         while(isThreadRunning())
    ///         {
    ///             // Do activity repeatedly here:
    ///
    ///             // int j = 1 + 1;
    ///
    ///             // This while loop will run as fast as it possibly
    ///             // can, consuming as much processor speed as it can.
    ///             // To help the processor stay cool, users are
    ///             // encouraged to let the while loop sleep via the
    ///             // sleep() method, or call the yield() method to let
    ///             // other threads have a turn.  See the sleep() and
    ///             // yield() methods for more information.
    ///
    ///             // sleep(100);
    ///         }
    ///     }
    ///
    virtual void threadedFunction();

    /// \brief The Poco::Thread that runs the Poco::Runnable.
    std::thread thread;

    /// \brief The internal mutex called through lock() & unlock().
    ///
    /// This mutext can also be used with std::unique_lock or lock_guard
    /// within the threaded function by calling:
    ///
    ///     std::unique_lock<std::mutex> lock(mutex);
    ///
    mutable std::mutex mutex;

private:
    ///< \brief Implements Poco::Runnable::run().
    void run();

    ///< \brief Is the thread running?
    std::atomic<bool> threadRunning;
    std::atomic<bool> threadDone;

    ///< \brief Should the mutex block?
    std::atomic<bool> mutexBlocks;

    std::string name;
    std::condition_variable condition;


};

#else

class ofThread{
public:
	void lock(){}
	void unlock(){}
	void startThread(){}
	void stopThread(){};
	bool isThreadRunning(){return false;}

    enum {
        INFINITE_JOIN_TIMEOUT = LONG_MAX
    };
};
#endif

#line 0 "../libs/openFrameworks/utils/ofThreadChannel.h"
#pragma once


#include <mutex>
#include <queue>
#include <condition_variable>


/// \brief Safely send data between threads without additional synchronization.
///
/// ofThreadChannel makes it easy to safely and efficiently share data between
/// threads without the need for shared memory, mutexes, or other
/// synchronization techniques. Additionally, ofThreadChannel employs a
/// signalling system that allows receiving threads to sleep until new data
/// arrives or the ofThreadChannel is closed.
///
/// A single ofThreadChannel class is designed for one-way communication. In
/// most cases an additional ofThreadChannel can be used for two-way
/// communication.
///
/// Data is sent through the ofThreadChannel in a FIFO (first in, first out)
/// order, guaranteeing that that data will be received in the same order that
/// it was sent.
///
/// If multiple threads attempt to send data using the same ofThreadChannel, the
/// send method will block the calling thread until it is free.
///
/// \sa https://github.com/openframeworks/ofBook/blob/master/chapters/threads/chapter.md
/// \tparam T The data type sent by the ofThreadChannel.
template<typename T>
class ofThreadChannel{
public:
	/// \brief Create a default ofThreadChannel.
	///
	/// ofThreadChannel must be instantiated with a template parameter such as:
	/// ~~~~{.cpp}
	/// 	ofThreadChannel<ofPixels> myThreadChannel;
	/// ~~~~
	ofThreadChannel()
	:closed(false){}

	/// \brief Block the receiving thread until a new sent value is available.
	///
	/// The receiving thread will block until a new sent value is available. In
	/// order to receive data, the user must create an instance of the data
	/// type, and pass it to the receive method to be set.
	///
	/// ofThreadChannel::receive will not make a copy or reallocate data.
	///
	/// ~~~~{.cpp}
	/// ofThreadChannel<ofPixels> myThreadChannel;
	///
	/// // ofThreadChannel<ofPixels> declared elsewhere.
	///
	/// ofPixels myPixelsToSet;
	///
	/// if (myThreadChannel.receive(myPixelsToSet)) {
	///		// If true, `myPixelsToSet` can be used.
	/// } else {
	///		// If false, thread channel was closed and the value of
	///		// `myPixelsToSet` may be invalid depending on the scope of
	///		// `myPixelsToSet`.
	/// }
	/// ~~~~
	///
	/// \param sentValue A reference to a sent value.
	/// \returns True if a new value was received or false if the ofThreadChannel was closed.
	bool receive(T & sentValue){
		std::unique_lock<std::mutex> lock(mutex);
		if(closed){
			return false;
		}
        while(queue.empty() && !closed){
			condition.wait(lock);
		}
		if(!closed){
			std::swap(sentValue,queue.front());
			queue.pop();
			return true;
		}else{
			return false;
		}
	}

	/// \brief If available, receive a new sent value without blocking.
	///
	/// ofThreadChannel::tryReceive is similar to ofThreadChannel::receive,
	/// except that it will not block the receiving thread.  If no data is
	/// available, it will return false and continue immediately.
	///
	/// ofThreadChannel::tryReceive will not make a copy or reallocate data.
	///
	/// Like ofThreadChannel::receive, in order to receive data, the user must
	/// create an instance of the data type, and pass it to the receive method
	/// to be set.
	///
	/// ~~~~{.cpp}
	/// ofThreadChannel<ofPixels> myThreadChannel;
	///
	/// // ofThreadChannel<ofPixels> initialized elsewhere.
	///
	/// ofPixels myPixelsToSet;
	///
	/// if (myThreadChannel.tryReceive(myPixelsToSet)) {
	///		// If true, `myPixelsToSet` can be used.
	/// } else {
	///		// If false, there was no new data OR the thread channel was closed.
	///		// Either way, the value of `myPixelsToSet` may be invalid depending
	///		// on the scope of `myPixelsToSet`.
	/// }
	/// ~~~~
	///
	/// \param sentValue A reference to a sent value.
	/// \returns True if a new value was received or false if the ofThreadChannel was closed.
	bool tryReceive(T & sentValue){
		std::unique_lock<std::mutex> lock(mutex);
		if(closed){
			return false;
		}
        if(!queue.empty()){
			std::swap(sentValue,queue.front());
			queue.pop();
			return true;
		}else{
			return false;
		}
	}

	/// \brief If available, receive a new sent value or wait for a user-specified duration.
	///
	/// ofThreadChannel::tryReceive is similar to ofThreadChannel::receive,
	/// except that it will block the receiving thread for a maximum of
	/// `timeoutMs` while it waits for sent data.  If no data is available
	/// during that time, it will return false and continue.
	///
	/// ofThreadChannel::tryReceive will not make a copy or reallocate data.
	///
	/// Like ofThreadChannel::receive, in order to receive data, the user must
	/// create an instance of the data type, and pass it to the receive method
	/// to be set.
	///
	/// ~~~~{.cpp}
	/// ofThreadChannel<ofPixels> myThreadChannel;
	///
	/// // ofThreadChannel<ofPixels> initialized elsewhere.
	///
	/// ofPixels myPixelsToSet;
	///
	/// if (myThreadChannel.tryReceive(myPixelsToSet)) {
	///		// If true, `myPixelsToSet` can be used.
	/// } else {
	///		// If false, there was no new data OR the thread channel was closed.
	///		// Either way, the value of `myPixelsToSet` may be invalid depending
	///		// on the scope of `myPixelsToSet`.
	/// }
	/// ~~~~
	///
	/// \param sentValue A reference to a sent value.
	/// \param timeoutMs The number of milliseconds to wait for new data before continuing.
	/// \returns True if a new value was received or false if the ofThreadChannel was closed.
	bool tryReceive(T & sentValue, int64_t timeoutMs){
		std::unique_lock<std::mutex> lock(mutex);
		if(closed){
			return false;
		}
		if(queue.empty()){
			condition.wait_for(lock, std::chrono::milliseconds(timeoutMs));
			if(queue.empty()) {
				return false;
			}
		}

		if(!closed){
			std::swap(sentValue,queue.front());
			queue.pop();
			return true;
		}else{
			return false;
		}
	}

	/// \brief Send a value to the receiver by making a copy.
	///
	/// This method copies the contents of the sent value, leaving the original
	/// data unchanged.
	///
	/// ~~~~{.cpp}
	/// ofThreadChannel<ofPixels> myThreadChannel;
	///
	/// // ofThreadChannel<ofPixels> initialized elsewhere.
	///
	/// ofPixels myPixelsToSend;
	///
	/// // Fill the pixels with valid data, an image for example.
	///
	/// ofLoadImage(myPixelsToSend, "myImage.jpg");
	///
	/// // Send `myPixelsToSend` by copying it. `myPixelsToSend` is still valid
	/// // after sending.
	/// if (myThreadChannel.send(myPixelsToSend)) {
	///		// If true, `myPixelsToSend` was sent successfully.
	/// } else {
	///		// If false, the thread channel was closed.
	/// }
	/// ~~~~
	///
	/// \returns true if the value was sent successfully or false if the channel was closed.
	bool send(const T & value){
		std::unique_lock<std::mutex> lock(mutex);
		if(closed){
			return false;
		}
		queue.push(value);
        condition.notify_one();
		return true;
	}

	/// \brief Send a value to the receiver without making a copy.
	///
	/// This method moves the contents of the sent value using `std::move`
	/// semantics. This avoids copying the data, but the original data data will
	/// be invalidated. Note that the original data will be invalideated even if
	/// the send fails because the channel is already closed.
	///
	/// ~~~~{.cpp}
	/// ofThreadChannel<ofPixels> myThreadChannel;
	///
	/// // ofThreadChannel<ofPixels> initialized elsewhere.
	///
	/// ofPixels myPixelsToSend;
	///
	/// // Fill the pixels with valid data, an image for example.
	///
	/// ofLoadImage(myPixelsToSend, "myImage.jpg");
	///
	/// // Send `myPixelsToSend` by moving it. `myPixelsToSend` will no longer
	/// // be valid, even if the send fails because the channel is closed.
	/// if (myThreadChannel.send(std::move(myPixelsToSend))) {
	///		// If true, `myPixelsToSend` was sent successfully.
	///		// `myPixelsToSend` is no longer valid because it was moved.
	/// } else {
	///		// If false, the thread channel was closed.
	///		// `myPixelsToSend` is no longer valid because it was moved.
	/// }
	///
	/// ~~~~
	///
	/// \returns true if the value was sent successfully or false if the channel was closed.
	bool send(T && value){
		std::unique_lock<std::mutex> lock(mutex);
		if(closed){
			return false;
		}
		queue.push(std::move(value));
        condition.notify_one();
		return true;
	}

	/// \brief Close the ofThreadChannel.
	///
	/// Closing the ofThreadChannel means that no new messages can be sent or
	/// received. All threads waiting to receive new values will be notified and
	/// all ofThreadChannel::receive and ofThreadChannel::tryReceive methods
	/// will return false.
	void close(){
		std::unique_lock<std::mutex> lock(mutex);
		closed = true;
		condition.notify_all();
	}


	/// \brief Queries empty channel.
	///
	/// This call is only an approximation, since messages come from a different
	/// thread the channel can return true when calling empty() and then receive
	/// a message right afterwards
	bool empty() const{
		return queue.empty();
	}

private:
	/// \brief The FIFO data queue.
	std::queue<T> queue;

	/// \brief The mutext to protect the data.
	std::mutex mutex;

	/// \brief The condition even to notify receivers.
	std::condition_variable condition;

	/// \brief True if the channel is closed.
	bool closed;

};

#line 0 "../libs/openFrameworks/sound/ofSoundBaseTypes.h"
#pragma once

/* #include "ofConstants.h" */
#include <functional>

class ofSoundBuffer;



/// \brief A base class representing a sound input stream.
class ofBaseSoundInput{
	public:
		/// \brief Destroy the ofBaseSoundInput.
		virtual ~ofBaseSoundInput() {};

		/// \brief Receive an audio buffer.
		/// \param buffer An audio buffer.
		virtual void audioIn( ofSoundBuffer& buffer );

		/// \deprecated This legacy method is deprecated and will be removed.
		/// Use void audioIn(ofSoundBuffer& buffer) instead.
		virtual void audioIn( float * input, int bufferSize, int nChannels, int deviceID, long unsigned long tickCount );

		/// \deprecated This legacy method is deprecated and will be removed.
		/// Use void audioIn(ofSoundBuffer& buffer) instead.
		virtual void audioIn( float * input, int bufferSize, int nChannels );

		/// \deprecated This legacy method is deprecated and will be removed.
		/// Use void audioIn(ofSoundBuffer& buffer) instead.
		virtual void audioReceived( float * input, int bufferSize, int nChannels ){}
};


/// \brief A base class representing a sound output stream.
class ofBaseSoundOutput{
	public:
		/// \brief Destroy the ofBaseSoundOutput.
		virtual ~ofBaseSoundOutput() {};

		/// \brief Output an audio buffer.
		/// \param buffer An audio buffer.
		virtual void audioOut( ofSoundBuffer& buffer );

		/// \deprecated This legacy method is deprecated and will be removed.
		/// Use void audioOut(ofSoundBuffer& buffer) instead.
		virtual void audioOut( float * output, int bufferSize, int nChannels, int deviceID, long unsigned long tickCount  );

		/// \deprecated This legacy method is deprecated and will be removed.
		/// Use void audioOut(ofSoundBuffer& buffer) instead.
		virtual void audioOut( float * output, int bufferSize, int nChannels );

		/// \deprecated This legacy method is deprecated and will be removed.
		/// Use void audioOut(ofSoundBuffer& buffer) instead.
		virtual void audioRequested( float * output, int bufferSize, int nChannels ){}
};

/// \class ofSoundDevice
/// \brief Represents information about a sound device on the system.
class ofSoundDevice {
public:
	enum Api {
		UNSPECIFIED,
		DEFAULT,
		ALSA,     /*!< The Advanced Linux Sound Architecture API. */
		PULSE,    /*!< The Linux PulseAudio API. */
		OSS,      /*!< The Linux Open Sound System API. */
		JACK,      /*!< The Jack Low-Latency Audio Server API. */
		OSX_CORE,    /*!< Macintosh OS-X Core Audio API. */
		MS_WASAPI, /*!< The Microsoft WASAPI API. */
		MS_ASIO,   /*!< The Steinberg Audio Stream I/O API. */
		MS_DS,     /*!< The Microsoft Direct Sound API. */
		NUM_APIS
	} api = UNSPECIFIED;

	friend std::ostream& operator << (std::ostream& os, const ofSoundDevice& dev);
	friend std::ostream& operator << (std::ostream& os, const std::vector<ofSoundDevice>& devs);

	/// \brief Descriptive name for the device
	/// This is the same string that ofSoundStream::getMatchingDevices() will be looking for
	std::string name{"Unknown"};

	/// \brief The device's unique ID (to be used in ofSoundStream::setDeviceID() )
	int deviceID = -1;

	/// \brief Number of input channels the device supports
	unsigned int inputChannels = 0;

	/// \brief Number of output channels the device supports
	unsigned int outputChannels = 0;

	/// \brief If true, this device will be used by ofSoundStream unless changed with setDeviceID()
	bool isDefaultInput = false;

	/// \brief If true, this device will be used by ofSoundStream unless changed with setDeviceID()
	bool isDefaultOutput = false;

	/// \brief List of sample rates the device claims to support
	std::vector<unsigned int> sampleRates;
};

class ofSoundStreamSettings {
public:
	virtual ~ofSoundStreamSettings() {}
	size_t sampleRate = 44100;
	size_t bufferSize = 256;
	size_t numBuffers = 4;
	size_t numInputChannels = 0;
	size_t numOutputChannels = 0;
	virtual bool setInDevice(const ofSoundDevice & device);
	virtual bool setOutDevice(const ofSoundDevice & device);
	virtual bool setApi(ofSoundDevice::Api api);
	virtual const ofSoundDevice * getInDevice() const;
	virtual const ofSoundDevice * getOutDevice() const;
	virtual ofSoundDevice::Api getApi() const;

	template<typename Listener>
	void setInListener(Listener * inListener){
		inCallback = std::bind(static_cast<void(Listener::*)(ofSoundBuffer &)>(&Listener::audioIn), inListener, std::placeholders::_1);
	}

	template<typename Listener>
	void setOutListener(Listener * outListener){
		outCallback = std::bind(static_cast<void(Listener::*)(ofSoundBuffer &)>(&Listener::audioOut), outListener, std::placeholders::_1);
	}

	std::function<void(ofSoundBuffer &)> inCallback;
	std::function<void(ofSoundBuffer &)> outCallback;
private:
	ofSoundDevice inDevice;
	ofSoundDevice outDevice;
	ofSoundDevice::Api api = ofSoundDevice::Api::UNSPECIFIED;
};

class ofBaseSoundStream {
public:
	virtual ~ofBaseSoundStream() {}
	virtual bool setup(const ofSoundStreamSettings & settings) = 0;
	virtual void setInput(ofBaseSoundInput * soundInput) = 0;
	virtual void setOutput(ofBaseSoundOutput * soundOutput) = 0;

	virtual std::vector<ofSoundDevice> getDeviceList(ofSoundDevice::Api api) const = 0;
	virtual void printDeviceList() const;

	virtual void start() = 0;
	virtual void stop() = 0;
	virtual void close() = 0;

	virtual uint64_t getTickCount() const = 0;
	virtual int getNumInputChannels() const = 0;
	virtual int getNumOutputChannels() const = 0;
	virtual int getSampleRate() const = 0;
	virtual int getBufferSize() const = 0;
	virtual ofSoundDevice getInDevice() const = 0;
	virtual ofSoundDevice getOutDevice() const = 0;
};

inline std::string toString(ofSoundDevice::Api api);


//----------------------------------------------------------
// ofBaseSoundPlayer
//----------------------------------------------------------
class ofBaseSoundPlayer {

public:

	ofBaseSoundPlayer(){};
	virtual ~ofBaseSoundPlayer(){};

	virtual bool load(const std::filesystem::path& fileName, bool stream = false)=0;
	virtual void unload()=0;
	virtual void play() = 0;
	virtual void stop() = 0;

	virtual void setVolume(float vol) = 0;
	virtual void setPan(float vol) = 0; // -1 = left, 1 = right
	virtual void setSpeed(float spd) = 0;
	virtual void setPaused(bool bP) = 0;
	virtual void setLoop(bool bLp) = 0;
	virtual void setMultiPlay(bool bMp) = 0;
	virtual void setPosition(float pct) = 0; // 0 = start, 1 = end;
	virtual void setPositionMS(int ms) = 0;

	virtual float getPosition() const = 0;
	virtual int getPositionMS() const = 0;
	virtual bool isPlaying() const = 0;
	virtual float getSpeed() const = 0;
	virtual float getPan() const = 0;
	virtual bool isLoaded() const = 0;
	virtual float getVolume() const = 0;

};

#line 0 "../libs/openFrameworks/video/ofVideoBaseTypes.h"
#pragma once
/* #include "ofGraphicsBaseTypes.h" */
/* #include "ofGLBaseTypes.h" */

enum ofPixelFormat: short;

/// \brief Used to represent the available video looping modes.
///
/// \sa ofVideoPlayer::setLoopState()
/// \sa ofVideoPlayer::getLoopState()
enum ofLoopType : short{
	/// \brief Plays the video once without looping.
	OF_LOOP_NONE=0x01,
	/// \brief Plays the video forwards then backwards repeatedly.
	OF_LOOP_PALINDROME=0x02,
	/// \brief Repeats the video over and over.
	OF_LOOP_NORMAL=0x03
};



/// \brief A structure describing attributes of a video format.
///
/// An ofVideoFormat is used to describe the size, pixel format and frame rates
/// offered by a video device.
///
/// \sa ofVideoDevice
class ofVideoFormat{
public:
	/// \brief The pixel format of the video format.
	ofPixelFormat pixelFormat;

	/// \brief The width of the video format in pixels.
	int width;

	/// \brief The height of the video format in pixels.
	int height;

	/// \brief A list of framerates for this video format in frames per second.
	std::vector<float> framerates;
};

/// \brief A structure describing attributes of a video device.
///
/// An ofVideoDevice can represent a camera, grabber or other frame source.
class ofVideoDevice{
public:
	/// \brief The video device ID.
	int id;

	/// \brief The video device name.
	std::string deviceName;

	/// \brief The video device hardware name.
	std::string hardwareName;

	/// \brief Unique identifier for the device if it has one.
	std::string serialID;

	/// \brief A list of video device formats provided by the device.
	/// \sa ofVideoFormat
	std::vector<ofVideoFormat> formats;

	/// \brief Is true if this video device is available.
	bool bAvailable;
};

/// \brief A base class representing a video source.
class ofBaseVideo: virtual public ofBaseHasPixels, public ofBaseUpdates{
public:
	/// \brief Destroy the ofBaseVideo.
	virtual ~ofBaseVideo(){}

	/// \returns true if the pixel data was updated since the last call to update().
	virtual bool isFrameNew() const =0;

	/// \brief Close the video source.
	virtual void close()=0;

	/// \brief Determine if the video source is initialized.
	///
	/// Video sources such as cameras are often initialized with a
	/// setup() method.  Video sources such as movie players are often
	/// initialized with a load() method.
	///
	/// \returns true if the video source is initialized.
	virtual bool isInitialized() const=0;

	/// \brief Set the requested ofPixelFormat.
	/// \param pixelFormat the requested ofPixelFormat.
	/// \returns true if the format was successfully changed.
	virtual bool setPixelFormat(ofPixelFormat pixelFormat) = 0;

	/// \returns the current ofPixelFormat.
	virtual ofPixelFormat getPixelFormat() const = 0;
};


/// \brief A base class representing a drawable video source.
class ofBaseVideoDraws:
	virtual public ofBaseVideo,
	public ofBaseDraws,
	public ofBaseHasTexturePlanes,
	virtual public ofBaseHasPixels{
public:
	/// \brief Destroy the ofBaseVideoDraws.
	virtual ~ofBaseVideoDraws(){}
};

/// \brief A base class representing a video device such as a camera.
class ofBaseVideoGrabber: virtual public ofBaseVideo{

	public :
	/// \brief Destroy the ofBaseVideoGrabber
	virtual ~ofBaseVideoGrabber();

	//needs implementing
	/// \brief Get a list of available video grabber devices.
	/// \returns a std::vector of ofVideoDevice objects.
	virtual std::vector<ofVideoDevice>	listDevices() const = 0;

	/// \brief Set up the grabber with the requested width and height.
	///
	/// Some video grabbers may take the requested width and height as
	/// a hint and choose the closest dimensions to those requested.
	/// Users can check the actual width and height by calling getWidth() and
	/// getHeight() respectively after a successful setup.
	///
	/// \param w the requested width.
	/// \param h the requested height.
	/// \returns true if the video grabber was set up successfully.
	virtual bool setup(int w, int h) = 0;

	/// \brief Get the video grabber's height.
	/// \returns the video grabber's height.
	virtual float getHeight() const = 0;

	/// \brief Get the video grabber's width.
	/// \returns the video grabber's width.
	virtual float getWidth() const = 0;

	/// \brief Get the video grabber's internal ofTexture pointer if available.
	///
	/// \note Subclasses should implement this method only if internal API can
	/// upload video grabber pixels directly to an ofTexture.
	///
	/// \returns the internal ofTexture pointer or nullptr if not available.
	virtual ofTexture * getTexturePtr(){ return nullptr; }

	/// \brief Set the video grabber's hardware verbosity level.
	/// \param bTalkToMe true if verbose grabber logging feedback is required.
	virtual void setVerbose(bool bTalkToMe);

	/// \brief Set the video grabber's device ID.
	///
	/// In most cases, a user can choose a specific grabber source by ID.  This
	/// device ID information should be available to the user via the
	/// listDevices() method.
	///
	/// \param deviceID The device ID provided by listDevices().
	virtual void setDeviceID(int deviceID);

	/// \brief Set the video grabber's desired frame rate.
	///
	/// Many video grabbers support user-specified frame rates.  This frame rate
	/// should be considered a hint for the video grabber and is not guaranteed.
	///
	/// \param framerate the desired frame rate.
	virtual void setDesiredFrameRate(int framerate);

	/// \brief Request a native GUI for video grabber settings.
	/// \note This feature may not be implemented by all video grabbers.
	virtual void videoSettings();

};


/// \brief A base class representing a video player.
class ofBaseVideoPlayer: virtual public ofBaseVideo{

public:
	/// \brief Destroys the ofBaseVideoPlayer.
	virtual ~ofBaseVideoPlayer();

	/// \brief Load a video resource by name.
	///
	/// The list of supported video types and sources (e.g. rtsp:// sources) is
	/// implementation dependent.
	///
	/// \param name The name of the video resource to load.
	/// \returns True if the video was loaded successfully.
	/// \sa loadAsync()
	virtual bool				load(std::string name) = 0;
	/// \brief Asynchronously load a video resource by name.
	///
	/// The list of supported video types and sources (e.g. rtsp:// sources) is
	/// implementation dependent.
	///
	/// When this method is used to load a video resouce, users can determine
	/// when the video is loaded by calling isLoaded().
	///
	/// \param name The name of the video resource to load.
	/// \sa isLoaded()
	virtual void				loadAsync(std::string name);

	/// \brief Play the video from the current playhead position.
	/// \sa getPosition()
	/// \sa setPostion()
	virtual void				play() = 0;
	/// \brief Pause and reset the playhead position to the first frame.
	virtual void				stop() = 0;
	/// \brief Get a pointer to the video texture used internally if it exists.
	///
	/// If the video player implementation supports direct-to-texture rendering,
	/// this method will return a pointer to the internal texture. If
	/// direct-to-texture rendering is not supported, nullptr is returned.
	///
	/// \returns A valid pointer to the internal texture, otherwise a nullptr.
	virtual ofTexture *			getTexturePtr(){return nullptr;};

	/// \brief Get the width in pixels of the loaded video.
	/// \returns The width in pixels of the loaded video or 0 if none is loaded.
	virtual float 				getWidth() const = 0;
	/// \brief Get the height in pixels of the loaded video.
	/// \returns The height in pixels of the loaded video or 0 if none is loaded.
	virtual float 				getHeight() const = 0;

	/// \brief Returns true if the video is paused.
	/// \returns True if the video is paused.
	virtual bool				isPaused() const = 0;
	/// \brief Returns true if a video is loaded.
	///
	/// This is helpful when loading a video with loadAsync(). This is also an
	/// alias of isInitialized().
	///
	/// \sa loadAsync()
	/// \returns True if a video is loaded.
	virtual bool				isLoaded() const = 0;
	/// \brief Returns true if the loaded video is playing.
	/// \returns True if the loaded video is playing.
	virtual bool				isPlaying() const = 0;
	/// \brief Returns true if a video is loaded.
	///
	/// This is helpful when loading a video with loadAsync(). This is also
	/// an alias of isLoaded().
	///
	/// \sa loadAsync()
	/// \returns True if a video is loaded.
	virtual bool				isInitialized() const{ return isLoaded(); }

	/// \brief Get the current playhead position of the loaded video.
	///
	/// This value is a normalized floating point value between 0.0 and 1.0 that
	/// represents the position of the playhead. 0.0 maps to the first frame of
	/// the loaded video and 1.0 maps to the last frame of the loaded video.
	///
	/// \returns A value between 0.0 and 1.0 representing playhead position.
	virtual float 				getPosition() const;
	/// \brief Get the playback speed of the video player.
	///
	/// When the loop state is OF_LOOP_NONE or OF_LOOP_NORMAL, positive speed
	/// will scale a forward playback rate while a negative speed will scale a
	/// a backward playback rate. When the loop state is OF_LOOP_PALINDROME,
	/// the direction of playback will change each loop, but the playback rate
	/// will still be scaled by the absolute value of the speed.
	///
	/// \returns The playback speed of the video player.
	virtual float 				getSpeed() const;
	/// \brief Get the duration of the loaded video in seconds.
	/// \returns The duration of the loaded video in seconds.
	virtual float 				getDuration() const;
	/// \brief Returns true if the loaded video has finished playing.
	/// \returns True if the loaded video has finished playing.
	virtual bool				getIsMovieDone() const;

	/// \brief Set the paused state of the video.
	/// \param bPause True to pause the video, false to play.
	virtual void 				setPaused(bool bPause);
	/// \brief Set the position of the playhead.
	///
	/// This value is a normalized floating point value between 0.0 and 1.0 that
	/// represents the position of the playhead. 0.0 maps to the first frame of
	/// the loaded video and 1.0 maps to the last frame of the loaded video.
	///
	/// \param pct A value between 0.0 and 1.0 representing playhead position.
	virtual void 				setPosition(float pct);
	/// \brief Set the volume of the video player.
	///
	/// This value is a normalized floating point value between 0.0 and 1.0 that
	/// represents the video player volume. 0.0 maps to silence and 1.0 maps to
	/// maximum volume.
	///
	/// \param volume A value between 0.0 and 1.0 representing volume.
	virtual void 				setVolume(float volume);
	/// \brief Set the video loop state.
	/// \param state The loop state of the video.
	/// \sa ::ofLoopType
	virtual void 				setLoopState(ofLoopType state);
	/// \brief Set the video playback speed.
	///
	/// When the loop state is OF_LOOP_NONE or OF_LOOP_NORMAL, positive speed
	/// will scale a forward playback rate while a negative speed will scale a
	/// a backward playback rate. When the loop state is OF_LOOP_PALINDROME,
	/// the direction of playback will change each loop, but the playback rate
	/// will still be scaled by the absolute value of the speed.
	///
	/// To play a video forward at normal speed, set the loop state to
	/// OF_LOOP_NONE or OF_LOOP_NORMAL and a speed of 1.0. To double the
	/// playback rate, set the speed to 2.0. To play a video backward, set the
	/// speed to a negative number. A speed 0.25 will play the video at 1/4 the
	/// the normal rate and a rate of 0.0 will effectively stop playback.
	///
	/// \param speed The desired playback speed of the video.
	virtual void   				setSpeed(float speed);
	/// \brief Set the current frame by frame number.
	///
	/// Similar to setPosition(), but accepts a frame number instead of
	/// a normalized floating point value. Frame count begins with the first
	/// frame as 0 and the last frame as getTotalNumFrames() - 1.
	///
	/// \param frame The frame number to set the new playhead to.
	virtual void				setFrame(int frame);

	/// \brief Get the current playhead position as a frame number.
	/// \returns The current playhead position as a frame number.
	virtual int					getCurrentFrame() const;
	/// \brief Get the total number of frames in the currently loaded video.
	/// \returns The total number of frames in the currently loaded video.
	virtual int					getTotalNumFrames() const;
	/// \brief Get the current loop state of the video.
	/// \sa ::ofLoopType
	virtual ofLoopType			getLoopState() const;

	/// \brief Set the playhead position to the first frame.
	///
	/// This is functionally equivalent to setFrame(0) or setPosition(0.0).
	virtual void				firstFrame();
	/// \brief Advance the playhead forward one frame.
	///
	/// This allows the user to advance through the video manually one frame at
	/// a time without calling play().
	virtual void				nextFrame();
	/// \brief Advance the playhead backward one frame.
	///
	/// This allows the user to advance backward through the video manually one
	/// frame at a time without calling play().
	virtual void				previousFrame();
};

#line 0 "../libs/openFrameworks/app/ofBaseApp.h"
#pragma once

/* #include "ofSoundBaseTypes.h" */

class ofResizeEventArgs;
class ofEventArgs;
class ofMouseEventArgs;
class ofKeyEventArgs;
class ofDragInfo;
class ofMessage;
class ofTouchEventArgs;

class ofBaseApp : public ofBaseSoundInput, public ofBaseSoundOutput{

	public:
		ofBaseApp();

		virtual ~ofBaseApp();

		virtual void setup();
		virtual void update();
		virtual void draw();
		virtual void exit();

		virtual void windowResized(int w, int h);

		virtual void keyPressed( int key );
		virtual void keyReleased( int key );

		/// \brief Called on the active window when the mouse is moved
		virtual void mouseMoved( int x, int y );

		/// \brief Called on the active window when the mouse is dragged, i.e.
		/// moved with a button pressed
		virtual void mouseDragged( int x, int y, int button );

		/// \brief Called on the active window when a mouse button is pressed
		virtual void mousePressed( int x, int y, int button );

		/// \brief Called on the active window when a mouse button is released
		virtual void mouseReleased(int x, int y, int button );

		/// \brief Called on the active window when the mouse wheel is scrolled
		virtual void mouseScrolled(int x, int y, float scrollX, float scrollY );

		/// \brief Called on the active window when the mouse cursor enters the
		/// window area
		///
		/// Note that the mouse coordinates are the last known x/y before the
		/// event occurred, i.e. from the previous frame
		virtual void mouseEntered( int x, int y );

		/// \brief Called on the active window when the mouse cursor leaves the
		/// window area
		///
		/// Note that the mouse coordinates are the last known x/y before the
		/// event occurred, i.e. from the previous frame
		virtual void mouseExited( int x, int y);
		
		virtual void dragEvent(ofDragInfo dragInfo);
		virtual void gotMessage(ofMessage msg);
		
		int mouseX, mouseY;			// for processing heads

		virtual void setup(ofEventArgs & args);
		virtual void update(ofEventArgs & args);
		virtual void draw(ofEventArgs & args);
		virtual void exit(ofEventArgs & args);

		virtual void windowResized(ofResizeEventArgs & resize);

		virtual void keyPressed( ofKeyEventArgs & key );
		virtual void keyReleased( ofKeyEventArgs & key );

		virtual void mouseMoved( ofMouseEventArgs & mouse );
		virtual void mouseDragged( ofMouseEventArgs & mouse );
		virtual void mousePressed( ofMouseEventArgs & mouse );
		virtual void mouseReleased(ofMouseEventArgs & mouse);
		virtual void mouseScrolled( ofMouseEventArgs & mouse );
		virtual void mouseEntered( ofMouseEventArgs & mouse );
		virtual void mouseExited( ofMouseEventArgs & mouse );
		virtual void dragged(ofDragInfo & drag);
		virtual void messageReceived(ofMessage & message);

		virtual void touchDown(int x, int y, int id);
		virtual void touchMoved(int x, int y, int id);
		virtual void touchUp(int x, int y, int id);
		virtual void touchDoubleTap(int x, int y, int id);
		virtual void touchCancelled(int x, int y, int id);

		virtual void touchDown(ofTouchEventArgs & touch);
		virtual void touchMoved(ofTouchEventArgs & touch);
		virtual void touchUp(ofTouchEventArgs & touch);
		virtual void touchDoubleTap(ofTouchEventArgs & touch);
		virtual void touchCancelled(ofTouchEventArgs & touch);
};



#line 0 "../libs/openFrameworks/app/ofWindowSettings.h"
#pragma once
/* #include "ofConstants.h" */
#include "glm/vec2.hpp"


/// \brief Used to represent the available windowing modes for the application.
enum ofWindowMode{
	/// \brief A floating application window.
	OF_WINDOW 		= 0,
	/// \brief A fullscreen application window.
	OF_FULLSCREEN 	= 1,
	/// \brief A fullscreen application window with a custom width and height.
	OF_GAME_MODE	= 2
};


/// \brief Used to represent the available screen orientations.
///
/// These don't use "landscape" or "portrait", because phones typically default
/// to portrait while desktop screens are typically landscape by default.
///
/// \sa ::ofSetOrientation
/// \sa ::ofGetOrientation
enum ofOrientation: short{
	/// \brief Represents the default screen orientation.
	OF_ORIENTATION_DEFAULT = 1,
	/// \brief Represents a screen rotated 180 degrees, also known as upside-down.
	OF_ORIENTATION_180 = 2,
	/// \brief Represents a screen rotated 90 degrees clockwise.
	OF_ORIENTATION_90_LEFT = 3,
	/// \brief Represents a screen rotated 90 degrees counter-clockwise.
	OF_ORIENTATION_90_RIGHT = 4,
	/// \brief Represents an unknown orientation.
	OF_ORIENTATION_UNKNOWN = 5
};

class ofWindowSettings{
public:
	ofWindowSettings()
	:windowMode(OF_WINDOW)
	,width(1024)
	,height(768)
	,sizeSet(false)
	,position(0,0)
	,positionSet(false){}

	virtual ~ofWindowSettings(){};

	std::string title;
	ofWindowMode windowMode;

	void setPosition(const glm::vec2 & position) {
		this->position = position;
		this->positionSet = true;
	}

	void setSize(int width, int height) {
		this->width = width;
		this->height = height;
		this->sizeSet = true;
	}

	bool isSizeSet() const {
		return sizeSet;
	}

	int getWidth() const {
		return width;
	}

	int getHeight() const {
		return height;
	}

	const glm::vec2 & getPosition() const {
		return position;
	}

	bool isPositionSet() const {
		return positionSet;
	}

protected:
	int width;
	int height;
	bool sizeSet;
	glm::vec2 position;
	bool positionSet;
};

class ofGLWindowSettings: public ofWindowSettings{
public:
	ofGLWindowSettings()
	:glVersionMajor(2)
	,glVersionMinor(1){}

	ofGLWindowSettings(const ofWindowSettings & settings)
	:ofWindowSettings(settings)
	,glVersionMajor(2)
	,glVersionMinor(1){
        const ofGLWindowSettings * glSettings = dynamic_cast<const ofGLWindowSettings*>(&settings);
        if(glSettings){
            glVersionMajor = glSettings->glVersionMajor;
            glVersionMinor = glSettings->glVersionMinor;
        }
    }

	virtual ~ofGLWindowSettings(){};

	void setGLVersion(int major, int minor){
		glVersionMajor = major;
		glVersionMinor = minor;
	}

	int glVersionMajor;
	int glVersionMinor;
};

class ofGLESWindowSettings: public ofWindowSettings{
public:
	ofGLESWindowSettings()
	:glesVersion(1){}

	ofGLESWindowSettings(const ofWindowSettings & settings)
	:ofWindowSettings(settings), glesVersion(1) {
        const ofGLESWindowSettings * glesSettings = dynamic_cast<const ofGLESWindowSettings*>(&settings);
        if(glesSettings){
            glesVersion = glesSettings->glesVersion;
        }
    }

	virtual ~ofGLESWindowSettings(){};

	void setGLESVersion(int version){
		glesVersion = version;
	}

	int glesVersion;
};

#line 0 "../libs/openFrameworks/app/ofMainLoop.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofEvents.h" */
#include <map>

class ofBaseApp;
class ofAppBaseWindow;
class ofWindowSettings;

class ofMainLoop {
public:
	ofMainLoop();
	virtual ~ofMainLoop();

	std::shared_ptr<ofAppBaseWindow> createWindow(const ofWindowSettings & settings);
	template<typename Window>
	void addWindow(std::shared_ptr<Window> window){
		allowMultiWindow = Window::allowsMultiWindow();
		if(Window::doesLoop()){
		    windowLoop = Window::loop;
		}
		if(Window::needsPolling()){
			windowPollEvents = Window::pollEvents;
		}
		if(!allowMultiWindow){
		    windowsApps.clear();
		}
		windowsApps[window] = std::shared_ptr<ofBaseApp>();
		currentWindow = window;
		ofAddListener(window->events().keyPressed,this,&ofMainLoop::keyPressed);
	}

	void run(std::shared_ptr<ofAppBaseWindow> window, std::shared_ptr<ofBaseApp> && app);
	void run(std::shared_ptr<ofBaseApp> && app);
	int loop();
	void loopOnce();
	void pollEvents();
	void exit();
	void shouldClose(int status);
	std::shared_ptr<ofAppBaseWindow> getCurrentWindow();
	void setCurrentWindow(std::shared_ptr<ofAppBaseWindow> window);
	void setCurrentWindow(ofAppBaseWindow * window);
	std::shared_ptr<ofBaseApp> getCurrentApp();
	void setEscapeQuitsLoop(bool quits);

	ofEvent<void> exitEvent;
	ofEvent<void> loopEvent;
private:
	void keyPressed(ofKeyEventArgs & key);
	std::map<std::shared_ptr<ofAppBaseWindow>,std::shared_ptr<ofBaseApp> > windowsApps;
	bool bShouldClose;
	std::weak_ptr<ofAppBaseWindow> currentWindow;
	int status;
	bool allowMultiWindow;
	std::function<void()> windowLoop;
	std::function<void()> windowPollEvents;
	bool escapeQuits;
};

#line 0 "../libs/openFrameworks/app/ofAppRunner.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofWindowSettings.h" */
/* #include "ofMainLoop.h" */
/* #include "ofRectangle.h" */

class ofAppBaseWindow;
class ofAppBaseGLWindow;
class ofAppBaseGLESWindow;
class ofAppGLFWWindow;
class ofBaseApp;
class ofBaseRenderer;
class ofCoreEvents;

#ifdef TARGET_QT
class QApp
{
    void *app;
    public:
        QApp(int &argc, char **argv);
        void destroy() { delete app; app = 0; }
        int exec();
};
QApp &qapplication();
#endif

void ofInit();
void ofSetupOpenGL(int w, int h, ofWindowMode screenMode);	// sets up the opengl context!
std::shared_ptr<ofAppBaseWindow> ofCreateWindow(const ofWindowSettings & settings);	// sets up the opengl context!
std::shared_ptr<ofMainLoop> ofGetMainLoop();
void ofSetMainLoop(std::shared_ptr<ofMainLoop> mainLoop);

template<typename Window>
void ofSetupOpenGL(std::shared_ptr<Window> windowPtr, int w, int h, ofWindowMode screenMode){
	ofInit();
	ofWindowSettings settings;
	settings.setSize(w, h);
	settings.windowMode = screenMode;
	ofGetMainLoop()->addWindow(windowPtr);
	windowPtr->setup(settings);
}

//special case so we preserve supplied settngs
//TODO: remove me when we remove the ofSetupOpenGL legacy approach.
void ofSetupOpenGL(std::shared_ptr<ofAppGLFWWindow> windowPtr, int w, int h, ofWindowMode screenMode);

template<typename Window>
static void noopDeleter(Window*){}

template<typename Window>
void ofSetupOpenGL(Window * windowPtr, int w, int h, ofWindowMode screenMode){
	std::shared_ptr<Window> window = std::shared_ptr<Window>(windowPtr,std::ptr_fun(noopDeleter<Window>));
	ofSetupOpenGL(window,w,h,screenMode);
}


int ofRunApp(std::shared_ptr<ofBaseApp> && OFSA);
int ofRunApp(ofBaseApp * OFSA = nullptr); // will be deprecated
void ofRunApp(std::shared_ptr<ofAppBaseWindow> window, std::shared_ptr<ofBaseApp> && app);
int ofRunMainLoop();


ofBaseApp * ofGetAppPtr();

void		ofExit(int status=0);

//-------------------------- time
float 		ofGetFrameRate();
float 		ofGetTargetFrameRate();
uint64_t	ofGetFrameNum();
void 		ofSetFrameRate(int targetRate);
double		ofGetLastFrameTime();
void		ofSetTimeModeSystem();
uint64_t	ofGetFixedStepForFps(double fps);
void		ofSetTimeModeFixedRate(uint64_t stepNanos = ofGetFixedStepForFps(60)); //default nanos for 1 frame at 60fps
void		ofSetTimeModeFiltered(float alpha = 0.9);

void		ofSetOrientation(ofOrientation orientation, bool vFlip=true);
ofOrientation			ofGetOrientation();

//-------------------------- cursor
void 		ofHideCursor();
void 		ofShowCursor();
//-------------------------- window / screen
int 		ofGetWindowPositionX();
int 		ofGetWindowPositionY();
int 		ofGetScreenWidth();
int 		ofGetScreenHeight();
int			ofGetWindowMode();
int 		ofGetWidth();			// ofGetWidth is correct for orientation
int 		ofGetHeight();
int 		ofGetWindowWidth();			// ofGetWindowWidth is correct for actual window coordinates - so doesn't change with orientation.
int 		ofGetWindowHeight();

std::string ofGetClipboardString();
void		ofSetClipboardString(const std::string & str);

/// \returns a random number between 0 and the width of the window.
float ofRandomWidth();

/// \returns a random number between 0 and the height of the window.
float ofRandomHeight();
bool		ofDoesHWOrientation();
glm::vec2	ofGetWindowSize();
ofRectangle	ofGetWindowRect();
ofAppBaseWindow * ofGetWindowPtr();
std::shared_ptr<ofAppBaseWindow> ofGetCurrentWindow();

void 		ofSetWindowPosition(int x, int y);
void 		ofSetWindowShape(int width, int height);
void 		ofSetWindowTitle(std::string title);
void		ofEnableSetupScreen();
void		ofDisableSetupScreen();
void		ofSetFullscreen(bool fullscreen);
void		ofToggleFullscreen();
//-------------------------- sync
void 		ofSetVerticalSync(bool bSync);

ofCoreEvents & ofEvents();
void ofSetCurrentRenderer(std::shared_ptr<ofBaseRenderer> renderer,bool setDefaults=false);
std::shared_ptr<ofBaseRenderer> & ofGetCurrentRenderer();
void ofSetEscapeQuitsApp(bool bQuitOnEsc);

//-------------------------- native window handles
#if defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI)
typedef unsigned long Window;
struct _XDisplay;
typedef struct _XDisplay Display;
Display* ofGetX11Display();
Window  ofGetX11Window();
#endif

#if defined(TARGET_LINUX) && !defined(TARGET_OPENGLES)
struct __GLXcontextRec;
typedef __GLXcontextRec * GLXContext;
GLXContext ofGetGLXContext();
#endif

#if defined(TARGET_LINUX) && defined(TARGET_OPENGLES)
EGLDisplay ofGetEGLDisplay();
EGLContext ofGetEGLContext();
EGLSurface ofGetEGLSurface();
#endif

#if defined(TARGET_OSX)
	void * ofGetNSGLContext();
	void * ofGetCocoaWindow();
#endif

#if defined(TARGET_WIN32)
	HGLRC ofGetWGLContext();
	HWND ofGetWin32Window();
#endif

#line 0 "../libs/openFrameworks/3d/of3dUtils.h"
#pragma once

/* #include "ofConstants.h" */
#include "glm/fwd.hpp"

/// \brief Draws x,y,z axes representing the current reference frame.
///
/// This function draws a set of x,y,z axes, which can be helpful for
/// understanding which way is up. There are no unit markings nor arrowheads.
/// Axes are not drawn in the negative directions. Axes are drawn in red (+x),
/// green (+y) and blue (+z), starting from the origin. 
//
/// \param size The size at which to draw the axes.
void ofDrawAxis(float size);

/// \brief Draws grid planes representing the current reference frame.
///
/// This function draws a set of three double-ended grid planes centered at the
/// origin. Parameters allow each of the grid planes (yz,xz, and xy) to be
/// turned on or off. Optionally, the function can include white numeric labels
/// for grid subdivisions. (Numeric labels are drawn using ofDrawBitmapString
/// internally.)
/// 
/// The yz plane (at x=0) is drawn in red.
/// The xz plane (at y=0) is drawn in green.
/// The xy plane (at z=0) is drawn in blue.
///
/// \param stepSize distance between (parallel) lines on the grid
/// \param numberOfSteps number of lines to draw on each side of the central axis of the grid. A number of 8 will draw 8 lines on each side of the central axis, plus one line at the central axis.
/// \param labels Whether or not labels are drawn.
/// \param x Whether or not the yz plane (at x=0) is drawn.
/// \param y Whether or not the xz plane (at y=0) is drawn.
/// \param z Whether or not the xy plane (at z=0) is drawn.
void ofDrawGrid(float stepSize = 1.25f, size_t numberOfSteps = 8, bool labels = false, bool x = true, bool y = true, bool z = true);

/// \brief Draws the YZ grid plane representing the current reference frame.
///
/// This function draws the YZ grid plane, at x=0, in a double-ended manner
/// centered at the origin. Optionally, the function can include white numeric
/// labels for grid subdivisions. (Numeric labels are drawn using
/// ofDrawBitmapString internally.) The grid is drawn with the current color
/// (i.e. set with ofSetColor). 
///
/// \param stepSize distance between (parallel) lines on the grid
/// \param numberOfSteps number of lines to draw on each side of the central axis of the grid. A number of 8 will draw 8 lines on each side of the central axis, plus one line at the central axis.
/// \param labels Whether or not labels are drawn.
void ofDrawGridPlane(float stepSize = 1.25f, size_t numberOfSteps = 8, bool labels = false );

/// \brief Draws an arrow with the current color. 
///
/// This function draws an arrow from a start (tail) point to an end (head)
/// point, with a conical arrowhead at the end point. The arrow is drawn in the
/// current color (e.g. set with ofSetColor). 
///
/// ~~~~{.cpp}
///     ofSetColor(0,0,0);
///     ofVec3f arrowTailPoint (0,0,0);
///     ofVec3f arrowHeadPoint (100, 150,0);
///     ofDrawArrow(arrowTailPoint, arrowHeadPoint, 20.0);
/// ~~~~
///
/// \param start The start point (tail) of the arrow, expressed as an ofVec3f.
/// \param end The end point (head) of the arrow, expressed as an ofVec3f. 
/// \param headSize The size of the arrowhead. 
void ofDrawArrow(const glm::vec3& start, const glm::vec3& end, float headSize = 0.05f);

/// \brief This function renders a set of 3 axis-aligned circular bands, centered at the origin.
///
/// \param radius The radius of the circular bands. 
/// \param stripWidth The width of the circular bands. The default is 10 units. 
/// \param circleRes The resolution of the circular bands. The default is 60 segments.
void ofDrawRotationAxes(float radius, float stripWidth = 10, int circleRes = 60);

#line 0 "../libs/openFrameworks/3d/ofNode.h"

#pragma once

/* #include "ofConstants.h" */
/* #include "ofParameter.h" */
#include <array>
#include "glm/mat4x4.hpp"

class ofBaseRenderer;


/// \brief A generic 3d object in space with transformation (position, rotation, scale).

class ofNode {
public:
	/// \cond INTERNAL
	
	ofNode();
	virtual ~ofNode();
	ofNode(const ofNode & node);
	ofNode(ofNode && node);
	ofNode & operator=(const ofNode & node);
	ofNode & operator=(ofNode && node);

	/// \endcond

	/// \name Parent Node
	/// \{

	/// \brief Set parent for the node. The node will inherit transformations from parent.
	/// \param param0 Reference to the ofNode which becomes the parent node.
	/// \param param1 Boolean if maintain child's global transformations (default = false). 
	void setParent(ofNode& parent, bool bMaintainGlobalTransform = false);

	/// \brief Remove parent node linking.
	/// \param param0 Boolean if maintain child's global transformations (default = false).
	void clearParent(bool bMaintainGlobalTransform = false);

	/// \brief Get the parent node of this node.
	/// \returns Pointer to parent ofNode.
	ofNode* getParent() const;

	/// \}
	/// \name Getters
	/// \{
	
	/// \brief Get node's local position as a 3D vector.
	/// \returns A 3D vector with the local coordinates.
	glm::vec3 getPosition() const;

	/// \brief Get node's local x position. 
	/// \returns Local x coordinate as a float.
	float getX() const;

	/// \brief Get node's local y position.
	/// \returns Local y coordinate as a float.
	float getY() const;

	/// \brief Get node's local z position.
	/// \returns Local z coordinate as a float.
	float getZ() const;
	
	/// \brief Get the node's local x axis as 3d vector.
	/// \returns A normalized 3D vector of the node's local x axis direction.
	glm::vec3 getXAxis() const;

	/// \brief Get the node's local y axis as 3d vector.
	/// \returns A normalized 3D vector of the node's local y axis direction.
	glm::vec3 getYAxis() const;

	/// \brief Get the node's local z axis as 3d vector.
	/// \returns A normalized 3D vector of the node's local z axis direction.
	glm::vec3 getZAxis() const;
	
	/// \brief Get direction of node's side aka local x axis, as 3d vector.
	/// \returns A normalized 3D vector of the node's local x axis direction.
	glm::vec3 getSideDir() const;
	
	/// \brief Get direction the node looks at aka local -z axis, as 3d vector.
	/// \returns A normalized 3D vector of the node's local -z axis direction.
	glm::vec3 getLookAtDir()const;

	/// \brief Get direction of node's top aka local y axis, as 3d vector.
	/// \returns A normalized 3D vector of the node's local y axis direction.
	glm::vec3 getUpDir() const;
	
	/// \brief Get pitch of node, aka the rotation along local x axis.
	/// \returns The rotation around the local x axis in degrees, as a float.
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", float getPitch() const);
	
	/// \brief Get heading of node, aka the rotation along local y axis.
	/// \returns The rotation around the local y axis in degrees, as a float.
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", float getHeading() const);
	
	/// \brief Get roll of node, aka the rotation along local z axis.
	/// \returns The rotation around the local z axis in degrees, as a float.
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", float getRoll() const);

	/// \brief Get pitch of node, aka the rotation along local x axis.
	/// \returns The rotation around the local x axis in degrees, as a float.
	float getPitchDeg() const;

	/// \brief Get heading of node, aka the rotation along local y axis.
	/// \returns The rotation around the local y axis in degrees, as a float.
	float getHeadingDeg() const;

	/// \brief Get roll of node, aka the rotation along local z axis.
	/// \returns The rotation around the local z axis in degrees, as a float.
	float getRollDeg() const;

	/// \brief Get pitch of node, aka the rotation along local x axis.
	/// \returns The rotation around the local x axis in degrees, as a float.
	float getPitchRad() const;

	/// \brief Get heading of node, aka the rotation along local y axis.
	/// \returns The rotation around the local y axis in degrees, as a float.
	float getHeadingRad() const;

	/// \brief Get roll of node, aka the rotation along local z axis.
	/// \returns The rotation around the local z axis in degrees, as a float.
	float getRollRad() const;
	
	/// \brief Get the local orientation of the node as a quaternion.
	/// \returns A quaternion of local orientation (useful for complex rotations)
	glm::quat getOrientationQuat() const;
	
	/// \brief Get local orientation of node in degrees around x, y, and z axes.
	/// \returns The local x, y and z axes orientation in degrees, as a 3D vector.
	OF_DEPRECATED_MSG("Use the Deg/Rad version", glm::vec3 getOrientationEuler() const);

	/// \brief Get local orientation of node in degrees around x, y, and z axes.
	/// \returns The local x, y and z axes orientation in degrees, as a 3D vector.
	glm::vec3 getOrientationEulerDeg() const;

	/// \brief Get local orientation of node in degrees around x, y, and z axes.
	/// \returns The local x, y and z axes orientation in degrees, as a 3D vector.
	glm::vec3 getOrientationEulerRad() const;
	
	/// \brief Get local scale of node in xyz axes where 1 is default.
	/// \returns The local scale in the xyz axes where 1 = 100% of size.
	glm::vec3 getScale() const;

	/// \brief Get node's local transformations (position, orientation, scale).
	/// \returns A refrence to mat4 containing node's local transformations.
	/// \sa https://open.gl/transformations
	const glm::mat4& getLocalTransformMatrix() const;
	
	// TODO: optimize and cache these
	// (parent would need to know about its children so it can inform them 
	// to update their global matrices if it itself transforms)
	
	/// \brief Get node's global transformations (position, orientation, scale).
	/// \returns A refrence to mat4 containing node's global transformations.
	/// \sa https://open.gl/transformations
	glm::mat4 getGlobalTransformMatrix() const;
	
	/// \brief Get node's global position as a 3D vector.
	/// \returns A 3D vector with the global coordinates.
	glm::vec3 getGlobalPosition() const;
	
	/// \brief Get the global orientation of the node as a quaternion.
	/// \returns An quaternion of the global orientations(useful for complex rotations)
	glm::quat getGlobalOrientation() const;
	
	/// \brief Get global scale of node in xyz axes where 1 is default.
	/// \returns The global scale in the xyz axes where 1 = 100% of size.
	glm::vec3 getGlobalScale() const;

	/// \}	
	/// \name Setters
	/// \{
	
	/// \brief Set the local position of the node using xyz coordinates.
	/// \param param0 Desired local x coordinate as a float.
	/// \param param1 Desired local y coordinate as a float.
	/// \param param2 Desired local z coordinate as a float.
	void setPosition(float px, float py, float pz);
	
	/// \brief Set the local position of the node using a 3D vector of coordinates.
	/// \param param0 Desired local xyz coordinates as ref to 3D vector.	
	void setPosition(const glm::vec3& p);
	
	/// \brief Set the global position of the node using xyz coordinates.
	/// \param param0 Desired global x coordinate as a float.
	/// \param param1 Desired global y coordinate as a float.
	/// \param param2 Desired global z coordinate as a float.	
	void setGlobalPosition(float px, float py, float pz);

	/// \brief Set the global position of the node using a 3D vector of coordinates.
	/// \param param0 Desired global xyz coordinates as ref to 3D vector.		
	void setGlobalPosition(const glm::vec3& p);

	/// \brief Set local orientation with a quaternion.
	/// \param param0 Desired local orientation as ref to an glm::quat.
	void setOrientation(const glm::quat& q);
	
	/// \brief Set local orientation with xyz euler angles.
	/// \param param0 Desired local xyz angles in degrees, as ref to 3D vector. 
	/// \note Using euler angles can cause gimbal lock.
	/// \sa https://en.wikipedia.org/wiki/Gimbal_lock
	void setOrientation(const glm::vec3& eulerAngles);
	
	/// \brief Set global orientation with a quaternion.
	/// \param param0 Desired global orientation as ref to an glm::quat.
	void setGlobalOrientation(const glm::quat& q);

	/// \brief Set local uniform scale (x, y, and z are equally scaled).
	/// \param param0 Desired scale for all axes as a float where 1 = 100%.
	void setScale(float s);
	
	/// \brief Set local scale for xyz axes individually.
	/// \param param0 Desired local scale for x axis as a float where 1 = 100%.
	/// \param param1 Desired local scale for y axis as a float where 1 = 100%.
	/// \param param2 Desired local scale for z axis as a float where 1 = 100%.
	void setScale(float sx, float sy, float sz);
	
	/// \brief Set local scale for xyz axes individually with a 3D vector.
	/// \param param0 Desired local scale for all axes as ref to 3D vector where 1 = 100%.
	void setScale(const glm::vec3& s);
	
    /// \}
	/// \name Modifiers
	/// \{

	/// \brief Move node by relative amount with xyz coordinates.
	/// \param param0 Desired relative position change along x axis as a float.
	/// \param param1 Desired relative position change along y axis as a float.
	/// \param param2 Desired relative position change along z axis as a float.
	void move(float x, float y, float z);			
	
	/// \brief Move node by relative amount with xyz as ref to 3D vector.
	/// \param param0 Desired relative position change along all axes as ref to 3D vector.
	void move(const glm::vec3& offset);

	/// \brief Move node left+right relative to current position (in local x axis).
	/// \param param0 Desired relative position change along local x axis as float.
	void truck(float amount);

	/// \brief Move node up+down relative to current position (in local y axis).
	/// \param param0 Desired relative position change along local y axis as float.
	void boom(float amount);

	/// \brief Move node backward+forward relative to current position (in local z axis).
	/// \param param0 Desired relative position change along local z axis as float.					
	void dolly(float amount);						
	
	/// \brief Tilt up+down relative to current orientation (around local x axis).
	/// \param param0 Desired relative rotation change along local x axis in degrees as float.
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void tilt(float degrees));

	/// \brief Tilt up+down relative to current orientation (around local x axis).
	/// \param param0 Desired relative rotation change along local x axis in degrees as float.
	void tiltDeg(float degrees);

	/// \brief Tilt up+down relative to current orientation (around local x axis).
	/// \param param0 Desired relative rotation change along local x axis in radians as float.
	void tiltRad(float radians);
	
	/// \brief Rotate left+right relative to current orientation (around local y axis).
	/// \param param0 Desired relative rotation change along local y axis in degrees as float.
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void pan(float degrees));

	/// \brief Rotate left+right relative to current orientation (around local y axis).
	/// \param param0 Desired relative rotation change along local y axis in degrees as float.
	void panDeg(float degrees);

	/// \brief Rotate left+right relative to current orientation (around local y axis).
	/// \param param0 Desired relative rotation change along local y axis in radians as float.
	void panRad(float radians);

	/// \brief Roll left+right relative to current orientation (around local z axis).
	/// \param param0 Desired relative rotation change along local z axis in degrees as float.
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void roll(float degrees));

	/// \brief Roll left+right relative to current orientation (around local z axis).
	/// \param param0 Desired relative rotation change along local z axis in degrees as float.
	void rollDeg(float degrees);

	/// \brief Roll left+right relative to current orientation (around local z axis).
	/// \param param0 Desired relative rotation change along local z axis in radians as float.
	void rollRad(float radians);
	
	/// \brief Rotate relative to current orientation by quaternion.
	/// \param param0 Desired relative rotation change as a ref to quaternion.
	void rotate(const glm::quat& q);
	
	/// \brief Rotate relative to current orientation around arbitrary axis.
	/// \param param0 Desired relative angle change in degrees as float.	
	/// \param param1 Desired axis to rotate around as a ref to cartesian 3D Vector.	
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void rotate(float degrees, const glm::vec3& v));

	/// \brief Rotate relative to current orientation around arbitrary axis.
	/// \param param0 Desired relative angle change in degrees as float.
	/// \param param1 Desired axis to rotate around as a ref to cartesian 3D Vector.
	void rotateDeg(float degrees, const glm::vec3& v);

	/// \brief Rotate relative to current orientation around arbitrary axis.
	/// \param param0 Desired relative angle change in radians as float.
	/// \param param1 Desired axis to rotate around as a ref to cartesian 3D Vector.
	void rotateRad(float radians, const glm::vec3& v);

	/// \brief Rotate relative to current orientation around arbitrary axis.
	/// \param param0 Desired relative angle change in degrees as float.	
	/// \param param1 X angle of the axis to rotate around in degrees as float.
	/// \param param2 Y angle of the axis to rotate around in degrees as float.
	/// \param param3 Z angle of the axis to rotate around in degrees as float.
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void rotate(float degrees, float vx, float vy, float vz));

	/// \brief Rotate relative to current orientation around arbitrary axis.
	/// \param param0 Desired relative angle change in degrees as float.
	/// \param param1 X angle of the axis to rotate around in degrees as float.
	/// \param param2 Y angle of the axis to rotate around in degrees as float.
	/// \param param3 Z angle of the axis to rotate around in degrees as float.
	void rotateDeg(float degrees, float vx, float vy, float vz);

	/// \brief Rotate relative to current orientation around arbitrary axis.
	/// \param param0 Desired relative angle change in radians as float.
	/// \param param1 X angle of the axis to rotate around in degrees as float.
	/// \param param2 Y angle of the axis to rotate around in degrees as float.
	/// \param param3 Z angle of the axis to rotate around in degrees as float.
	void rotateRad(float radians, float vx, float vy, float vz);
	
	/// \brief Rotate relative to current orientation by quaternion around point.
	/// \param param0 Desired relative rotation change as a ref to quaternion.
	/// \param param1 Point to rotate around in local xyz coordinates as ref to 3D vector.	
	void rotateAround(const glm::quat& q, const glm::vec3& point);

	/// \brief Rotate relative to current orientation around arbitrary axis around point.
	/// \param param0 Desired relative angle change in degrees as float.
	/// \param param1 The arbitrary axis to rotate around as ref to cartesian 3D vector.
	/// \param param2 Point to rotate around in local xyz coordinates as ref to 3D vector.
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void rotateAround(float degrees, const glm::vec3& axis, const glm::vec3& point));
	
	/// \brief Rotate relative to current orientation around arbitrary axis around point.
	/// \param param0 Desired relative angle change in degrees as float.    
	/// \param param1 The arbitrary axis to rotate around as ref to cartesian 3D vector.
    /// \param param2 Point to rotate around in local xyz coordinates as ref to 3D vector.
	void rotateAroundDeg(float degrees, const glm::vec3& axis, const glm::vec3& point);

	/// \brief Rotate relative to current orientation around arbitrary axis around point.
	/// \param param0 Desired relative angle change in degrees as float.
	/// \param param1 The arbitrary axis to rotate around as ref to cartesian 3D vector.
	/// \param param2 Point to rotate around in local xyz coordinates as ref to 3D vector.
	void rotateAroundRad(float radians, const glm::vec3& axis, const glm::vec3& point);

    /// \brief Orient node to look at point (-z axis pointing to global position).
    /// \param param0 XYZ coordinates of point to look at as ref to 3D vector.
    /// \note This version calculates the up vector automatically to try to keep
    /// 	  it relatively consistant with the original angle.
	void lookAt(const glm::vec3& lookAtPosition);

    /// \brief Orient node to look at point (-z axis pointing to global position).
    /// \param param0 XYZ coordinates of point to look at as ref to 3D vector.
    /// \param param1 The desired up axis as a cartesian 3D vector.
	void lookAt(const glm::vec3& lookAtPosition, glm::vec3 upVector);

    /// \brief Orient node to look at another node (-z axis pointing at other node).
    /// \param param0 A reference to the node to look at.
    /// \note This version calculates the up vector automatically to try to keep
    /// 	  it relatively consistant with the original angle.
    void lookAt(const ofNode& lookAtNode);
	
    /// \brief Orient node to look at another node (-z axis pointing at other node).
    /// \param param0 A reference to the node to look at.
    /// \param param1 The desired up axis as a ref to cartesian 3D vector.
	void lookAt(const ofNode& lookAtNode, const glm::vec3& upVector);
	
	/// \brief Orbit node around a global position at a specific radius.
	/// \param param0 The longitudinal position of the node in degrees as float.
	/// \param param1 The latitudinal position of the node in degrees as float.
	/// \param param2 The desired radius from the position in degrees as float.
	/// \param param3 The global position to orbit around as ref to 3D vector. Default = (0, 0, 0).	
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void orbit(float longitude, float latitude, float radius, const glm::vec3& centerPoint = glm::vec3(0, 0, 0)));

	/// \brief Orbit node around another node at a specific radius.
	/// \param param0 The longitudinal position of the node in degrees as float.
	/// \param param1 The latitudinal position of the node in degrees as float.
	/// \param param2 The desired radius from the other node in degrees as float.
	/// \param param3 A reference to the node to rotate around.	
	OF_DEPRECATED_MSG("Use the Deg/Rad version", void orbit(float longitude, float latitude, float radius, ofNode& centerNode));

	/// \brief Orbit node around a global position at a specific radius.
	/// \param param0 The longitudinal position of the node in degrees as float.
	/// \param param1 The latitudinal position of the node in degrees as float.
	/// \param param2 The desired radius from the position in degrees as float.
	/// \param param3 The global position to orbit around as ref to 3D vector. Default = (0, 0, 0).
	void orbitDeg(float longitude, float latitude, float radius, const glm::vec3& centerPoint = glm::vec3(0, 0, 0));

	/// \brief Orbit node around another node at a specific radius.
	/// \param param0 The longitudinal position of the node in degrees as float.
	/// \param param1 The latitudinal position of the node in degrees as float.
	/// \param param2 The desired radius from the other node in degrees as float.
	/// \param param3 A reference to the node to rotate around.
	void orbitDeg(float longitude, float latitude, float radius, ofNode& centerNode);

	/// \brief Orbit node around a global position at a specific radius.
	/// \param param0 The longitudinal position of the node in radians as float.
	/// \param param1 The latitudinal position of the node in radians as float.
	/// \param param2 The desired radius from the position in radians as float.
	/// \param param3 The global position to orbit around as ref to 3D vector. Default = (0, 0, 0).
	void orbitRad(float longitude, float latitude, float radius, const glm::vec3& centerPoint = glm::vec3(0, 0, 0));

	/// \brief Orbit node around another node at a specific radius.
	/// \param param0 The longitudinal position of the node in radians as float.
	/// \param param1 The latitudinal position of the node in radians as float.
	/// \param param2 The desired radius from the other node in radians as float.
	/// \param param3 A reference to the node to rotate around.
	void orbitRad(float longitude, float latitude, float radius, ofNode& centerNode);
	
	/// \}
	/// \name OpenGL Transformation
	/// \{
	
	/// \brief Set opengl renderer's modelview matrix to this nodes transform.
	/// \param param0 A pointer to the renderer you want to set to this node's transform;
	/// \note If you want to draw something at the position+orientation+scale of this node,
	/// call ofNode::transform(); write your draw code, and ofNode::restoreTransform();
	/// OR A simpler way is to extend ofNode and override ofNode::customDraw();
	void transformGL(ofBaseRenderer * renderer = nullptr) const;
	
	/// \brief Restore opengl renderer's previous modelview transform matrix.
	/// \param param0 A pointer to the renderer you want to restore transformation to;	
	void restoreTransformGL(ofBaseRenderer * renderer = nullptr) const;
	
	
	/// \brief Reset this node's transformations, position, rotation and scale.
	void resetTransform();
	
	/// \}
	/// \name Drawing
	/// \{

	/// \brief If you extend ofNode and wish to change the way it draws, extend this.
	/// \param param0 A pointer to the renderer you want to draw to.
	/// \note Try to not use global functions for rendering and instead use the passed
	/// renderer.
	virtual void customDraw(const ofBaseRenderer * renderer) const;
	
	/// \brief If you extend ofNode and wish to change the way it draws, extend this.
	/// \note Try to not use global functions for rendering and instead use the passed
	/// renderer.
	virtual void customDraw();

	
	/// \brief Draw the node as a white cube with xyz axes. 
	/// \note do NOT override this. 
	/// It transforms the node to its position+orientation+scale
	/// and calls the virtual 'customDraw' method above which you CAN override.
	virtual void draw() const;

	/// \}
	
protected:
	void createMatrix();
	void updateAxis();
	
	/// \brief classes extending ofNode can override this method to get
	/// notified when the position changed.
	virtual void onPositionChanged() {}

	/// \brief classes extending ofNode can override this methods to get notified when the orientation changed.
	virtual void onOrientationChanged() {}

	/// \brief classes extending ofNode can override this methods to get notified when the scale changed.
	virtual void onScaleChanged() {}

	ofNode * parent = nullptr;

private:
	void onParentPositionChanged(glm::vec3 & position) {onPositionChanged();}
	void onParentOrientationChanged(glm::quat & orientation) {onOrientationChanged();}
	void onParentScaleChanged(glm::vec3 & scale) {onScaleChanged();}

	ofParameter<glm::vec3> position;
	ofParameter<glm::quat> orientation;
	ofParameter<glm::vec3> scale;

	std::array<glm::vec3,3> axis;

	glm::mat4 localTransformMatrix;
	bool legacyCustomDrawOverrided;
	std::set<ofNode*> children;

	void addListener(ofNode & node);
	void removeListener(ofNode & node);
//	glm::mat4 globalTransformMatrix;
};

#line 0 "../libs/openFrameworks/3d/ofCamera.h"
#pragma once


/* #include "ofNode.h" */
/* #include "ofRectangle.h" */

class ofRectangle;

// \todo Use the public API of ofNode for all transformations
// \todo add set projection matrix
// \todo support for left handed or right handed?

/// \brief A basic camera object for interacting with objects in 3D space.
/// \author Memo Akten, MSA Visuals Ltd. 2011
class ofCamera : public ofNode {
public:
	/// \name Constructor and Destructor
	/// \{
    
    /// \brief Construct a default camera.
	ofCamera();

    /// \brief Destroy the camera.
    virtual ~ofCamera();
	
	/// \}
    /// \name Camera Settings
    /// \{

	/// \brief Set the field of view for a perspective camera.
	///
	/// This sets the vertical field of view for the camera, in degrees.
	/// This only operates with perspective cameras, and will have no effect 
	/// with cameras in orthographic mode. 
	///
	/// \param f The desired field of view for the camera, in degrees.
	void setFov(float f);
	
	void setNearClip(float f);

    void setFarClip(float f);
	
	/// \brief Set the "lens offset" applied to this camera.
	/// 
	/// Ordinarily, the camera is pointed straight down the center of its view
    /// frustum. However, it is possible to orient the camera towards a location
    /// offset from the center of its frustum. This is called an "assymetric
    /// frustum" and is used (for example) in stereo views.  It is acheived by
    /// applying an offset to the center of projection.  This function sets this
    /// offset from an ofVec2f argument.  For more information see
    /// <http://www.orthostereo.com/geometryopengl.html>.
	///
	/// \param lensOffset The "lens offset" to apply to this camera, encoded in
    ///     an ofVec2f.
	void setLensOffset(const glm::vec2 & lensOffset);
	
	/// \brief Set the recommended aspect ratio for a perspective camera.
	///
	/// Sets the aspect ratio of the camera to the desired float, and forces the
    /// use of aspect ratio calculations.  Currently only used with perspective
    /// cameras. The default value (and the value used with orthographic
    /// cameras) is the ratio of the viewport's width to the viewport's height.
	/// 
	/// \param aspectRatio The desired aspect ratio, e.g. 1.3333, 1.6, etc.
	void setAspectRatio(float aspectRatio);
	
	/// \brief Set whether or not the aspect ratio of this camera is forced to a non-default setting.
	/// 
	/// The camera's aspect ratio, by default, is the aspect ratio of your
    /// viewport.  If you have set a non-default value (with
    /// ofCamera::setAspectRatio()), you can toggle whether or not this value is
    /// applied.
	/// 
	/// \param forceAspectRatio Whether or not this camera should use an aspect ratio you have set yourself.  
	void setForceAspectRatio(bool forceAspectRatio);

	/// \brief Get the camera's field of view, in degrees.
	///
	/// Get the camera's vertical field of view, in degrees.  This is only
    /// meaningful for perspective cameras.
	///
	/// \returns The camera's field of view, in degrees.
	float getFov() const { return fov; };
	
    float getNearClip() const { return nearClip; };

    float getFarClip() const { return farClip; };
	
	/// \brief Get the "lens offset" applied to this camera, encoded as an ofVec2f.
	/// 
	/// Ordinarily, the camera is pointed straight down the center of its view
    /// frustum.  However, it is possible to orient the camera towards a
    /// location offset from the center of its frustum.  This is called an
    /// "asymetric frustum" and is used (for example) in stereo views.  It is
    /// acheived by applying an offset to the center of projection.  This
    /// function returns the offset that has been applied, as an ofVec2f.  For
    /// more information see http://www.orthostereo.com/geometryopengl.html.
	///
	/// \returns The "lens offset" applied to this camera, encoded in an ofVec2f.
	glm::vec2 getLensOffset() const { return lensOffset; };
	
	/// \brief Get the boolean state which indicates whether the aspect ratio of this camera is forced to a non-default setting.
	/// 
	/// \returns A boolean: whether or not this camera's aspect ratio is set to a non-default value. 
	bool getForceAspectRatio() const {return forceAspectRatio;};
	
	/// \brief Get the aspect ratio of this camera's viewport.
	///
	/// Returns the aspect ratio of this camera's viewport. Usually this will be
    /// the ratio of the width to height of your display. Intended for
    /// perspective cameras.
	/// 
	/// \returns The aspect ratio of this camera's viewport.
	float getAspectRatio() const {return aspectRatio; };

	/// \}
	/// \name OpenGL Setup
	/// \{
	
	void setupPerspective(bool vFlip = true, float fov = 60, float nearDist = 0, float farDist = 0, const glm::vec2 & lensOffset = glm::vec2(0.0f, 0.0f));

	void setupOffAxisViewPortal(const glm::vec3 & topLeft, const glm::vec3 & bottomLeft, const glm::vec3 & bottomRight);
	
	void setVFlip(bool vflip);

    bool isVFlipped() const;

	void enableOrtho();

    void disableOrtho();

    bool getOrtho() const;
	
	float getImagePlaneDistance(const ofRectangle & viewport = ofRectangle()) const;

	/// \}
	/// \name Rendering
	/// \{

	/// \brief Begins rendering with the camera.
    ///
    /// ~~~~{.cpp}
    /// void draw() {
    ///     // Begin rendering from the camera's perspective.
    ///     camera.begin();
    ///
    ///     ofLine(0, 0, ofGetWidth(), ofGetHeight());
    ///     // Additional rendering ...
    ///
    ///     // End rendering form the camera's perspective.
    ///     camera.end();
    /// }
    /// ~~~~
    /// \param viewport The camera's rendering viewport.
	virtual void begin(){
		begin(getViewport());
	}
	virtual void begin(const ofRectangle & viewport);

    /// \brief Ends rendering with the camera.
	virtual void end();
	
	/// \}
	/// \name OpenGL Matrix
	/// \{

	/// \brief Access the projection matrix.
    /// \returns the current 4x4 projection matrix.
	glm::mat4 getProjectionMatrix() const{
		return getProjectionMatrix(getViewport());
	}
	glm::mat4 getProjectionMatrix(const ofRectangle & viewport) const;

    /// \brief Access the model view matrix.
    /// \returns the current 4x4 model view matrix.
	glm::mat4 getModelViewMatrix() const;

    /// \todo getModelViewProjectionMatrix()
	glm::mat4 getModelViewProjectionMatrix(const ofRectangle & viewport) const;
	glm::mat4 getModelViewProjectionMatrix() const{
		return getModelViewProjectionMatrix(getViewport());
	}

    /// \}
    /// \name Coordinate Conversion
    /// \{
	
    /// \brief Obtain the screen coordinates of a point in the 3D world.
	///
	/// Takes an (X,Y,Z) point in your 3D world, encoded as an ofVec3f, 
	/// and returns the location (also as an ofVec3f) where this point would
    /// appear on your (two-dimensional) display. The screen position's "Z
    /// coordinate" is set to be the same as your camera's.
	///
	/// \param WorldXYZ A 3D point in the world, whose screen coordinates you wish to know. 
	/// \param viewport (Optional) A viewport. The default is ofGetCurrentViewport(). 
	/// \returns An ofVec3f containing the screen coordinates of your 3D point of interest. 
	glm::vec3 worldToScreen(glm::vec3 WorldXYZ, const ofRectangle & viewport) const;
	glm::vec3 worldToScreen(glm::vec3 WorldXYZ) const{
		return worldToScreen(WorldXYZ, getViewport());
	}
	
	/// \brief Obtain the coordinates, in the 3D world, of a 2D point presumed to be on your screen.
	///
	/// Takes a pixel location on your screen, encoded in an ofVec3f, 
	/// and returns (also as an ofVec3f) the 3D world coordinates of that point.
	/// You'll also need to specify a Z value when providing your screen point. 
	/// This Z value is interpreted as a distance into or away from the screen. 
	///
	/// \param ScreenXYZ A point on your screen, whose 3D world coordinates you wish to know.
	glm::vec3 screenToWorld(glm::vec3 ScreenXYZ, const ofRectangle & viewport) const;
	glm::vec3 screenToWorld(glm::vec3 ScreenXYZ) const{
		return screenToWorld(ScreenXYZ, getViewport());
	}
	
	/// \todo worldToCamera()
	glm::vec3 worldToCamera(glm::vec3 WorldXYZ, const ofRectangle & viewport) const;
	glm::vec3 worldToCamera(glm::vec3 WorldXYZ) const{
		return worldToCamera(WorldXYZ, getViewport());
	}

	/// \todo cameraToWorld()
	glm::vec3 cameraToWorld(glm::vec3 CameraXYZ, const ofRectangle & viewport) const;
	glm::vec3 cameraToWorld(glm::vec3 CameraXYZ) const{
		return cameraToWorld(CameraXYZ, getViewport());
	}

	/// \}
	/// \name Renderer
	/// \{
    
    void setRenderer(std::shared_ptr<ofBaseRenderer> renderer);
	
	/// \}

	/// \brief Draw a visual representation of the camera's frustum
	/// \note  This will only be visible when the camera drawing its 
	///        frustum is viewed through another camera.
	void drawFrustum(const ofRectangle & viewport) const;
	void drawFrustum() const{
		drawFrustum(getViewport());
	}

protected:
	ofRectangle getViewport() const;
	std::shared_ptr<ofBaseRenderer> getRenderer() const;
	void calcClipPlanes(const ofRectangle & viewport);
	
private:
	bool isOrtho;
	float fov;
	float nearClip;
	float farClip;
	glm::vec2 lensOffset;
	bool forceAspectRatio;
	float aspectRatio; // only used when forceAspect=true, = w / h
	bool vFlip;
	std::shared_ptr<ofBaseRenderer> renderer;
};


#line 0 "../libs/openFrameworks/3d/ofEasyCam.h"
#pragma once

/* #include "ofCamera.h" */
/* #include "ofEvents.h" */
/* #include "ofRectangle.h" */
#include "glm/gtc/quaternion.hpp"

/// \brief A super simple camera for interacting with objects in 3D space.
class ofEasyCam : public ofCamera {
public:
    /// \name Constructor and Destructor
	/// \{
    
    /// \brief Create a default camera.
	ofEasyCam();

	/// \}
	/// \name Rendering
	/// \{

	virtual void begin(const ofRectangle & viewport);
	virtual void begin(){
		begin(getViewport());
	}

    /// \brief Reset the camera position and orientation.
	void reset();
	
	/// \}
	/// \name Camera Target
	/// \{

    /// \brief Set the camera's target.
    /// \param target The position of the target.
	void setTarget(const glm::vec3& target);

    /// \brief Set the camera's target.
    /// \param target The position of the target.
	void setTarget(ofNode& target);

    /// \brief Get the camera's target node reference.
    /// \returns a reference the the camera's target node.
	const ofNode& getTarget() const;

	/// \}
	/// \name Getters and Setters
	/// \{

    /// \brief Set the camera's distance to the target.
    /// \param distance The distance to the target.
	void setDistance(float distance);

    /// \brief Get the distance to the target.
    /// \returns the distance to the target.
	float getDistance() const;

    /// \brief Set the camera's drag coefficient.
    ///
    /// Drag is affects how quickly the camera starts up and slows down when
    /// a user interacts with its position using a pointer.
    ///
    /// \param drag The normalized coefficient value between 0 and 1.
	void setDrag(float drag);

    /// \brief Get the camera's drag coefficient.
    /// \returns the camera's drag coefficient.
	float getDrag() const;

	/// \brief Enable or disable camera autodistance.
    ///
    /// Allow the camera to attempt to set the distance based on the camera's
    /// current viewpoirt.
    ///
    /// \param bAutoDistance true to enable auto distance.
    void setAutoDistance(bool bAutoDistance);

    void setEvents(ofCoreEvents & events);
	
	/// \brief Set the input sensitivity of the rotation.
	/// X and Y axes - when the value is 1.0, moving the mouse from one side to
	/// the other of the arcball (min(viewport.width, viewport.height)) will
	/// rotate 180 degrees. When the value is 0.5, the rotation will be 90
	/// degrees.
	/// \param value Scales the xyz axes rotation factor by these values.
	void setRotationSensitivity(float x, float y, float z);
	void setRotationSensitivity(const glm::vec3& sensitivity);
	
    /// \brief Set the input sensitivity of the translation.
    /// \param value Scales the xyz axes translation factor by these values.
    void setTranslationSensitivity(float x, float y, float z);
	void setTranslationSensitivity(const glm::vec3& sensitivity);
    /// \brief Set the key used to switch between camera rotation and translation.
    ///
    /// Translation will only happen when the translation key is pressed.
    ///
    /// \param key The key code for the translation key.
    /// \todo char is not the right data type for this. Should be int.
	void setTranslationKey(char key);

    /// \brief Get the current translation key code.
    /// \returns the current translation key code.
    char getTranslationKey() const;

    /// \}
    /// \name Mouse Input
    /// \{

    /// \brief Enable mouse camera control.
	void enableMouseInput();

    /// \brief Disable mouse camera control.
	void disableMouseInput();

    /// \brief Determine if mouse camera control is enabled.
    /// \todo Rename to isMouseInputEnabled().
    /// \returns true iff mouse camera control is enabled.
	bool getMouseInputEnabled() const;

    /// \brief Enable the mouse's middle button for camera control.
	void enableMouseMiddleButton();

    /// \brief Disable the mouse's middle button for camera control.
	void disableMouseMiddleButton();

    /// \brief Determine if the middle mouse button is enabled.
    /// \todo Rename to isMouseMiddleButtonEnabled().
    /// \returns true iff the mouse's middle button is enabled.
	bool getMouseMiddleButtonEnabled() const;

	/// \}

	/// Uses Y axis relative to the camera orientation
	///
	/// By default the Y axis used for interactive rotation
	/// is vec3(0,1,0) or whatever is set as up axis using
	/// setUpAxis
	void setRelativeYAxis(bool relative=true);

	/// Determine if the Y axis is set to be relative to the 
	/// camera orientation
	bool getRelativeYAxis() const;

	/// Set the camera fixed up axis for interactive
	/// manipulation.
	void setUpAxis(const glm::vec3 & up);

	/// Get the up axis.
	const glm::vec3 & getUpAxis() const;

	void enableInertia();
	void disableInertia();

	/// Determine if intertia is enabled.
	bool getInertiaEnabled() const;

	/// Set the area bounds for mouse control.
	/// Uses the full viewport by default.
	void setControlArea(const ofRectangle & controlArea);

	/// Clears the area bounds for mouse control so that 
	/// the full viewport is used.
	void clearControlArea();

	/// Returns the area bounds used for mouse control.
	ofRectangle getControlArea() const;
	
	/// Transformation types available for mouse interaction.
	enum TransformType{
		TRANSFORM_NONE,
		TRANSFORM_ROTATE,
		TRANSFORM_TRANSLATE_XY,
		TRANSFORM_TRANSLATE_Z,
		TRANSFORM_SCALE
	};

	void addInteraction(TransformType type, int mouseButton, int key = -1);
	void removeInteraction(TransformType type, int mouseButton, int key = -1);
	bool hasInteraction(TransformType type, int mouseButton, int key = -1);
	bool hasInteraction(int mouseButton, int key);
	void removeAllInteractions();
private:
	void setDistance(float distance, bool save);

	ofNode target;

	bool bEnableMouseMiddleButton = true;
	bool bApplyInertia = false;
	
	bool bInsideArcball = false;
	bool bMouseInputEnabled = true;
	bool bDistanceSet = false;
	bool bAutoDistance = true;
	bool bEventsSet = false;
	bool bIsScrolling = false;
	float lastDistance = 0.f;

	
	float drag = 0.9f;
	
	/// rot and translated are used as a temporary values shared between the mouse callbacks and the update method.
	/// How much the camera needs to be rotated.
	glm::vec3 rot;
	/// How much the camera needs to be translated.
	glm::vec3 translate;
	
	/// \brief Sensitivity
	/// These varibles determine how sensitive is the interaction.
	/// High values mean faster and bigger movements/rotations.
	/// Low Values mean more presicion.
	glm::vec3 sensitivityTranslate;
	glm::vec3 sensitivityRot;
	float     sensitivityScroll = 1.0f;

	/// \brief The previous mouse position.
	glm::vec2 prevMouse;
	/// \brief The mouse velocity (mouse position delta).
	glm::vec2 mouseVel;
	
	void updateRotation();
	void updateTranslation();
	void update(ofEventArgs & args);
	void mousePressed(ofMouseEventArgs & mouse);
	void mouseReleased(ofMouseEventArgs & mouse);
	void mouseScrolled(ofMouseEventArgs & mouse);
	void updateMouse(const glm::vec2 & mouse);
	/// \brief Returns the up axis vector;
	glm::vec3 up() const;

    /// \brief The key used to differentiate between translation and rotation.
	char doTranslationKey = 'm';

    /// \brief The time of the last pointer down event.
	unsigned long lastTap = 0;

    /// \brief The current rotation quaternion.
	glm::quat curRot;
	
	/// \name On Press cache
	/// \{
	/// \brief camera properties when the mouse is pressed.

	glm::vec3 lastPressAxisX;
	glm::vec3 lastPressAxisY;
	glm::vec3 lastPressAxisZ;
	glm::vec3 lastPressPosition;
	glm::quat lastPressOrientation;
	glm::vec2 lastPressMouse;
	
	/// \}
	
	/// \brief the current viewport.
	ofRectangle viewport;

	/// \brief If set, the area mouse control is bound to.
	ofRectangle controlArea;

	ofEventListeners listeners;
	ofCoreEvents * events = nullptr;

	bool bRelativeYAxis = false;
	bool doInertia = false;
	glm::vec3 upAxis{0,1,0};
	
	glm::vec2 mouseAtScroll;
	
	/// \brief previous far and near clip.
	float prevFarClip, prevNearClip;
	
	TransformType currentTransformType;
	/// \brief This struct holds the combination of mouse button and key press that will trigger a specific interaction.
	struct interaction{
		interaction():mouseButton(0), key(-1), transformType(TRANSFORM_NONE){}
		interaction(TransformType type, int _mouseButton, int _key = -1):mouseButton(_mouseButton), key(_key), transformType(type){}
		int mouseButton;
		int key;
		TransformType transformType;
	};
	std::vector<interaction> interactions;
};

#line 0 "../libs/openFrameworks/3d/ofMesh.h"
// This include guard is not a pragma once on purpose
// so some IDEs are happy include this file back form the corresponding inl
#ifndef OF_MESH_H
#define OF_MESH_H

/* #include "ofConstants.h" */
/* #include "ofGLUtils.h" */

template<class V, class N, class C, class T>
class ofMeshFace_;

/// \brief Represents a set of vertices in 3D spaces with normals, colors,
/// and texture coordinates at those points.
///
/// Each of these different properties is stored in a vector.
/// Vertices are passed to your graphics card and your graphics card fill in
/// the spaces in between them in a processing usually called the rendering
/// pipeline. The rendering pipeline goes more or less like this:
///
/// 1. Say how you're going to connect all the points.
/// 2. Make some points.
/// 3. Say that you're done making points.
///
/// You may be thinking: I'll just make eight vertices and voila: a cube.
/// Not so quick. There's a hitch and that hitch is that the OpenGL renderer
/// has different ways of connecting the vertices that you pass to it and none
/// are as efficient as to only need eight vertices to create a cube.
///
/// You've probably seen a version of the following image somewhere before.
/// ![PRIMATIVES](3d/primitives_new-640x269.gif)
/// Generally you have to create your points to fit the drawing mode that
/// you've selected because of whats called winding.
/// A vertex gets connected to another vertex in the order that the mode does
/// its winding and this means that you might need multiple vertices in a given
/// location to create the shape you want. The cube, for example, requires
/// eighteen vertices, not the eight that you would expect.
/// If you note the order of vertices in the GL chart above you'll see that all
/// of them use their vertices slightly differently (in particular you should
/// make note of the GL_TRIANGLE_STRIP example). Drawing a shape requires that
/// you keep track of which drawing mode is being used and which order
/// your vertices are declared in.
///
/// If you're thinking: it would be nice if there were an abstraction layer
/// for this you're thinking right. Enter the mesh, which is really just
/// an abstraction of the vertex and drawing mode that we started with
/// but which has the added bonus of managing the draw order for you.
/// That may seem insignificant at first, but it provides some real benefits
/// when working with complex geometry.
///
/// A very typical usage is something like the following:
///
/// ~~~~{.cpp}
/// ofMesh mesh;
/// for (int y = 0; y < height; y++){
/// 	for (int x = 0; x<width; x++){
/// 		mesh.addVertex(glm::vec3(x,y,0)); // make a new vertex
/// 		mesh.addColor(ofFloatColor(0,0,0));  // add a color at that vertex
/// 	}
/// }
/// ~~~~
///
/// Now it's important to make sure that each vertex is correctly connected
/// with the other vertices around it. This is done using indices, which you
/// can set up like so:
/// ~~~~{.cpp}
/// for (int y = 0; y<height-1; y++){
/// 	for (int x=0; x<width-1; x++){
/// 		mesh.addIndex(x+y*width);				// 0
/// 		mesh.addIndex((x+1)+y*width);			// 1
/// 		mesh.addIndex(x+(y+1)*width);			// 10
///
/// 		mesh.addIndex((x+1)+y*width);			// 1
/// 		mesh.addIndex((x+1)+(y+1)*width);		// 11
/// 		mesh.addIndex(x+(y+1)*width);			// 10
/// 	}
/// }
/// ~~~~
template<class V, class N, class C, class T>
class ofMesh_{
public:

	/// \name Construction
	/// \{

	/// \brief This creates the mesh,
	/// using OF_PRIMITIVE_TRIANGLES without any initial vertices.
	ofMesh_();

	/// \brief This allows to you to use one of the other ofPrimitiveModes:
	/// OF_PRIMITIVE_TRIANGLES, OF_PRIMITIVE_TRIANGLE_STRIP,
	/// OF_PRIMITIVE_TRIANGLE_FAN, OF_PRIMITIVE_LINES, OF_PRIMITIVE_LINE_STRIP,
	/// OF_PRIMITIVE_LINE_LOOP, OF_PRIMITIVE_POINTS.
	/// See [ofGLUtils](../gl/ofGLUtils.htm) for more information on these types.
	ofMesh_(ofPrimitiveMode mode, const std::vector<V>& verts);

	virtual ~ofMesh_(){}

	void setFromTriangles( const std::vector<ofMeshFace_<V,N,C,T>>& tris, bool bUseFaceNormal=false );

	/// \}
	/// \name Mesh Mode
	/// \{

	/// \brief Allows you to set the ofPrimitiveMode.
	/// The available modes are OF_PRIMITIVE_TRIANGLES,
	/// OF_PRIMITIVE_TRIANGLE_STRIP, OF_PRIMITIVE_TRIANGLE_FAN,
	/// OF_PRIMITIVE_LINES, OF_PRIMITIVE_LINE_STRIP,
	/// OF_PRIMITIVE_LINE_LOOP, OF_PRIMITIVE_POINTS
	void setMode(ofPrimitiveMode mode);

	/// \\returns the primitive mode that the mesh is using.
	ofPrimitiveMode getMode() const;

	/// \}
	/// \name Primitive constructor helper methods
	/// \{
	static ofMesh_ plane(float width, float height, int columns=2, int rows=2,
		ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP);
	static ofMesh_ sphere(float radius, int res=12,
		ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP);
	static ofMesh_ icosahedron(float radius);
	static ofMesh_ icosphere(float radius, std::size_t iterations=2);
	///
	///	\brief A helper method that returns a cylinder made of triangles.
	/// The resolution settings for the radius, height, and cap are optional
	/// (they are set at a default of 12 segments around the radius, 6 segments
	/// in the height, and 2 on the cap). You have the option to cap the
	/// cylinder or not. The only valid modes are the default
	/// OF_PRIMITIVE_TRIANGLE_STRIP and OF_PRIMITIVE_TRIANGLES.
	///	~~~~{.cpp}
	///	ofMesh mesh;
	///	mesh = ofMesh::cylinder(100.0, 200.0);
	///	~~~~
	///
	///	![image of a simple cylinder](3d/cylinder.jpg)
	///
	static ofMesh_ cylinder(float radius, float height, int radiusSegments=12,
		int heightSegments=6, int numCapSegments=2, bool bCapped = true,
		ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP);

	/// \brief A helper method that returns a cone made of triangles.
	/// The resolution settings for the radius, height, and cap are optional
	/// (they are set at a default of 12 segments around the radius, 6 segments
	/// in the height, and 2 on the cap). The only valid modes are the default
	/// OF_PRIMITIVE_TRIANGLE_STRIP and OF_PRIMITIVE_TRIANGLES.
	/// ~~~~{.cpp}
	/// ofMesh mesh;
	/// mesh = ofMesh::cone(100.0, 200.0);
	/// ~~~~
	///
	/// ![image of a simple cone](3d/cone.jpg)
	static ofMesh_ cone(float radius, float height, int radiusSegments=12,
		int heightSegments=6, int capSegments=2,
		ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP);

	/// \brief A helper method that returns a box made of triangles.
	/// The resolution settings for the width and height are optional
	/// (they are both set at a default of 2 triangles per side).
	/// ~~~~{.cpp}
	/// ofMesh mesh;
	/// mesh = ofMesh::box(200.0, 200.0, 200.0);
	/// ~~~~
	///
	/// ![image of a simple box](3d/box.jpg)
	static ofMesh_ box(float width, float height, float depth, int resX=2,
		int resY=2, int resZ=2);

	/// \returns an ofMesh representing an XYZ coordinate system.
	static ofMesh_ axis(float size=1.0);

	/// \}
	/// \name Vertices
	/// \{

	/// \brief Add a new vertex at the end of the current list of vertices.
	/// It is important to remember that the order the vertices are added to
	/// the list determines how they link they form the polygons and strips
	/// (assuming you do not change their indeces). See the ofMesh class
	/// description for details.
	void addVertex(const V& v);

	/// \brief Add a vector of vertices to a mesh, allowing you to push out
	/// many at once rather than adding one at a time. The vector of vertices
	/// is added after the end of the current vertices list.
	void addVertices(const std::vector<V>& verts);

	/// \brief Add an array of vertices to the mesh.
	/// Because you are using a pointer to the array you also have to define
	/// the length of the array as an int (amt). The vertices are added at the
	/// end of the current vertices list.
	void addVertices(const V* verts, std::size_t amt);

	/// \brief Removes the vertex at the index in the vector.
	void removeVertex(ofIndexType index);

	void setVertex(ofIndexType index, const V& v);

	/// \brief Removes all the vertices.
	void clearVertices();

	/// \brief Removes all the vertices, colors, and indices from the mesh.
	void clear();


	/// \returns the size of the vertices vector for the mesh.
	/// This will tell you how many vertices are contained in the mesh.
	std::size_t getNumVertices() const;

	/// \returns a pointer to the vertices that the mesh contains.
	V* getVerticesPointer();

	/// \returns a pointer to the vertices that the mesh contains.
	const V* getVerticesPointer() const;

	/// \returns the vertex at the index.
	V getVertex(ofIndexType i) const;

	/// \returns the vector that contains all of the vertices of the mesh.
	std::vector<V> & getVertices();

	/// \returns the vector that contains all of the vertices of the mesh.
	const std::vector<V> & getVertices() const;

	/// \returns Whether the mesh has any vertices.
	bool hasVertices() const;

	/// \brief Add the vertices, normals, texture coordinates and indices of one mesh onto another mesh.
	/// Everything from the referenced mesh is simply added at the end
	/// of the current mesh's lists.
	void append(const ofMesh_ & mesh);

	void mergeDuplicateVertices();

	/// \returns a ofVec3f defining the centroid of all the vetices in the mesh.
	V getCentroid() const;


	/// \}

	/// \name Normals
	/// \{

	/// \\returns the normal at the index in the normals vector.
	N getNormal(ofIndexType i) const;

	/// \brief Add a normal to the mesh as a 3D vector,
	/// typically perpendicular to the plane of the face. A normal is a vector
	/// that defines how a surface responds to lighting, i.e. how it is lit.
	/// The amount of light reflected by a surface is proportional to the angle
	/// between the light's direction and the normal. The smaller the angle the
	/// brighter the surface will look. See the normalsExample for advice on
	/// computing the normals.
	/// addNormal adds the 3D vector to the end of the list, so you need to
	/// make sure you add normals at the same index of the matching vertex.
	void addNormal(const N& n);

	/// \brief Add a vector of normals to a mesh,
	/// allowing you to push out many normals at once rather than
	/// adding one at a time. The vector of normals is added after the end of
	/// the current normals list.
	void addNormals(const std::vector<N>& norms);

	/// \brief Add an array of normals to the mesh.
	/// Because you are using a pointer to the array you also have to define
	/// the length of the array as an std::size_t (amt). The normals are added at the
	/// end of the current normals list.
	void addNormals(const N* norms, std::size_t amt);

	/// \brief Remove a normal.
	void removeNormal(ofIndexType index);

	/// \todo Documentation.
	void setNormal(ofIndexType index, const N& n);

	/// \brief Remove all the normals.
	void clearNormals();

	/// \brief This will tell you how many normals are contained in the mesh.
	/// \returns the size of the normals vector for the mesh.
	std::size_t getNumNormals() const;

	/// \returns a pointer to the normals that the mesh contains.
	N* getNormalsPointer();

	/// \returns a pointer to the normals that the mesh contains.
	const N* getNormalsPointer() const;

	/// Use this if you plan to change the normals as part of this call as it
	/// will force a reset of the cache.
	/// \returns the vector that contains all of the normals of the mesh,
	/// if it has any.
	std::vector<N> & getNormals();

	/// \returns the vector that contains all of the normals of the mesh, if
	/// it has any. (read only)
	const std::vector<N> & getNormals() const;

	/// /returnsWhether the mesh has any normals.
	bool hasNormals() const;

	/// \brief Enable mesh normals.
	/// Use disableNormals() to turn normals off.
	/// Normals are enabled by default when they are added to the mesh.
	virtual void enableNormals();
	/// \brief Disable mesh normals.
	/// Use enableNormals() to turn normals back on.
	virtual void disableNormals();
	virtual bool usingNormals() const;

	void smoothNormals( float angle );
        
        /// \brief Duplicates vertices and updates normals to get a low-poly look.
        void flatNormals();

	/// \}
	/// \name Faces
	/// \{

	/// \returns the vector that contains all of the faces of the mesh. This isn't currently implemented.
	ofMeshFace_<V,N,C,T> getFace(ofIndexType faceId) const;

	/// \brief Get normals for each face
	/// As a default it only calculates the normal for the face as a whole but
	/// by setting (perVertex = true) it will return the same normal value for
	/// each of the three vertices making up a face.
	/// \returns a vector containing the calculated normals of each face in the mesh.
	std::vector<N> getFaceNormals( bool perVetex=false) const;

	/// \returns the mesh as a vector of unique ofMeshFace_s
	/// a list of triangles that do not share vertices or indices
	const std::vector<ofMeshFace_<V,N,C,T>> & getUniqueFaces() const;

	/// \}
	/// \name Colors
	/// \{

	/// \brief Get the color at the index in the colors vector.
	/// \returns the color at the index in the colors vector.
	C getColor(ofIndexType i) const;

	/// \brief This adds a color to the mesh,
	/// the color will be associated with the vertex in the same position.
	void addColor(const C& c);

	/// \brief This adds colors using a reference to a vector of ofColors.
	/// For each color in the vector, this will put the colors at the corresponding vertex.
	void addColors(const std::vector<C>& cols);

	/// \brief This adds a pointer of colors to the ofMesh instance with the amount passed as the second parameter.
	void addColors(const C* cols, std::size_t amt);

	/// \brief Remove a color at the index in the colors vector.
	void removeColor(ofIndexType index);

	/// \brief Set the color at the index in the colors vector.
	void setColor(ofIndexType index, const C& c);

	/// \brief Clear all the colors.
	void clearColors();

	/// \returns the size of the colors vector for the mesh.
	/// This will tell you how many colors are contained in the mesh.
	std::size_t getNumColors() const;

	/// Use this if you plan to change the colors as part of this call as it will force a reset of the cache.
	/// \returns a pointer that contains all of the colors of the mesh, if it has any.
	C* getColorsPointer();

	/// \returns a pointer that contains all of the colors of the mesh, if it has any. (read only)
	const C* getColorsPointer() const;

	/// Use this if you plan to change the colors as part of this call as it will force a reset of the cache.
	/// \returns the vector that contains all of the colors of the mesh, if it has any.
	std::vector<C> & getColors();

	/// \returns the vector that contains all of the colors of the mesh, if it has any. (read only)
	const std::vector<C> & getColors() const;

	/// /returns Whether the mesh has any colors.
	bool hasColors() const;

	/// \brief Enable mesh colors.
	/// Use disableColors() to turn colors off.
	/// Colors are enabled by default when they are added to the mesh.
	virtual void enableColors();

	/// \brief Disable mesh colors.
	/// Use enableColors() to turn colors back on.
	virtual void disableColors();
	virtual bool usingColors() const;

	/// \}


	/// \name Texture Coordinates
	/// \{

	/// \returns the Vec2f representing the texture coordinate.
	/// Because OF uses ARB textures these are in pixels rather than
	/// 0-1 normalized coordinates.
	T getTexCoord(ofIndexType i) const;

	/// \brief Add a Vec2f representing the texture coordinate.
	/// Because OF uses ARB textures these are in pixels rather than
	/// 0-1 normalized coordinates.
	void addTexCoord(const T& t);

	/// \brief Add a vector of texture coordinates to a mesh,
	/// allowing you to push out many at once rather than adding one at a time.
	/// The vector of texture coordinates is added after the end of the current
	/// texture coordinates list.
	void addTexCoords(const std::vector<T>& tCoords);

	/// \brief  Add an array of texture coordinates to the mesh.
	/// Because you are using a pointer to the array you also have to define
	/// the length of the array as an std::size_t (amt).
	/// The texture coordinates are added at the end of the current texture
	/// coordinates list.
	void addTexCoords(const T* tCoords, std::size_t amt);

	/// \brief  Remove a Vec2f representing the texture coordinate.
	void removeTexCoord(ofIndexType index);
	void setTexCoord(ofIndexType index, const T& t);

	/// \brief  Clear all the texture coordinates.
	void clearTexCoords();

	/// \brief This will tell you how many texture coordinates are contained in the mesh.
	/// \returns the size of the texture coordinates vector for the mesh.
	std::size_t getNumTexCoords() const;

	/// \returns a pointer to the texture coords that the mesh contains.
	T* getTexCoordsPointer();

	/// \brief Get a pointer to the ofVec2f texture coordinates that the mesh contains.
	const T* getTexCoordsPointer() const;

	/// \brief Get a vector representing the texture coordinates of the mesh
	/// Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates.
	/// Use this if you plan to change the texture coordinates as part of this
	/// call as it will force a reset of the cache.
	/// \returns a vector of Vec2f representing the texture coordinates for the whole mesh.
	std::vector<T> & getTexCoords();

	/// Because OF uses ARB textures these are in pixels rather than 0-1 normalized coordinates.
	/// \returns a vector of Vec2f representing the texture coordinates for the whole mesh. (read only)
	const std::vector<T> & getTexCoords() const;

	/// /returns Whether the mesh has any textures assigned to it.
	bool hasTexCoords() const;

	/// \brief Enable mesh textures.
	/// Use disableTextures() to turn textures off.
	/// Textures are enabled by default when they are added to the mesh.
	virtual void enableTextures();

	/// \brief Disable mesh textures.
	/// Use enableTextures() to turn textures back on.
	virtual void disableTextures();
	virtual bool usingTextures() const;


	/// \}

	/// \name Indices
	/// \{

	/// \brief Allow you to set up the indices automatically when you add a vertex.
	void setupIndicesAuto();

	/// \brief Use this if you plan to change the indices as part of this call as it
	/// will force a reset of the cache.
	/// \returns the vector that contains all of the indices of the mesh, if it has any.
	std::vector<ofIndexType> & getIndices();


	/// \returns the index from the index vector. Each index represents the index of the vertex in the vertices vector. This determines the way that the vertices are connected into the polgoynon type set in the primitiveMode.
	ofIndexType getIndex(ofIndexType i) const;


	/// Add an index to the index vector. Each index represents the order of
	/// connection for  vertices. This determines the way that the vertices are
	/// connected according to the polygon type set in the primitiveMode.
	/// It important to note that a particular vertex might be used for several
	/// faces and so would be referenced several times in the index vector.
	/// ~~~~{.cpp}
	/// ofMesh mesh;
	/// mesh.setMode(OF_PRIMITIVE_TRIANGLES);
	/// mesh.addVertex(glm::vec3(0,-200,0));
	/// mesh.addVertex(glm::vec3(200, 0, 0 ));
	/// mesh.addVertex(glm::vec3(-200, 0, 0 ));
	/// mesh.addVertex(glm::vec3(0, 200, 0 ));
	/// mesh.addIndex(0); //connect the first vertex we made, v0
	/// mesh.addIndex(1); //to v1
	/// mesh.addIndex(2); //to v2 to complete the face
	/// mesh.addIndex(1); //now start a new face beginning with v1
	/// mesh.addIndex(2); //that is connected to v2
	/// mesh.addIndex(3); //and we complete the face with v3
	/// ~~~~

	/// Will give you this shape:
	/// ![image of basic use of indices](3d/index.jpg)
	void addIndex(ofIndexType i);

	/// \brief This adds a vector of indices.
	void addIndices(const std::vector<ofIndexType>& inds);

	/// \brief This adds indices to the ofMesh by pointing to an array of indices.
	/// The "amt" defines the length of the array.
	void addIndices(const ofIndexType* inds, std::size_t amt);

	/// \brief Removes an index.
	void removeIndex(ofIndexType index);

	/// \brief This sets the index at i.
	void setIndex(ofIndexType index, ofIndexType val);

	/// \brief Remove all the indices of the mesh.
	/// This means that your mesh will be a point cloud.
	void clearIndices();

	/// \brief This will tell you how many indices are contained in the mesh.
	/// \returns the size of the indices vector for the mesh.
	std::size_t getNumIndices() const;

	/// \returns a pointer to the indices that the mesh contains.
	ofIndexType* getIndexPointer();

	/// \returns a pointer to the indices that the mesh contains.
	const ofIndexType* getIndexPointer() const;


	/// \returns the vector that contains all of the indices of the mesh, if it has any. (read only)
	const std::vector<ofIndexType> & getIndices() const;

	/// /returns Whether the mesh has any indices assigned to it.
	bool hasIndices() const;

	/// \brief Adding a triangle means using three of the vertices that have already been added to create a triangle.
	/// This is an easy way to create triangles in the mesh. The indices refer to the index of the vertex in the vector of vertices.
	void addTriangle(ofIndexType index1, ofIndexType index2, ofIndexType index3);

	/// \brief Enable mesh indices.
	/// Use disableIndices() to turn indices off.
	/// Indices are enabled by default when they are added to the mesh.
	virtual void enableIndices();

	/// \brief Disable mesh indices.
	/// Use enableIndices() to turn indices back on.
	virtual void disableIndices();
	virtual bool usingIndices() const;

	void setColorForIndices( ofIndexType startIndex, ofIndexType endIndex, C color );

	/// The new mesh includes the mesh mode, colors, textures, and normals of the original mesh (assuming any were added).
	/// \returns a mesh made up of a range of indices from startIndex to the endIndex.
	ofMesh_<V,N,C,T> getMeshForIndices( ofIndexType startIndex, ofIndexType endIndex ) const;
	ofMesh_<V,N,C,T> getMeshForIndices( ofIndexType startIndex, ofIndexType endIndex, ofIndexType startVertIndex, ofIndexType endVertIndex ) const;


	/// \}
	/// \name Drawing
	/// \{

	/// \brief This allows you draw just the vertices, meaning that you'll have a point cloud.
	void drawVertices() const;

	/// \brief This draws the mesh as GL_LINES, meaning that you'll have a wireframe.
	void drawWireframe() const;

	/// \brief This draws the mesh as faces, meaning that you'll have a collection of faces.
	void drawFaces() const;

	/// \brief This draws the mesh using its primitive type, meaning that if
	/// you set them up to be triangles, this will draw the triangles.
	void draw() const;

	/// \brief This draws the mesh using a defined renderType,
	/// overriding the renderType defined with setMode().
	virtual void draw(ofPolyRenderMode renderType) const;

	/// \}
	/// \name Saving and loading
	/// \{

	/// \brief Loads a mesh from a file located at the provided path into the mesh.
	/// This will replace any existing data within the mesh.
	///
	/// It expects that the file will be in the [PLY Format](http://en.wikipedia.org/wiki/PLY_(file_format)).
	/// It will only load meshes saved in the PLY ASCII format; the binary format is not supported.
    void load(const std::filesystem::path& path);

	///  \brief Saves the mesh at the passed path in the [PLY Format](http://en.wikipedia.org/wiki/PLY_(file_format)).
	///
	///  There are two format options for PLY: a binary format and an ASCII format.
	///  By default, it will save using the ASCII format.
	///  Passing ``true`` into the ``useBinary`` parameter will save it in the binary format.
	///
	///  If you're planning on reloading the mesh into ofMesh, ofMesh currently only supports loading the ASCII format.
	///
	///  For more information, see the [PLY format specification](http://paulbourke.net/dataformats/ply/).
    void save(const std::filesystem::path& path, bool useBinary = false) const;

	/// \}

protected:

	/// \returns If the vertices of the mesh have changed, been added or removed.
	bool haveVertsChanged();

	/// \returns If the normals of the mesh have changed, been added or removed.
	bool haveNormalsChanged();

	/// \returns If the colors of the mesh have changed, been added or removed.
	bool haveColorsChanged();

	/// \returns If the texture coords of the mesh have changed, been added or removed.
	bool haveTexCoordsChanged();

	/// \returns If the indices of the mesh have changed, been added or removed.
	bool haveIndicesChanged();

private:

	std::vector<V> vertices;
	std::vector<C> colors;
	std::vector<N> normals;
	std::vector<T> texCoords;
	std::vector<ofIndexType> indices;

	// this variables are only caches and returned always as const
	// mutable allows to change them from const methods
	mutable std::vector<ofMeshFace_<V,N,C,T>> faces;
	mutable bool bFacesDirty;

	bool bVertsChanged, bColorsChanged, bNormalsChanged, bTexCoordsChanged,
		bIndicesChanged;
	ofPrimitiveMode mode;

	bool useColors;
	bool useTextures;
	bool useNormals;
	bool useIndices;

//	ofMaterial *mat;
};


/// \brief An ofMeshFace_ is a face on one of the ofPrimitive instances.
/// In the ofPrimitive a face consists of 3 points connected together.
///
/// You can get a vector of ofMeshFace_ instances from any ofPrimitive like so:
///
/// ~~~~{.cpp}
///
/// vector<ofMeshFace_> triangles = box.getMesh().getUniqueFaces();
///
/// ~~~~
///
/// They're very handy for manipulating individual vertices or doing strange/fun
/// things with intersection and boundary testing, among many many other things.
///
/// this is always a triangle
template<class V, class N, class C, class T>
class ofMeshFace_ {
public:
	ofMeshFace_();

	const N & getFaceNormal() const;

	void setVertex( ofIndexType index, const V& v );
	const V& getVertex( ofIndexType index ) const;

	void setNormal( ofIndexType index, const N& n );
	const N& getNormal( ofIndexType  index ) const;

	void setColor( ofIndexType index, const C& color );
	const C& getColor(ofIndexType  index) const;

	void setTexCoord( ofIndexType index, const T& tCoord );
	const T& getTexCoord( ofIndexType index ) const;

	void setHasColors( bool bColors );
	void setHasNormals( bool bNormals );
	void setHasTexcoords( bool bTexcoords );

	bool hasColors() const;
	bool hasNormals() const;
	bool hasTexcoords() const;

private:
	void calculateFaceNormal() const;
	bool bHasNormals, bHasColors, bHasTexcoords;

	// this variables are only caches and returned always as const
	// mutable allows to change them from const methods
	mutable bool bFaceNormalDirty;
	mutable N faceNormal;
	V vertices[3];
	N normals[3];
	C colors[3];
	T texCoords[3];
};

/* #include "ofMesh.inl" */

using ofMesh = ofMesh_<ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType>;
using ofMeshFace = ofMeshFace_<ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType>;

#endif

#line 0 "../libs/openFrameworks/3d/ofMesh.inl"
#ifndef OF_MESH_H
/* #include "ofMesh.h" */
#endif

/* #include "ofAppRunner.h" */
/* #include "ofGraphicsBaseTypes.h" */
/* #include "ofVectorMath.h" */
/* #include "ofMath.h" */
/* #include "ofLog.h" */
#include <map>

//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T>::ofMesh_(){
	mode = OF_PRIMITIVE_TRIANGLES;
	bVertsChanged = false;
	bColorsChanged = false;
	bNormalsChanged = false;
	bTexCoordsChanged = false;
	bIndicesChanged = false;
	bFacesDirty = false;
	useColors = true;
	useTextures = true;
	useNormals = true;
	useIndices = true;
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T>::ofMesh_(ofPrimitiveMode mode, const std::vector<V>& verts){
	bColorsChanged = false;
	bNormalsChanged = false;
	bTexCoordsChanged = false;
	useColors = true;
	useTextures = true;
	useNormals = true;
	useIndices = true;
	setMode(mode);
	addVertices(verts);
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::clear(){
	if(!vertices.empty()){
		bVertsChanged = true;
		vertices.clear();
	}
	if(!colors.empty()){
		bColorsChanged = true;
		colors.clear();
	}
	if(!normals.empty()){
		bNormalsChanged = true;
		normals.clear();
	}
	if(!texCoords.empty()){
		bTexCoordsChanged = true;
		texCoords.clear();
	}
	if(!indices.empty()){
		bIndicesChanged = true;
		indices.clear();
	}
	bFacesDirty = true;
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::haveVertsChanged(){
	if(bVertsChanged){
		bVertsChanged = false;
		return true;
	}else{
		return false;
	}
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::haveColorsChanged(){
	if(bColorsChanged){
		bColorsChanged = false;
		return true;
	}else{
		return false;
	}
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::haveNormalsChanged(){
	if(bNormalsChanged){
		bNormalsChanged = false;
		return true;
	}else{
		return false;
	}
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::haveTexCoordsChanged(){
	if(bTexCoordsChanged){
		bTexCoordsChanged = false;
		return true;
	}else{
		return false;
	}
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::haveIndicesChanged(){
	if(bIndicesChanged){
		bIndicesChanged = false;
		return true;
	}else{
		return false;
	}
}




//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::hasVertices() const{
	return !vertices.empty();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::hasColors() const{
	return !colors.empty();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::hasNormals() const{
	return !normals.empty();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::hasTexCoords() const{
	return !texCoords.empty();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::hasIndices() const{
	return !indices.empty();
}

//ADDERS



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addVertex(const V& v){
	vertices.push_back(v);
	bVertsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addVertices(const std::vector<V>& verts){
	vertices.insert(vertices.end(),verts.begin(),verts.end());
	bVertsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addVertices(const V* verts, std::size_t amt){
	vertices.insert(vertices.end(),verts,verts+amt);
	bVertsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addColor(const C& c){
	colors.push_back(c);
	bColorsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addColors(const std::vector<C>& cols){
	colors.insert(colors.end(),cols.begin(),cols.end());
	bColorsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addColors(const C* cols, std::size_t amt){
	colors.insert(colors.end(),cols,cols+amt);
	bColorsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addNormal(const N& n){
	normals.push_back(n);
	bNormalsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addNormals(const std::vector<N>& norms){
	normals.insert(normals.end(),norms.begin(),norms.end());
	bNormalsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addNormals(const N* norms, std::size_t amt){
	normals.insert(normals.end(),norms,norms+amt);
	bNormalsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addTexCoord(const T& t){
	//TODO: figure out if we add to all other arrays to match
	texCoords.push_back(t);
	bTexCoordsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addTexCoords(const std::vector<T>& tCoords){
	texCoords.insert(texCoords.end(),tCoords.begin(),tCoords.end());
	bTexCoordsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addTexCoords(const T* tCoords, std::size_t amt){
	texCoords.insert(texCoords.end(),tCoords,tCoords+amt);
	bTexCoordsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofIndexType ofMesh_<V,N,C,T>::getIndex(ofIndexType i) const{
	return indices[i];
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addIndex(ofIndexType i){
	indices.push_back(i);
	bIndicesChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addIndices(const std::vector<ofIndexType>& inds){
	indices.insert(indices.end(),inds.begin(),inds.end());
	bIndicesChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addIndices(const ofIndexType* inds, std::size_t amt){
	indices.insert(indices.end(),inds,inds+amt);
	bIndicesChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::addTriangle(ofIndexType index1, ofIndexType index2, ofIndexType index3) {
	addIndex(index1);
	addIndex(index2);
	addIndex(index3);
}

//REMOVERS


//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::removeVertex(ofIndexType index){
  if(index >= vertices.size()){
	ofLogError("ofMesh") << "removeVertex(): ignoring out of range index " << index << ", number of vertices is" << vertices.size();
  }else{
	vertices.erase(vertices.begin() + index);
	bVertsChanged = true;
	bFacesDirty = true;
  }
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::removeNormal(ofIndexType index){
  if(index >= normals.size()){
	ofLogError("ofMesh") << "removeNormal(): ignoring out of range index " << index << ", number of normals is" << normals.size();
  }else{
	normals.erase(normals.begin() + index);
	bNormalsChanged = true;
	bFacesDirty = true;
  }
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::removeColor(ofIndexType index){
  if(index >= colors.size()){
	ofLogError("ofMesh") << "removeColor(): ignoring out of range index " << index << ", number of colors is" << colors.size();
  }else{
	colors.erase(colors.begin() + index);
	bColorsChanged = true;
	bFacesDirty = true;
  }
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::removeTexCoord(ofIndexType index){
  if(index >= texCoords.size()){
	ofLogError("ofMesh") << "removeTexCoord(): ignoring out of range index " << index << ", number of tex coords is" << texCoords.size();
  }else{
	texCoords.erase(texCoords.begin() + index);
	bTexCoordsChanged = true;
	bFacesDirty = true;
  }
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::removeIndex(ofIndexType index){
  if(index >= indices.size()){
	ofLogError("ofMesh") << "removeIndex(): ignoring out of range index " << index << ", number of indices is" << indices.size();
  }else{
	indices.erase(indices.begin() + index);
	bIndicesChanged = true;
	bFacesDirty = true;
  }
}


//GETTERS


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofPrimitiveMode ofMesh_<V,N,C,T>::getMode() const{
	return mode;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
V ofMesh_<V,N,C,T>::getVertex(ofIndexType i) const{
	return vertices[i];
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
N ofMesh_<V,N,C,T>::getNormal(ofIndexType i) const{
	return normals[i];
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
C ofMesh_<V,N,C,T>::getColor(ofIndexType i) const{
	return colors[i];
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
T ofMesh_<V,N,C,T>::getTexCoord(ofIndexType i) const{
	return texCoords[i];
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::size_t ofMesh_<V,N,C,T>::getNumVertices() const{
	return vertices.size();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::size_t ofMesh_<V,N,C,T>::getNumColors() const{
	return colors.size();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::size_t ofMesh_<V,N,C,T>::getNumNormals() const{
	return normals.size();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::size_t ofMesh_<V,N,C,T>::getNumTexCoords() const{
	return texCoords.size();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::size_t ofMesh_<V,N,C,T>::getNumIndices() const{
	return indices.size();
}

/*


//--------------------------------------------------------------
template<class V, class N, class C, class T>
int ofPrimitive::getNumIndicesSolid(){
	return indicesSolid.size();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
int ofPrimitive::getNumIndicesWire(){
	return indicesWire.size();
}
 */



//--------------------------------------------------------------
template<class V, class N, class C, class T>
V* ofMesh_<V,N,C,T>::getVerticesPointer(){
	return vertices.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
C* ofMesh_<V,N,C,T>::getColorsPointer(){
	return colors.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
N* ofMesh_<V,N,C,T>::getNormalsPointer(){
	return normals.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
T* ofMesh_<V,N,C,T>::getTexCoordsPointer(){
	return texCoords.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofIndexType* ofMesh_<V,N,C,T>::getIndexPointer(){
	return indices.data();
}




//--------------------------------------------------------------
template<class V, class N, class C, class T>
const V* ofMesh_<V,N,C,T>::getVerticesPointer() const{
	return vertices.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
const C* ofMesh_<V,N,C,T>::getColorsPointer() const{
	return colors.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
const N* ofMesh_<V,N,C,T>::getNormalsPointer() const{
	return normals.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
const T* ofMesh_<V,N,C,T>::getTexCoordsPointer() const{
	return texCoords.data();
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
const ofIndexType * ofMesh_<V,N,C,T>::getIndexPointer() const{
	return indices.data();
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::vector<V> & ofMesh_<V,N,C,T>::getVertices(){
	bVertsChanged = true;
	bFacesDirty = true;
	return vertices;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::vector<C> & ofMesh_<V,N,C,T>::getColors(){
	bColorsChanged = true;
	bFacesDirty = true;
	return colors;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::vector<N> & ofMesh_<V,N,C,T>::getNormals(){
	bNormalsChanged = true;
	bFacesDirty = true;
	return normals;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::vector<T> & ofMesh_<V,N,C,T>::getTexCoords(){
	bTexCoordsChanged = true;
	bFacesDirty = true;
	return texCoords;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::vector<ofIndexType> & ofMesh_<V,N,C,T>::getIndices(){
	bIndicesChanged = true;
	bFacesDirty = true;
	return indices;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const std::vector<V> & ofMesh_<V,N,C,T>::getVertices() const{
	return vertices;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const std::vector<C> & ofMesh_<V,N,C,T>::getColors() const{
	return colors;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const std::vector<N> & ofMesh_<V,N,C,T>::getNormals() const{
	return normals;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const std::vector<T> & ofMesh_<V,N,C,T>::getTexCoords() const{
	return texCoords;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const std::vector<ofIndexType> & ofMesh_<V,N,C,T>::getIndices() const{
	return indices;
}

/*


//--------------------------------------------------------------
template<class V, class N, class C, class T>
GLuint* ofPrimitive::getSolidIndexPointer(){
	return &indicesSolid[0];
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
GLuint* ofPrimitive::getWireIndexPointer(){
	return &indicesWire[0];
}
 */

/*


//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::vector<int>& ofPrimitive::getFace(int faceNum){
	switch(mode){
		//GL_QUADS
		indices[faceNum*4+0];
		indices[faceNum*4+1];
		indices[faceNum*4+2];
		indices[faceNum*4+3];

		//GL_TRIANGLES
		indices[faceNum*3+0];
		indices[faceNum*3+1];
		indices[faceNum*3+2];

		//GL_TRIANGLE_FAN
		// 1 element per fan
		indices[0];
		indices[faceNum+1];
		indices[faceNum+2];

		//GL_TRIANGLE_STRIP
		// 1 element per strip
		indices[faceNum+0];
		indices[faceNum+1];
		indices[faceNum+2];
		default:break;
	}
}
 */




//--------------------------------------------------------------
template<class V, class N, class C, class T>
V ofMesh_<V,N,C,T>::getCentroid() const {
	if(vertices.size() == 0) {
		ofLogWarning("ofMesh") << "getCentroid(): mesh has no vertices, returning glm::vec3(0, 0, 0)";
		return glm::vec3(0, 0, 0);
	}

	V sum;
	for(ofIndexType i = 0; i < vertices.size(); i++) {
		sum += vertices[i];
	}
	sum /= vertices.size();
	return sum;
}

//SETTERS


//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setMode(ofPrimitiveMode m){
	bIndicesChanged = true;
	mode = m;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setVertex(ofIndexType index, const V& v){
	vertices[index] = v;
	bVertsChanged = true;
	bIndicesChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setNormal(ofIndexType index, const N& n){
	normals[index] = n;
	bNormalsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setColor(ofIndexType index, const C& c){
	colors[index] = c;
	bColorsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setTexCoord(ofIndexType index, const T& t){
	texCoords[index] = t;
	bTexCoordsChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setIndex(ofIndexType index, ofIndexType  val){
	indices[index] = val;
	bIndicesChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setupIndicesAuto(){
	bIndicesChanged = true;
	bFacesDirty = true;
	indices.resize(vertices.size());
	for(ofIndexType i = 0; i < vertices.size();i++){
		indices[i]=i;
	}
}





//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::clearVertices(){
	vertices.clear();
	bVertsChanged=true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::clearNormals(){
	normals.clear();
	bNormalsChanged=true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::clearColors(){
	colors.clear();
	bColorsChanged=true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::clearTexCoords(){
	texCoords.clear();
	bTexCoordsChanged=true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::clearIndices(){
	indices.clear();
	bIndicesChanged = true;
	bFacesDirty = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::drawVertices() const{
	draw(OF_MESH_POINTS);
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::drawWireframe() const{
	draw(OF_MESH_WIREFRAME);
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::drawFaces() const{
	draw(OF_MESH_FILL);
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::draw() const{
	draw(OF_MESH_FILL);
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::draw(ofPolyRenderMode renderType) const{
	if(getNumVertices()==0) return;
	ofGetCurrentRenderer()->draw(*this,renderType,useColors,useTextures,useNormals);
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::enableColors(){
	useColors = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::enableTextures(){
	useTextures = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::enableNormals(){
	useNormals = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::enableIndices(){
	useIndices = true;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::disableColors(){
	useColors = false;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::disableTextures(){
	useTextures = false;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::disableNormals(){
	useNormals = false;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::disableIndices(){
	useIndices = false;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::usingColors() const{
	return useColors;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::usingTextures() const{
	return useTextures;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::usingNormals() const{
	return useNormals;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMesh_<V,N,C,T>::usingIndices() const{
	return useIndices;
}




//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::append(const ofMesh_<V,N,C,T> & mesh){
	ofIndexType prevNumVertices = static_cast<ofIndexType>(vertices.size());
	if(mesh.getNumVertices()){
		vertices.insert(vertices.end(),mesh.getVertices().begin(),mesh.getVertices().end());
	}
	if(mesh.getNumTexCoords()){
		texCoords.insert(texCoords.end(),mesh.getTexCoords().begin(),mesh.getTexCoords().end());
	}
	if(mesh.getNumColors()){
		colors.insert(colors.end(),mesh.getColors().begin(),mesh.getColors().end());
	}
	if(mesh.getNumNormals()){
		normals.insert(normals.end(),mesh.getNormals().begin(),mesh.getNormals().end());
	}
	if(mesh.getNumIndices()){
		for(auto index: mesh.getIndices()){
			indices.push_back(index+prevNumVertices);
		}
	}
}




//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::load(const std::filesystem::path& path){
	ofFile is(path, ofFile::ReadOnly);
	auto & data = *this;


	std::string error;
	ofBuffer buffer(is);
	auto backup = data;

	int orderVertices=-1;
	int orderIndices=-1;

	ofIndexType vertexCoordsFound=0;
	ofIndexType colorCompsFound=0;
	ofIndexType texCoordsFound=0;
	ofIndexType normalsCoordsFound=0;

	ofIndexType currentVertex = 0;
	ofIndexType currentFace = 0;

	bool colorTypeIsUChar = false; /// flag to distinguish between uchar (more common) and float (less common) color format in ply file
	
	enum State{
		Header,
		VertexDef,
		FaceDef,
		Vertices,
		Normals,
		Faces
	};

	
	enum Attribute {
		Position,
		Color,
		Normal,
		TexCoord,
	};
	
	std::vector<Attribute> meshDefinition;
	
	data.clear();
	State state = Header;

	int lineNum = 0;
	ofBuffer::Lines lines = buffer.getLines();
	ofBuffer::Line line = lines.begin();
	lineNum++;
	if(*line!="ply"){
		error = "wrong format, expecting 'ply'";
		goto clean;
	}

	line++;
	lineNum++;
	if(*line!="format ascii 1.0"){
		error = "wrong format, expecting 'format ascii 1.0'";
		goto clean;
	}

	for(;line != lines.end(); ++line){
		lineNum++;
		std::string lineStr = *line;
		if(lineStr.find("comment")==0 || lineStr.empty()){
			continue;
		}

		if((state==Header || state==FaceDef) && lineStr.find("element vertex")==0){
			state = VertexDef;
			orderVertices = MAX(orderIndices, 0)+1;
			data.getVertices().resize(ofTo<size_t>(lineStr.substr(15)));
			continue;
		}

		if((state==Header || state==VertexDef) && lineStr.find("element face")==0){
			state = FaceDef;
			orderIndices = MAX(orderVertices, 0)+1;
			data.getIndices().resize(ofTo<size_t>(lineStr.substr(13))*3);
			continue;
		}

		if(state==VertexDef && (lineStr.find("property float x")==0 || lineStr.find("property float y")==0 || lineStr.find("property float z")==0)){
			meshDefinition.push_back(Position);
			vertexCoordsFound++;
			continue;
		}

		if(state==VertexDef && (lineStr.find("property float r")==0 || lineStr.find("property float g")==0 || lineStr.find("property float b")==0 || lineStr.find("property float a")==0)){
			colorCompsFound++;
			meshDefinition.push_back(Color);
			data.getColors().resize(data.getVertices().size());
			continue;
		}

		if(state==VertexDef && (lineStr.find("property uchar red")==0 || lineStr.find("property uchar green")==0 || lineStr.find("property uchar blue")==0 || lineStr.find("property uchar alpha")==0)){
			colorTypeIsUChar = true;
			colorCompsFound++;
			meshDefinition.push_back(Color);
			data.getColors().resize(data.getVertices().size());
			continue;
		}

		if(state==VertexDef && (lineStr.find("property float u")==0 || lineStr.find("property float v")==0|| lineStr.find("property float s")==0 || lineStr.find("property float t")==0)){
			texCoordsFound++;
			meshDefinition.push_back(TexCoord);
			data.getTexCoords().resize(data.getVertices().size());
			continue;
		}

		if(state==VertexDef && (lineStr.find("property float nx")==0 || lineStr.find("property float ny")==0 || lineStr.find("property float nz")==0)){
			normalsCoordsFound++;
			meshDefinition.push_back(Normal);
			if (normalsCoordsFound==3) data.getNormals().resize(data.getVertices().size());
			continue;
		}

		if(state==FaceDef && lineStr.find("property list")!=0 && lineStr!="end_header"){
			error = "wrong face definition";
			goto clean;
		}

		if(lineStr=="end_header"){
			if(data.hasColors() && colorCompsFound!=3 && colorCompsFound!=4){
				error =  "data has color coordiantes but not correct number of components. Found " + ofToString(colorCompsFound) + " expecting 3 or 4";
				goto clean;
			}
			if(data.hasNormals() && normalsCoordsFound!=3){
				error = "data has normal coordiantes but not correct number of components. Found " + ofToString(normalsCoordsFound) + " expecting 3";
				goto clean;
			}
			if(!data.hasVertices()){
				ofLogWarning("ofMesh") << "load(): mesh loaded from \"" << path << "\" has no vertices";
			}
			if(orderVertices==-1) orderVertices=9999;
			if(orderIndices==-1) orderIndices=9999;

			if(orderVertices < orderIndices){
				state = Vertices;
			}else {
				state = Faces;
			}
			continue;
		}

		if(state==Vertices){
			if(data.getNumVertices()<=currentVertex){
				error = "found more vertices: " + ofToString(currentVertex+1) + " than specified in header: " + ofToString(data.getNumVertices());
				goto clean;
			}
			std::stringstream sline(lineStr);
			
			// read in a line of vertex elements
			// and split it into attributes,
			// based attribute order specified in file header
			ofIndexType vAttr = 0;
			ofIndexType nAttr = 0;
			ofIndexType tAttr = 0;
			ofIndexType cAttr = 0;
			for(auto s:meshDefinition){
				switch (s) {
					case Position:
						sline >> *(&data.getVertices()[currentVertex].x + (vAttr++)%vertexCoordsFound);
						break;
					case Color:
						if (colorTypeIsUChar){
							int c = 0;
							sline >> c;
							*(&data.getColors()[currentVertex].r + (cAttr++)%colorCompsFound) = c/255.f;
						} else {
							sline >> *(&data.getColors()[currentVertex].r + (cAttr++)%colorCompsFound);
						}
						break;
					case Normal:
						sline >> *(&data.getNormals()[currentVertex].x + (nAttr++)%normalsCoordsFound);
						break;
					case TexCoord:
						sline >> *(&data.getTexCoords()[currentVertex].x + (tAttr++)%texCoordsFound);
						break;
					default:
						break;
				}
			}
			if (vAttr != vertexCoordsFound || cAttr!= colorCompsFound || nAttr!=normalsCoordsFound || tAttr!=texCoordsFound){
				error = "attribute data does not match definition in header";
				goto clean;
			}
			
			currentVertex++;
			if(currentVertex==data.getNumVertices()){
				if(orderVertices<orderIndices){
					state = Faces;
				}else{
					state = Vertices;
				}
			}
			continue;
		}

		if(state==Faces){
			if(data.getNumIndices()/3<currentFace){
				error = "found more faces than specified in header";
				goto clean;
			}
			std::stringstream sline(lineStr);
			int numV;
			sline >> numV;
			if(numV!=3){
				error = "face not a triangle";
				goto clean;
			}
			ofIndexType i;
			sline >> i;
			data.getIndices()[currentFace*3] = i;
			sline >> i;
			data.getIndices()[currentFace*3+1] = i;
			sline >> i;
			data.getIndices()[currentFace*3+2] = i;

			currentFace++;
			if(currentFace==data.getNumIndices()/3){
				if(orderVertices<orderIndices){
					state = Vertices;
				}else{
					state = Faces;
				}
			}
			continue;
		}
	}


	return;
	clean:
	ofLogError("ofMesh") << "load(): " << lineNum << ":" << error;
	ofLogError("ofMesh") << "load(): \"" << *line << "\"";
	data = backup;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::save(const std::filesystem::path& path, bool useBinary) const{
	ofFile os(path, ofFile::WriteOnly);
	const auto & data = *this;

	os << "ply" << std::endl;
	if(useBinary) {
		os << "format binary_little_endian 1.0" << std::endl;
	} else {
		os << "format ascii 1.0" << std::endl;
	}

	if(data.getNumVertices()){
		os << "element vertex " << data.getNumVertices() << std::endl;
		os << "property float x" << std::endl;
		os << "property float y" << std::endl;
		os << "property float z" << std::endl;
		if(data.getNumColors()){
			os << "property uchar red" << std::endl;
			os << "property uchar green" << std::endl;
			os << "property uchar blue" << std::endl;
			os << "property uchar alpha" << std::endl;
		}
		if(data.getNumTexCoords()){
			os << "property float u" << std::endl;
			os << "property float v" << std::endl;
		}
		if(data.getNumNormals()){
			os << "property float nx" << std::endl;
			os << "property float ny" << std::endl;
			os << "property float nz" << std::endl;
		}
	}

	uint8_t faceSize = 3;
	if(data.getNumIndices()){
		os << "element face " << data.getNumIndices() / faceSize << std::endl;
		os << "property list uchar int vertex_indices" << std::endl;
	} else if(data.getMode() == OF_PRIMITIVE_TRIANGLES) {
		os << "element face " << data.getNumVertices() / faceSize << std::endl;
		os << "property list uchar int vertex_indices" << std::endl;
	}

	os << "end_header" << std::endl;

	for(std::size_t i = 0; i < data.getNumVertices(); i++){
		if(useBinary) {
			os.write((char*) &data.getVertices()[i], sizeof(V));
		} else {
			os << data.getVertex(i).x << " " << data.getVertex(i).y << " " << data.getVertex(i).z;
		}
		if(data.getNumColors()){
			// VCG lib / MeshLab don't support float colors, so we have to cast
			ofColor cur = data.getColors()[i];
			if(useBinary) {
				os.write((char*) &cur, sizeof(ofColor));
			} else {
				os << " " << (int) cur.r << " " << (int) cur.g << " " << (int) cur.b << " " << (int) cur.a;
			}
		}
		if(data.getNumTexCoords()){
			if(useBinary) {
				os.write((char*) &data.getTexCoords()[i], sizeof(T));
			} else {
				os << " " << data.getTexCoord(i).x << " " << data.getTexCoord(i).y;
			}
		}
		if(data.getNumNormals()){
			if(useBinary) {
				os.write((char*) &data.getNormals()[i], sizeof(V));
			} else {
				os << " " << data.getNormal(i).x << " " << data.getNormal(i).y << " " << data.getNormal(i).z;
			}
		}
		if(!useBinary) {
			os << std::endl;
		}
	}

	if(data.getNumIndices()) {
		for(uint32_t i = 0; i < data.getNumIndices(); i += faceSize) {
			if(useBinary) {
				os.write((char*) &faceSize, sizeof(unsigned char));
				os.write((char*)&data.getIndices()[i], faceSize);
			} else {
				os << (std::size_t) faceSize << " " << data.getIndex(i) << " " << data.getIndex(i+1) << " " << data.getIndex(i+2) << std::endl;
			}
		}
	} else if(data.getMode() == OF_PRIMITIVE_TRIANGLES) {
		for(uint32_t i = 0; i < data.getNumVertices(); i += faceSize) {
			uint32_t indices[] = {i, i + 1, i + 2};
			if(useBinary) {
				os.write((char*) &faceSize, sizeof(unsigned char));
				os.write((char*) indices, sizeof(indices));
			} else {
				os << (std::size_t) faceSize << " " << indices[0] << " " << indices[1] << " " << indices[2] << std::endl;
			}
		}
	}

	//TODO: add index generation for other OF_PRIMITIVE cases
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setColorForIndices( ofIndexType startIndex, ofIndexType endIndex, C color ) {
	if(!hasColors()) {
		// no colors for vertices, so we must set them here //
		getColors().resize( getNumVertices() );
	}

	for(ofIndexType i = startIndex; i < endIndex; i++) {
		setColor( getIndex(i), color);
	}
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::getMeshForIndices( ofIndexType startIndex, ofIndexType endIndex ) const {
	ofIndexType startVertIndex = 0;
	ofIndexType endVertIndex = 0;

	if(startIndex >= getNumIndices() ) {
		startVertIndex = 0;
	} else {
		startVertIndex = getIndex( startIndex );
	}

	if(endIndex >= getNumIndices() ) {
		// set to the total, because the vector assign does not include the last element //
		endVertIndex = getNumVertices();
	} else {
		endVertIndex = getIndex( endIndex );
	}
	return getMeshForIndices(startIndex, endIndex, startVertIndex, endVertIndex );
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::getMeshForIndices( ofIndexType startIndex, ofIndexType endIndex, ofIndexType startVertIndex, ofIndexType endVertIndex ) const{

	ofMesh_<V,N,C,T> mesh;
	mesh.setMode( getMode() );

	mesh.getVertices().assign( getVertices().begin()+startVertIndex, getVertices().begin()+endVertIndex );

	if( hasColors() ) {
		std::vector<ofFloatColor> colors;
		mesh.getColors().assign( getColors().begin()+startVertIndex, getColors().begin()+endVertIndex );
		if( usingColors()) mesh.enableColors();
		else mesh.disableColors();
	}

	if( hasTexCoords() ) {
		mesh.getTexCoords().assign( getTexCoords().begin()+startVertIndex, getTexCoords().begin()+endVertIndex );
		if( usingTextures() ) mesh.enableTextures();
		else mesh.disableTextures();
	}

	if( hasNormals() ) {
		mesh.getNormals().assign( getNormals().begin()+startVertIndex, getNormals().begin()+endVertIndex );
		if( usingNormals() ) mesh.enableNormals();
		else mesh.disableNormals();
	}

	ofIndexType offsetIndex = getIndex(startIndex);
	bool bFoundLessThanZero = false;
	for(ofIndexType i = startIndex; i < endIndex; i++) {
		ofIndexType index;
		if(getIndex(i)<offsetIndex){
			index = 0;
			bFoundLessThanZero = true;
		}else{
			index = getIndex(i) - offsetIndex;
		}
		mesh.addIndex( index );
	}

	if(bFoundLessThanZero) {
		ofLogWarning( "ofMesh :: getMeshForIndices : found some indices less than 0, setting them to 0"  );
	}

	return mesh;
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::mergeDuplicateVertices() {

	std::vector<V> verts = getVertices();
	std::vector<ofIndexType> indices = getIndices();

	//get indexes to share single point - TODO: try j < i
	for(ofIndexType i = 0; i < indices.size(); i++) {
		for(ofIndexType j = 0; j < indices.size(); j++ ) {
			if(i==j) continue;

			ofIndexType i1 = indices[i];
			ofIndexType i2 = indices[j];
			const V & v1 = verts[ i1 ];
			const V & v2 = verts[ i2 ];

			if( v1 == v2 && i1 != i2) {
				indices[j] = i1;
				break;
			}
		}
	}

	//indices array now has list of unique points we need
	//but we need to delete the old points we're not using and that means the index values will change
	//so we are going to create a new list of points and new indexes - we will use a map to map old index values to the new ones
	std::vector <V> newPoints;
	std::vector <ofIndexType> newIndexes;
	std::map <ofIndexType, bool> ptCreated;
	std::map <ofIndexType, ofIndexType> oldIndexNewIndex;

	std::vector<ofFloatColor> newColors;
	std::vector<ofFloatColor>& colors = getColors();
	std::vector<T> newTCoords;
	std::vector<T>& tcoords = getTexCoords();
	std::vector<N> newNormals;
	std::vector<N>& normals = getNormals();

	for(ofIndexType i = 0; i < indices.size(); i++){
		ptCreated[i] = false;
	}

	for(ofIndexType i = 0; i < indices.size(); i++){
		ofIndexType index = indices[i];
		const auto & p = verts[ index ];

		if( ptCreated[index] == false ){
			oldIndexNewIndex[index] = newPoints.size();
			newPoints.push_back( p );
			if(hasColors()) {
				newColors.push_back(colors[index]);
			}
			if(hasTexCoords()) {
				newTCoords.push_back(tcoords[index]);
			}
			if(hasNormals()) {
				newNormals.push_back(normals[index]);
			}

			ptCreated[index] = true;
		}

		//ofLogNotice("ofMesh") << "[" << i << "]: old " << index << " --> " << oldIndexNewIndex[index];
		newIndexes.push_back( oldIndexNewIndex[index] );
	}

	verts.clear();
	verts = newPoints;

	indices.clear();
	indices = newIndexes;

	clearIndices();
	addIndices(indices);
	clearVertices();
	addVertices( verts );

	if(hasColors()) {
		clearColors();
		addColors( newColors );
	}

	if(hasTexCoords()) {
		clearTexCoords();
		addTexCoords( newTCoords );
	}

	if(hasNormals()) {
		clearNormals();
		addNormals( newNormals );
	}

}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMeshFace_<V,N,C,T> ofMesh_<V,N,C,T>::getFace(ofIndexType faceId) const{
	const std::vector<ofMeshFace_<V,N,C,T>> & faces = getUniqueFaces();
	if(faces.size()>faceId){
		return faces[faceId];
	}else{
		ofLogError() << "couldn't find face " << faceId;
		return ofMeshFace_<V,N,C,T>();
	}
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
const std::vector<ofMeshFace_<V,N,C,T>> & ofMesh_<V,N,C,T>::getUniqueFaces() const{
	if(bFacesDirty){
		// if we are doing triangles, we have to use a vert and normal for each triangle
		// that way we can calculate face normals and use getFaceNormal();
		faces.resize( indices.size()/3 );

		int index	   = 0;
		int triindex	= 0;

		bool bHasColors	 = hasColors();
		bool bHasNormals	= hasNormals();
		bool bHasTexcoords  = hasTexCoords();

		if( getMode() == OF_PRIMITIVE_TRIANGLES) {
			for(std::size_t j = 0; j < indices.size(); j += 3) {
				ofMeshFace_<V,N,C,T> & tri = faces[triindex];
				for(std::size_t k = 0; k < 3; k++) {
					index = indices[j+k];
					tri.setVertex( k, vertices[index] );
					if(bHasNormals)
						tri.setNormal(k, normals[index] );
					if(bHasTexcoords)
						tri.setTexCoord(k, texCoords[index] );
					if(bHasColors)
						tri.setColor(k, colors[index] );
				}
				triindex++;
			}

		} else {
			ofLogWarning("ofMesh") << "getUniqueFaces(): only works with primitive mode OF_PRIMITIVE_TRIANGLES";
		}

		bFacesDirty = false;
	}

	return faces;

}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
std::vector<N> ofMesh_<V,N,C,T>::getFaceNormals( bool perVertex ) const{
	// default for ofPrimitiveBase is vertex normals //
	std::vector<N> faceNormals;

	if( hasVertices() ) {
		if(vertices.size() > 3 && indices.size() > 3) {
			if(perVertex){
				faceNormals.resize(indices.size()*3);
			}else{
				faceNormals.resize(indices.size());
			}
			ofMeshFace_<V,N,C,T> face;
			N n;
			for(ofIndexType i = 0; i < indices.size(); i+=3) {
				face.setVertex( 0, vertices[indices[i+0]] );
				face.setVertex( 1, vertices[indices[i+1]] );
				face.setVertex( 2, vertices[indices[i+2]] );

				n = face.getFaceNormal();

				faceNormals[i]=n;
				if(perVertex) {
					faceNormals[i+1]=n;
					faceNormals[i+2]=n;
				}
			}
		}
	}

	return faceNormals;
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::setFromTriangles( const std::vector<ofMeshFace_<V,N,C,T>>& tris, bool bUseFaceNormal ) {
	if(tris.empty()) {
		ofLogWarning("ofMesh") << "setFromTriangles(): ignoring empty tris vector";
		return;
	}

	typename std::vector<ofMeshFace_<V,N,C,T>>::const_iterator it;

	vertices.resize(tris.size()*3 );
	it = tris.begin();
	// if the first tri has data, assume the rest do as well //
	if(it->hasNormals()){
		normals.resize(tris.size()*3);
	}else{
		normals.clear();
	}
	if(it->hasColors()){
		colors.resize(tris.size()*3);
	}else{
		colors.clear();
	}
	if(it->hasTexcoords()){
		texCoords.resize(tris.size()*3);
	}else{
		texCoords.clear();
	}

	int i = 0;
	for(it = tris.begin(); it != tris.end(); it++) {
		for(std::size_t k = 0; k < 3; k++) {
			vertices[i] = it->getVertex(k);
			if(it->hasTexcoords())
				texCoords[i] = it->getTexCoord(k);
			if(it->hasColors())
				colors[i] = it->getColor(k);
			if(bUseFaceNormal)
				normals[i] = it->getFaceNormal();
			else if(it->hasNormals())
				normals[i] = it->getNormal(k);
			i++;
		}
	}

	setupIndicesAuto();
	bVertsChanged = true;
	bIndicesChanged = true;
	bNormalsChanged = true;
	bColorsChanged = true;
	bTexCoordsChanged = true;

	bFacesDirty = false;
	faces = tris;
}


//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::smoothNormals( float angle ) {

	if( getMode() == OF_PRIMITIVE_TRIANGLES) {
		std::vector<ofMeshFace_<V,N,C,T>> triangles = getUniqueFaces();
		std::vector<V> verts;
		for(ofIndexType i = 0; i < triangles.size(); i++) {
			for(ofIndexType j = 0; j < 3; j++) {
				verts.push_back( triangles[i].getVertex(j) );
			}
		}

		std::map<int, int> removeIds;

		float epsilon = .01f;
		for(ofIndexType i = 0; i < verts.size()-1; i++) {
			for(ofIndexType j = i+1; j < verts.size(); j++) {
				if(i != j) {
					const auto& v1 = toGlm(verts[i]);
					const auto& v2 = toGlm(verts[j]);
					if( glm::distance(v1, v2) <= epsilon ) {
						// average the location //
						verts[i] = (v1+v2)/2.f;
						verts[j] = verts[i];
						removeIds[j] = 1;
					}
				}
			}
		}

		// string of vertex in 3d space to triangle index //
		std::map<std::string, std::vector<int> > vertHash;

		//ofLogNotice("ofMesh") << "smoothNormals(): num verts = " << verts.size() << " tris size = " << triangles.size();

		std::string xStr, yStr, zStr;

		for(ofIndexType i = 0; i < verts.size(); i++ ) {
			xStr = "x"+ofToString(verts[i].x==-0?0:verts[i].x);
			yStr = "y"+ofToString(verts[i].y==-0?0:verts[i].y);
			zStr = "z"+ofToString(verts[i].z==-0?0:verts[i].z);
			std::string vstring = xStr+yStr+zStr;
			if(vertHash.find(vstring) == vertHash.end()) {
				for(ofIndexType j = 0; j < triangles.size(); j++) {
					for(ofIndexType k = 0; k < 3; k++) {
						if(verts[i].x == triangles[j].getVertex(k).x) {
							if(verts[i].y == triangles[j].getVertex(k).y) {
								if(verts[i].z == triangles[j].getVertex(k).z) {
									vertHash[vstring].push_back( j );
								}
							}
						}
					}
				}
			}
		}

//		for( std::map<std::string, std::vector<int> >::iterator it = vertHash.begin(); it != vertHash.end(); ++it) {
//			//for( std::map<std::string, int >::iterator it = vertHash.begin(); it != vertHash.end(); ++it) {
//			ofLogNotice("ofMesh") << "smoothNormals(): " << it->first << "  num = " << it->second.size();
//		}

		V vert;
		N normal;
		float angleCos = cos(angle * DEG_TO_RAD );
		float numNormals=0;

		for(ofIndexType j = 0; j < triangles.size(); j++) {
			for(ofIndexType k = 0; k < 3; k++) {
				vert = triangles[j].getVertex(k);
				xStr = "x"+ofToString(vert.x==-0?0:vert.x);
				yStr = "y"+ofToString(vert.y==-0?0:vert.y);
				zStr = "z"+ofToString(vert.z==-0?0:vert.z);

				std::string vstring = xStr+yStr+zStr;
				numNormals=0;
				normal = {0.f,0.f,0.f};
				if(vertHash.find(vstring) != vertHash.end()) {
					for(ofIndexType i = 0; i < vertHash[vstring].size(); i++) {
						auto f1 = triangles[j].getFaceNormal();
						auto f2 = triangles[vertHash[vstring][i]].getFaceNormal();
						if(glm::dot(toGlm(f1), toGlm(f2)) >= angleCos ) {
							normal += f2;
							numNormals+=1.f;
						}
					}
					//normal /= (float)vertHash[vstring].size();
					normal /= numNormals;

					triangles[j].setNormal(k, normal);
				}
			}
		}

		//ofLogNotice("ofMesh") << "smoothNormals(): setting from triangles ";
		setFromTriangles( triangles );

	}
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMesh_<V,N,C,T>::flatNormals() {
    if( getMode() == OF_PRIMITIVE_TRIANGLES) {
        
        // get copy original mesh data
        auto numIndices = getIndices().size();
        auto verts = getVertices();
        auto texCoords = getTexCoords();
        auto colors = getColors();
        
        // remove all data to start from scratch
        clear();
        
        // add mesh data back, duplicating vertices and recalculating normals
        N normal;
        for(ofIndexType i = 0; i < numIndices; i++) {
            ofIndexType indexCurr = getIndex(i);
    
            if(i % 3 == 0) {
                ofIndexType indexNext1 = getIndex(i + 1);
                ofIndexType indexNext2 = getIndex(i + 2);
                auto e1 = verts[indexCurr] - verts[indexNext1];
                auto e2 = verts[indexNext2] - verts[indexNext1];
                normal = glm::normalize(glm::cross(e1, e2));
            }
    
            addIndex(i);
            addNormal(normal);
    
            if(indexCurr < texCoords.size()) {
                addTexCoord(texCoords[indexCurr]);
            }
    
            if(indexCurr < verts.size()) {
                addVertex(verts[indexCurr]);
            }
    
            if(indexCurr < colors.size()) {
                addColor(colors[indexCurr]);
            }
        }
    }
}

// PLANE MESH //


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::plane(float width, float height, int columns, int rows, ofPrimitiveMode mode ) {
	ofMesh_<V,N,C,T> mesh;

	if(mode != OF_PRIMITIVE_TRIANGLE_STRIP && mode != OF_PRIMITIVE_TRIANGLES) {
		ofLogWarning("ofMesh") << "ofGetPlaneMesh(): primtive mode " << mode << " not supported, setting to OF_PRIMITIVE_TRIANGLES";
		mode = OF_PRIMITIVE_TRIANGLES;
	}

	mesh.setMode(mode);

	V vert;
	N normal(0, 0, 1); // always facing forward //
	T texcoord;

	// the origin of the plane is at the center //
	float halfW = width  * 0.5f;
	float halfH = height * 0.5f;
	
	// add the vertexes //
	for(int iy = 0; iy != rows; iy++) {
		for(int ix = 0; ix != columns; ix++) {

			// normalized tex coords //
			texcoord.x =       ((float)ix/((float)columns-1));
			texcoord.y = 1.f - ((float)iy/((float)rows-1));

			vert.x = texcoord.x * width - halfW;
			vert.y = -(texcoord.y-1) * height - halfH;

			mesh.addVertex(vert);
			mesh.addTexCoord(texcoord);
			mesh.addNormal(normal);
		}
	}
	if(mode == OF_PRIMITIVE_TRIANGLE_STRIP) {
		for(int y = 0; y < rows-1; y++) {
			// even rows //
			if((y&1)==0) {
				for(int x = 0; x < columns; x++) {
					mesh.addIndex( (y) * columns + x );
					mesh.addIndex( (y+1) * columns + x);
				}
			} else {
				for(int x = columns-1; x >0; x--) {
					mesh.addIndex( (y+1) * columns + x );
					mesh.addIndex( y * columns + x-1 );
				}
			}
		}

		if(rows%2!=0) mesh.addIndex(mesh.getNumVertices()-columns);
	} else {
		// Triangles //
		for(int y = 0; y < rows-1; y++) {
			for(int x = 0; x < columns-1; x++) {
				// first triangle //
				mesh.addIndex((y)*columns + x);
				mesh.addIndex((y)*columns + x+1);
				mesh.addIndex((y+1)*columns + x);

				// second triangle //
				mesh.addIndex((y)*columns + x+1);
				mesh.addIndex((y+1)*columns + x+1);
				mesh.addIndex((y+1)*columns + x);
			}
		}
	}

	return mesh;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::sphere( float radius, int res, ofPrimitiveMode mode ) {

	ofMesh_<V,N,C,T> mesh;

	float doubleRes = res*2.f;
	float polarInc = PI/(res); // ringAngle
	float azimInc = TWO_PI/(doubleRes); // segAngle //

	if(mode != OF_PRIMITIVE_TRIANGLE_STRIP && mode != OF_PRIMITIVE_TRIANGLES) {
		mode = OF_PRIMITIVE_TRIANGLE_STRIP;
	}
	mesh.setMode(mode);

	V vert;
	T tcoord;

	for(float i = 0; i < res+1; i++) {

		float tr = sin( PI-i * polarInc );
		float ny = cos( PI-i * polarInc );

		tcoord.y = 1.f - (i / res);

		for(float j = 0; j <= doubleRes; j++) {

			float nx = tr * sin(j * azimInc);
			float nz = tr * cos(j * azimInc);

			tcoord.x = j / (doubleRes);

			vert = {nx, ny, nz};
			mesh.addNormal(vert);
			vert *= radius;
			mesh.addVertex(vert);
			mesh.addTexCoord(tcoord);
		}
	}

	int nr = doubleRes+1;
	if(mode == OF_PRIMITIVE_TRIANGLES) {

		ofIndexType index1, index2, index3;

		for(float iy = 0; iy < res; iy++) {
			for(float ix = 0; ix < doubleRes; ix++) {

				// first tri //
				if(iy > 0) {
					index1 = (iy+0) * (nr) + (ix+0);
					index2 = (iy+0) * (nr) + (ix+1);
					index3 = (iy+1) * (nr) + (ix+0);

					mesh.addIndex(index1);
					mesh.addIndex(index3);
					mesh.addIndex(index2);
				}

				if(iy < res-1 ) {
					// second tri //
					index1 = (iy+0) * (nr) + (ix+1);
					index2 = (iy+1) * (nr) + (ix+1);
					index3 = (iy+1) * (nr) + (ix+0);

					mesh.addIndex(index1);
					mesh.addIndex(index3);
					mesh.addIndex(index2);

				}
			}
		}

	} else {
		for(int y = 0; y < res; y++) {
			for(int x = 0; x <= doubleRes; x++) {
				mesh.addIndex( (y)*nr + x );
				mesh.addIndex( (y+1)*nr + x );
			}
		}
	}


	return mesh;
}

/*
 -----------------------------------------------------------------------------
 This source file is part of ogre-procedural
 
 For the latest info, see http://code.google.com/p/ogre-procedural/
 
 Copyright (c) 2010 Michael Broutin
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 -----------------------------------------------------------------------------
 */
// http://code.google.com/p/ogre-procedural/source/browse/library/src/ProceduralIcoSphereGenerator.cpp


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::icosahedron(float radius) {
        auto mesh = icosphere(radius, 0);
        mesh.flatNormals();
	return mesh;
}

// based on code by Michael Broutin for the ogre-procedural library //
// http://code.google.com/p/ogre-procedural/source/browse/library/src/ProceduralIcoSphereGenerator.cpp
// For the latest info, see http://code.google.com/p/ogre-procedural/ //

//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::icosphere(float radius, std::size_t iterations) {
	ofMesh_<V,N,C,T> sphere;

	/// Step 1 : Generate icosahedron
	const float sqrt5 = sqrt(5.0f);
	const float phi = (1.0f + sqrt5) * 0.5f;
	const float invnorm = 1/sqrt(phi*phi+1);

    sphere.addVertex(invnorm * V(-1,  phi, 0));//0
	sphere.addVertex(invnorm * V( 1,  phi, 0));//1
	sphere.addVertex(invnorm * V(0,   1,  -phi));//2
	sphere.addVertex(invnorm * V(0,   1,   phi));//3
	sphere.addVertex(invnorm * V(-phi,0,  -1));//4
	sphere.addVertex(invnorm * V(-phi,0,   1));//5
	sphere.addVertex(invnorm * V( phi,0,  -1));//6
	sphere.addVertex(invnorm * V( phi,0,   1));//7
	sphere.addVertex(invnorm * V(0,   -1, -phi));//8
	sphere.addVertex(invnorm * V(0,   -1,  phi));//9
	sphere.addVertex(invnorm * V(-1,  -phi,0));//10
	sphere.addVertex(invnorm * V( 1,  -phi,0));//11
       
        ofIndexType firstFaces[] = {
		0,1,2,
		0,3,1,
		0,4,5,
		1,7,6,
		1,6,2,
		1,3,7,
		0,2,4,
		0,5,3,
		2,6,8,
		2,8,4,
		3,5,9,
		3,9,7,
		11,6,7,
		10,5,4,
		10,4,8,
		10,9,5,
		11,8,6,
		11,7,9,
		10,8,11,
		10,11,9
	};

        for(ofIndexType i = 0; i < 60; i+=3) {
		sphere.addTriangle(firstFaces[i], firstFaces[i+1], firstFaces[i+2]);
	}
        
	auto& vertices = sphere.getVertices();
	auto& faces = sphere.getIndices();

	ofIndexType size = faces.size();

	/// Step 2 : tessellate
	for (ofIndexType iteration = 0; iteration < iterations; iteration++)
	{
		size*=4;
		std::vector<ofIndexType> newFaces;
		for (ofIndexType i=0; i<size/12; i++)
		{
			auto i1 = faces[i*3];
			auto i2 = faces[i*3+1];
			auto i3 = faces[i*3+2];
			auto i12 = vertices.size();
			auto i23 = i12+1;
			auto i13 = i12+2;
			auto v1 = vertices[i1];
			auto v2 = vertices[i2];
			auto v3 = vertices[i3];
			//make 1 vertice at the center of each edge and project it onto the sphere
			vertices.push_back(glm::normalize(toGlm(v1+v2)));
			vertices.push_back(glm::normalize(toGlm(v2+v3)));
			vertices.push_back(glm::normalize(toGlm(v1+v3)));
			//now recreate indices
			newFaces.push_back(i1);
			newFaces.push_back(i12);
			newFaces.push_back(i13);
			newFaces.push_back(i2);
			newFaces.push_back(i23);
			newFaces.push_back(i12);
			newFaces.push_back(i3);
			newFaces.push_back(i13);
			newFaces.push_back(i23);
			newFaces.push_back(i12);
			newFaces.push_back(i23);
			newFaces.push_back(i13);
		}
		faces.swap(newFaces);
	}

	/// Step 3 : generate texcoords
	std::vector<T> texCoords;
	for (ofIndexType i=0;i<vertices.size();i++)
	{
		const auto& vec = vertices[i];
		float u, v;
		float r0 = sqrtf(vec.x*vec.x+vec.z*vec.z);
		float alpha;
		alpha = atan2f(vec.z,vec.x);
		u = alpha/TWO_PI+.5f;
		v = atan2f(vec.y, r0)/PI + .5f;
		// reverse the u coord, so the default is texture mapped left to
		// right on the outside of a sphere 
		// reverse the v coord, so that texture origin is at top left
		texCoords.push_back(T(1.0-u,1.f-v));
	}

	/// Step 4 : fix texcoords
	// find vertices to split
	std::vector<ofIndexType> indexToSplit;

	for (ofIndexType i=0;i<faces.size()/3;i++)
	{
		T& t0 = texCoords[faces[i*3+0]];
		T& t1 = texCoords[faces[i*3+1]];
		T& t2 = texCoords[faces[i*3+2]];

		if (std::abs(t2.x-t0.x)>0.5)
		{
			if (t0.x<0.5)
				indexToSplit.push_back(faces[i*3]);
			else
				indexToSplit.push_back(faces[i*3+2]);
		}
		if (std::abs(t1.x-t0.x)>0.5)
		{
			if (t0.x<0.5)
				indexToSplit.push_back(faces[i*3]);
			else
				indexToSplit.push_back(faces[i*3+1]);
		}
		if (std::abs(t2.x-t1.x)>0.5)
		{
			if (t1.x<0.5)
				indexToSplit.push_back(faces[i*3+1]);
			else
				indexToSplit.push_back(faces[i*3+2]);
		}
	}

	//split vertices
	for (ofIndexType i=0;i<indexToSplit.size();i++)
	{
		ofIndexType index = indexToSplit[i];
		//duplicate vertex
		V v = vertices[index];
		T t = texCoords[index] + T(1.f, 0.f);
		vertices.push_back(v);
		texCoords.push_back(t);
		ofIndexType newIndex = vertices.size()-1;
		//reassign indices
		for (ofIndexType j=0;j<faces.size();j++)
		{
			if (faces[j]==index)
			{
				ofIndexType index1 = faces[(j+1)%3+(j/3)*3];
				ofIndexType index2 = faces[(j+2)%3+(j/3)*3];
				if ((texCoords[index1].x>0.5) || (texCoords[index2].x>0.5))
				{
					faces[j] = newIndex;
				}
			}
		}
	}

	// tig: flip face(=triangle) winding order, so that we are consistent with all other ofPrimitives.
	// i wish there was a more elegant way to do this, but anything happening before "split vertices"
	// makes things very, very complicated.
	
	for (ofIndexType i = 0; i < faces.size(); i+=3) {
		std::swap(faces[i+1], faces[i+2]);
	}

	sphere.addNormals( vertices );
	sphere.addTexCoords( texCoords );

	for(ofIndexType i = 0; i < vertices.size(); i++ ) {
		vertices[i] *= radius;
	}

	return  sphere;
}
/*
 -----------------------------------------------------------------------------
 // END OGRE
 -----------------------------------------------------------------------------
 */



// Cylinder Mesh

//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::cylinder( float radius, float height, int radiusSegments, int heightSegments, int numCapSegments, bool bCapped, ofPrimitiveMode mode ) {
	ofMesh_<V,N,C,T> mesh;
	if(mode != OF_PRIMITIVE_TRIANGLE_STRIP && mode != OF_PRIMITIVE_TRIANGLES) {
		mode = OF_PRIMITIVE_TRIANGLE_STRIP;
	}
	mesh.setMode(mode);

	radiusSegments = radiusSegments+1;
	int capSegs = numCapSegments;
	capSegs = capSegs+1;
	heightSegments = heightSegments+1;
	if(heightSegments < 2) heightSegments = 2;
	if( capSegs < 2 ) bCapped = false;
	if(!bCapped) capSegs=1;

	float angleIncRadius = -1 * (TWO_PI/((float)radiusSegments-1.f));
	float heightInc = height/((float)heightSegments-1.f);
	float halfH = height*.5f;

	float newRad;
	V vert;
	T tcoord;
	N normal;
	glm::vec3 up(0,1,0);

	std::size_t vertOffset = 0;

	float maxTexY   = heightSegments-1.f;
	if(capSegs > 0) {
		maxTexY += (capSegs*2)-2.f;
	}
	float maxTexYNormalized = (capSegs-1.f) / maxTexY;

	// add the top cap //
	if(bCapped && capSegs > 0) {
		normal = {0.f, -1.f, 0.f};
		for(int iy = 0; iy < capSegs; iy++) {
			for(int ix = 0; ix < radiusSegments; ix++) {
				newRad = ofMap((float)iy, 0, capSegs-1, 0.0, radius);
				vert.x = cos((float)ix*angleIncRadius) * newRad;
				vert.z = sin((float)ix*angleIncRadius) * newRad;
				vert.y = -halfH;

				tcoord.x = (float)ix/((float)radiusSegments-1.f);
				tcoord.y = 1.f - ofMap(iy, 0, capSegs-1, 0, maxTexYNormalized);

				mesh.addTexCoord( tcoord );
				mesh.addVertex( vert );
				mesh.addNormal( normal );
			}
		}

		if(mode == OF_PRIMITIVE_TRIANGLES) {
			for(int y = 0; y < capSegs-1; y++) {
				for(int x = 0; x < radiusSegments-1; x++) {
					if(y > 0) {
						// first triangle //
						mesh.addIndex( (y)*radiusSegments + x + vertOffset );
						mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset);
						mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);
					}

					// second triangle //
					mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset);
					mesh.addIndex( (y+1)*radiusSegments + x+1 + vertOffset);
					mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);
				}
			}
		} else {
			for(int y = 0; y < capSegs-1; y++) {
				for(int x = 0; x < radiusSegments; x++) {
					mesh.addIndex( (y)*radiusSegments + x + vertOffset );
					mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);
				}
			}
		}

		vertOffset = mesh.getNumVertices();

	}

	//maxTexY			 = heightSegments-1.f + capSegs-1.f;
	float minTexYNormalized = 0;
	if(bCapped) minTexYNormalized = maxTexYNormalized;
	maxTexYNormalized   = 1.f;
	if(bCapped) maxTexYNormalized = (heightSegments) / maxTexY;

	// cylinder vertices //
	for(int iy = 0; iy < heightSegments; iy++) {
		normal = {1.f, 0.f, 0.f};
		for(int ix = 0; ix < radiusSegments; ix++) {

			//newRad = ofMap((float)iy, 0, heightSegments-1, 0.0, radius);
			vert.x = cos(ix*angleIncRadius) * radius;
			vert.y = heightInc*float(iy) - halfH;
			vert.z = sin(ix*angleIncRadius) * radius;

			tcoord.x = float(ix)/(float(radiusSegments)-1.f);
			tcoord.y = 1.f - ofMap(iy, 0, heightSegments-1, minTexYNormalized, maxTexYNormalized );

			mesh.addTexCoord( tcoord );
			mesh.addVertex( vert );
			mesh.addNormal( normal );

			normal = glm::rotate(toGlm(normal), -angleIncRadius, up);

		}
	}

	if(mode == OF_PRIMITIVE_TRIANGLES) {
		for(int y = 0; y < heightSegments-1; y++) {
			for(int x = 0; x < radiusSegments-1; x++) {
				// first triangle //
				mesh.addIndex( (y)*radiusSegments + x + vertOffset);
				mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset );
				mesh.addIndex( (y+1)*radiusSegments + x + vertOffset );

				// second triangle //
				mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset );
				mesh.addIndex( (y+1)*radiusSegments + x+1 + vertOffset );
				mesh.addIndex( (y+1)*radiusSegments + x + vertOffset );
			}
		}
	} else {
		for(int y = 0; y < heightSegments-1; y++) {
			for(int x = 0; x < radiusSegments; x++) {
				mesh.addIndex( (y)*radiusSegments + x + vertOffset );
				mesh.addIndex( (y+1)*radiusSegments + x + vertOffset );
			}
		}
	}

	vertOffset = mesh.getNumVertices();

	// add the bottom cap
	if(bCapped && capSegs > 0) {
		minTexYNormalized = maxTexYNormalized;
		maxTexYNormalized   = 1.f;

		normal = {0.f, 1.f, 0.f};
		for(int iy = 0; iy < capSegs; iy++) {
			for(int ix = 0; ix < radiusSegments; ix++) {
				newRad = ofMap((float)iy, 0, capSegs-1, radius, 0.0);
				vert.x = cos((float)ix*angleIncRadius) * newRad;
				vert.z = sin((float)ix*angleIncRadius) * newRad;
				vert.y = halfH;

				tcoord.x = (float)ix/((float)radiusSegments-1.f);
				tcoord.y = 1.f - ofMap(iy, 0, capSegs-1, minTexYNormalized, maxTexYNormalized);

				mesh.addTexCoord( tcoord );
				mesh.addVertex( vert );
				mesh.addNormal( normal );
			}
		}

		if(mode == OF_PRIMITIVE_TRIANGLES) {
			for(int y = 0; y < capSegs-1; y++) {
				for(int x = 0; x < radiusSegments-1; x++) {
					// first triangle //
					mesh.addIndex( (y)*radiusSegments + x + vertOffset );
					mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset);
					mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);

					if(y < capSegs -1 && capSegs > 2) {
						// second triangle //
						mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset);
						mesh.addIndex( (y+1)*radiusSegments + x+1 + vertOffset);
						mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);
					}
				}
			}
		} else {
			for(int y = 0; y < capSegs-1; y++) {
				for(int x = 0; x < radiusSegments; x++) {
					mesh.addIndex( (y)*radiusSegments + x + vertOffset );
					mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);
				}
			}
		}

		vertOffset = mesh.getNumVertices();

	}

	return mesh;
}

// Cone Mesh //


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::cone( float radius, float height, int radiusSegments, int heightSegments, int capSegments, ofPrimitiveMode mode ) {
	ofMesh_<V,N,C,T> mesh;
	if(mode != OF_PRIMITIVE_TRIANGLE_STRIP && mode != OF_PRIMITIVE_TRIANGLES) {
		mode = OF_PRIMITIVE_TRIANGLE_STRIP;
	}
	mesh.setMode(mode);

	radiusSegments = radiusSegments+1;
	capSegments = capSegments+1;
	heightSegments = heightSegments+1;
	if(heightSegments < 2) heightSegments = 2;
	int capSegs = capSegments;
	if( capSegs < 2 ) {
		capSegs = 0;
	}


	float angleIncRadius = -1.f * ((TWO_PI/((float)radiusSegments-1.f)));
	float heightInc = height/((float)heightSegments-1);
	float halfH = height*.5f;

	float newRad;
	V vert;
	N normal;
	T tcoord;
	glm::vec3 up(0,1,0);

	std::size_t vertOffset = 0;

	float maxTexY = heightSegments-1.f;
	if(capSegs > 0) {
		maxTexY += capSegs-1.f;
	}

	V startVec(0, -halfH-1.f, 0);

	// cone vertices //
	for(int iy = 0; iy < heightSegments; iy++) {
		for(int ix = 0; ix < radiusSegments; ix++) {

			newRad = ofMap((float)iy, 0, heightSegments-1, 0.0, radius);
			vert.x = cos((float)ix*angleIncRadius) * newRad;
			vert.y = heightInc*((float)iy) - halfH;
			vert.z = sin((float)ix*angleIncRadius) * newRad;

			tcoord.x = (float)ix/((float)radiusSegments-1.f);
			tcoord.y = 1.f - (float)iy/((float)maxTexY);

			mesh.addTexCoord( tcoord );
			mesh.addVertex( vert );

			if(iy == 0) {
				newRad = 1.f;
				vert.x = cos((float)ix*angleIncRadius) * newRad;
				vert.y = heightInc*((float)iy) - halfH;
				vert.z = sin((float)ix*angleIncRadius) * newRad;
			}

			auto diff = toGlm(vert - startVec);
			auto crossed = glm::cross(up, toGlm(vert));
			normal = glm::cross(crossed, diff);
			mesh.addNormal( glm::normalize(toGlm(normal)) );

		}
	}

	if(mode == OF_PRIMITIVE_TRIANGLES) {
		for(int y = 0; y < heightSegments-1; y++) {
			for(int x = 0; x < radiusSegments-1; x++) {
				if(y > 0){
					// first triangle //
					mesh.addIndex( (y)*radiusSegments + x );
					mesh.addIndex( (y)*radiusSegments + x+1 );
					mesh.addIndex( (y+1)*radiusSegments + x );
				}

				// second triangle //
				mesh.addIndex( (y)*radiusSegments + x+1 );
				mesh.addIndex( (y+1)*radiusSegments + x+1 );
				mesh.addIndex( (y+1)*radiusSegments + x );
			}
		}
	} else {
		for(int y = 0; y < heightSegments-1; y++) {
			for(int x = 0; x < radiusSegments; x++) {
				mesh.addIndex( (y)*radiusSegments + x );
				mesh.addIndex( (y+1)*radiusSegments + x );
			}
		}
	}

	vertOffset = mesh.getNumVertices();
	float maxTexYNormalized = (heightSegments-1.f) / maxTexY;

	// add the cap //
	normal= {0.f,1.f,0.f};
	for(int iy = 0; iy < capSegs; iy++) {
		for(int ix = 0; ix < radiusSegments; ix++) {
			newRad = ofMap((float)iy, 0, capSegs-1, radius, 0.0);
			vert.x = cos((float)ix*angleIncRadius) * newRad;
			vert.z = sin((float)ix*angleIncRadius) * newRad;
			vert.y = halfH;

			tcoord.x = (float)ix/((float)radiusSegments-1.f);
			tcoord.y = 1.f - ofMap(iy, 0, capSegs-1, maxTexYNormalized, 1.f);

			mesh.addTexCoord( tcoord );
			mesh.addVertex( vert );
			mesh.addNormal( normal );
		}
	}

	if(mode == OF_PRIMITIVE_TRIANGLES) {
		if( capSegs > 0 ) {
			for(int y = 0; y < capSegs-1; y++) {
				for(int x = 0; x < radiusSegments-1; x++) {
					// first triangle //
					mesh.addIndex( (y)*radiusSegments + x + vertOffset );
					mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset);
					mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);

					if(y < capSegs-1) {
						// second triangle //
						mesh.addIndex( (y)*radiusSegments + x+1 + vertOffset);
						mesh.addIndex( (y+1)*radiusSegments + x+1 + vertOffset);
						mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);
					}
				}
			}
		}
	} else {
		if(capSegs > 0 ) {
			for(int y = 0; y < capSegs-1; y++) {
				for(int x = 0; x < radiusSegments; x++) {
					mesh.addIndex( (y)*radiusSegments + x + vertOffset );
					mesh.addIndex( (y+1)*radiusSegments + x + vertOffset);
				}
			}
		}
	}

	return mesh;
}


// Box Mesh //


//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::box( float width, float height, float depth, int resX, int resY, int resZ ) {
	// mesh only available as triangles //
	ofMesh_<V,N,C,T> mesh;
	mesh.setMode( OF_PRIMITIVE_TRIANGLES );

	resX = resX + 1;
	resY = resY + 1;
	resZ = resZ + 1;

	if( resX < 2 ) resX = 0;
	if( resY < 2 ) resY = 0;
	if( resZ < 2 ) resZ = 0;

	// halves //
	float halfW = width * .5f;
	float halfH = height * .5f;
	float halfD = depth * .5f;

	V vert;
	T texcoord;
	N normal;
	std::size_t vertOffset = 0;

	// TRIANGLES //

	// Front Face //
	normal = {0.f, 0.f, 1.f};
	// add the vertexes //
	for(int iy = 0; iy < resY; iy++) {
		for(int ix = 0; ix < resX; ix++) {

			// normalized tex coords //
			texcoord.x = ((float)ix/((float)resX-1.f));
			texcoord.y = 1.f - ((float)iy/((float)resY-1.f));

			vert.x = texcoord.x * width - halfW;
			vert.y = -(texcoord.y-1.f) * height - halfH;
			vert.z = halfD;

			mesh.addVertex(vert);
			mesh.addTexCoord(texcoord);
			mesh.addNormal(normal);
		}
	}

	for(int y = 0; y < resY-1; y++) {
		for(int x = 0; x < resX-1; x++) {
			// first triangle //
			mesh.addIndex((y)*resX + x + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);
			mesh.addIndex((y)*resX + x+1 + vertOffset);

			// second triangle //
			mesh.addIndex((y)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);
			mesh.addIndex((y+1)*resX + x+1 + vertOffset);
		}
	}

	vertOffset = mesh.getNumVertices();


	// Right Side Face //
	normal = {1.f, 0.f, 0.f};
	// add the vertexes //
	for(int iy = 0; iy < resY; iy++) {
		for(int ix = 0; ix < resZ; ix++) {

			// normalized tex coords //
			texcoord.x = ((float)ix/((float)resZ-1.f));
			texcoord.y = 1.f - ((float)iy/((float)resY-1.f));

			//vert.x = texcoord.x * width - halfW;
			vert.x = halfW;
			vert.y = -(texcoord.y-1.f) * height - halfH;
			vert.z = texcoord.x * -depth + halfD;

			mesh.addVertex(vert);
			mesh.addTexCoord(texcoord);
			mesh.addNormal(normal);
		}
	}

	for(int y = 0; y < resY-1; y++) {
		for(int x = 0; x < resZ-1; x++) {
			// first triangle //
			mesh.addIndex((y)*resZ + x + vertOffset);
			mesh.addIndex((y+1)*resZ + x + vertOffset);
			mesh.addIndex((y)*resZ + x+1 + vertOffset);

			// second triangle //
			mesh.addIndex((y)*resZ + x+1 + vertOffset);
			mesh.addIndex((y+1)*resZ + x + vertOffset);
			mesh.addIndex((y+1)*resZ + x+1 + vertOffset);
		}
	}

	vertOffset = mesh.getNumVertices();

	// Left Side Face //
	normal = {-1.f, 0.f, 0.f};
	// add the vertexes //
	for(int iy = 0; iy < resY; iy++) {
		for(int ix = 0; ix < resZ; ix++) {

			// normalized tex coords //
			texcoord.x = ((float)ix/((float)resZ-1.f));
			texcoord.y = 1.f-((float)iy/((float)resY-1.f));

			//vert.x = texcoord.x * width - halfW;
			vert.x = -halfW;
			vert.y = -(texcoord.y-1.f) * height - halfH;
			vert.z = texcoord.x * depth - halfD;

			mesh.addVertex(vert);
			mesh.addTexCoord(texcoord);
			mesh.addNormal(normal);
		}
	}

	for(int y = 0; y < resY-1; y++) {
		for(int x = 0; x < resZ-1; x++) {
			// first triangle //
			mesh.addIndex((y)*resZ + x + vertOffset);
			mesh.addIndex((y+1)*resZ + x + vertOffset);
			mesh.addIndex((y)*resZ + x+1 + vertOffset);

			// second triangle //
			mesh.addIndex((y)*resZ + x+1 + vertOffset);
			mesh.addIndex((y+1)*resZ + x + vertOffset);
			mesh.addIndex((y+1)*resZ + x+1 + vertOffset);
		}
	}

	vertOffset = mesh.getNumVertices();


	// Back Face //
	normal = {0.f, 0.f, -1.f};
	// add the vertexes //
	for(int iy = 0; iy < resY; iy++) {
		for(int ix = 0; ix < resX; ix++) {

			// normalized tex coords //
			texcoord.x = ((float)ix/((float)resX-1.f));
			texcoord.y = 1.f-((float)iy/((float)resY-1.f));

			vert.x = texcoord.x * -width + halfW;
			vert.y = -(texcoord.y-1.f) * height - halfH;
			vert.z = -halfD;

			mesh.addVertex(vert);
			mesh.addTexCoord(texcoord);
			mesh.addNormal(normal);
		}
	}

	for(int y = 0; y < resY-1; y++) {
		for(int x = 0; x < resX-1; x++) {
			// first triangle //
			mesh.addIndex((y)*resX + x + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);
			mesh.addIndex((y)*resX + x+1 + vertOffset);

			// second triangle //
			mesh.addIndex((y)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);
			mesh.addIndex((y+1)*resX + x+1 + vertOffset);
		}
	}

	vertOffset = mesh.getNumVertices();


	// Top Face //
	normal = {0.f, -1.f, 0.f};
	// add the vertexes //
	for(int iy = 0; iy < resZ; iy++) {
		for(int ix = 0; ix < resX; ix++) {

			// normalized tex coords //
			texcoord.x = ((float)ix/((float)resX-1.f));
			texcoord.y = 1.f-((float)iy/((float)resZ-1.f));

			vert.x = texcoord.x * width - halfW;
			//vert.y = -(texcoord.y-1.f) * height - halfH;
			vert.y = -halfH;
			vert.z = texcoord.y * depth - halfD;

			mesh.addVertex(vert);
			mesh.addTexCoord(texcoord);
			mesh.addNormal(normal);
		}
	}

	for(int y = 0; y < resZ-1; y++) {
		for(int x = 0; x < resX-1; x++) {
			// first triangle //
			mesh.addIndex((y)*resX + x + vertOffset);
			mesh.addIndex((y)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);

			// second triangle //
			mesh.addIndex((y)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);
		}
	}

	vertOffset = mesh.getNumVertices();


	// Bottom Face //
	normal = {0.f, 1.f, 0.f};
	// add the vertexes //
	for(int iy = 0; iy < resZ; iy++) {
		for(int ix = 0; ix < resX; ix++) {

			// normalized tex coords //
			texcoord.x = ((float)ix/((float)resX-1.f));
			texcoord.y = 1.f-((float)iy/((float)resZ-1.f));

			vert.x = texcoord.x * width - halfW;
			//vert.y = -(texcoord.y-1.f) * height - halfH;
			vert.y = halfH;
			vert.z = texcoord.y * -depth + halfD;

			mesh.addVertex(vert);
			mesh.addTexCoord(texcoord);
			mesh.addNormal(normal);
		}
	}

	for(int y = 0; y < resZ-1; y++) {
		for(int x = 0; x < resX-1; x++) {
			// first triangle //
			mesh.addIndex((y)*resX + x + vertOffset);
			mesh.addIndex((y)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);

			// second triangle //
			mesh.addIndex((y)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x+1 + vertOffset);
			mesh.addIndex((y+1)*resX + x + vertOffset);
		}
	}

	return mesh;
}




//--------------------------------------------------------------
/// Returns an ofMesh representing an XYZ coordinate system.
template<class V, class N, class C, class T>
ofMesh_<V,N,C,T> ofMesh_<V,N,C,T>::axis( float size ) {
	ofMesh_<V,N,C,T> mesh;

	// mesh only available as wireframe //
	mesh.setMode(OF_PRIMITIVE_LINES);

	V vertices[6] = {
		V(0,0,0),
		V(size,0,0),
		V(0,0,0),
		V(0,size,0),
		V(0,0,0),
		V(0,0,size),
	};
	C colors[6] = {
		C::red,
		C::red,
		C::green,
		C::green,
		C::blue,
		C::blue,
	};

	mesh.addVertices(vertices, 6);
	mesh.addColors(colors, 6);

	return mesh;
}



//--------------------------------------------------------------
template<class V, class N, class C, class T>
ofMeshFace_<V,N,C,T>::ofMeshFace_()
:bHasNormals(false)
,bHasColors(false)
,bHasTexcoords(false)
,bFaceNormalDirty(false)
{
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const N & ofMeshFace_<V,N,C,T>::getFaceNormal() const{
	if(bFaceNormalDirty) calculateFaceNormal();
	return faceNormal;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::calculateFaceNormal() const{
	glm::vec3 u, v;

	u = toGlm(vertices[1]-vertices[0]);
	v = toGlm(vertices[2]-vertices[0]);

	faceNormal = glm::cross(u, v);
	faceNormal = glm::normalize(toGlm(faceNormal));
	bFaceNormalDirty = false;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::setVertex( ofIndexType index, const V& v ) {
	vertices[index] = v;
	bFaceNormalDirty = true;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const V& ofMeshFace_<V,N,C,T>::getVertex( ofIndexType index ) const{
	return vertices[index];
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::setNormal( ofIndexType index, const N& n ) {
	normals[index] = n;
	bHasNormals = true;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const N& ofMeshFace_<V,N,C,T>::getNormal( ofIndexType index ) const{
	return normals[ index ];
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::setColor( ofIndexType index, const C& color ) {
	colors[index] = color;
	bHasColors = true;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const C& ofMeshFace_<V,N,C,T>::getColor( ofIndexType index) const{
	return colors[index];
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::setTexCoord( ofIndexType index, const T& tCoord ) {
	texCoords[index] = tCoord;
	bHasTexcoords = true;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
const T& ofMeshFace_<V,N,C,T>::getTexCoord( ofIndexType index ) const{
	return texCoords[index];
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::setHasColors( bool bColors ) {
	bHasColors = bColors;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::setHasNormals( bool bNormals ) {
	bHasNormals = bNormals;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
void ofMeshFace_<V,N,C,T>::setHasTexcoords( bool bTexcoords ) {
	bHasTexcoords = bTexcoords;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMeshFace_<V,N,C,T>::hasColors() const{
	return bHasColors;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMeshFace_<V,N,C,T>::hasNormals() const{
	return bHasNormals;
}

//--------------------------------------------------------------
template<class V, class N, class C, class T>
bool ofMeshFace_<V,N,C,T>::hasTexcoords() const{
	return bHasTexcoords;
}

#line 0 "../libs/openFrameworks/3d/of3dPrimitives.h"
#pragma once

/* #include "ofMesh.h" */
/* #include "ofNode.h" */
#include <map>

class ofTexture;
class ofVboMesh;
class ofRectangle;

/// \brief A class representing a 3d primitive.
class of3dPrimitive : public ofNode {
public:
    of3dPrimitive();
    virtual ~of3dPrimitive();

    of3dPrimitive(const ofMesh & mesh);
    of3dPrimitive(const of3dPrimitive & mom);
    of3dPrimitive & operator=(const of3dPrimitive & mom);

    void mapTexCoords( float u1, float v1, float u2, float v2 );
    //void setTexCoords( int meshindex, float u1, float v1, float u2, float v2 );
    // does not store texture. Creates tex coords from texture, if texture is
    // non-arb, then it will create normalized tex coords //
    // defaults to index 0
    void mapTexCoordsFromTexture( const ofTexture& inTexture );


    ofMesh* getMeshPtr();
    ofMesh& getMesh();

    const ofMesh* getMeshPtr() const;
    const ofMesh& getMesh() const;

	glm::vec4* getTexCoordsPtr();
	glm::vec4& getTexCoords();

	const glm::vec4* getTexCoordsPtr() const;
	const glm::vec4& getTexCoords() const;

    bool hasScaling() const;
    bool hasNormalsEnabled() const;

    void enableNormals();
    void enableTextures();
    void enableColors();

    void disableNormals();
    void disableTextures();
    void disableColors();

    using ofNode::draw;
    void drawVertices() const;
    void drawWireframe() const;
    void drawFaces() const;
    void draw(ofPolyRenderMode renderType) const;
    void draw() const;
    void drawNormals( float length, bool bFaceNormals=false ) const;
    void drawAxes(float a_size) const;

    void setUseVbo(bool useVbo);
    bool isUsingVbo() const;
protected:

    // useful when creating a new model, since it uses normalized tex coords //
    void normalizeAndApplySavedTexCoords();

	glm::vec4 texCoords;
    bool usingVbo;
    std::shared_ptr<ofMesh>  mesh;
    mutable ofMesh normalsMesh;

    std::vector<ofIndexType> getIndices( int startIndex, int endIndex ) const;

};


/// \brief The ofPlanePrimitive allows you to create an UV plane.
/// Can be used for example as simple canvas for projecting simple texture .
/// 
/// Like all primitives it allows you to set the size, in this case height 
/// and width, draw it, set positions, etc, as a simple example:
/// 
/// ~~~~{.cpp}
/// 
/// ofPlanePrimitive plane;
/// 
/// void setup()
/// {
/// /// let's say we have a window set to be at 
/// // resolution 640x480...
/// 
///     plane.set(640, 480);   ///dimensions for width and height in pixels
/// plane.setPosition(320, 240, 0); /// position in x y z
/// plane.setResolution(2, 2); /// this resolution (as columns and rows) is enough
/// }
/// 
/// void draw()
/// {
/// plane.drawWireframe();
/// }
/// ~~~~
/// As you can see, plane is constructed from two triangles.
/// To draw a texture over any primitive, simply bind the ofTexture instance 
/// and then draw your primitive:
/// 
/// ~~~~{.cpp}
/// 
/// texture.getTextureReference().bind();
/// // now draw filled...
/// plane.draw();
/// 
/// ~~~~
/// 
/// The plane primitive also allows you to simply pass an ofTexture to the 
/// plane and generate the texture coordinates from that texture so that the 
/// ofTexture fills the plane when it's drawn. This saves you the hassle of 
/// creating all the texture coordinates for each vertex, which is nice.

class ofPlanePrimitive : public of3dPrimitive {
public:
    ofPlanePrimitive();
    ofPlanePrimitive( float width, float height, int columns, int rows, 
        ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    ~ofPlanePrimitive();

    void set(float width, float height, int columns, int rows, 
        ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    void set( float width, float height );
    void resizeToTexture( ofTexture& inTexture, float scale=1.f );
    void setWidth( float width );
    void setHeight( float height );

    void setColumns( int columns );
    void setRows( int rows );
    void setResolution( int columns, int rows );
    void setMode( ofPrimitiveMode mode );

    int getNumColumns() const;
    int getNumRows() const;
    // x = columns, y = rows //
	glm::vec2 getResolution() const;

    float getWidth() const;
    float getHeight() const;

protected:
    float width;
    float height;
	glm::vec2 resolution;
};


/// \brief The ofSpherePrimitive allows you to create a UV sphere.
/// A UV spherewhich is a sphere based on UV slices rather than faces like 
/// the ofIcoSpherePrimitive. Note this:
/// 
/// [IMG](3d/spheretypes.png)
/// 
/// On the left is a UV sphere and on the right is an ICO sphere.
/// 
/// Like all primitives it allows you to set the size (radius), draw it, 
/// set positions, etc, as a simple example:
/// 
/// ~~~~{.cpp}
/// 
/// void setup()
/// {
/// 
///     sphere.setRadius( width );
/// }
/// 
/// void draw()
/// {
/// 
///     sphere.setPosition(ofGetWidth()*.2, ofGetHeight()*.75, 0);
///     sphere.rotate(spinX, 1.0, 0.0, 0.0);
///     sphere.rotate(spinY, 0, 1.0, 0.0);
/// 
///     // get all the faces from the icoSphere, handy when you want to copy
///     // individual vertices or tweak them a little ;)
///     vector<ofMeshFace> triangles = sphere.getMesh().getUniqueFaces();
/// 
///     // now draw
///     sphere.draw();
/// }
/// ~~~~
/// 
/// To draw a texture over any primitive, simply bind the ofTexture instance 
/// and then draw your primitive:
/// 
/// ~~~~{.cpp}
/// 
/// texture.getTextureReference().bind();
/// // now draw
/// sphere.draw();
/// 
/// ~~~~
/// 
/// The sphere can look a little weird if you don't do ofEnableDepthTest() 
/// and ofDisableAlphaBlending().
/// 

class ofSpherePrimitive : public of3dPrimitive {
public:
    ofSpherePrimitive();
    ofSpherePrimitive( float radius, int res, 
        ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    ~ofSpherePrimitive();

    void set( float radius, int resolution, 
        ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    void setResolution( int res );
    void setRadius(float radius);
    void setMode( ofPrimitiveMode mode );

    float getRadius() const;
    int getResolution() const;

protected:
    float radius;
    int resolution;
};

/// \brief The ofIcoSpherePrimitive allows you to create an icosphere. 
/// An icosphere is a sphere not based on UV slices like the ofSpherePrimitive,
/// but rather faces. Like this:
/// 
/// Like all primitives it allows you to set the radius, 
/// draw it, set positions, etc.
/// 
/// ~~~~{.cpp}
/// 
/// void setup()
/// {
/// 
///     icoSphere.setRadius( width );
/// }
/// 
/// void draw()
/// {
/// 
///     icoSphere.setPosition(ofGetWidth()*.2, ofGetHeight()*.75, 0);
///     icoSphere.rotate(spinX, 1.0, 0.0, 0.0);
///     icoSphere.rotate(spinY, 0, 1.0, 0.0);
/// 
///     // get all the faces from the icoSphere, handy when you want to copy
///     // individual vertices or tweak them a little ;)
///     vector<ofMeshFace> triangles = icoSphere.getMesh().getUniqueFaces();
/// 
///     // now draw
///     icoSphere.draw();
/// }
/// ~~~~

class ofIcoSpherePrimitive : public of3dPrimitive {
public:
    ofIcoSpherePrimitive();
    ofIcoSpherePrimitive( float radius, int iterations );
    ~ofIcoSpherePrimitive();

    void set( float radius, int res );
    void setResolution( int iterations );
    void setRadius( float radius );
    void setMode( ofPrimitiveMode mode );

    float getRadius() const;
    int getResolution() const;

protected:
    float radius;
    int resolution;
};


/// \brief The ofCylinderPrimitive allows you to create an cylinder mesh.
/// 
/// Like all primitives it allows you to set the size, for the cylinder 
/// a radius and height, draw it, set positions, etc, as a simple example:
/// 
/// ~~~~{.cpp}
/// 
/// void setup()
/// {
/// 
///     cylinder.set( cylinderRadius, cylinderHeight );
/// }
/// 
/// void draw()
/// {
/// 
///     cylinder.setPosition(ofGetWidth()*.2, ofGetHeight()*.75, 0);
///     cylinder.rotate(spinX, 1.0, 0.0, 0.0);
///     cylinder.rotate(spinY, 0, 1.0, 0.0);
/// 
///     // get all the faces from the icoSphere, handy when you want to copy
///     // individual vertices or tweak them a little ;)
///     vector<ofMeshFace> triangles = cylinder.getMesh().getUniqueFaces();
/// 
///     // now draw
///     cylinder.draw();
/// }
/// ~~~~
/// 
/// To draw a texture over any primitive, simply bind the ofTexture instance 
/// and then draw your primitive:
/// 
/// ~~~~{.cpp}
/// 
/// texture.getTextureReference().bind();
/// // now draw
/// cylinder.draw();
/// 
/// ~~~~

class ofCylinderPrimitive : public of3dPrimitive {
public:
    ofCylinderPrimitive();
    ofCylinderPrimitive( float radius, float height, int radiusSegments, 
        int heightSegments, int capSegments=2, bool bCapped = true,
        ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    ~ofCylinderPrimitive();

    void set( float radius, float height, int radiusSegments, 
        int heightSegments, int capSegments=2, bool bCapped=true,
        ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    void set( float radius, float height, bool bCapped=true );
    void setRadius( float radius );
    void setHeight( float height );
    void setCapped( bool bCapped );

    void setResolutionRadius( int radiusRes );
    void setResolutionHeight( int heightRes );
    void setResolutionCap( int capRes );
    void setResolution( int radiusSegments, int heightSegments, int capSegments=2 );
    void setMode( ofPrimitiveMode mode );

    void setTopCapColor( ofColor color );
    void setCylinderColor( ofColor color );
    void setBottomCapColor( ofColor color );

    std::vector<ofIndexType> getTopCapIndices() const;
    ofMesh getTopCapMesh() const;
    std::vector<ofIndexType> getCylinderIndices() const;
    ofMesh getCylinderMesh() const;
    std::vector<ofIndexType> getBottomCapIndices() const;
    ofMesh getBottomCapMesh() const;

    int getResolutionRadius() const;
    int getResolutionHeight() const;
    int getResolutionCap() const;
	glm::vec3 getResolution() const;

    float getHeight() const;
    float getRadius() const;
    bool getCapped() const;
protected:
    float radius;
    float height;
    bool bCapped;
    int strides[3][2];
    int vertices[3][2];
	glm::vec3 resolution;
};

/// \brief The ofConePrimitive allows you to create a 3D cone. 
/// Like all primitives it allows you to set the size, draw it, 
/// set positions, etc, as a simple example:
/// 
/// ~~~~{.cpp}
/// 
/// void setup()
/// {
/// 
///     cone.set( coneRadius, coneHeight, coneRadiusSegments, coneHeightSegments );
/// }
/// 
/// void draw()
/// {
/// 
///     cone.setPosition(ofGetWidth()*.2, ofGetHeight()*.75, 0);
///     cone.rotate(spinX, 1.0, 0.0, 0.0);
///     cone.rotate(spinY, 0, 1.0, 0.0);
/// 
///     // get all the faces from the cpme, handy when you want to copy
///     // individual vertices or tweak them a little ;)
///     vector<ofMeshFace> triangles = cone.getMesh().getUniqueFaces();
/// 
///     // now draw
///     cone.draw();
/// }
/// ~~~~
/// 
/// To draw a texture over any primitive, simply bind the ofTexture instance 
/// and then draw your primitive:
/// 
/// ~~~~{.cpp}
/// 
/// texture.getTextureReference().bind();
/// // now draw
/// cone.draw();
/// 
/// ~~~~
/// 
/// Beware of the cone texture coordinates, they're a little strange.
/// 

class ofConePrimitive : public of3dPrimitive {
public:

    ofConePrimitive();
    ofConePrimitive( float radius, float height, int radiusSegments, 
        int heightSegments, int capSegments=2, 
        ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    ~ofConePrimitive();

    void set( float radius, float height, int radiusSegments, int heightSegments, 
        int capSegments=2, ofPrimitiveMode mode=OF_PRIMITIVE_TRIANGLE_STRIP );
    void set( float radius, float height );
    void setResolutionRadius( int radiusRes );
    void setResolutionHeight( int heightRes );
    void setResolutionCap( int capRes );
    void setResolution( int radiusRes, int heightRes, int capRes );

    void setMode( ofPrimitiveMode mode );
    void setRadius( float radius );
    void setHeight( float height );

    void setTopColor( ofColor color );
    void setCapColor( ofColor color );

    /// \return a vector of the indices of vertices that make up the cone (as opposed to the cap indices).
    std::vector<ofIndexType> getConeIndices() const;

    /// \return This returns an ofMesh made up of the cone (as opposed to the cap).
    ofMesh getConeMesh() const;

    /// \return a vector of the indices of vertices that make up the cap (as opposed to the cone indices).
    std::vector<ofIndexType> getCapIndices() const;

    /// \return an ofMesh made up of the cap (as opposed to the cone).
    ofMesh getCapMesh() const;

    int getResolutionRadius() const;
    int getResolutionHeight() const;

    /// \return the resolution of the cap (rather than the cone).
    int getResolutionCap() const;

    /// \return the resolution of the cone (rather than the cap).
	glm::vec3 getResolution() const;

    /// \return the radius of the cap.
    float getRadius() const;

    /// \return the height of the cone.
    float getHeight() const;

protected:
    float radius;
    float height;

	glm::vec3 resolution;

    int strides[2][2];
    int vertices[2][2];
};


/// \brief The ofBoxPrimitive allows you to create cubes and cuboids.
/// 
/// Like other primitives, it allows you to set its dimensions and position, draw it, etc. As a simple example:
/// 
/// ~~~~{.cpp}
/// 
/// void setup()
/// {
/// 
///     box.set( boxSize );
///     // or
///     // box.set( boxHeight, boxWidth, boxDepth );
/// }
/// 
/// void draw()
/// {
/// 
///     box.setPosition(ofGetWidth()*.2, ofGetHeight()*.75, 0);
///     box.rotate(spinX, 1.0, 0.0, 0.0);
///     box.rotate(spinY, 0, 1.0, 0.0);
/// 
///     // get all the faces from the icoSphere, handy when you want to copy
///     // individual vertices or tweak them a little ;)
///     vector<ofMeshFace> triangles = box.getMesh().getUniqueFaces();
/// 
///     // now draw
///     box.draw();
/// }
/// ~~~~
/// 
/// To draw a texture over any primitive, simply bind the ofTexture instance and then draw your primitive:
/// 
/// ~~~~{.cpp}
/// 
/// texture.getTextureReference().bind();
/// // now draw
/// box.draw();
/// 
/// ~~~~
/// 

class ofBoxPrimitive : public of3dPrimitive {
public:

    enum BoxSides {
        SIDE_FRONT,
        SIDE_RIGHT,
        SIDE_LEFT,
        SIDE_BACK,
        SIDE_TOP,
        SIDE_BOTTOM,
        SIDES_TOTAL
    };
    ofBoxPrimitive();
    ofBoxPrimitive( float width, float height, float depth, int resWidth=2, 
        int resHeight=2, int resDepth=2 );
    ~ofBoxPrimitive();

    void set( float width, float height, float depth, int resWidth, 
        int resHeight, int resDepth);
    void set( float width, float height, float depth );
    void set( float size ); // all sides the same dimensions //

    void setWidth( float a_width );
    void setHeight( float a_height );
    void setDepth( float a_depth );

    void resizeToTexture( ofTexture& inTexture );

    std::vector<ofIndexType> getSideIndices( int sideIndex ) const;
    ofMesh getSideMesh( int sideIndex ) const;

    void setResolution( int res ); // same resolution for all sides //
    void setResolutionWidth( int widthRes );
    void setResolutionHeight( int heightRes );
    void setResolutionDepth( int depthRes );
    void setResolution( int resWidth, int resHeight, int resDepth );

    void setMode( ofPrimitiveMode mode );
    void setSideColor( int sideIndex, ofColor color );

    int getResolutionWidth() const;
    int getResolutionHeight() const;
    int getResolutionDepth() const;
	glm::vec3 getResolution() const;

    float getWidth() const;
    float getHeight() const;
    float getDepth() const;
	glm::vec3 getSize() const;
protected:
	glm::vec3 size;
	glm::vec3 resolution;
    // indices strides for faces //
    int strides[6][2];
    int vertices[6][2];

};

#line 0 "../libs/openFrameworks/gl/ofBufferObject.h"
#pragma once

/* #include "ofConstants.h" */

template<typename T>
class ofPixels_;

class ofBufferObject {
public:
	ofBufferObject();

	/// creates a buffer without allocating any memory yet
	/// glGenBuffers, allocates a GL buffer
	void allocate();

	/// creates a buffer and allocates the required number of bytes
	/// glGenBuffers + glNamedBufferData: https://www.opengl.org/sdk/docs/man4/html/glBufferData.xhtml
	/// before GL 4.5 emulates glNamedBufferData by binding to last known target
	/// for this buffer uploading data to that target and unbinding again
	void allocate(GLsizeiptr bytes, GLenum usage);
	void allocate(GLsizeiptr bytes, const void * data, GLenum usage);

	template<typename T>
	void allocate(const std::vector<T> & data, GLenum usage){
		allocate(data.size()*sizeof(T),&data[0],usage);
	}

	template<typename T>
	void allocate(const ofPixels_<T> & data, GLenum usage){
		allocate(data.size()*sizeof(T),data.getData(),usage);
	}

	/// true if allocate was called before
	bool isAllocated() const;

	/// glBindBuffer: https://www.opengl.org/sdk/docs/man4/html/glBindBuffer.xhtml
	void bind(GLenum target) const;

	/// binds the passed target to buffer 0
	void unbind(GLenum target) const;

#ifndef TARGET_OPENGLES
	/// glBindBufferBase: https://www.opengl.org/sdk/docs/man4/html/glBindBufferBase.xhtml
	void bindBase(GLenum target,GLuint index) const;

	/// binds the given target and index to buffer 0
	void unbindBase(GLenum target,GLuint index) const;

	/// glBindBufferRange: https://www.opengl.org/sdk/docs/man4/html/glBindBufferRange.xhtml
	void bindRange(GLenum target,GLuint index, GLintptr offset, GLsizeiptr size) const;

	/// binds the given target and index to 0
	void unbindRange(GLenum target,GLuint index) const;
#endif

	/// returns the id of the buffer if it's allocated or 0 otherwise
	GLuint getId() const;

	/// glNamedBufferData: https://www.opengl.org/sdk/docs/man4/html/glBufferData.xhtml
	/// before GL 4.5 emulates glNamedBufferData by binding to last known target
	/// for this buffer uploading data to that target and unbinding again
	void setData(GLsizeiptr bytes, const void * data, GLenum usage);


	/// glNamedBufferSubData: https://www.opengl.org/sdk/docs/man4/html/glBufferSubData.xhtml
	/// before GL 4.5 emulates glNamedBufferSubData by binding to last known target
	/// for this buffer uploading data to that target and unbinding again
	void updateData(GLintptr offset, GLsizeiptr bytes, const void * data);
    void updateData(GLsizeiptr bytes, const void * data);

	/// typed version of setData, same functionality but guesses the size from the size
	/// of the passed vector and size of the type
	template<typename T>
	void setData(const std::vector<T> & data, GLenum usage){
		setData(data.size()*sizeof(T),&data[0],usage);
	}

	template<typename T>
	void setData(const ofPixels_<T> & data, GLenum usage){
		setData(data.size()*sizeof(T),data.getPixels(),usage);
	}

	/// typed version of updateData, same functionality but guesses the size from the size
	/// of the passed vector and size of the type
	template<typename T>
	void updateData(GLintptr offset, const std::vector<T> & data){
		updateData(offset,data.size()*sizeof(T),&data[0]);
	}

    /// typed version of updateData, same functionality but guesses the size from the size
    /// of the passed vector and size of the type
    template<typename T>
    void updateData(const std::vector<T> & data){
        updateData(0,data.size()*sizeof(T),&data[0]);
    }

#ifndef TARGET_OPENGLES
	/// glMapNamedBuffer: https://www.opengl.org/sdk/docs/man4/html/glMapBuffer.xhtml
	/// before GL 4.5 emulates glMapNamedBuffer by binding to last known target
	/// for this buffer and mapping that target
	void * map(GLenum access);

	/// glUnmapNamedBuffer: https://www.opengl.org/sdk/docs/man4/html/glUnmapBuffer.xhtml
	/// before GL 4.5 emulates glUnmapNamedBuffer by unmapping and unbinding
	/// the last known target for this buffer
	void unmap();

	/// typed version of map, returns an array of T when used like:
	/// buffer.map<Type>(access)
	template<typename T>
	T * map(GLenum access){
		return static_cast<T*>(map(access));
	}

	/// glMapNamedBufferRange: https://www.opengl.org/sdk/docs/man4/html/glMapBufferRange.xhtml
	/// before GL 4.5 emulates glMapNamedBufferRange by binding to last known target
	/// for this buffer and mapping that target
	void * mapRange(GLintptr offset, GLsizeiptr length, GLenum access);

	/// same as unmap, just to make the api more clear
	void unmapRange();

	/// typed version of mapRange, returns an array of T when used like:
	/// buffer.mapRange<Type>(access)
	template<typename T>
	T * mapRange(GLintptr offset, GLsizeiptr length, GLenum access){
		return static_cast<T*>(mapRange(offset,length,access));
	}

	void copyTo(ofBufferObject & dstBuffer) const;
	void copyTo(ofBufferObject & dstBuffer, int readOffset, int writeOffset, size_t size) const;

    void invalidate();
#endif

	GLsizeiptr size() const;

private:
	struct Data{
		Data();
		~Data();
		GLuint id;
		GLsizeiptr size;
		GLenum lastTarget;
		bool isBound;
		bool isDSA;
	};
	std::shared_ptr<Data> data;
};

#line 0 "../libs/openFrameworks/gl/ofVbo.h"
//TODO: Add edge flags?

#pragma once
/* #include "ofConstants.h" */
/* #include "ofGraphicsConstants.h" */
/* #include "ofBufferObject.h" */
#include <map>

template<typename T>
class ofColor_;
typedef ofColor_<float> ofFloatColor;

class ofVec2f;
class ofVec3f;

template<class V, class N, class C, class T>
class ofMesh_;
using ofMesh = ofMesh_<ofDefaultVertexType, ofDefaultNormalType, ofDefaultColorType, ofDefaultTexCoordType>;

class ofVbo {
public:
	
	ofVbo();
	ofVbo(const ofVbo & mom);
	ofVbo & operator=(const ofVbo& mom);
	~ofVbo();

	void setMesh(const ofMesh & mesh, int usage);
	void setMesh(const ofMesh & mesh, int usage, bool useColors, bool useTextures, bool useNormals);
	
	void setVertexData(const glm::vec3 * verts, int total, int usage);
	void setVertexData(const glm::vec2 * verts, int total, int usage);
	void setVertexData(const ofVec3f * verts, int total, int usage);
	void setVertexData(const ofVec2f * verts, int total, int usage);

	void setColorData(const ofFloatColor * colors, int total, int usage);
	void setNormalData(const glm::vec3 * normals, int total, int usage);
	void setNormalData(const ofVec3f * normals, int total, int usage);
	void setTexCoordData(const glm::vec2 * texCoords, int total, int usage);
	void setTexCoordData(const ofVec2f * texCoords, int total, int usage);
	void setIndexData(const ofIndexType * indices, int total, int usage);

	void setVertexData(const float * vert0x, int numCoords, int total, int usage, int stride=0);
	void setColorData(const float * color0r, int total, int usage, int stride=0);
	void setNormalData(const float * normal0x, int total, int usage, int stride=0);
	void setTexCoordData(const float * texCoord0x, int total, int usage, int stride=0);

	void setAttributeData(int location, const float * vert0x, int numCoords, int total, int usage, int stride=0);

#ifndef TARGET_OPENGLES
	/// used to send an attribute per instance(s) instead of per vertex.
	/// will send per vertex if set to 0 or to the number of instances if >0
	///
	/// see textureBufferInstancedExample
	/// and https://www.opengl.org/sdk/docs/man4/html/glVertexAttribDivisor.xhtml
	void setAttributeDivisor(int location, int divisor);
#endif

	void setVertexBuffer(ofBufferObject & buffer, int numCoords, int stride, int offset=0);
	void setColorBuffer(ofBufferObject & buffer, int stride, int offset=0);
	void setNormalBuffer(ofBufferObject & buffer, int stride, int offset=0);
	void setTexCoordBuffer(ofBufferObject & buffer, int stride, int offset=0);
	void setIndexBuffer(ofBufferObject & buffer);
	
	void setAttributeBuffer(int location, ofBufferObject & buffer, int numCoords, int stride, int offset=0);

	ofBufferObject & getVertexBuffer();
	ofBufferObject & getColorBuffer();
	ofBufferObject & getNormalBuffer();
	ofBufferObject & getTexCoordBuffer();
	ofBufferObject & getIndexBuffer();
	ofBufferObject & getAttributeBuffer(int location);

	const ofBufferObject & getVertexBuffer() const;
	const ofBufferObject & getColorBuffer() const;
	const ofBufferObject & getNormalBuffer() const;
	const ofBufferObject & getTexCoordBuffer() const;
	const ofBufferObject & getIndexBuffer() const;

	const ofBufferObject & getAttributeBuffer(int location) const;

	void updateMesh(const ofMesh & mesh);

	void updateVertexData(const glm::vec3 * verts, int total);
	void updateVertexData(const glm::vec2 * verts, int total);
	void updateVertexData(const ofVec3f * verts, int total);
	void updateVertexData(const ofVec2f * verts, int total);
	void updateColorData(const ofFloatColor * colors, int total);
	void updateNormalData(const glm::vec3 * normals, int total);
	void updateNormalData(const ofVec3f * normals, int total);
	void updateTexCoordData(const glm::vec2 * texCoords, int total);
	void updateTexCoordData(const ofVec2f * texCoords, int total);
	void updateIndexData(const ofIndexType * indices, int total);
	
	void updateVertexData(const float * ver0x, int total);
	void updateColorData(const float * color0r, int total);
	void updateNormalData(const float * normal0x, int total);
	void updateTexCoordData(const float * texCoord0x, int total);

	void updateAttributeData(int location, const float * vert0x, int total);

	void enableColors();
	void enableNormals();
	void enableTexCoords();
	void enableIndices();

	void disableColors();
	void disableNormals();
	void disableTexCoords();
	void disableIndices();

	GLuint getVaoId() const;
	GLuint getVertId() const;
	GLuint getColorId() const;
	GLuint getNormalId() const;
	GLuint getTexCoordId() const;
	GLuint getIndexId() const;
	
	/// returns OpenGL memory object id for GL buffer holding attribute data
	GLuint  getAttributeId(int AttrPos_) const;
	
	bool getIsAllocated() const;
	bool getUsingVerts() const;
	bool getUsingColors() const;
	bool getUsingNormals() const;
	bool getUsingTexCoords() const;
	bool getUsingIndices() const;
	
	void draw(int drawMode, int first, int total) const;
	void drawElements(int drawMode, int amt, int offsetelements = 0) const;
	
	void drawInstanced(int drawMode, int first, int total, int primCount) const;
	void drawElementsInstanced(int drawMode, int amt, int primCount) const;
	
	void bind() const;
	void unbind() const;

	void clear();

	void clearVertices();
	void clearNormals();
	void clearColors();
	void clearTexCoords();
	void clearIndices();
	
	void clearAttribute(int attributePos_);

	int getNumVertices() const;
	int getNumIndices() const;
	
	bool hasAttribute(int attributePos_) const;

private:

	struct VertexAttribute{
		VertexAttribute();
		bool isAllocated() const;
		void allocate();
		void bind() const;
		void unbind() const;
		void setData(GLsizeiptr bytes, const void * data, GLenum usage);
		void updateData(GLintptr offset, GLsizeiptr bytes, const void * data);
		void setData(const float * attrib0x, int numCoords, int total, int usage, int stride, bool normalize=false);
		void setBuffer(ofBufferObject & buffer, int numCoords, int stride, int offset);
		void enable() const;
		void disable() const;
		GLuint getId() const;
		ofBufferObject buffer;
		GLsizei stride;
		GLsizeiptr offset;
		int numCoords;
		GLuint location;
		bool normalize;
		int divisor;
	};

	struct IndexAttribute{
		IndexAttribute();
		bool isAllocated() const;
		void allocate();
		void bind() const;
		void unbind() const;
		void setData(GLsizeiptr bytes, const void * data, GLenum usage);
		void updateData(GLintptr offset, GLsizeiptr bytes, const void * data);
		GLuint getId() const;
		ofBufferObject buffer;
	};

	GLuint vaoID;
	mutable bool vaoChanged;

	IndexAttribute indexAttribute;

	mutable bool bUsingVerts;		// need at least vertex data
	mutable bool bUsingTexCoords;
	mutable bool bUsingColors;
	mutable bool bUsingNormals;
	mutable bool bUsingIndices;

	int	totalVerts;
	int	totalIndices;

	VertexAttribute positionAttribute;
	VertexAttribute colorAttribute;
	VertexAttribute texCoordAttribute;
	VertexAttribute normalAttribute;
	std::map<int,VertexAttribute> customAttributes;
	
	static bool vaoChecked;
	static bool vaoSupported;

	VertexAttribute & getOrCreateAttr(int location);
};

#line 0 "../libs/openFrameworks/gl/ofVboMesh.h"
#pragma once

/* #include "ofMesh.h" */
/* #include "ofVbo.h" */

class ofVboMesh: public ofMesh{
public:
	using ofMesh::draw;
	ofVboMesh();
	ofVboMesh(const ofMesh & mom);
    void operator=(const ofMesh & mom);
	virtual ~ofVboMesh();
	void setUsage(int usage);

    void enableColors();
    void enableTextures();
    void enableNormals();
    void enableIndices();

    void disableColors();
    void disableTextures();
    void disableNormals();
    void disableIndices();

    virtual bool usingColors() const;
    virtual bool usingTextures() const;
    virtual bool usingNormals() const;
    virtual bool usingIndices() const;

	void draw(ofPolyRenderMode drawMode) const;
	void drawInstanced(ofPolyRenderMode drawMode, int primCount) const;
	
	ofVbo & getVbo();
	const ofVbo & getVbo() const;
	
private:
	void updateVbo();
	void unloadVbo();
	ofVbo vbo;
	int usage;
	std::size_t vboNumVerts;
	std::size_t vboNumIndices;
	std::size_t vboNumNormals;
	std::size_t vboNumTexCoords;
	std::size_t vboNumColors;
};

#line 0 "../libs/openFrameworks/graphics/of3dGraphics.h"
//
//  of3dGraphics.h
//  openFrameworksLib
//
//  Created by Nick Hardeman on 9/14/12.
//
//

#pragma once

/* #include "ofConstants.h" */
/* #include "of3dPrimitives.h" */


// Grid Plane - drawn from the center //
void ofSetPlaneResolution( int columns, int rows );
glm::vec2 ofGetPlaneResolution();
void ofDrawPlane(float x, float y, float width, float height);
void ofDrawPlane(float x, float y, float z, float width, float height);
void ofDrawPlane(glm::vec3& position, float width, float height);
void ofDrawPlane( float width, float height );

// UV Sphere
void ofSetSphereResolution(int res);
int ofGetSphereResolution();
void ofDrawSphere(float x, float y, float radius);
void ofDrawSphere(float x, float y, float z, float radius);
void ofDrawSphere(const glm::vec3& position, float radius);
void ofDrawSphere(float radius);

// Deprecated Methods //
OF_DEPRECATED_MSG("Use ofDrawSphere instead.", void ofSphere(float x, float y, float radius) );
OF_DEPRECATED_MSG("Use ofDrawSphere instead.", void ofSphere(float x, float y, float z, float radius) );
OF_DEPRECATED_MSG("Use ofDrawSphere instead.", void ofSphere(const glm::vec3& position, float radius) );
OF_DEPRECATED_MSG("Use ofDrawSphere instead.", void ofSphere(float radius) );


// Ico Sphere
void ofSetIcoSphereResolution( int res );
int ofGetIcoSphereResolution();
void ofDrawIcoSphere(float x, float y, float z, float radius);
void ofDrawIcoSphere(float x, float y, float radius);
void ofDrawIcoSphere(const glm::vec3& position, float radius);
void ofDrawIcoSphere(float radius);

// Cylinder //
void ofSetCylinderResolution( int radiusSegments, int heightSegments, int capSegments=2 );
glm::vec3 ofGetCylinderResolution();
void ofDrawCylinder(float x, float y, float radius, float height);
void ofDrawCylinder(float x, float y, float z, float radius, float height);
void ofDrawCylinder(const glm::vec3& position, float radius, float height);
void ofDrawCylinder(float radius, float height);

// Cone

/// \brief Set the resolution of a polygonized cone. 
///
/// Allows you to set the polygonization resolution of any cones you subsequently draw with ofDrawCone(). 
///
/// \param radiusSegments The number of facets (subdivisions) around the cone's circular footprint. 
/// \param heightSegments The number of subdivisions from the cone's top to bottom. 
/// \param capSegments The number of annular (ring-shaped) subdivisions of the cone's endcap. 
void ofSetConeResolution( int radiusSegments, int heightSegments, int capSegments=2);

/// \brief Retrieve a data structure describing the resolution with which cones are polygonized. 
///
/// Allows you to fetch the resolution with which cones are polygonized.
/// Returns an ofVec3f containing the following data: 
/// Encoded as "x": radiusSegments, the number of facets (subdivisions) around the cone's circular footprint. 
/// Encoded as "y": heightSegments, the number of subdivisions from the cone's top to bottom. 
/// Encoded as "z": capSegments, the number of annular (ring-shaped) subdivisions of the cone's endcap. 
///
/// \returns An ofVec3f containing (radiusSegments, heightSegments, capSegments) for cone polygonization. 
glm::vec3 ofGetConeResolution();

void ofDrawCone(float x, float y, float z, float radius, float height);
void ofDrawCone(float x, float y, float radius, float height);
void ofDrawCone(const glm::vec3& position, float radius, float height);
void ofDrawCone(float radius, float height);

// Deprecated Methods //
OF_DEPRECATED_MSG("Use ofDrawCone instead.", void ofCone(float x, float y, float z, float radius, float height) );
OF_DEPRECATED_MSG("Use ofDrawCone instead.", void ofCone(float x, float y, float radius, float height) );
OF_DEPRECATED_MSG("Use ofDrawCone instead.", void ofCone(const glm::vec3& position, float radius, float height) );
OF_DEPRECATED_MSG("Use ofDrawCone instead.", void ofCone(float radius, float height) );

// Box
void ofSetBoxResolution( int res );
void ofSetBoxResolution( int resWidth, int resHeight, int resDepth );
glm::vec3 ofGetBoxResolution();

/// \brief Draws a rectangular box with the specified dimensions, starting from the specified coordinates. 
///
/// A box is a rectangular solid: an extruded rectangle. 
/// It is drawn starting from a 3D reference coordinate. 
/// It has a width (in x), a height (in y), and a depth (in z).
/// The box is drawn with the current color, e.g. set with ofSetColor().
/// The box is drawn filled by default; change this with ofFill();
///
/// \param x The x-coordinate of the box's origin. 
/// \param y The y-coordinate of the box's origin. 
/// \param z The z-coordinate of the box's origin. 
/// \param width The width of the box. 
/// \param height The height of the box.
/// \param depth The depth of the box.
void ofDrawBox( float x, float y, float z, float width, float height, float depth);

/// \brief Draws a cube with the specified size, starting from the specified coordinates. 
///
/// A cube is a rectangular solid bounded by six square faces of equal size.
/// It is also known as a regular hexahedron, a square parallelepiped, an equilateral cuboid 
/// and a right rhombohedron. It is a regular square prism in three orientations.
///
/// It is drawn starting from a 3D reference coordinate, with the specified size.
/// The cube is drawn with the current color, e.g. set with ofSetColor().
/// The cube is drawn filled by default; change this with ofFill();
///
/// \param x The x-coordinate of the cube's origin. 
/// \param y The y-coordinate of the cube's origin. 
/// \param z The z-coordinate of the cube's origin. 
/// \param size The size of the cube. 
void ofDrawBox(float x, float y, float z, float size);

/// \brief Draws a rectangular box with the specified dimensions, starting from the specified position. 
///
/// A box is a rectangular solid: an extruded rectangle. 
/// It is drawn starting from a 3D reference coordinate. 
/// It has a width (in x), a height (in y), and a depth (in z).
/// The box is drawn with the current color, e.g. set with ofSetColor().
/// The box is drawn filled by default; change this with ofFill();
///
/// \param position an glm::vec3 which contains the (x,y,z) coordinates for the box's reference corner.
/// \param width The width of the box. 
/// \param height The height of the box.
/// \param depth The depth of the box.
void ofDrawBox(const glm::vec3& position, float width, float height, float depth);

/// \brief Draws a cube with the specified size, starting from the specified position. 
///
/// A cube is drawn starting from a 3D reference position, with the specified size.
/// The cube is drawn with the current color, e.g. set with ofSetColor().
/// The cube is drawn filled by default; change this with ofFill();
///
/// \param position an glm::vec3 which contains the (x,y,z) coordinates for the cube's reference corner.
/// \param size The size of the cube. 
void ofDrawBox(const glm::vec3& position, float size);

/// \brief Draws a cube with the specified size, starting from the origin. 
///
/// The cube is drawn with the current color, e.g. set with ofSetColor().
/// The cube is drawn filled by default; change this with ofFill();
///
/// \param size The size of the cube. 
void ofDrawBox(float size);

/// \brief Draws a rectangular box with the specified dimensions, starting from the origin. 
///
/// A box is a rectangular solid: an extruded rectangle. 
/// It is drawn starting from the origin of the current reference frame. 
/// It has a width (in x), a height (in y), and a depth (in z).
/// The box is drawn with the current color, e.g. set with ofSetColor().
/// The box is drawn filled by default; change this with ofFill();
///
/// \param width The width of the box. 
/// \param height The height of the box.
/// \param depth The depth of the box.
void ofDrawBox( float width, float height, float depth );

// deprecated methods //
OF_DEPRECATED_MSG("Use ofDrawBox instead.", void ofBox( float x, float y, float z, float width, float height, float depth) );
OF_DEPRECATED_MSG("Use ofDrawBox instead.", void ofBox(float x, float y, float z, float size) );
OF_DEPRECATED_MSG("Use ofDrawBox instead.", void ofBox(const glm::vec3& position, float width, float height, float depth) );
OF_DEPRECATED_MSG("Use ofDrawBox instead.", void ofBox(const glm::vec3& position, float size) );
OF_DEPRECATED_MSG("Use ofDrawBox instead.", void ofBox(float size) );
OF_DEPRECATED_MSG("Use ofDrawBox instead.", void ofBox( float width, float height, float depth ) );

class of3dGraphics{
public:
	of3dGraphics(ofBaseRenderer * renderer);
	void setPlaneResolution( int columns, int rows );
	glm::vec2 getPlaneResolution() const;
	void drawPlane(float x, float y, float width, float height) const;
	void drawPlane(float x, float y, float z, float width, float height) const;
	void drawPlane(glm::vec3& position, float width, float height) const;
	void drawPlane( float width, float height ) const;

	// UV Sphere
	void setSphereResolution(int res);
	int getSphereResolution() const;
	void drawSphere(float x, float y, float radius) const;
	void drawSphere(float x, float y, float z, float radius) const;
	void drawSphere(const glm::vec3& position, float radius) const;
	void drawSphere(float radius) const;

	// Ico Sphere
	void setIcoSphereResolution( int res );
	int getIcoSphereResolution() const;
	void drawIcoSphere(float x, float y, float z, float radius) const;
	void drawIcoSphere(float x, float y, float radius) const;
	void drawIcoSphere(const glm::vec3& position, float radius) const;
	void drawIcoSphere(float radius) const;

	// Cylinder //
	void setCylinderResolution( int radiusSegments, int heightSegments, int capSegments=2 );
	glm::vec3 getCylinderResolution() const;
	void drawCylinder(float x, float y, float radius, float height) const;
	void drawCylinder(float x, float y, float z, float radius, float height) const;
	void drawCylinder(const glm::vec3& position, float radius, float height) const;
	void drawCylinder(float radius, float height) const;

	// Cone

	/// \brief Set the resolution of a polygonized cone.
	///
	/// Allows you to set the polygonization resolution of any cones you subsequently draw with ofDrawCone().
	///
	/// \param radiusSegments The number of facets (subdivisions) around the cone's circular footprint.
	/// \param heightSegments The number of subdivisions from the cone's top to bottom.
	/// \param capSegments The number of annular (ring-shaped) subdivisions of the cone's endcap.
	void setConeResolution( int radiusSegments, int heightSegments, int capSegments=2);

	/// \brief Retrieve a data structure describing the resolution with which cones are polygonized.
	///
	/// Allows you to fetch the resolution with which cones are polygonized.
	/// Returns an ofVec3f containing the following data:
	/// Encoded as "x": radiusSegments, the number of facets (subdivisions) around the cone's circular footprint.
	/// Encoded as "y": heightSegments, the number of subdivisions from the cone's top to bottom.
	/// Encoded as "z": capSegments, the number of annular (ring-shaped) subdivisions of the cone's endcap.
	///
	/// \returns An ofVec3f containing (radiusSegments, heightSegments, capSegments) for cone polygonization.
	glm::vec3 getConeResolution() const;

	void drawCone(float x, float y, float z, float radius, float height) const;
	void drawCone(float x, float y, float radius, float height) const;
	void drawCone(const glm::vec3& position, float radius, float height) const;
	void drawCone(float radius, float height) const;

	// Box
	void setBoxResolution( int res );
	void setBoxResolution( int resWidth, int resHeight, int resDepth );
	glm::vec3 getBoxResolution() const;

	/// \brief Draws a rectangular box with the specified dimensions, starting from the specified coordinates.
	///
	/// A box is a rectangular solid: an extruded rectangle.
	/// It is drawn starting from a 3D reference coordinate.
	/// It has a width (in x), a height (in y), and a depth (in z).
	/// The box is drawn with the current color, e.g. set with ofSetColor().
	/// The box is drawn filled by default; change this with ofFill();
	///
	/// \param x The x-coordinate of the box's origin.
	/// \param y The y-coordinate of the box's origin.
	/// \param z The z-coordinate of the box's origin.
	/// \param width The width of the box.
	/// \param height The height of the box.
	/// \param depth The depth of the box.
	void drawBox( float x, float y, float z, float width, float height, float depth) const;

	/// \brief Draws a cube with the specified size, starting from the specified coordinates.
	///
	/// A cube is a rectangular solid bounded by six square faces of equal size.
	/// It is also known as a regular hexahedron, a square parallelepiped, an equilateral cuboid
	/// and a right rhombohedron. It is a regular square prism in three orientations.
	///
	/// It is drawn starting from a 3D reference coordinate, with the specified size.
	/// The cube is drawn with the current color, e.g. set with ofSetColor().
	/// The cube is drawn filled by default; change this with ofFill();
	///
	/// \param x The x-coordinate of the cube's origin.
	/// \param y The y-coordinate of the cube's origin.
	/// \param z The z-coordinate of the cube's origin.
	/// \param size The size of the cube.
	void drawBox(float x, float y, float z, float size) const;

	/// \brief Draws a rectangular box with the specified dimensions, starting from the specified position.
	///
	/// A box is a rectangular solid: an extruded rectangle.
	/// It is drawn starting from a 3D reference coordinate.
	/// It has a width (in x), a height (in y), and a depth (in z).
	/// The box is drawn with the current color, e.g. set with ofSetColor().
	/// The box is drawn filled by default; change this with ofFill();
	///
	/// \param position an glm::vec3 which contains the (x,y,z) coordinates for the box's reference corner.
	/// \param width The width of the box.
	/// \param height The height of the box.
	/// \param depth The depth of the box.
	void drawBox(const glm::vec3& position, float width, float height, float depth) const;

	/// \brief Draws a cube with the specified size, starting from the specified position.
	///
	/// A cube is drawn starting from a 3D reference position, with the specified size.
	/// The cube is drawn with the current color, e.g. set with ofSetColor().
	/// The cube is drawn filled by default; change this with ofFill();
	///
	/// \param position an glm::vec3 which contains the (x,y,z) coordinates for the cube's reference corner.
	/// \param size The size of the cube.
	void drawBox(const glm::vec3& position, float size) const;

	/// \brief Draws a cube with the specified size, starting from the origin.
	///
	/// The cube is drawn with the current color, e.g. set with ofSetColor().
	/// The cube is drawn filled by default; change this with ofFill();
	///
	/// \param size The size of the cube.
	void drawBox(float size) const;

	/// \brief Draws a rectangular box with the specified dimensions, starting from the origin.
	///
	/// A box is a rectangular solid: an extruded rectangle.
	/// It is drawn starting from the origin of the current reference frame.
	/// It has a width (in x), a height (in y), and a depth (in z).
	/// The box is drawn with the current color, e.g. set with ofSetColor().
	/// The box is drawn filled by default; change this with ofFill();
	///
	/// \param width The width of the box.
	/// \param height The height of the box.
	/// \param depth The depth of the box.
	void drawBox( float width, float height, float depth ) const;

	void drawAxis(float size) const;
	void drawGrid(float stepSize, size_t numberOfSteps, bool labels, bool x, bool y, bool z) const;
	void drawGridPlane(float stepSize, size_t numberOfSteps, bool labels) const;
	void drawArrow(const glm::vec3& start, const glm::vec3& end, float headSize) const;
	void drawRotationAxes(float radius, float stripWidth, int circleRes) const;

private:
	void renderCached3dPrimitive( const of3dPrimitive& model ) const;
	mutable ofBaseRenderer * renderer;
	ofPlanePrimitive plane;
	ofSpherePrimitive sphere;
	ofIcoSpherePrimitive icoSphere;
	ofBoxPrimitive box;
	ofConePrimitive cone;
	ofCylinderPrimitive cylinder;
	ofBoxPrimitive boxWireframe;
	of3dPrimitive axis;
};

#line 0 "../libs/openFrameworks/graphics/ofGraphics.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofGraphicsBaseTypes.h" */
/* #include "ofRectangle.h" */
#include "glm/fwd.hpp"
///* #include "ofUtils.h" */

class ofVec3f;
class ofVec2f;

template<typename T>
class ofColor_;

typedef ofColor_<unsigned char> ofColor;
typedef ofColor_<float> ofFloatColor;
typedef ofColor_<unsigned short> ofShortColor;

template<typename T>
std::string ofToString(const T&);

/// \cond INTERNAL
#define  	CIRC_RESOLUTION		    22
/// \endcond

/// \name Color
/// \{

/// \brief Sets the draw color with r,g,b, 0-255. For example, red would
/// be: ofSetColor(255,0,0). This affects not only the color of shapes drawn
/// with ofDrawRectangle(), ofDrawCircle(), etc, but also the tint of images and
/// textures.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofSetColor(0,0,255);    //set the color to blue
///     ofDrawRectangle(10,10,100,100);
/// }
/// ~~~~
void ofSetColor(int r, int g, int b);

/// \brief Sets the draw color with r,g,b,a 0-255.
///
/// For alpha (transparency), you must first enable transparent blending
/// (turned off by default for performance reasons) with
/// ofEnableAlphaBlending()
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofEnableAlphaBlending();    // turn on alpha blending
///     ofSetColor(255,0,0,127);    // red, 50% transparent
///     ofDrawRectangle(20,20,100,100);
///     ofDisableAlphaBlending();   // turn it back off, if you don't need it
/// }
/// ~~~~
void ofSetColor(int r, int g, int b, int a);
void ofSetColor(const ofColor & color);
void ofSetColor(const ofColor & color, int _a);
void ofSetColor(int gray);

/// Sets the draw color with r,g,b, passed in as a hex. Hex is a conventient
/// way to write colors.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofSetColor(0xffffff);  // white  (255,255,255)
///     ofSetColor(0x000000);  // black  (0,0,0);
///     ofSetColor(0x00ff00);  // green  (0,255,0);
/// }
/// ~~~~
void ofSetHexColor( int hexColor );

/// \brief Draw shapes as outlines with the current draw color.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofSetColor(0,0,255);
///     ofNoFill();
///     ofDrawRectangle(10,10,100,100);  //draws only the outline in blue
/// }
/// ~~~~
void ofNoFill();

/// \brief Draw shapes filled with the current draw color.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofSetColor(0,0,255);
///     ofFill();
///     ofDrawRect(10,10,100,100);  //draws the rectangle filled in blue
/// }
/// ~~~~
void ofFill();
ofFillFlag ofGetFill();

/// \}
/// \name Background Color
/// \{

/// \brief Returns the current background color as an ofColor.
ofColor ofGetBackgroundColor();
OF_DEPRECATED_MSG("Use ofGetBackgroundColor instead",ofColor ofGetBackground());


/// \brief Sets the background color.
///
/// It takes as input r,g,b (0-255). The background is
/// cleared automatically, just before the draw() command, so if the background
/// color is not changing, you could call this inside of setup() (once, at the
/// start of the application). If the background color is changing, you can call
/// this inside of update().
///
/// ~~~~{.cpp}
/// void ofApp::setup(){
///     ofBackground(255,0,0);  // Sets the background color to red
/// }
/// ~~~~
void ofBackground(int r, int g, int b, int a=255);
void ofBackground(int brightness, int alpha = 255);
void ofBackground(const ofColor & c);

/// \brief Sets the background color using a hex color value.
/// ~~~~{.cpp}
/// void ofApp::setup(){
///     ofBackgroundHex(0xff0000);  // Sets the background color to red
/// }
/// ~~~~
void ofBackgroundHex(int hexColor, int alpha = 255);


/// \brief Sets the background color to a gradient.
///
/// It takes as input 2 ofColor() objects and a Gradient Mode.
/// Must be called in the draw() function.
///
/// Accepted modes are:
///
/// - Circular: `OF_GRADIENT_CIRCULAR`
/// - Linear: `OF_GRADIENT_LINEAR`
/// - Bar: `OF_GRADIENT_BAR`
///
/// **Background Gradient: Circular:**
/// ![Background Gradient Circular](bkgGradient_circular.png)
/// ~~~~{.cpp}
/// void ofApp::draw(){
///
///     ofColor colorOne(255, 0, 0);
///     ofColor colorTwo(0, 0, 0);
///
///     ofBackgroundGradient(colorOne, colorTwo, OF_GRADIENT_CIRCULAR);
///     // Sets the background to a circular gradient
/// }
/// ~~~~
///
/// **Background Gradient: Linear:**
/// ![Background Gradient Linear](bkgGradient_linear.png)
/// ~~~~{.cpp}
/// void ofApp::draw(){
///
///     ofColor colorOne(255, 0, 0);
///     ofColor colorTwo(0, 0, 0);
///
///     ofBackgroundGradient(colorOne, colorTwo, OF_GRADIENT_LINEAR);
///       // Sets the background to a linear gradient
/// }
/// ~~~~
///
/// **Background Gradient: Bar:**
/// ![Background Gradient Bar](bkgGradient_bar.png)
/// ~~~~{.cpp}
/// void ofApp::draw(){
///
///     ofColor colorOne(255, 0, 0);
///     ofColor colorTwo(0, 0, 0);
///
///     ofBackgroundGradient(colorOne, colorTwo, OF_GRADIENT_BAR);
///       // Sets the background to a bar gradient
/// }
/// ~~~~
void ofBackgroundGradient(const ofColor& start, const ofColor& end, ofGradientMode mode = OF_GRADIENT_CIRCULAR);

/// \brief Sets the background color. It takes as input r,g,b (0-255). The
/// background is cleared automatically, just before the draw() command, so
/// if the background color is not changing, you could call this inside
/// setup() (once, at the start of the application). If the background color
/// is changing, you can call this inside update().
///
/// ~~~~{.cpp}
/// void ofApp::setup(){
///     ofSetBackgroundColor(255,0,0);  // Sets the background color to red
/// }
/// ~~~~
void ofSetBackgroundColor(int r, int g, int b, int a=255);
void ofSetBackgroundColor(int brightness, int alpha = 255);
void ofSetBackgroundColor(const ofColor & c);

/// \brief Sets the background color using a hex color value.
/// ~~~~{.cpp}
/// void ofApp::setup(){
///     ofSetBackgroundColorHex(0xff0000);  // Sets the background color to red
/// }
/// ~~~~
void ofSetBackgroundColorHex(int hexColor, int alpha = 255);

/// \brief Sets the background clearing function to be auto (default) or not. If non-
/// auto, then background clearing will not occur per frame (at the start of
/// draw) but rather, whenever ofBackground is called.
///
/// ~~~~{.cpp}
/// void ofApp::setup(){
///     ofSetBackgroundAuto(false); //disable automatic background redraw
/// }
/// void ofApp::draw(){
///     if(ofGetFrameNum() % 10 == 0){
///         // draws a black background every 10 frames
///         ofSetBackgroundColor(0,0,0);
///     }
/// }
/// ~~~~
void ofSetBackgroundAuto(bool bManual);		// default is true
bool ofGetBackgroundAuto();

/// \brief Clears the color and depth bits of current renderer and replaces it with
/// an RGB color.
///
/// When drawing to the screen, ofClear() will clear the screen entirely.
///
/// ~~~~{.cpp}
/// void ofApp::draw() {
///     ofClear(255, 0, 0);
///     // Clears current screen and replaces it with red.
///     // Screen will render as a flat color.
/// }
/// ~~~~
///
/// When using the openGL renderer and drawing into an
/// [FBO][1], ofClear() will clear that buffer rather than the main
/// screen.
///
/// ~~~~{.cpp}
/// void ofApp::draw() {
///     ofFbo myFbo;
///     myFbo.allocate(300, 300);
///
///     myFbo.begin();
///         ofClear(255, 0, 0);
///         // Clears FBO buffer and replaces it with red.
///         // No effect in current drawing screen.
///     myFbo.end();
/// }
/// ~~~~
///
/// ofClear() is based on [glClear][2].
///
/// [1]: http://www.openframeworks.cc/documentation/gl/ofFbo.html
/// [2]: http://www.opengl.org/sdk/docs/man/xhtml/glClear.xml
void ofClear(float r, float g, float b, float a=0);

/// \brief Clears the color and depth bits of current renderer and replaces it with a
/// grayscale value.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofClear(128);
///     // Clears current screen and replaces it with a grayscale value.
/// }
/// ~~~~
void ofClear(float brightness, float a=0);

/// \brief Clears the color and depth bits of current renderer and replaces it with
/// an ofColor.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofColor myColor(0, 0, 255);
///     ofClear(myColor);
///     // Clears current screen and replaces it with myColor.
/// }
/// ~~~~

void ofClear(const ofColor & c);
void ofClearAlpha();

// OF's access to settings (bgAuto, origin, corner mode):
OF_DEPRECATED_MSG("Use ofGetBackgroundAuto instead",bool ofbClearBg());

/// \}
/// \name 2D Primitives Drawing
/// \{

/// \brief Draws a triangle, with the three points: (x1,y1),(x2, y2),(x3, y3).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawTriangle(50,10,10,40,90,40);
/// }
/// ~~~~
void ofDrawTriangle(float x1,float y1,float x2,float y2,float x3, float y3);
void ofDrawTriangle(float x1,float y1,float z1,float x2,float y2,float z2,float x3, float y3,float z3);
void ofDrawTriangle(const glm::vec3 & p1, const glm::vec3 & p2, const glm::vec3 & p3);
void ofDrawTriangle(const glm::vec2 & p1, const glm::vec2 & p2, const glm::vec2 & p3);

/// \brief Draws a circle, centered at x,y, with a given radius.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawCircle(150,150,100);
/// }
/// ~~~~
/// Please keep in mind that drawing circle with different outline color and
/// fill requires calling ofNoFill and ofSetColor for drawing stroke and
/// ofFill and again ofSetColor for filled solid color circle.
///
void ofDrawCircle(float x, float y, float radius);
void ofDrawCircle(float x, float y, float z, float radius);
void ofDrawCircle(const glm::vec3 & p, float radius);
void ofDrawCircle(const glm::vec2 & p, float radius);

/// \brief Draws an ellipse from point (x,y) with a given width (w) and height (h).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawEllipse(10,10,50,30);
/// }
/// ~~~~
void ofDrawEllipse(float x, float y, float width, float height);
void ofDrawEllipse(float x, float y, float z, float width, float height);
void ofDrawEllipse(const glm::vec3 & p, float width, float height);
void ofDrawEllipse(const glm::vec2 & p, float width, float height);

/// Draws a line between two points: (x1,y1),(x2,y2).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawLine(10,10,100,100);
/// }
/// ~~~~
void ofDrawLine(float x1,float y1,float x2,float y2);
void ofDrawLine(float x1,float y1,float z1,float x2,float y2,float z2);
void ofDrawLine(const glm::vec3 & p1, const glm::vec3 & p2);
void ofDrawLine(const glm::vec2 & p1, const glm::vec2 & p2);

/// \brief Draws a rectangle from point x,y with a given width and height.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawRect(10,10,100,100);
/// }
/// ~~~~
void ofDrawRectangle(float x1,float y1,float w,float h);


/// \brief Draws an rectangle from the given rectangle.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRectangle rect;
///     rect.x = 10;
///     rect.y = 10;
///     rect.width = 100;
///     rect.height = 100;
///
///     ofDrawRectangle(rect);
/// }
/// ~~~~
void ofDrawRectangle(const ofRectangle & r);


/// \brief Draws an rectangle from point p, with a given width and height.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     glm::vec3 p;      // create a point P
///     p.x = 10;       // set the x of the point
///     p.y = 10;       // set the y of the point
///
///     ofDrawRectangle(p, 80, 80); // Draw the rectangle
/// }
/// ~~~~
void ofDrawRectangle(const glm::vec3 & p,float w,float h);
void ofDrawRectangle(const glm::vec2 & p,float w,float h);


/// Draws an rectangle from point X, Y at depth Z with a given width and height.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawRectangle(10,10,-100, 80, 80); // Draw a rectangle at 100 pixels in depth
/// }
/// ~~~~
void ofDrawRectangle(float x,float y,float z,float w,float h);

/// \brief Draws a rounded rectangle from the given rectangle using given
/// radius.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRectangle myRect;
///     myRect.x = 10;
///     myRect.y = 10;
///     myRect.width = 100;
///     myRect.height = 100;
///
///     ofDrawRectRounded(myRect, 10);
/// }
/// ~~~~
void ofDrawRectRounded(const ofRectangle & b, float r);

/// \brief Draws a rectangle from point p with a given width, height and radius of
/// rounded corners.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofPoint p;
///     p.set ( 10, 10 );
///     ofDrawRectRounded( p, 100, 100, 10 );
/// }
/// ~~~~
void ofDrawRectRounded(const glm::vec3 & p, float w, float h, float r);
void ofDrawRectRounded(const glm::vec2 & p, float w, float h, float r);


/// \brief Draws a rectangle from point X, Y with a given width, height and radius of
/// rounded corners.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawRectRounded(10, 10, 100, 100, 10);
/// }
/// ~~~~
void ofDrawRectRounded(float x, float y, float w, float h, float r);


/// \brief Draws a rectangle from point X, Y, at depth Z with a given width, height and
/// radius of rounded corners.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawRectRounded(10, 10, 10, 100, 100, 10);
/// }
/// ~~~~
void ofDrawRectRounded(float x, float y, float z, float w, float h, float r);


/// \brief Draws a rounded rectangle from point X, Y, at depth Z with a given width,
/// height and radius of rounded corners.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawRectRounded(10, 10, 10, 100, 100, 10);
/// }
/// ~~~~
void ofDrawRectRounded(const glm::vec3 & p, float w, float h, float topLeftRadius,
					   float topRightRadius,
					   float bottomRightRadius,
					   float bottomLeftRadius);
void ofDrawRectRounded(const glm::vec2 & p, float w, float h, float topLeftRadius,
					   float topRightRadius,
					   float bottomRightRadius,
					   float bottomLeftRadius);


/// \brief Draws a rounded rectangle from the given rectangle using different given
/// radius for each of the corners.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRectangle myRect;
///     myRect.x = 10;
///     myRect.y = 10;
///     myRect.width = 100;
///     myRect.height = 100;
///
///     ofDrawRectRounded( myRect, 10, 20, 30, 40 );
/// }
/// ~~~~
void ofDrawRectRounded(const ofRectangle & b, float topLeftRadius,
					   float topRightRadius,
					   float bottomRightRadius,
					   float bottomLeftRadius);

/// \brief Draws a rounded rectangle from point X, Y, at depth Z with a given width,
/// height and different radius for each rounded corner.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawRectRounded(10, 10, 10, 100, 100, 10, 20, 30, 40);
/// }
/// ~~~~
void ofDrawRectRounded(float x, float y, float z, float w, float h, float topLeftRadius,
					   float topRightRadius,
					   float bottomRightRadius,
					   float bottomLeftRadius);

/// \brief Draws a curve from point (x1, y1) to point (x2, y2). The curve is shaped by
/// the two control points (x0,y0) and (x3,y3).
void ofDrawCurve(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3);

/// \brief Draws a 3-dimensional curve from point (x1, y1, z1) to point (x2, y2, z2).
/// The curve is shaped by the two control points (x0, y0, z0) and (x3, y3, z3).
void ofDrawCurve(float x0, float y0, float z0, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3);
void ofDrawBezier(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3);
void ofDrawBezier(float x0, float y0, float z0, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3);

OF_DEPRECATED_MSG("Use ofDrawTriangle instead",void ofTriangle(float x1,float y1,float x2,float y2,float x3, float y3));
OF_DEPRECATED_MSG("Use ofDrawTriangle instead",void ofTriangle(float x1,float y1,float z1,float x2,float y2,float z2,float x3, float y3,float z3));
OF_DEPRECATED_MSG("Use ofDrawTriangle instead",void ofTriangle(const glm::vec3 & p1, const glm::vec3 & p2, const glm::vec3 & p3));

OF_DEPRECATED_MSG("Use ofDrawCircle instead",void ofCircle(float x, float y, float radius));
OF_DEPRECATED_MSG("Use ofDrawCircle instead",void ofCircle(float x, float y, float z, float radius));
OF_DEPRECATED_MSG("Use ofDrawCircle instead",void ofCircle(const glm::vec3 & p, float radius));

OF_DEPRECATED_MSG("Use ofDrawEllipse instead",void ofEllipse(float x, float y, float width, float height));
OF_DEPRECATED_MSG("Use ofDrawEllipse instead",void ofEllipse(float x, float y, float z, float width, float height));
OF_DEPRECATED_MSG("Use ofDrawEllipse instead",void ofEllipse(const glm::vec3 & p, float width, float height));

OF_DEPRECATED_MSG("Use ofDrawLine instead",void ofLine(float x1,float y1,float x2,float y2));
OF_DEPRECATED_MSG("Use ofDrawLine instead",void ofLine(float x1,float y1,float z1,float x2,float y2,float z2));
OF_DEPRECATED_MSG("Use ofDrawLine instead",void ofLine(const glm::vec3 & p1, const glm::vec3 & p2));

OF_DEPRECATED_MSG("Use ofDrawRectangle instead",void ofRect(float x1,float y1,float w,float h));
OF_DEPRECATED_MSG("Use ofDrawRectangle instead",void ofRect(const ofRectangle & r));
OF_DEPRECATED_MSG("Use ofDrawRectangle instead",void ofRect(const glm::vec3 & p,float w,float h));
OF_DEPRECATED_MSG("Use ofDrawRectangle instead",void ofRect(float x,float y,float z,float w,float h));

OF_DEPRECATED_MSG("Use ofDrawRectRounded instead",void ofRectRounded(const ofRectangle & b, float r));
OF_DEPRECATED_MSG("Use ofDrawRectRounded instead",void ofRectRounded(const glm::vec3 & p, float w, float h, float r));
OF_DEPRECATED_MSG("Use ofDrawRectRounded instead",void ofRectRounded(float x, float y, float w, float h, float r));
OF_DEPRECATED_MSG("Use ofDrawRectRounded instead",void ofRectRounded(float x, float y, float z, float w, float h, float r));

//----------------------------------------------------------
OF_DEPRECATED_MSG("Use ofDrawRectRounded instead",void ofRectRounded(const glm::vec3 & p, float w, float h, float topLeftRadius,
																	 float topRightRadius,
																	 float bottomRightRadius,
																	 float bottomLeftRadius));

OF_DEPRECATED_MSG("Use ofDrawRectRounded instead",void ofRectRounded(const ofRectangle & b, float topLeftRadius,
																	 float topRightRadius,
																	 float bottomRightRadius,
																	 float bottomLeftRadius));

OF_DEPRECATED_MSG("Use ofDrawRectRounded instead",void ofRectRounded(float x, float y, float z, float w, float h, float topLeftRadius,
																	 float topRightRadius,
																	 float bottomRightRadius,
																	 float bottomLeftRadius));

OF_DEPRECATED_MSG("Use ofDrawCurve instead",void ofCurve(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3));
OF_DEPRECATED_MSG("Use ofDrawCurve instead",void ofCurve(float x0, float y0, float z0, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3));
OF_DEPRECATED_MSG("Use ofDrawBezier instead",void ofBezier(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3));
OF_DEPRECATED_MSG("Use ofDrawBezier instead",void ofBezier(float x0, float y0, float z0, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3));


/// \}
/// \name Custom Shapes Drawing
/// \{

/// \brief Start drawing a new shape. Needs to be followed by a list of
/// vertex points and lastly a call to ofEndShape().
///
/// ~~~~{.cpp}
/// //draws a star
/// ofSetPolyMode(OF_POLY_WINDING_NONZERO);
/// ofBeginShape();
///   ofVertex(400,135);
///   ofVertex(215,135);
///   ofVertex(365,25);
///   ofVertex(305,200);
///   ofVertex(250,25);
/// ofEndShape();
/// ~~~~
///
/// \sa ofEndShape()
void ofBeginShape();

/// \brief Specifies a single point of a shape. To be called between ofBeginShape() and
/// ofEndShape().
void ofVertex(float x, float y);
void ofVertex(float x, float y, float z);
void ofVertex(const glm::vec3 & p);
void ofVertex(const glm::vec2 & p);
void ofVertices(const std::vector <glm::vec3> & polyPoints);
void ofVertices(const std::vector <glm::vec2> & polyPoints);
void ofVertices(const std::vector <ofVec3f> & polyPoints);
void ofVertices(const std::vector <ofVec2f> & polyPoints);

/// \brief Specifies a single point of a shape. The difference from ofVertex is that
/// the line describing the edge of the shape between two points will be a
/// curve as opposed to a straight line. The curve is automatically generated
/// using the catmull from formula.
///
/// This function has to be called between ofBeginShape() and ofEndShape().
void ofCurveVertex(float x, float y);
void ofCurveVertex(float x, float y, float z);
void ofCurveVertex(const glm::vec3 & p);
void ofCurveVertex(const glm::vec2 & p);

/// \brief Draws a curve through a series of vertices stored as a vector of
/// ofPoints. Should be called between ofBeginShape() and ofEndShape().
void ofCurveVertices(const std::vector <glm::vec3> & curvePoints);
void ofCurveVertices(const std::vector <glm::vec2> & curvePoints);
void ofCurveVertices(const std::vector <ofVec3f> & curvePoints);
void ofCurveVertices(const std::vector <ofVec2f> & curvePoints);

/// \brief Describes a bezier curve through three points of a shape. To be called
/// between ofBeginShape() and ofEndShape().
void ofBezierVertex(float x1, float y1, float x2, float y2, float x3, float y3);
void ofBezierVertex(const glm::vec3 & p1, const glm::vec3 & p2, const glm::vec3 & p3);
void ofBezierVertex(const glm::vec2 & p1, const glm::vec2 & p2, const glm::vec2 & p3);
void ofBezierVertex(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3);


enum ofCloseShape{
	OF_OPEN = 0,
	OF_CLOSE = 1,
};

/// \brief This tells the program that your shape is finished and that it should now
/// draw it to the screen.
///
/// This function must be called otherwise you will not see your shape.
///
/// \param bClose If you set it to true it will automatically close your
/// shape for you. Default false.
void ofEndShape(bool bClose = false);

/// \brief Allows you to draw multiple contours within one shape. Call this
/// between ofBeginShape() and ofEndShape() to create a new contour for your
/// shape.
///
/// \param bClose If set to true then the previous contour will be
/// automatically closed. Default false
void ofNextContour(bool bClose = false);  // for multi contour shapes!


/// \}
/// \name Text Drawing
/// \{


/// \brief Set the bitmap drawing mode
///
/// Valid modes:
///
/// OF_BITMAPMODE_SCREEN: this is the default mode. It projects the 3d prosition onto
/// the screen so the letters always look the same size but can be positioned in any 3d coordinate.
///
/// OF_BITMAPMODE_VIEWPORT: does the same as screen but uses the current viewport instead
/// of the full window if it's different.
///
/// OF_BITMAPMODE_MODEL: uses real 3d coordinates so the text will look scaled if it's not in z=0
///
/// OF_BITMAPMODE_MODEL_BILLBOARD: uses real 3d coordinates but the text always faces the camera.
///
/// OF_BITMAPMODE_SIMPLE: only does 2d and the z coordinate is just disacarded, so if z is not 0
/// the position in which it'll be drawn will be wrong.
///
void ofSetDrawBitmapMode(ofDrawBitmapMode mode);

/// \brief Draws a bitmapped string, on screen, at point (x,y).
///
/// For example, you can write some text on screen like this:
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofDrawBitmapString("hi!!", 100,100);
/// }
/// ~~~~
///
/// Your strings can even be multiline:
/// ~~~~{.cpp}
/// ofDrawBitmapString("a test
/// of multiline
/// text", 100,100);
/// ~~~~
///
/// you can also using dynamically generated strings. For example, to print
/// the frame rate:
/// ~~~~{.cpp}
/// string fpsStr = "frame rate: "+ofToString(ofGetFrameRate(), 2);
/// ofDrawBitmapString(fpsStr, 100,100);
/// ~~~~
///
/// \note ofDrawBitmapString wraps a glut function that uses glDrawPixels. On
/// some graphics cards, you may discover that glDrawPixels is slow (or even,
/// very slow). If so, you might want to investigate using ofTrueTypeFont
/// with a small typeface, non-anti-aliased, as a suitable alternative.
///
/// \sa ofTrueTypeFont
template<typename T>
void ofDrawBitmapString(const T & textString, float x, float y);
template<typename T>
void ofDrawBitmapString(const T & textString, const glm::vec3 & p);
template<typename T>
void ofDrawBitmapString(const T & textString, const glm::vec2 & p);
template<typename T>
void ofDrawBitmapString(const T & textString, float x, float y, float z);
template<>
void ofDrawBitmapString(const std::string & textString, const glm::vec3 & p);
template<>
void ofDrawBitmapString(const std::string & textString, const glm::vec2 & p);
template<>
void ofDrawBitmapString(const std::string & textString, float x, float y, float z);
void ofDrawBitmapStringHighlight(std::string text, const glm::vec3& position, const ofColor& background = ofColor::black, const ofColor& foreground = ofColor::white);
void ofDrawBitmapStringHighlight(std::string text, const glm::vec2& position, const ofColor& background = ofColor::black, const ofColor& foreground = ofColor::white);
void ofDrawBitmapStringHighlight(std::string text, int x, int y, const ofColor& background = ofColor::black, const ofColor& foreground = ofColor::white);


/// \}
/// \name Rendering Settings
/// \{

/// \brief Resets openGL screen coordinates and values back to OF defaults.
void ofSetupGraphicDefaults();

void ofSetupScreen();

/// \brief Tells you if rectangle drawing mode is set to drawn from the center or drawn
/// from the top left corner, as set with the ofSetRectMode() function.
///
/// Default is `OF_RECTMODE_CORNER`
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     if(ofGetRectMode() == OF_RECTMODE_CORNER){
///         ofDrawRea10,10,80,80);
///     }
///     else {
///         ofDrawRectangle(50,50,80,80);
///     }
/// }
/// ~~~~
/// \sa ofSetRectMode()
ofRectMode  ofGetRectMode();

/// \brief Sets the resolution for the ofDrawCircle command. By default, the circle is 22
/// points, but if you need to draw larger circles, you can adjust the
/// resolution using this command. All circles are cached in openGL using a
/// display list for optimization purposes.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofSetCircleResolution(10);
///     ofDrawCircle(150,150,100);          //draws a rough circle
///     ofSetCircleResolution(100);
///     ofDrawCircle(450,150,100);          //draws a fine circle
/// }
/// ~~~~
void ofSetCircleResolution(int res);      // if there 22 is a problem, you can change it here
void ofSetCurveResolution(int res);


/// \brief Sets the width of the ofDrawLine() called after.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofSetLineWidth(1);          // set line width to 1
///     ofDrawLine(10,10,100,100);  // draw thin line
///     ofSetLineWidth(10);         // set line width to 10
///     ofDrawLine(10,100,100,10);  // draw fat line
/// }
/// ~~~~
void ofSetLineWidth(float lineWidth);

/// \brief Set depth testing on or off to either sort by z-depth (`true`)
/// or draw order (`false`).
void ofSetDepthTest(bool depthTest);


/// \brief Turns on depth testing so rendering happens according to z-depth rather
/// than draw order.
///
/// \sa ofDisableDepthTest()
void ofEnableDepthTest();

/// \brief Turn off depth testing so rendering happens in draw order rather than by
/// z-depth.
///
/// Turning off depth test is useful for combining 3d scenes with 2d
/// overlays such as a control panel.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///
///     ofPushMatrix();
///
///         ofTranslate( ofGetWidth()/2, ofGetHeight()/2, 0 );
///
///         ofEnableDepthTest();
///         ofSetColor(255);
///         ofDrawSphere(0,0,100,60);
///         ofSetColor(255,0,255);
///         ofDrawSphere(50,0,50,100);
///         ofDisableDepthTest();
///
///         ofSetColor(0);
///         ofDrawRectangle(75,75,120,30);
///         ofSetColor(255);
///         ofDrawBitmapString("Some bubbles.",85,90);
///
///     ofPopMatrix();
/// }
/// ~~~~
///
/// \sa ofEnableDepthTest()
void ofDisableDepthTest();

/// \brief Sets and enables the blend mode for drawing. The options are:
///
///     OF_BLENDMODE_DISABLED
///     OF_BLENDMODE_ALPHA
///     OF_BLENDMODE_ADD
///     OF_BLENDMODE_SUBTRACT
///     OF_BLENDMODE_MULTIPLY
///     OF_BLENDMODE_SCREEN
///
/// There is a blendingExample in the openFrameworks examples > graphics
void ofEnableBlendMode(ofBlendMode blendMode);

/// \brief Disable the current blend mode.
void ofDisableBlendMode();

/// \brief Turn on point sprite.
///
/// Textures can be mapped onto points. By default, point size is 1pt. So
/// texture is not shown correctly. You can change point size by
/// `glPointSize(GLfloat size).
void ofEnablePointSprites();

/// \brief Turn off point sprites
void ofDisablePointSprites();

/// \brief Turns on alpha blending (which is on by default since OF version 0.8.0).
/// It simply wraps opengl commands that enable blending, and turn on a common
/// blend mode.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofEnableAlphaBlending();    // turn on alpha blending
///     ofSetColor(255,0,0,127);    // red, 50% transparent
///     ofDrawRectangle(20,20,100,100);      // draws the rect with alpha
///     ofDisableAlphaBlending();   // turn off alpha
///     ofDrawRectangle(120,20,100,100);     // draws the rect without alpha
/// }
/// ~~~~
void ofEnableAlphaBlending();  // this just turns on and off opengl blending, the common mode

/// \brief Turn off alpha blending.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofEnableAlphaBlending();    // turn on alpha blending
///     ofSetColor(255,0,0,127);    // red, 50% transparent
///     ofDrawRectangle(20,20,100,100);      // draws the rect with alpha
///     ofDisableAlphaBlending();   // turn off alpha
///     ofDrawRectangle(120,20,100,100); // draws the rect without alpha
/// }
/// ~~~~
///
/// \sa ofEnableAlphaBlending()
void ofDisableAlphaBlending();

void ofEnableSmoothing();

/// \brief Turn off smoothing. Currently, this only works for lines. You can draw a
/// filled object, and then draw the outline with smoothing enabled to get
/// smoothing effects on filled shapes.
void ofDisableSmoothing();

/// Enables anti-aliasing (smoothing) for lines.
void ofEnableAntiAliasing();

/// \brief Turns off anti-aliasing (smoothing).
void ofDisableAntiAliasing();

// drawing style - combines color, fill, blending and smoothing
ofStyle ofGetStyle();

/// \brief Set the current style of the ofGraphics.
/// \param style contains information of the graphics style such as
/// ofColor, ofFill, polyMode and others.
///
/// \sa See ofStyle for more details.
void ofSetStyle(ofStyle style);

/// \brief Saves the current style settings for the ofGraphics after its call.
/// Usage of ofPushStyle and ofPopStyle allow users to have more control of
/// certain graphics elements. All the style that applies to certain elements
/// is controled using ofStyle class. See ofStyle type.
///
/// In the following example the properties of being red and filled only applies to the ellipse:
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofPushStyle();  // push the current style for use later
///     ofFill();
///     ofSetColor(255,0,0);
///     ofDrawEllipse(30,10,40,40);
///     ofPopStyle();   // recall the pushed style
///
///     ofDrawCircle(10,10,5);
/// }
/// ~~~~
/// sa ofPopStyle()
void ofPushStyle();

/// \brief Restores the prior style settings. It needs to be called after ofPushStyle.
///
/// \sa ofPushStyle()
void ofPopStyle();

/// \brief Sets the drawing behavior for overlapping parts of the same polygon.
///
/// Possible modes are:
///
///     OF_POLY_WINDING_ODD
///     OF_POLY_WINDING_NONZERO
///     OF_POLY_WINDING_POSITIVE
///     OF_POLY_WINDING_NEGATIVE
///     OF_POLY_WINDING_ABS_GEQ_TWO
void ofSetPolyMode(ofPolyWindingMode mode);

/// \brief Sets the mode for drawing rectangles and other rectangular objects, if
/// they are corner aligned, or drawn so that the x,y position is the center
/// of the rectangle. possible options are `OF_RECTMODE_CENTER` and
/// `OF_RECTMODE_CORNER`. This affects not only how ofDrawRectangle() objects are drawn,
/// but also ofTexture (and therefore ofImage) objects.
///
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofSetRectMode(OF_RECTMODE_CORNER); //set rectangle mode to the corner
///     ofDrawRectangle(10,10,80,80);
///     ofSetRectMode(OF_RECTMODE_CENTER); //set rectangle mode to the center
///     ofDrawRectangle(50,50,80,80);
///     // both rectangles are drawn at the same place
/// }
/// ~~~~
void ofSetRectMode(ofRectMode mode);

/// \}
/// \name Transformation
/// \{

/// \brief Saves the current coordinate system allowing users to develop specific
/// movements in some graphic objects. ofPopMatrix needs to be called after.
///
/// In the following example we only rotate the square.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofPushMatrix();         // push the current coordinate position
///     ofRotateX(90);          // change the coordinate system
///     ofDrawRea10,10,40,40);  // draw a rect
///     ofPopMatrix()           // recall the pushed coordinate position
///     ofDrawCircle(10, 10, 5);    // draw a circle
/// }
/// ~~~~
void ofPushMatrix();

/// \brief Restores the prior coordinate system.
///
/// \sa ofPushMatrix()
void ofPopMatrix();

/// \brief Query the current (oF internal) Transformation Matrix state.
glm::mat4 ofGetCurrentMatrix(ofMatrixMode matrixMode);

/// \brief Query the current (oF internal) Orientation Matrix state.
/// \note  The matrix returned is the matrix openFrameworks uses internally
///        to calculate the (final, oriented) projection matrix as it is
///        passed on to the GPU.
///
///        Currently, only GL Programmable Renderer and GL Renderer
///        implement ofGetCurrentOrientationMatrix.
glm::mat4 ofGetCurrentOrientationMatrix();

/// \brief Query the current (oF internal) Normal Matrix state.
/// \note  The matrix returned is the transposed of the inverse of the
///        view matrix
///
///        Currently, only GL Programmable Renderer and GL Renderer
///        implement ofGetCurrentNormalMatrix.
glm::mat4 ofGetCurrentNormalMatrix();

/// \brief Translate by (x,y,z) vector of our coordinate system.
/// The call of ofTranslate() modifies graphics positions.
///
/// Use ofPushMatrix() and ofPopMatrix() to save and restore the untranslated
/// coordinate system.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofTranslate(100, 100, 0);   // move the coordinate system to position x 100 and y 100 and make that zero.
///     ofDrawRectangle(0, 0, 10, 10);       // draw a rect at that position
/// }
/// ~~~~
void ofTranslate(float x, float y, float z = 0);

void ofTranslate(const glm::vec3 & p);
void ofTranslate(const glm::vec2 & p);

void ofScale(float xAmnt, float yAmnt, float zAmnt = 1);

/// \brief Scale along the X, Y and Z axis with the same amount.
void ofScale(float amount);

void ofScale(const glm::vec3 & p);

/// \brief Produces a rotation around the vector (vecX,vecY,vecZ).
///
/// All graphics drawn after ofRotate is called are rotated. Use ofPushMatrix()
/// and ofPopMatrix() to save and restore the unrotated coordinate system.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotate(50, 1, 0.5, 0); //rotates the coordinate system 50 degrees along the x-axis and 25 degrees on the y-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
///
/// \param degrees Specifies the angle of rotation, in degrees.
/// \param vecX specifies the x coordinates of a vector
/// \param vecY specifies the y coordinates of a vector
/// \param vecZ specifies the z coordinates of a vector
OF_DEPRECATED_MSG("Use ofRotateDeg or ofRotateRad", void ofRotate(float degrees, float vecX, float vecY, float vecZ));

/// \brief Rotate around the z-axis
OF_DEPRECATED_MSG("Use ofRotateDeg or ofRotateRad", void ofRotate(float degrees));

/// \brief Produces a rotation around the X-axis of our coordinate
/// system represented by the vector (1,0,0).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateX(45); //rotates the coordinate system 45 degrees around the x-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
OF_DEPRECATED_MSG("Use ofRotateXDeg or ofRotateXRad", void ofRotateX(float degrees));

/// \brief Produces a rotation around the Y-axis of our coordinate
/// system represented by the vector (0,1,0).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateY(45); //rotates the coordinate system 45 degrees around the y-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
OF_DEPRECATED_MSG("Use ofRotateYDeg or ofRotateYRad", void ofRotateY(float degrees));

/// \brief Produces a rotation around the Z-axis of our coordinate
/// system represented by the vector (0,0,1).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateZ(45); //rotates the coordinate system 45 degrees around the z-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
OF_DEPRECATED_MSG("Use ofRotateZDeg or ofRotateZRad", void ofRotateZ(float degrees));

/// \brief Produces a rotation around the vector (vecX,vecY,vecZ).
///
/// All graphics drawn after ofRotate is called are rotated. Use ofPushMatrix()
/// and ofPopMatrix() to save and restore the unrotated coordinate system.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotate(50, 1, 0.5, 0); //rotates the coordinate system 50 degrees along the x-axis and 25 degrees on the y-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
///
/// \param degrees Specifies the angle of rotation, in degrees.
/// \param vecX specifies the x coordinates of a vector
/// \param vecY specifies the y coordinates of a vector
/// \param vecZ specifies the z coordinates of a vector
void ofRotateDeg(float degrees, float vecX, float vecY, float vecZ);

/// \brief Rotate around the z-axis
void ofRotateDeg(float degrees);

/// \brief Produces a rotation around the X-axis of our coordinate
/// system represented by the vector (1,0,0).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateX(45); //rotates the coordinate system 45 degrees around the x-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
void ofRotateXDeg(float degrees);

/// \brief Produces a rotation around the Y-axis of our coordinate
/// system represented by the vector (0,1,0).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateY(45); //rotates the coordinate system 45 degrees around the y-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
void ofRotateYDeg(float degrees);

/// \brief Produces a rotation around the Z-axis of our coordinate
/// system represented by the vector (0,0,1).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateZ(45); //rotates the coordinate system 45 degrees around the z-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
void ofRotateZDeg(float degrees);

/// \brief Produces a rotation around the vector (vecX,vecY,vecZ).
///
/// All graphics drawn after ofRotate is called are rotated. Use ofPushMatrix()
/// and ofPopMatrix() to save and restore the unrotated coordinate system.
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotate(50, 1, 0.5, 0); //rotates the coordinate system 50 degrees along the x-axis and 25 degrees on the y-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
///
/// \param degrees Specifies the angle of rotation, in degrees.
/// \param vecX specifies the x coordinates of a vector
/// \param vecY specifies the y coordinates of a vector
/// \param vecZ specifies the z coordinates of a vector
void ofRotateRad(float degrees, float vecX, float vecY, float vecZ);

/// \brief Rotate around the z-axis
void ofRotateRad(float degrees);

/// \brief Produces a rotation around the X-axis of our coordinate
/// system represented by the vector (1,0,0).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateX(45); //rotates the coordinate system 45 degrees around the x-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
void ofRotateXRad(float degrees);

/// \brief Produces a rotation around the Y-axis of our coordinate
/// system represented by the vector (0,1,0).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateY(45); //rotates the coordinate system 45 degrees around the y-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
void ofRotateYRad(float degrees);

/// \brief Produces a rotation around the Z-axis of our coordinate
/// system represented by the vector (0,0,1).
/// ~~~~{.cpp}
/// void ofApp::draw(){
///     ofRotateZ(45); //rotates the coordinate system 45 degrees around the z-axis
///     ofDrawRectangle(20,20,100,100);
/// }
/// ~~~~
/// \param degrees Specifies the angle of rotation, in degrees.
void ofRotateZRad(float degrees);

/// \}
/// \name Matrix Transformation
/// \{

void ofLoadIdentityMatrix (void);
void ofLoadMatrix (const glm::mat4 & m);   // Andreas: I've included both a mat and a float* version here,
void ofLoadMatrix (const float *m);     // ideally we would always use mat4, but in a lot of temporary
void ofMultMatrix (const glm::mat4 & m);  // mat objects when interacting with non-OF code
void ofMultMatrix (const float *m);
void ofSetMatrixMode(ofMatrixMode matrixMode);
void ofLoadViewMatrix(const glm::mat4 & m);
void ofMultViewMatrix(const glm::mat4 & m);
glm::mat4 ofGetCurrentViewMatrix();


/// \}
/// \name Viewport Setup
/// \{

/// \brief Stores the current viewport and matrix settings
void ofPushView();

/// \brief Restores the viewport and matrix settings set by ofPushView()
void ofPopView();

/// \brief Get if view is flipped vertically
bool ofIsVFlipped();

/// \brief Setup the drawing viewport
/// \param viewport A rectangle describing the size and position of the viewport.
/// If the width or height are set to 0, it will assume the size to be the window
/// size (ofGetWidth(), ofGetHeight())
void ofViewport(ofRectangle viewport);

/// \brief Setup the drawing viewport
/// \param x The x position of the viewport
/// \param y The y position of the viewport
/// \param width The width of the viewport, defaults to ofGetWidth()
/// \param height The height of the viewport, defaults to ofGetHeight()
void ofViewport(float x = 0, float y = 0, float width = -1, float height = -1, bool vflip=ofIsVFlipped());

/// \brief Get the position and size of the current viewport
/// \returns A rectangle describing the viewport
ofRectangle ofGetCurrentViewport();

/// \brief Get the position and size of the native viewport
/// \returns A rectangle describing the viewport
ofRectangle ofGetNativeViewport();

/// \brief Get the width of the current viewport
/// \returns A width in pixels
int ofGetViewportWidth();

/// \brief Get the height of the current viewport
/// \returns A height in pixels
int ofGetViewportHeight();


// if nearDist or farDist are 0 assume defaults (calculated based on width / height)
void ofSetupScreenPerspective(float width = -1, float height = -1, float fov = 60, float nearDist = 0, float farDist = 0);
void ofSetupScreenOrtho(float width = -1, float height = -1, float nearDist = -1, float farDist = 1);

OF_DEPRECATED_MSG("ofSetupScreenPerspective() doesn't accept orientation and vflip parameters anymore, use ofSetOrientation() to specify them",
				  void ofSetupScreenPerspective(float width, float height, ofOrientation orientation, bool vFlip = ofIsVFlipped(), float fov = 60, float nearDist = 0, float farDist = 0)
				  );
OF_DEPRECATED_MSG("ofSetupScreenOrtho() doesn't accept orientation and vflip parameters anymore, use ofSetOrientation() to specify them",
				  void ofSetupScreenOrtho(float width, float height, ofOrientation orientation, bool vFlip = ofIsVFlipped(), float nearDist = -1, float farDist = 1)
				  );

int ofOrientationToDegrees(ofOrientation orientation);

void ofSetCoordHandedness(ofHandednessType handedness);
ofHandednessType ofGetCoordHandedness();

/// \}
/// \name Screen Saving
/// \{

/// \brief Begin rendering to a PDF file.
///
/// openFrameworks allows rendering of 2D graphics to pdf via the
/// ofCairoRenderer. ofBeginSaveScreenAsPDF() is called before drawing. When
/// done drawing call ofEndSaveScreenAsPDF() to output the file.
///
/// ~~~~{.cpp}
/// void ofApp::setup(){
///     ofBeginSaveScreenAsPDF("screenshot.pdf", false);
///     ofSetColor(54,54,54);
///     ofDrawEllipse(100,100,200,200);
///     ofEndSaveScreenAsPDF();
/// }
/// ~~~~
/// \sa End drawing with ofEndSaveScreenAsPDF()
void ofBeginSaveScreenAsPDF(std::string filename, bool bMultipage = false, bool b3D = false, ofRectangle outputsize = ofRectangle(0,0,0,0));

/// \brief Terminates draw to PDF through ofCairoRenderer and outputs the file.
/// \sa ofBeginSaveScreenAsPDF()
void ofEndSaveScreenAsPDF();

/// \brief Begin rendering to a SVG file.
/// \sa ofEndSaveScreenAsSVG(), ofBeginSaveScreenAsPDF()
void ofBeginSaveScreenAsSVG(std::string filename, bool bMultipage = false, bool b3D = false, ofRectangle outputsize = ofRectangle(0,0,0,0));

/// \brief Terminates draw to SVG and outputs the file.
/// \sa ofBeginSaveScreenAsSVG()
void ofEndSaveScreenAsSVG();

/// \}


//--------------------------------------------------
template<typename T>
void ofDrawBitmapString(const T & textString, const glm::vec3 & p){
	ofDrawBitmapString(ofToString(textString), p);
}

//--------------------------------------------------
template<typename T>
void ofDrawBitmapString(const T & textString, const glm::vec2 & p){
	ofDrawBitmapString(ofToString(textString), p);
}

//--------------------------------------------------
template<typename T>
void ofDrawBitmapString(const T & textString, float x, float y){
	ofDrawBitmapString(ofToString(textString), x, y, 0.f);
}

//--------------------------------------------------
template<typename T>
void ofDrawBitmapString(const T & textString, float x, float y, float z){
	ofDrawBitmapString(ofToString(textString), x, y, z);
}

#line 0 "../libs/openFrameworks/graphics/ofPolyline.h"
// This include guard is not a pragma once on purpose
// so some IDEs are happy include this file back form the corresponding inl
#ifndef OF_POLYLINE_H
#define OF_POLYLINE_H

/* #include "ofConstants.h" */
#include "glm/fwd.hpp"
#include <deque>

/// \file
/// ofPolyLine allows you to combine multiple points into a single vector data
/// object that can be drawn to the screen, manipulated point by point, and
/// combined with other ofPolyline instances. It is less complex than the ofPath
/// and generally represents a single line or vector shape rather than multiple
/// lines or shapes.
///
/// You can add points to an ofPolyline by adding vertices:
/// ~~~~{.cpp}
/// float i = 0;
/// while (i < TWO_PI) { // make a heart
/// 	float r = (2-2*sin(i) + sin(i)*sqrt(abs(cos(i))) / (sin(i)+1.4)) * -80;
/// 	float x = ofGetWidth()/2 + cos(i) * r;
/// 	float y = ofGetHeight()/2 + sin(i) * r;
/// 	line.addVertex(ofVec2f(x,y));
/// 	i+=0.005*HALF_PI*0.5;
/// }
/// line.close(); // close the shape
/// ~~~~
///
/// Or you can draw lines or curves:
/// ~~~~{.cpp}
/// float angle = 0;
/// while (angle < TWO_PI ) {
/// 	b.curveTo(100*cos(angle), 0, 100*sin(angle));
/// 	b.curveTo(300*cos(angle), 300, 300*sin(angle));
/// 	angle += TWO_PI / 30;
/// }
/// ~~~~
///
/// ofPolyline also includes methods to get the closest point, determine whether a
/// point is inside shape, and resample shapes. Along with the ofPath class, it's
/// the best way to draw and manipulate 2D and 3D vector graphics that you'll need
/// to update and manipulate frequently.
///
/// If you use the lineTo() or curveTo() or bezierTo() functions, you move the
/// drawing point, so that drawing a line to 100,100 means a line from 0,0 to
/// 100, 100. The next line would be a line from 100,100 to wherever you go
/// next. Storing this position means that you can easily create continuous
/// drawings without difficulty.



class ofRectangle;

template<class T>
class ofPolyline_ {
public:
	/// \name Constructors
	/// \{

	/// \brief Creates an ofPolyline.
	ofPolyline_();

	/// \brief Creates an ofPolyline from a vector of ofVec2f or T objects.
	ofPolyline_(const std::vector<T>& verts);

	static ofPolyline_ fromRectangle(const ofRectangle& rect);

    /// \}
    /// \name Add and Remove Vertices
    /// \{

	/// \brief Removes all the points from the ofPolyline.
	void clear();

	/// \brief Adds a point using an T at the end of the ofPolyline.
	void addVertex( const T& p );

    /// \brief Adds a point using floats at the end of the ofPolyline.
	void addVertex( float x, float y, float z=0 );

	/// \brief Add multiple points at the end of the ofPolyline using a vector of
	/// T objects
	///
	/// ~~~~{.cpp}
	/// 	// make a pentagon
	/// 	float size = 80.f;
	/// 	float X1 = 0.125*sqrt(10 + 2*sqrt(5)) * size;
	/// 	float X2 = 0.125*sqrt(10 - 2*sqrt(5)) * size;
	/// 	float Y1 = 0.125*(sqrt(5) - 1) * size;
	/// 	float Y2 = 0.125*(sqrt(5) + 1) * size;
	/// 	vector<T> verts = {
	///			{0, -0.5 * size, 0.f),
	///			{-X1, -Y1, 0.f},
	///			{-X2, Y2, 0.f},
	///			{X2, Y2, 0.f},
	///			{X1, -Y1, 0.f},
	///		};
	/// 	ofPolyline p;
	/// 	p.addVertices(verts);
	/// ~~~~
	void addVertices( const std::vector<T>& verts );

	/// \brief Adds multiple points at the end of the ofPolyline using a pointer to
	/// an array of T objects.
	void addVertices(const T* verts, int numverts);

	void insertVertex(const T &p, int index);
	void insertVertex(float x, float y, float z, int index);

	/// \brief Resize the number of points in the ofPolyline to the value
	/// passed in.
	void resize(size_t size);

	/// \}
	/// \name Access Vertices
	/// \{

	/// \brief The number of points in the ofPolyline.
	size_t size() const;

	/// Allows you to access the points of the ofPolyline just like you would
	/// in an array, so to make the points of a line follow the mouse
	/// movement, you could do:
	///
	/// ~~~~{.cpp}
	/// line[0].set(mouseX, mouseY);
	/// int i = 1;
	/// while ( i<bounds.size()) {
	/// 	float angle = atan2(line[i-1].y - line[i].y, line[i-1].x - line[i].x);
	/// 	bounds[i].set(bounds[i-1].x - cos(angle) * 20, bounds[i-1].y - sin(angle) * 20);
	/// 	i++;
	/// }
	/// ~~~~
	const T& operator[] (int index) const;
	T& operator[] (int index);

	/// \brief Gets a vector of vertices that the line contains
	std::vector<T> & getVertices();
	const std::vector<T> & getVertices() const;

	typename std::vector<T>::iterator begin();
	typename std::vector<T>::const_iterator begin() const;
	typename std::vector<T>::reverse_iterator rbegin();
	typename std::vector<T>::const_reverse_iterator rbegin() const;
	typename std::vector<T>::iterator end();
	typename std::vector<T>::const_iterator end() const;
	typename std::vector<T>::reverse_iterator rend();
	typename std::vector<T>::const_reverse_iterator rend() const;

	/// \}
	/// \name Lines and Curves
	/// \{

	/// \brief Add a straight line from the last point added, or from 0,0 if no point
	/// is set, to the point indicated by the T passesd in.
	void lineTo(const T & to ){ addVertex(to); }

	/// \brief Add a straight line from the last point added, or from 0,0 if no point
	/// is set, to the point indicated by the floats x,y,z passesd in.
	void lineTo(float x, float y, float z=0){
		addVertex(x,y,z);
	}

	/// \brief Adds an arc around the T `center` with the width of `radiusX`
	/// and the height of `radiusY` to the polyline.
	///
	/// The `angleBegin` and `angleEnd` indicate the start and end angles of
	/// the arc in degrees measured clockwise from the x-axis.
	///
	/// The `clockwise` boolean sets the drawing direction.  Passing 'false' to
	/// it will draw the arc counter-clockwise.
	///
	/// Optionally, you can specify `circleResolution`, which is the number of
	/// line segments a circle would be drawn with.
	///
	/// If the arc doesn't start at the same point the last vertex finished a
	/// straight line will be created to join both
	void arc(const T & center, float radiusX, float radiusY, float angleBegin, float angleEnd, bool clockwise, int circleResolution = 20);

	/// \brief Adds an arc around the T `center` with the width of
	/// `radiusX` and the height of `radiusY`.
	///
	/// The `angleBegin` and `angleEnd` indicate the start and end angles
	/// of the arc in degrees measured clockwise from the x-axis.
	///
	/// Optionally, you can specify `circleResolution`, which is the number of
	/// line segments a circle would be drawn with. A partial arc will be
	/// drawn with the same resolution: if circleResolution == 20, a half-
	/// circle will be drawn with 10 segments.
	///
	/// If there are already vertexes in the ofPolyline the arc will extend
	/// them; a line will be created from the endmost point on the ofPolyline
	/// to the beginning point of the arc.
	///
	/// ~~~~{.cpp}
	/// ofPolyline polyline1, polyline2;
	///
	/// // draw an line, then an semi-circle in red
	/// polyline2.lineTo(300, 50);
	/// T point2(450,120);
	/// polyline2.arc(point2,100,100,0,180);
	/// ofSetColor(ofColor::red);
	/// polyline2.draw();
	/// ~~~~
	///
	/// ![Arc Example](graphics/ofpolyline_arc.jpg)
	void arc(const T & center, float radiusX, float radiusY, float angleBegin, float angleEnd, int circleResolution = 20) {
		arc(center, radiusX,  radiusY,  angleBegin,  angleEnd, true,  circleResolution);
	}

	/// \brief Adds an arc around the coordinates (`x`,`y`) with the width of
	/// `radiusX` and the height of `radiusY`.
	///
	/// The `angleBegin` and `angleEnd` indicate the start and end angles
	/// of the arc in degrees measured clockwise from the x-axis.
	///
	/// Optionally, you can specify `circleResolution`, which is the number
	/// of line segments a circle would be drawn with.
	void arc(float x, float y, float radiusX, float radiusY, float angleBegin, float angleEnd, int circleResolution = 20){
		arc(T(x, y, 0.f), radiusX, radiusY, angleBegin, angleEnd, true, circleResolution);
	}

	/// \brief Adds an arc around the coordinates (`x`,`y`,`z`) with the width of
	/// `radiusX` and the height of `radiusY`.
	///
	/// The `angleBegin` and `angleEnd` indicate the start and end angles of
	/// the arc in degrees measured clockwise from the x-axis.
	///
	/// Optionally, you can specify `circleResolution`, which is the number of
	/// line segments a circle would be drawn with.
	void arc(float x, float y, float z, float radiusX, float radiusY, float angleBegin, float angleEnd, int circleResolution = 20){
		arc(T(x, y, z), radiusX, radiusY, angleBegin, angleEnd, true, circleResolution);
	}
	void arcNegative(const T & center, float radiusX, float radiusY, float angleBegin, float angleEnd, int circleResolution = 20) {
		arc(center, radiusX, radiusY, angleBegin, angleEnd, false, circleResolution);
	}
	void arcNegative(float x, float y, float radiusX, float radiusY, float angleBegin, float angleEnd, int circleResolution = 20){
		arc(T(x,y,0.f), radiusX, radiusY, angleBegin, angleEnd, false, circleResolution);
	}
	void arcNegative(float x, float y, float z, float radiusX, float radiusY, float angleBegin, float angleEnd, int circleResolution = 20){
		arc(T(x, y, z), radiusX, radiusY, angleBegin, angleEnd, false, circleResolution);
	}



	/// \brief Adds a curve to an T object passed in
	///
	/// ~~~~{.cpp}
	/// float angle = 0;
	/// while (angle < TWO_PI ) {
	/// 	b.curveTo( T(100*cos(angle), 100*sin(angle)));
	/// 	b.curveTo( T(300*cos(angle), 300*sin(angle)));
	/// 	angle += TWO_PI / 30;
	/// }
	/// ~~~~
	///
	/// \note You need at least 4 points to be able to use curveTo()
	/// \sa [Catmull-Rom splines wiki](http://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline)
	void curveTo( const T & to, int curveResolution = 20 );

	/// \brief Adds a curve to the x,y,z points passed in with the optional
	/// resolution.
	void curveTo(float x, float y, float z = 0,  int curveResolution = 20 ){
		curveTo({x,y,z},curveResolution);
	}

	/// \brief Adds a cubic bezier line from the current drawing point with the 2
	/// control points indicated by T cp1 and cp2, that ends at T
	/// to.
	///
	/// ~~~~{.cpp}
	/// line.addVertex(T(200, 400));
	/// line.bezierTo(100, 100, 800, 100, 700, 400);
	/// ~~~~
	/// ![polyline bezier](bezier.jpg)
	/// The control points are shown in red.
	void bezierTo( const T & cp1, const T & cp2, const T & to, int curveResolution = 20);

	/// \brief Adds a cubic bezier line from the current drawing point with the 2
	/// control points indicated by the coordinates cx1, cy1 and cx2, cy2,
	/// that ends at the coordinates x, y.
	void bezierTo(float cx1, float cy1, float cx2, float cy2, float x, float y, int curveResolution = 20){
		bezierTo({cx1,cy1,0.f}, {cx2,cy2,0.f}, {x,y,0.f}, curveResolution);
	}

	/// \brief Adds a cubic bezier line in 3D space from the current drawing point
	/// with the 2 control points indicated by the coordinates cx1, cy1, cz1
	/// and cx2, cy2, cz2, that ends at the coordinates x, y, z.
	void bezierTo(float cx1, float cy1, float cz1, float cx2, float cy2, float cz2, float x, float y, float z, int curveResolution = 20){
		bezierTo({cx1,cy1,cz1}, {cx2,cy2,cz2}, {x,y,z}, curveResolution);
	}

	/// \brief Adds a quadratic bezier line in 3D space from the current drawing
	/// point with the beginning indicated by the coordinates cx1, cy1, cz1,
	/// the control point at cx2, cy2, cz2, and that ends at the coordinates
	/// x, y, z.
	///
	/// ![polyline curves](graphics/curves.png)
	void quadBezierTo(float cx1, float cy1, float cz1, float cx2, float cy2, float cz2, float x, float y, float z, int curveResolution = 20);

	/// \brief Adds a quadratic bezier line in 2D space from the current drawing
	/// point with the beginning indicated by the point p1, the control point
	/// at p2, and that ends at the point p3.
	void quadBezierTo(  const T & p1, const T & p2, const T & p3,  int curveResolution = 20 ){
		quadBezierTo(p1.x,p1.y,p1.z,p2.x,p2.y,p2.z,p3.x,p3.y,p3.z,curveResolution);
	}

	/// \brief Adds a quadratic bezier line in 2D space from the current drawing
	/// point with the beginning indicated by the coordinates cx1, cy1, the
	/// control point at cx2, cy2, and that ends at the coordinates x, y.
	void quadBezierTo(float cx1, float cy1, float cx2, float cy2, float x, float y, int curveResolution = 20){
		quadBezierTo(cx1,cy1,0,cx2,cy2,0,x,y,0,curveResolution);
	}

	/// \}
	/// \name Smoothing and Resampling
	/// \{

	/// \brief Gets a smoothed version of the ofPolyline.
	///
	/// `smoothingSize` is the size of the smoothing window. So if
	/// `smoothingSize` is 2, then 2 points from the left, 1 in the center,
	/// and 2 on the right (5 total) will be used for smoothing each point.
	/// `smoothingShape` describes whether to use a triangular window (0) or
	/// box window (1) or something in between (for example, .5).
	ofPolyline_ getSmoothed(int smoothingSize, float smoothingShape = 0) const;

	/// \brief Resamples the line based on the spacing passed in. The larger the
	/// spacing, the more points will be eliminated.
	///
	/// ~~~~{.cpp}
	/// line.draw();
	/// ofTranslate(400, 0);
	/// line.getResampledBySpacing(100).draw();
	/// ~~~~
	/// ![polyline resample](graphics/resample.jpg)
	ofPolyline_ getResampledBySpacing(float spacing) const;

	/// \brief Resamples the line based on the count passed in. The lower the
	/// count passed in, the more points will be eliminated.
	///
	/// This doesn't add new points to the line.
	ofPolyline_ getResampledByCount(int count) const;

	/// \brief Simplifies the polyline, removing un-necessary vertices.
	///
	/// \param tolerance determines how dis-similar points need to be to stay in the line.
	/// Higher tolerance means more points removed, lower tolerance means less
	/// points removed.
	void simplify(float tolerance=0.3f);

	/// \}
	/// \name Transform polyline
	/// \{

	void rotateDeg(float degrees, const glm::vec3& axis);
	void rotateRad(float radians, const glm::vec3& axis);
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", void rotate(float degrees, const glm::vec3& axis));

	void translate(const glm::vec3 & p);

	void rotateDeg(float degrees, const glm::vec2& axis);
	void rotateRad(float radians, const glm::vec2& axis);
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", void rotate(float degrees, const glm::vec2& axis));

	void translate(const glm::vec2 & p);

	/// \brief Change the size of the ofPolyline
	/// These changes are non-reversible, so for instance
	/// scaling by 0,0 zeros out all data.
	void scale(float x, float y);

	/// \}
	/// \name Polyline State
	/// \{

	/// \brief Closes the ofPolyline, meaning that all the vertices will be linked
	/// and can be "walked".
	void close();

	/// \brief Closes the ofPolyline, meaning that all the vertices will be linked
	/// and can be "walked".
	void setClosed( bool tf );
	bool isClosed() const;


	/// \brief Returns whether the vertices within the line have changed.
	bool hasChanged();
	void flagHasChanged();

	/// \}
	/// \name Geometric Functions
	/// \{

	/// \brief Tests whether the x,y coordinates are within a closed ofPolyline.
	static bool inside(float x, float y, const ofPolyline_ & polyline);
	/// \brief Tests whether the x,y coordinates are within a closed ofPolyline.
	bool inside(float x, float y) const;

	/// \brief Tests whether the T is within a closed ofPolyline.
	static bool inside(const T & p, const ofPolyline_ & polyline);
	/// \brief Tests whether the T is within a closed ofPolyline.
	bool inside(const T & p) const;

	/// \brief Get the bounding box of the polyline , taking into account
	/// all the points to determine the extents of the polyline.
	ofRectangle getBoundingBox() const;

	/// \brief Gets the size of the perimeter of the polyline, good for
	/// determining length of the line, rather than just the bounding box
	/// shape.
	float getPerimeter() const;

	/// \brief Gets the precise area bounded by the line
	float getArea() const;

	/// \brief Get the center of the area bounded by the line
	T getCentroid2D() const;

	/// \brief Gets the point on the line closest to the target. You can also
	/// optionally pass a pointer to/address of an unsigned int to get the
	/// index of the closest vertex
	T getClosestPoint(const T& target, unsigned int* nearestIndex = nullptr) const;


	/// \}
	/// \name Other Functions
	/// \{

	/// \brief Get (interpolated) index at given length along the path
	///
	/// Includes info on percentage along segment, e.g. `ret=5.75` =>
	/// 75% along the path between 5th and 6th points
	float getIndexAtLength(float f) const;

	/// \brief Get (interpolated) index at given percentage along the path
	///
	/// Includes info on percentage along segment, e.g. `ret=5.75`
	/// => 75% along the path between 5th and 6th points
	float getIndexAtPercent(float f) const;

	/// \brief Get length along path at index
	float getLengthAtIndex(int index) const;

	/// \brief Get length along path at interpolated index (e.g. `f=5.75` => 75% along
	/// the path between 5th and 6th points)
	float getLengthAtIndexInterpolated(float findex) const;

	/// \brief Get point long the path at a given length (e.g. `f=150` => 150
	/// units along the path)
	T getPointAtLength(float f) const;

	/// \brief Get point along the path at a given percentage (e.g. `f=0.25`
	/// => 25% along the path)
	T getPointAtPercent(float f) const;

	/// \brief Get point along the path at interpolated index (e.g. `f=5.75` =>
	/// 75% along the path between 5th and 6th points)
	T getPointAtIndexInterpolated(float findex) const;

	/// \brief Get angle (degrees) of the path at index
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", float getAngleAtIndex(int index) const);

	/// \brief Get angle (degrees) at interpolated index (interpolated between
	/// neighboring indices)
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", float getAngleAtIndexInterpolated(float findex) const);

	/// \brief Get rotation vector at index (magnitude is sine of angle)
	T getRotationAtIndex(int index) const;

	/// \brief Get rotation vector at interpolated index
	/// (interpolated between neighboring indices) (magnitude is sine of angle)
	T getRotationAtIndexInterpolated(float findex) const;

	/// \brief Get angle (degrees) of the path at index
	float getDegreesAtIndex(int index) const;

	/// \brief Get angle (degrees) at interpolated index (interpolated between
	/// neighboring indices)
	float getDegreesAtIndexInterpolated(float findex) const;

	/// \brief Get angle (degrees) of the path at index
	float getRadiansAtIndex(int index) const;

	/// \brief Get angle (degrees) at interpolated index (interpolated between
	/// neighboring indices)
	float getRadiansAtIndexInterpolated(float findex) const;

	/// \brief Get tangent vector at index
	T getTangentAtIndex(int index) const;

	/// \brief Get tangent vector at interpolated index
	/// (interpolated between neighboring indices)
	T getTangentAtIndexInterpolated(float findex) const;

	/// \brief Get normal vector at index
	T getNormalAtIndex(int index) const;

	/// \brief Get normal vector at interpolated index
	/// (interpolated between neighboring indices)
	T getNormalAtIndexInterpolated(float findex) const;

	/// \brief Get wrapped index depending on whether poly is closed or not
	int getWrappedIndex(int index) const;

	// used for calculating the normals
	void setRightVector(T v = T(0, 0, -1));
	T getRightVector() const;

	/// \}
	/// \name Drawing
	/// \{

	/// \brief Draw the line using the current renderer
	void draw() const;

	/// \}


private:
	void setCircleResolution(int res);
	float wrapAngle(float angleRad);

	std::vector<T> points;
	T rightVector;

	// cache
	mutable std::vector<float> lengths;    // cumulative lengths, stored per point (lengths[n] is the distance to the n'th point, zero based)
	mutable std::vector<T> tangents;       // tangent at vertex, stored per point
	mutable std::vector<T> normals;        //
	mutable std::vector<T> rotations;      // rotation axes between adjacent segments, stored per point (cross product)
	mutable std::vector<float> angles;     // angle (rad) between adjacent segments, stored per point (asin(cross product))
	mutable T centroid2D;
	mutable float area;


	std::deque<T> curveVertices;
	std::vector<T> circlePoints;

	bool bClosed;
	bool bHasChanged;   // public API has access to this
	mutable bool bCacheIsDirty;   // used only internally, no public API to read

	void updateCache(bool bForceUpdate = false) const;

	// given an interpolated index (e.g. 5.75) return neighboring indices and interolation factor (e.g. 5, 6, 0.75)
	void getInterpolationParams(float findex, int &i1, int &i2, float &t) const;

	void calcData(int index, T &tangent, float &angle, T &rotation, T &normal) const;
};

/* #include "ofPolyline.inl" */

using ofPolyline = ofPolyline_<ofDefaultVertexType>;

/// \brief Determine if an (x,y) coordinate is within the polygon defined by a vector of glm::vec3s.
/// \param x The x dimension of the coordinate.
/// \param y The y dimension of the coordinate.
/// \param poly a vector of glm::vec3s defining a polygon.
/// \returns True if the point defined by the coordinates is enclosed, false otherwise.
template<class T>
bool ofInsidePoly(float x, float y, const std::vector<T>& polygon){
	return ofPolyline_<T>::inside(x,y, ofPolyline_<T>(polygon));
}


/// \brief Determine if an glm::vec3 is within the polygon defined by a vector of glm::vec3s.
/// \param p A point to check.
/// \param poly A vector of glm::vec3s defining a polygon.
/// \returns True if the glm::vec3 is enclosed, false otherwise.
template<class T>
bool ofInsidePoly(const T& p, const std::vector<T>& poly){
	return ofPolyline_<T>::inside(p.x,p.y, ofPolyline_<T>(poly));
}

#endif

#line 0 "../libs/openFrameworks/graphics/ofPolyline.inl"
#ifndef OF_POLYLINE_H
/* #include "ofPolyline.h" */
#endif

/* #include "ofConstants.h" */
/* #include "ofRectangle.h" */
/* #include "ofGraphicsBaseTypes.h" */
/* #include "ofVectorMath.h" */
/* #include "ofAppRunner.h" */
/* #include "ofMath.h" */
/* #include "ofLog.h" */

//----------------------------------------------------------
template<class T>
ofPolyline_<T>::ofPolyline_(){
    setRightVector();
	clear();
}

//----------------------------------------------------------
template<class T>
ofPolyline_<T>::ofPolyline_(const std::vector<T>& verts){
    setRightVector();
	clear();
	addVertices(verts);
}

//----------------------------------------------------------
template<class T>
ofPolyline_<T> ofPolyline_<T>::fromRectangle(const ofRectangle& rect) {
	ofPolyline_ polyline;
    polyline.addVertex(rect.getMin());
    polyline.addVertex(rect.getMaxX(),rect.getMinY());
    polyline.addVertex(rect.getMax());
    polyline.addVertex(rect.getMinX(),rect.getMaxY());
    polyline.close();
    return polyline;
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::clear() {
	setClosed(false);
	points.clear();
	curveVertices.clear();
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::addVertex(const T& p) {
	curveVertices.clear();
	points.push_back(p);
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::addVertex(float x, float y, float z) {
	curveVertices.clear();
	addVertex(T(x,y,z));
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::addVertices(const std::vector<T>& verts) {
	curveVertices.clear();
	points.insert( points.end(), verts.begin(), verts.end() );
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::addVertices(const T* verts, int numverts) {
	curveVertices.clear();
	points.insert( points.end(), verts, verts + numverts );
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::insertVertex(const T &p, int index) {
    curveVertices.clear();
    points.insert(points.begin()+index, p);
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::insertVertex(float x, float y, float z, int index) {
	insertVertex(T(x, y, z), index);
}


//----------------------------------------------------------
template<class T>
size_t ofPolyline_<T>::size() const {
	return points.size();
}

//----------------------------------------------------------
template<class T>
const T& ofPolyline_<T>::operator[] (int index) const {
	return points[index];
}

//----------------------------------------------------------
template<class T>
T& ofPolyline_<T>::operator[] (int index) {
    flagHasChanged();
	return points[index];
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::resize(size_t size){
	points.resize(size);
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::setClosed( bool tf ) {
	bClosed = tf;
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
bool ofPolyline_<T>::isClosed() const {
	return bClosed;
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::close(){
    setClosed(true);
}

//----------------------------------------------------------
template<class T>
bool ofPolyline_<T>::hasChanged(){
    if(bHasChanged){
        bHasChanged=false;
        return true;
    }else{
        return false;
    }
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::flagHasChanged() {
    bHasChanged = true;
    bCacheIsDirty = true;
}

//----------------------------------------------------------
template<class T>
std::vector<T> & ofPolyline_<T>::getVertices(){
    flagHasChanged();
	return points;
}

//----------------------------------------------------------
template<class T>
const std::vector<T> & ofPolyline_<T>::getVertices() const {
	return points;
}


//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::setCircleResolution(int res){
	if (res > 1 && res != (int)circlePoints.size()){
		circlePoints.resize(res);
        
		float angle = 0.0f;
		const float angleAdder = M_TWO_PI / (float)res;
		for (int i = 0; i < res; i++){
			circlePoints[i].x = cos(angle);
			circlePoints[i].y = sin(angle);
			circlePoints[i].z = 0.0f;
			angle += angleAdder;
		}
	}
}

//----------------------------------------------------------
template<class T>
// wraps any radian angle -FLT_MAX to +FLT_MAX into 0->2PI range.
// TODO, make angle treatment consistent across all functions
// should always be radians?  or should this take degrees?
// used internally, so perhaps not as important
float ofPolyline_<T>::wrapAngle(float angleRadians) {
	return ofWrap(angleRadians, 0.0f, TWO_PI);
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::bezierTo( const T & cp1, const T & cp2, const T & to, int curveResolution ){
	// if, and only if poly vertices has points, we can make a bezier
	// from the last point
	curveVertices.clear();
    
	// the resolultion with which we computer this bezier
	// is arbitrary, can we possibly make it dynamic?
    
	if (size() > 0){
		float x0 = points[size()-1].x;
		float y0 = points[size()-1].y;
		float z0 = points[size()-1].z;
        
		float   ax, bx, cx;
		float   ay, by, cy;
		float   az, bz, cz;
		float   t, t2, t3;
		float   x, y, z;
        
		// polynomial coefficients
		cx = 3.0f * (cp1.x - x0);
		bx = 3.0f * (cp2.x - cp1.x) - cx;
		ax = to.x - x0 - cx - bx;
        
		cy = 3.0f * (cp1.y - y0);
		by = 3.0f * (cp2.y - cp1.y) - cy;
		ay = to.y - y0 - cy - by;
        
		cz = 3.0f * (cp1.z - z0);
		bz = 3.0f * (cp2.z - cp1.z) - cz;
		az = to.z - z0 - cz - bz;
        
		for (int i = 1; i <= curveResolution; i++){
			t 	=  (float)i / (float)(curveResolution);
			t2 = t * t;
			t3 = t2 * t;
			x = (ax * t3) + (bx * t2) + (cx * t) + x0;
			y = (ay * t3) + (by * t2) + (cy * t) + y0;
			z = (az * t3) + (bz * t2) + (cz * t) + z0;
			points.emplace_back(x,y,z);
		}
	}
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::quadBezierTo(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, int curveResolution){
	curveVertices.clear();
	for(int i=0; i <= curveResolution; i++){
		double t = (double)i / (double)(curveResolution);
		double a = (1.0 - t)*(1.0 - t);
		double b = 2.0 * t * (1.0 - t);
		double c = t*t;
		double x = a * x1 + b * x2 + c * x3;
		double y = a * y1 + b * y2 + c * y3;
		double z = a * z1 + b * z2 + c * z3;
		points.emplace_back(x, y, z);
	}
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::curveTo( const T & to, int curveResolution ){
    
	curveVertices.push_back(to);
    
	if (curveVertices.size() == 4){
        
		float x0 = curveVertices[0].x;
		float y0 = curveVertices[0].y;
		float z0 = curveVertices[0].z;
		float x1 = curveVertices[1].x;
		float y1 = curveVertices[1].y;
		float z1 = curveVertices[1].z;
		float x2 = curveVertices[2].x;
		float y2 = curveVertices[2].y;
		float z2 = curveVertices[2].z;
		float x3 = curveVertices[3].x;
		float y3 = curveVertices[3].y;
		float z3 = curveVertices[3].z;
        
		float t,t2,t3;
		float x,y,z;
        
		for (int i = 1; i <= curveResolution; i++){
            
			t 	=  (float)i / (float)(curveResolution);
			t2 	= t * t;
			t3 	= t2 * t;
            
			x = 0.5f * ( ( 2.0f * x1 ) +
                        ( -x0 + x2 ) * t +
                        ( 2.0f * x0 - 5.0f * x1 + 4 * x2 - x3 ) * t2 +
                        ( -x0 + 3.0f * x1 - 3.0f * x2 + x3 ) * t3 );
            
			y = 0.5f * ( ( 2.0f * y1 ) +
                        ( -y0 + y2 ) * t +
                        ( 2.0f * y0 - 5.0f * y1 + 4 * y2 - y3 ) * t2 +
                        ( -y0 + 3.0f * y1 - 3.0f * y2 + y3 ) * t3 );
            
			z = 0.5f * ( ( 2.0f * z1 ) +
                        ( -z0 + z2 ) * t +
                        ( 2.0f * z0 - 5.0f * z1 + 4 * z2 - z3 ) * t2 +
                        ( -z0 + 3.0f * z1 - 3.0f * z2 + z3 ) * t3 );
            
			points.emplace_back(x,y,z);
		}
		curveVertices.pop_front();
	}
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
void ofPolyline_<T>::arc(const T & center, float radiusX, float radiusY, float angleBegin, float angleEnd, bool clockwise, int circleResolution){
    
    if(circleResolution<=1) circleResolution=2;
    setCircleResolution(circleResolution);
    points.reserve(points.size()+circleResolution);

    const float epsilon = 0.0001f;
    
    const size_t nCirclePoints = circlePoints.size();
    float segmentArcSize  = M_TWO_PI / (float)nCirclePoints;
    
    // convert angles to radians and wrap them into the range 0-M_TWO_PI and
    float angleBeginRad = wrapAngle(ofDegToRad(angleBegin));
    float angleEndRad =   wrapAngle(ofDegToRad(angleEnd));
    
    while(angleBeginRad >= angleEndRad) angleEndRad += M_TWO_PI;
    
    // determine the directional angle delta
    float d = clockwise ? angleEndRad - angleBeginRad : angleBeginRad - angleEndRad;
    // find the shortest angle delta, clockwise delta direction yeilds POSITIVE values
    float deltaAngle = atan2(sin(d),cos(d));
    
    // establish the remaining angle that we have to work through
    float remainingAngle = deltaAngle;
    
    // if the delta angle is in the CCW direction OR the start and stop angles are
    // effectively the same adjust the remaining angle to be a be a full rotation
    if(deltaAngle < 0 || std::abs(deltaAngle) < epsilon) remainingAngle += M_TWO_PI;
    
	T radii(radiusX, radiusY, 0.f);
	T point;
    
    int currentLUTIndex = 0;
    bool isFirstPoint = true; // special case for the first point
    
    while(remainingAngle > 0) {
        if(isFirstPoint) {
            // TODO: should this be the exact point on the circle or
            // should it be an intersecting point on the line that connects two
            // surrounding LUT points?
            //
            // get the EXACT first point requested (for points that
            // don't fall precisely on a LUT entry)
			point = T(cos(angleBeginRad), sin(angleBeginRad), 0.f);
            // set up the get any in between points from the LUT
            float ratio = angleBeginRad / M_TWO_PI * (float)nCirclePoints;
            currentLUTIndex = clockwise ? (int)ceil(ratio) : (int)floor(ratio);
            float lutAngleAtIndex = currentLUTIndex * segmentArcSize;
            // the angle between the beginning angle and the next angle in the LUT table
            float d = clockwise ? (lutAngleAtIndex - angleBeginRad) : (angleBeginRad - lutAngleAtIndex);
            float firstPointDelta = atan2(sin(d),cos(d)); // negative is in the clockwise direction
            
            // if the are "equal", get the next one CCW
            if(std::abs(firstPointDelta) < epsilon) {
                currentLUTIndex = clockwise ? (currentLUTIndex + 1) : (currentLUTIndex - 1);
                firstPointDelta = segmentArcSize; // we start at the next lut point
            }
            
            // start counting from the offset
            remainingAngle -= firstPointDelta;
            isFirstPoint = false;
        } else {
			point = T(circlePoints[currentLUTIndex].x, circlePoints[currentLUTIndex].y, 0.f);
            if(clockwise) {
                currentLUTIndex++; // go to the next LUT point
                remainingAngle -= segmentArcSize; // account for next point
                // if the angle overshoots, then the while loop will fail next time
            } else {
                currentLUTIndex--; // go to the next LUT point
                remainingAngle -= segmentArcSize; // account for next point
                // if the angle overshoots, then the while loop will fail next time
            }
        }
        
        // keep the current lut index in range
        if(clockwise) {
            currentLUTIndex = currentLUTIndex % nCirclePoints;
        } else {
            if(currentLUTIndex < 0) currentLUTIndex = nCirclePoints + currentLUTIndex;
        }
        
        // add the point to the poly line
        point = point * radii + center;
        points.push_back(point);
        
        // if the next LUT point moves us past the end angle then
        // add a a point a the exact end angle and call it finished
        if(remainingAngle < epsilon) {
			point = T(cos(angleEndRad), sin(angleEndRad), 0.f);
            point = point * radii + center;
            points.push_back(point);
            remainingAngle = 0; // call it finished, the next while loop test will fail
        }
    }
    flagHasChanged();
}

//----------------------------------------------------------
template<class T>
float ofPolyline_<T>::getPerimeter() const {
    if(points.size() < 2) {
        return 0;
    } else {
        updateCache();
        return lengths.back();
    }
}

//----------------------------------------------------------
template<class T>
float ofPolyline_<T>::getArea() const{
    updateCache();
    return area;
}

//----------------------------------------------------------
template<class T>
T ofPolyline_<T>::getCentroid2D() const{
    updateCache();
    return centroid2D;
}

//----------------------------------------------------------
template<class T>
ofRectangle ofPolyline_<T>::getBoundingBox() const {
    
	ofRectangle box;
    for(size_t i = 0; i < size(); i++) {
        if(i == 0) {
            box.set(points[i],0,0);
        } else {
            box.growToInclude(points[i]);
        }
    }
	return box;
}

//----------------------------------------------------------
template<class T>
ofPolyline_<T> ofPolyline_<T>::getSmoothed(int smoothingSize, float smoothingShape) const {
	int n = size();
	smoothingSize = ofClamp(smoothingSize, 0, n);
	smoothingShape = ofClamp(smoothingShape, 0, 1);
	
	// precompute weights and normalization
	std::vector<float> weights;
	weights.resize(smoothingSize);
	// side weights
	for(int i = 1; i < smoothingSize; i++) {
		float curWeight = ofMap(i, 0, smoothingSize, 1, smoothingShape);
		weights[i] = curWeight;
	}
	
	// make a copy of this polyline
	ofPolyline_ result = *this;
	
	for(int i = 0; i < n; i++) {
		float sum = 1; // center weight
		for(int j = 1; j < smoothingSize; j++) {
			T cur;
			int leftPosition = i - j;
			int rightPosition = i + j;
			if(leftPosition < 0 && bClosed) {
				leftPosition += n;
			}
			if(leftPosition >= 0) {
				cur += points[leftPosition];
				sum += weights[j];
			}
			if(rightPosition >= n && bClosed) {
				rightPosition -= n;
			}
			if(rightPosition < n) {
				cur += points[rightPosition];
				sum += weights[j];
			}
			result[i] += cur * weights[j];
		}
		result[i] /= sum;
	}
	
	return result;
}

//----------------------------------------------------------
template<class T>
ofPolyline_<T> ofPolyline_<T>::getResampledBySpacing(float spacing) const {
    if(spacing==0 || size() == 0) return *this;
	ofPolyline_ poly;
    float totalLength = getPerimeter();
    for(float f=0; f<totalLength; f += spacing) {
        poly.lineTo(getPointAtLength(f));
    }
    
    if(!isClosed()) {
        if(poly.size() > 0) poly.points.back() = points.back();
        poly.setClosed(false);
    } else {
        poly.setClosed(true);
    }
    
    return poly;
}

//----------------------------------------------------------
template<class T>
ofPolyline_<T> ofPolyline_<T>::getResampledByCount(int count) const {
	float perimeter = getPerimeter();
	if(count < 2) {
		ofLogWarning("ofPolyline_") << "getResampledByCount(): requested " << count <<" points, using minimum count of 2 ";
		count = 2;
    }
	return ofPolyline_<T>::getResampledBySpacing(perimeter / (count-1));
}

//----------------------------------------------------------
// http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/
template<class T>
inline T getClosestPointUtil(const T& p1, const T& p2, const T& p3, float* normalizedPosition) {
	// if p1 is coincident with p2, there is no line
	if(p1 == p2) {
		if(normalizedPosition != nullptr) {
			*normalizedPosition = 0;
		}
		return p1;
	}
	
	float u = (p3.x - p1.x) * (p2.x - p1.x);
	u += (p3.y - p1.y) * (p2.y - p1.y);
	// perfect place for fast inverse sqrt...
	float len = glm::length(toGlm(p2 - p1));
	u /= (len * len);
	
	// clamp u
	if(u > 1) {
		u = 1;
	} else if(u < 0) {
		u = 0;
	}
	if(normalizedPosition != nullptr) {
		*normalizedPosition = u;
	}
	return glm::lerp(toGlm(p1), toGlm(p2), u);
}

//----------------------------------------------------------
template<class T>
// a much faster but less accurate version would check distances to vertices first,
// which assumes vertices are evenly spaced
T ofPolyline_<T>::getClosestPoint(const T& target, unsigned int* nearestIndex) const {
	const ofPolyline_ & polyline = *this;
    
	if(polyline.size() < 2) {
		if(nearestIndex != nullptr) {
			nearestIndex = 0;
		}
		return target;
	}
	
	float distance = 0;
	T nearestPoint;
	unsigned int nearest = 0;
	float normalizedPosition = 0;
	unsigned int lastPosition = polyline.size() - 1;
	if(polyline.isClosed()) {
		lastPosition++;
	}
	for(int i = 0; i < (int) lastPosition; i++) {
		bool repeatNext = i == (int) (polyline.size() - 1);
		
		const auto& cur = polyline[i];
		const auto& next = repeatNext ? polyline[0] : polyline[i + 1];
		
		float curNormalizedPosition = 0;
		auto curNearestPoint = getClosestPointUtil(cur, next, target, &curNormalizedPosition);
		float curDistance = glm::distance(toGlm(curNearestPoint), toGlm(target));
		if(i == 0 || curDistance < distance) {
			distance = curDistance;
			nearest = i;
			nearestPoint = curNearestPoint;
			normalizedPosition = curNormalizedPosition;
		}
	}
	
	if(nearestIndex != nullptr) {
		if(normalizedPosition > .5) {
			nearest++;
			if(nearest == polyline.size()) {
				nearest = 0;
			}
		}
		*nearestIndex = nearest;
	}
	
	return nearestPoint;
}

//--------------------------------------------------
template<class T>
bool ofPolyline_<T>::inside(const T & p, const ofPolyline_ & polyline){
	return ofPolyline_<T>::inside(p.x,p.y,polyline);
}

//--------------------------------------------------
template<class T>
bool ofPolyline_<T>::inside(float x, float y, const ofPolyline_ & polyline){
	int counter = 0;
	int i;
	double xinters;
	T p1,p2;
    
	int N = polyline.size();
    
	p1 = polyline[0];
	for (i=1;i<=N;i++) {
		p2 = polyline[i % N];
		if (y > MIN(p1.y,p2.y)) {
            if (y <= MAX(p1.y,p2.y)) {
                if (x <= MAX(p1.x,p2.x)) {
                    if (p1.y != p2.y) {
                        xinters = (y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
                        if (p1.x == p2.x || x <= xinters)
                            counter++;
                    }
                }
            }
		}
		p1 = p2;
	}
    
	if (counter % 2 == 0) return false;
	else return true;
}

//--------------------------------------------------
template<class T>
bool ofPolyline_<T>::inside(float x, float y) const {
	return ofPolyline_<T>::inside(x, y, *this);
    
}

//--------------------------------------------------
template<class T>
bool ofPolyline_<T>::inside(const T & p) const {
	return ofPolyline_<T>::inside(p, *this);
}



//--------------------------------------------------
namespace of{
	namespace priv{

		//This is for polygon/contour simplification - we use it to reduce the number of points needed in
		//representing the letters as openGL shapes - will soon be moved to ofGraphics.cpp

		// From: http://softsurfer.com/Archive/algorithm_0205/algorithm_0205.htm
		// Copyright 2002, softSurfer (www.softsurfer.com)
		// This code may be freely used and modified for any purpose
		// providing that this copyright notice is included with it.
		// SoftSurfer makes no warranty for this code, and cannot be held
		// liable for any real or imagined damage resulting from its use.
		// Users of this code must verify correctness for their application.
		template<class T>
		struct Segment{
			T P0;
			T P1;
		};

		template<class T>
		static void simplifyDP(float tol, T* v, int j, int k, int* mk ){
			if (k <= j+1) // there is nothing to simplify
				return;

			// check for adequate approximation by segment S from v[j] to v[k]
			int     maxi	= j;          // index of vertex farthest from S
			float   maxd2	= 0;         // distance squared of farthest vertex
			float   tol2	= tol * tol;  // tolerance squared
			Segment<T> S	= {v[j], v[k]};  // segment from v[j] to v[k]
			auto u			= S.P1 - S.P0;   // segment direction vector
			double  cu		= glm::dot(toGlm(u), toGlm(u));     // segment length squared

			// test each vertex v[i] for max distance from S
			// compute using the Feb 2001 Algorithm's dist_ofPoint_to_Segment()
			// Note: this works in any dimension (2D, 3D, ...)
			T  w;
			T  Pb;                // base of perpendicular from v[i] to S
			float  b, cw, dv2;        // dv2 = distance v[i] to S squared

			for (int i=j+1; i<k; i++){
				// compute distance squared
				w = v[i] - S.P0;
				cw = glm::dot(toGlm(w), toGlm(u));
				if ( cw <= 0 ) dv2 = glm::length2(toGlm(v[i]) - toGlm(S.P0));
				else if ( cu <= cw ) dv2 = glm::length2(toGlm(v[i]) - toGlm(S.P1));
				else {
					b = (float)(cw / cu);
					Pb = S.P0 + u*b;
					dv2 = glm::length2(toGlm(v[i]) - toGlm(Pb));
				}
				// test with current max distance squared
				if (dv2 <= maxd2) continue;

				// v[i] is a new max vertex
				maxi = i;
				maxd2 = dv2;
			}
			if (maxd2 > tol2)        // error is worse than the tolerance
			{
				// split the polyline at the farthest vertex from S
				mk[maxi] = 1;      // mark v[maxi] for the simplified polyline
				// recursively simplify the two subpolylines at v[maxi]
				simplifyDP( tol, v, j, maxi, mk );  // polyline v[j] to v[maxi]
				simplifyDP( tol, v, maxi, k, mk );  // polyline v[maxi] to v[k]
			}
			// else the approximation is OK, so ignore intermediate vertices
		}
	}
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::simplify(float tol){
    if(points.size() < 2) return;
    
	int n = size();
	
	if(n == 0) {
		return;
	}

	std::vector <T> sV;
	sV.resize(n);
    
    int    i, k, m, pv;            // misc counters
    float  tol2 = tol * tol;       // tolerance squared
    std::vector<T> vt;
    std::vector<int> mk;
    vt.resize(n);
	mk.resize(n,0);
    
    
    // STAGE 1.  Vertex Reduction within tolerance of prior vertex cluster
    vt[0] = points[0];              // start at the beginning
    for (i=k=1, pv=0; i<n; i++) {
		if (glm::length2((const glm::vec3&)points[i] - (const glm::vec3&)points[pv]) < tol2) continue;
        
        vt[k++] = points[i];
        pv = i;
    }
    if (pv < n-1) vt[k++] = points[n-1];      // finish at the end
    
    // STAGE 2.  Douglas-Peucker polyline simplification
    mk[0] = mk[k-1] = 1;       // mark the first and last vertices
	of::priv::simplifyDP( tol, &vt[0], 0, k-1, &mk[0] );
    
    // copy marked vertices to the output simplified polyline
    for (i=m=0; i<k; i++) {
        if (mk[i]) sV[m++] = vt[i];
    }
    
	//get rid of the unused points
	if( m < (int)sV.size() ){
		points.assign( sV.begin(),sV.begin()+m );
	}else{
		points = sV;
	}
    
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::translate(const glm::vec3 & p){
    for(auto & point : points){
        point += p;
    }
    flagHasChanged();
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::translate(const glm::vec2 &p){
    translate(glm::vec3(p, 0.0));
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::rotateDeg(float degrees, const glm::vec3& axis){
    rotateRad(ofDegToRad(degrees), axis);
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::rotateRad(float radians, const glm::vec3& axis){
    for(auto & point : points){
        point = glm::rotate(toGlm(point), radians, axis);
    }
    flagHasChanged();
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::rotate(float degrees, const glm::vec3 &axis){
    rotateDeg(degrees, axis);
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::rotateDeg(float degrees, const glm::vec2& axis){
    rotateRad(ofDegToRad(degrees), glm::vec3(axis, 0.0));
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::rotateRad(float radians, const glm::vec2& axis){
    rotateRad(radians, glm::vec3(axis, 0.0));
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::rotate(float degrees, const glm::vec2 &axis){
    rotateRad(ofDegToRad(degrees), glm::vec3(axis, 0.0));
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::scale(float x, float y){
    for(auto & point : points){
        point.x *= x;
        point.y *= y;
    }
    flagHasChanged();
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::draw() const{
	ofGetCurrentRenderer()->draw(*this);
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::setRightVector(T v) {
    rightVector = v;
    flagHasChanged();
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getRightVector() const {
    return rightVector;
}

//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getIndexAtLength(float length) const {
    if(points.size() < 2) return 0;
    updateCache();
    
    float totalLength = getPerimeter();
    length = ofClamp(length, 0, totalLength);
    
    int lastPointIndex = isClosed() ? points.size() : points.size()-1;
    
    int i1 = ofClamp(floor(length / totalLength * lastPointIndex), 0, lengths.size()-2);   // start approximation here
    int leftLimit = 0;
    int rightLimit = lastPointIndex;
    
    float distAt1, distAt2;
    for(int iterations = 0; iterations < 32; iterations ++) {	// limit iterations
        i1 = ofClamp(i1, 0, lengths.size()-1);
        distAt1 = lengths[i1];
        if(distAt1 <= length) {         // if Length at i1 is less than desired Length (this is good)
            distAt2 = lengths[i1+1];
            if(distAt2 >= length) {
                float t = ofMap(length, distAt1, distAt2, 0, 1);
                return i1 + t;
            } else {
                leftLimit = i1;
            }
        } else {
            rightLimit = i1;
        }
        i1 = (leftLimit + rightLimit)/2;
    }
    return 0;
}


//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getIndexAtPercent(float f) const {
    return getIndexAtLength(f * getPerimeter());
}

//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getLengthAtIndex(int index) const {
    if(points.size() < 2) return 0;
    updateCache();
    return lengths[getWrappedIndex(index)];
}

//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getLengthAtIndexInterpolated(float findex) const {
    if(points.size() < 2) return 0;
    updateCache();
    int i1, i2;
    float t;
    getInterpolationParams(findex, i1, i2, t);
    return ofLerp(getLengthAtIndex(i1), getLengthAtIndex(i2), t);
}


//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getPointAtLength(float f) const {
	if(points.size() < 2) return T();
    updateCache();
    return getPointAtIndexInterpolated(getIndexAtLength(f));
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getPointAtPercent(float f) const {
    float length = getPerimeter();
    return getPointAtLength(f * length);
}


//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getPointAtIndexInterpolated(float findex) const {
	if(points.size() < 2) return T();
    int i1, i2;
    float t;
    getInterpolationParams(findex, i1, i2, t);
	T leftPoint(points[i1]);
	T rightPoint(points[i2]);
	return glm::lerp(toGlm(leftPoint), toGlm(rightPoint), t);
}


//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getAngleAtIndex(int index) const {
	return getDegreesAtIndex(index);
}

//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getAngleAtIndexInterpolated(float findex) const {
	return getDegreesAtIndexInterpolated(findex);
}


//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getDegreesAtIndex(int index) const {
	if(points.size() < 2) return 0;
	updateCache();
	return ofRadToDeg(angles[getWrappedIndex(index)]);
}

//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getDegreesAtIndexInterpolated(float findex) const {
	if(points.size() < 2) return 0;
	int i1, i2;
	float t;
	getInterpolationParams(findex, i1, i2, t);
	return ofRadToDeg(ofLerp(getDegreesAtIndex(i1), getDegreesAtIndex(i2), t));
}


//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getRadiansAtIndex(int index) const {
	if(points.size() < 2) return 0;
	updateCache();
	return angles[getWrappedIndex(index)];
}

//--------------------------------------------------
template<class T>
float ofPolyline_<T>::getRadiansAtIndexInterpolated(float findex) const {
	if(points.size() < 2) return 0;
	int i1, i2;
	float t;
	getInterpolationParams(findex, i1, i2, t);
	return ofLerp(getRadiansAtIndex(i1), getRadiansAtIndex(i2), t);
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getRotationAtIndex(int index) const {
	if(points.size() < 2) return T();
    updateCache();
    return rotations[getWrappedIndex(index)];
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getRotationAtIndexInterpolated(float findex) const {
	if(points.size() < 2) return T();
    int i1, i2;
    float t;
    getInterpolationParams(findex, i1, i2, t);
	return glm::lerp(toGlm(getRotationAtIndex(i1)), toGlm(getRotationAtIndex(i2)), t);
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getTangentAtIndex(int index) const {
	if(points.size() < 2) return T();
    updateCache();
    return tangents[getWrappedIndex(index)];
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getTangentAtIndexInterpolated(float findex) const {
	if(points.size() < 2) return T();
    int i1, i2;
    float t;
    getInterpolationParams(findex, i1, i2, t);
	return glm::lerp(toGlm(getTangentAtIndex(i1)), toGlm(getTangentAtIndex(i2)), t);
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getNormalAtIndex(int index) const {
	if(points.size() < 2) return T();
    updateCache();
    return normals[getWrappedIndex(index)];
}

//--------------------------------------------------
template<class T>
T ofPolyline_<T>::getNormalAtIndexInterpolated(float findex) const {
	if(points.size() < 2) return T();
    int i1, i2;
    float t;
    getInterpolationParams(findex, i1, i2, t);
	return glm::lerp(toGlm(getNormalAtIndex(i1)), toGlm(getNormalAtIndex(i2)), t);
}


//--------------------------------------------------
template<class T>
void ofPolyline_<T>::calcData(int index, T &tangent, float &angle, T &rotation, T &normal) const {
	int i1 = getWrappedIndex( index - 1 );
	int i2 = getWrappedIndex( index     );
	int i3 = getWrappedIndex( index + 1 );

	const auto &p1 = toGlm(points[i1]);
	const auto &p2 = toGlm(points[i2]);
	const auto &p3 = toGlm(points[i3]);

	auto v1(p1 - p2); // vector to previous point
	auto v2(p3 - p2); // vector to next point
	
	v1 = glm::normalize(v1);
	v2 = glm::normalize(v2);

	// If just one of p1, p2, or p3 was identical, further calculations 
	// are (almost literally) pointless, as v1 or v2 will then contain 
	// NaN values instead of floats.

	bool noSegmentHasZeroLength = (v1 == v1 && v2 == v2);

	if ( noSegmentHasZeroLength ){
		tangent  = toOf( glm::length2(v2 - v1) > 0 ? glm::normalize(v2 - v1) : -v1 );
		normal   = toOf( glm::normalize( glm::cross( toGlm( rightVector ), toGlm( tangent ) ) ) );
		rotation = toOf( glm::cross( v1, v2 ) );
		angle    = glm::pi<float>() - acosf( ofClamp( glm::dot( v1, v2 ), -1.f, 1.f ) );
	} else{
		rotation = tangent = normal = T( 0.f );
		angle    = 0.f;
	}
}


//--------------------------------------------------
template<class T>
int ofPolyline_<T>::getWrappedIndex(int index) const {
    if(points.empty()) return 0;
    
    if(index < 0) return isClosed() ? (index + points.size()) % points.size() : 0;
    if(index > int(points.size())-1) return isClosed() ? index % points.size() : points.size() - 1;
    return index;
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::getInterpolationParams(float findex, int &i1, int &i2, float &t) const {
    i1 = floor(findex);
    t = findex - i1;
    i1 = getWrappedIndex(i1);
    i2 = getWrappedIndex(i1 + 1);
}

//--------------------------------------------------
template<class T>
void ofPolyline_<T>::updateCache(bool bForceUpdate) const {
    if(bCacheIsDirty || bForceUpdate) {
        lengths.clear();
        angles.clear();
        rotations.clear();
        normals.clear();
        tangents.clear();
        area = 0;
		centroid2D = {0.f, 0.f, 0.f};
        bCacheIsDirty = false;
        
        if(points.size() < 2) return;

        // area
        for(int i=0;i<(int)points.size()-1;i++){
            area += points[i].x * points[i+1].y - points[i+1].x * points[i].y;
        }
        area += points[points.size()-1].x * points[0].y - points[0].x * points[points.size()-1].y;
        area *= 0.5;
        
        if(fabsf(area) < FLT_EPSILON) {
            centroid2D = getBoundingBox().getCenter();
        } else {
            // centroid
            // TODO: doesn't seem to work on all concave shapes
            for(int i=0;i<(int)points.size()-1;i++){
                centroid2D.x += (points[i].x + points[i+1].x) * (points[i].x*points[i+1].y - points[i+1].x*points[i].y);
                centroid2D.y += (points[i].y + points[i+1].y) * (points[i].x*points[i+1].y - points[i+1].x*points[i].y);
            }
            centroid2D.x += (points[points.size()-1].x + points[0].x) * (points[points.size()-1].x*points[0].y - points[0].x*points[points.size()-1].y);
            centroid2D.y += (points[points.size()-1].y + points[0].y) * (points[points.size()-1].x*points[0].y - points[0].x*points[points.size()-1].y);
            
            centroid2D.x /= (6*area);
            centroid2D.y /= (6*area);
        }

        
        // per vertex cache
        lengths.resize(points.size());
        tangents.resize(points.size());
        angles.resize(points.size());
        normals.resize(points.size());
        rotations.resize(points.size());
        
        float angle;
		T rotation;
		T normal;
		T tangent;

        float length = 0;
        for(int i=0; i<(int)points.size(); i++) {
            lengths[i] = length;

            calcData(i, tangent, angle, rotation, normal);
            tangents[i] = tangent;
            angles[i] = angle;
            rotations[i] = rotation;
            normals[i] = normal;
            
			length += glm::distance(toGlm(points[i]), toGlm(points[getWrappedIndex(i + 1)]));
        }
        
        if(isClosed()) lengths.push_back(length);
    }
}


//--------------------------------------------------
template<class T>
typename std::vector<T>::iterator ofPolyline_<T>::begin(){
	return points.begin();
}

//--------------------------------------------------
template<class T>
typename std::vector<T>::iterator ofPolyline_<T>::end(){
	return points.end();
}

//--------------------------------------------------
template<class T>
typename std::vector<T>::const_iterator ofPolyline_<T>::begin() const{
	return points.begin();
}

//--------------------------------------------------
template<class T>
typename std::vector<T>::const_iterator ofPolyline_<T>::end() const{
	return points.end();
}

//--------------------------------------------------
template<class T>
typename std::vector<T>::reverse_iterator ofPolyline_<T>::rbegin(){
	return points.rbegin();
}

//--------------------------------------------------
template<class T>
typename std::vector<T>::reverse_iterator ofPolyline_<T>::rend(){
	return points.rend();
}

//--------------------------------------------------
template<class T>
typename std::vector<T>::const_reverse_iterator ofPolyline_<T>::rbegin() const{
	return points.rbegin();
}

//--------------------------------------------------
template<class T>
typename std::vector<T>::const_reverse_iterator ofPolyline_<T>::rend() const{
	return points.rend();
}


#line 0 "../libs/openFrameworks/graphics/ofTessellator.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofGraphicsBaseTypes.h" */


typedef struct TESStesselator TESStesselator;
typedef struct TESSalloc TESSalloc;

/// \brief
/// ofTessellator exists for one purpose: to turn ofPolylines into ofMeshes so
/// that they can be more efficiently displayed using OpenGL. The ofPath class
/// uses tessellation to turn its paths into openGL-ready shapes under the hood,
/// so if you're interested in just having ofPolyline instances converted to
/// meshes, it's handled for you by ofPath. If you're interested in using the
/// tessellation multiple polylines at a time, then you'll find what you need in
/// the ofTessellator. Many shapes can't be drawn by OpenGL without tessellation,
/// but by breaking them into triangles or quads, they can be drawn easily.
/// 
/// An example: The fairly simple shape shown on the left needs to be broken
/// into triangles to be displayed, an example of how this might be done is
/// shown on the right.
/// 
/// ![tessellation](graphics/tessellation.jpg)
class ofTessellator
{
public:	
	ofTessellator();
	~ofTessellator();

	/// \brief Copy constructor to copy properties from one tessellator to another. 
	ofTessellator(const ofTessellator & mom);

	/// \brief Operator overloading to copy properties from one tessellator to another. 
	ofTessellator & operator=(const ofTessellator & mom);

	/// \brief Tessellates a vector of ofPolyline instances into a single
	/// ofMesh instance using the winding mode set in ofPolyWindingMode.
	void tessellateToMesh( const std::vector<ofPolyline>& src, ofPolyWindingMode polyWindingMode, ofMesh & dstmesh, bool bIs2D=false );
	
	/// \brief Tessellates a ofPolyline instance into a single ofMesh instance
	/// using the winding mode set in ofPolyWindingMode.
	void tessellateToMesh( const ofPolyline& src,  ofPolyWindingMode polyWindingMode, ofMesh& dstmesh, bool bIs2D=false );

	/// \brief Tessellates a vector of ofPolyline instances into vector of
	/// ofPolyline instances using the winding mode set in ofPolyWindingMode.	
	void tessellateToPolylines( const std::vector<ofPolyline>& src, ofPolyWindingMode polyWindingMode, std::vector<ofPolyline>& dstpoly, bool bIs2D=false );

	/// \brief Tessellate multiple polylines into a single polyline.
	void tessellateToPolylines( const ofPolyline & src, ofPolyWindingMode polyWindingMode, std::vector<ofPolyline>& dstpoly, bool bIs2D=false );

private:
	
	void performTessellation( ofPolyWindingMode polyWindingMode, ofMesh& dstmesh, bool bIs2D );
	void performTessellation(ofPolyWindingMode polyWindingMode, std::vector<ofPolyline>& dstpoly, bool bIs2D );
	void init();

	TESStesselator * cacheTess;
	TESSalloc tessAllocator;
};



#line 0 "../libs/openFrameworks/graphics/ofPath.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofColor.h" */
/* #include "ofPolyline.h" */
/* #include "ofVboMesh.h" */
/* #include "ofTessellator.h" */

/// \class

/// \brief ofPath is a way to create a path or multiple paths consisting of
/// points. It allows you to combine multiple paths consisting of points into
/// a single vector data object that can be drawn to the screen, manipulated
/// point by point, or manipulated with it's child subpaths. It is better at
/// representing and manipulating complex shapes than the ofPolyline and more
/// easily represents multiple child lines or shapes as either ofSubPath or
/// ofPolyline instances. By default ofPath uses ofSubPath instances. Closing
/// the path automatically creates a new path:
///
/// ~~~~{.cpp}
/// for( int i = 0; i < 5; i++) {
///     // create a new ofSubPath
///     path.arc( i * 50 + 20, i * 50 + 20, i * 40 + 10, i * 40 + 10, 0, 360);
///     path.close();
/// }
/// ~~~~
///
/// To use ofPolyline instances, simply set the mode to POLYLINES
///
/// ~~~~{.cpp}
/// path.setMode(POLYLINES);
/// ~~~~
class ofPath{
public:
	/// \name Create and remove paths and sub paths
	/// \{

	/// \brief Create a new ofPath instance.
	ofPath();

	/// \brief Remove all subpaths from the ofPath instance
	void clear();

	/// \brief Create a new subpath, either an ofPolyline instance or an ofSubPath
	/// instance. All points added after a call to ofSubPath will be done in
	/// the newly created subpath. Calling close() automatically calls create
	/// newSubPath(), ensuring that the closed path doesn't have new points
	/// added to it.
	void newSubPath();

	/// \brief Close the current subpath and create a new subpath, either an
	/// ofPolyline or ofSubPath by calling newSubPath(), ensuring that the
	/// closed path doesn't have new points added to it.
	void close();

	/// \}
	/// \name Sub paths
	/// \{

	/// \brief Draw a straight line from the current drawing position to the
	/// location indicated by p.
	void lineTo(const glm::vec3 & p);
	void lineTo(const glm::vec2 & p);

	/// \brief Draw a straight line from the current drawing position to the
	/// location indicated by x,y.
	void lineTo(float x, float y);

	/// \brief Draw a straight line from the current drawing position to the
	/// location indicated by x,y,z.
	void lineTo(float x, float y, float z);


	/// \brief Move the drawing position to p. This means that a subsequent calls to,
	/// for instance, lineTo() or curveTo() will connect the location p to the new
	/// location.
	void moveTo(const glm::vec3 & p);
	void moveTo(const glm::vec2 & p);

	/// \brief Move the drawing position to x,y.z. This means that a subsequent
	/// calls to, for instance, lineTo() or curveTo() will connect the
	/// location x,y,z to the new location.
	void moveTo(float x, float y, float z=0);

	/// \brief Draws a curve to p from the current drawing position
	void curveTo(const glm::vec3 & p);
	void curveTo(const glm::vec2 & p);

	/// \brief Draws a curve to x,y from the current drawing position
	void curveTo(float x, float y);

	/// \brief Draws a curve to x,y,z from the current drawing position
	void curveTo(float x, float y, float z);

	/// \brief Create a cubic bezier line from the current drawing point with the 2
	/// control points indicated by glm::vec3 `cp1` and `cp2`, that ends at glm::vec3
	/// to.
	///
	/// ~~~~{.cpp}
	/// line.addVertex(glm::vec3(200, 400));
	/// line.bezierTo(100, 100, 800, 100, 700, 400);
	/// ~~~~
	/// ![polyline bezier](graphics/bezier.jpg)
	/// The control points are shown in red.
	void bezierTo(const glm::vec3 & cp1, const glm::vec3 & cp2, const glm::vec3 & p);
	void bezierTo(const glm::vec2 & cp1, const glm::vec2 & cp2, const glm::vec2 & p);

	/// \brief Create a cubic bezier line from the current drawing point with the 2
	/// control points indicated by the coordinates cx1, cy1 and cx2, cy2,
	/// that ends at the coordinates x, y.
	void bezierTo(float cx1, float cy1, float cx2, float cy2, float x, float y);

	/// \brief Create a cubic bezier line in 3D space from the current drawing point
	/// with the 2 control points indicated by the coordinates cx1, cy1, cz1
	/// and cx2, cy2, cz2, that ends at the coordinates x, y, z.
	void bezierTo(float cx1, float cy1, float cz1, float cx2, float cy2, float cz2, float x, float y, float z);

	/// \brief Create a quadratic bezier line in 3D space from the current drawing
	/// point with the beginning indicated by the coordinates cx1, cy1, cz1,
	/// the control point at cx2, cy2, cz2, and that ends at the coordinates
	/// x, y, z.
	/// ![Curves](graphics/curves.jpg)
	void quadBezierTo(const glm::vec3 & cp1, const glm::vec3 & cp2, const glm::vec3 & p);
	void quadBezierTo(const glm::vec2 & cp1, const glm::vec2 & cp2, const glm::vec2 & p);

	/// \brief Creates a quadratic bezier line in 2D space from the current drawing
	/// point with the beginning indicated by the point p1, the control point
	/// at p2, and that ends at the point p3.
	void quadBezierTo(float cx1, float cy1, float cx2, float cy2, float x, float y);

	/// \brief Creates a quadratic bezier line in 3D space from the current drawing
	/// point with the beginning indicated by the coordinates cx1, cy1, the
	/// control point at cx2, cy2, and that ends at the coordinates x, y.
	void quadBezierTo(float cx1, float cy1, float cz1, float cx2, float cy2, float cz2, float x, float y, float z);

	/// \brief Create an arc at centre, which has the radiusX, radiusY, and begins at
	/// angleBegin and ends at angleEnd. To draw a circle with a radius of 50 pixels
	/// at 100, 100:
	///
	/// \note angleBegin needs to be larger than angleEnd, i.e. 0,180 is ok,
	/// while 180,0 is not.
	void arc(const glm::vec3 & centre, float radiusX, float radiusY, float angleBegin, float angleEnd);
	void arc(const glm::vec3 & centre, float radiusX, float radiusY, float angleBegin, float angleEnd, bool clockwise);
	void arc(const glm::vec2 & centre, float radiusX, float radiusY, float angleBegin, float angleEnd);
	void arc(const glm::vec2 & centre, float radiusX, float radiusY, float angleBegin, float angleEnd, bool clockwise);

	/// \brief Create an arc at x,y, which has the radiusX, radiusY, and begins at
	/// angleBegin and ends at angleEnd. To draws a shape with a radius of 200 pixels
	/// at 300, 300:
	///
	/// ~~~~{.cpp}
	/// path.moveTo(300, 300);
	/// path.arc( 300, 300, 200, 200, 0, 271); // note 271, not 270 for precision
	/// ~~~~
	///
	/// ![ofPath arc](graphics/ofPath_arc.jpg)
	///
	/// \note angleBegin needs to be larger than angleEnd, i.e. 0, 180 is ok,
	/// while 180,0 is not.
	void arc(float x, float y, float radiusX, float radiusY, float angleBegin, float angleEnd);

	/// \brief Create an arc at x,y,z, which has the radiusX, radiusY, and begins at
	/// angleBegin and ends at angleEnd.
	void arc(float x, float y, float z, float radiusX, float radiusY, float angleBegin, float angleEnd);

	void arcNegative(const glm::vec3 & centre, float radiusX, float radiusY, float angleBegin, float angleEnd);
	void arcNegative(const glm::vec2 & centre, float radiusX, float radiusY, float angleBegin, float angleEnd);
	void arcNegative(float x, float y, float radiusX, float radiusY, float angleBegin, float angleEnd);
	void arcNegative(float x, float y, float z, float radiusX, float radiusY, float angleBegin, float angleEnd);

	void triangle(float x1,float y1,float x2,float y2,float x3, float y3);
	void triangle(float x1,float y1,float z1,float x2,float y2,float z2,float x3, float y3,float z3);
	void triangle(const glm::vec3 & p1, const glm::vec3 & p2, const glm::vec3 & p3);
	void triangle(const glm::vec2 & p1, const glm::vec2 & p2, const glm::vec2 & p3);

	void circle(float x, float y, float radius);
	void circle(float x, float y, float z, float radius);
	void circle(const glm::vec3 & p, float radius);
	void circle(const glm::vec2 & p, float radius);

	void ellipse(float x, float y, float width, float height);
	void ellipse(float x, float y, float z, float width, float height);
	void ellipse(const glm::vec3 & p, float width, float height);
	void ellipse(const glm::vec2 & p, float width, float height);

	void rectangle(const ofRectangle & r);
	void rectangle(const glm::vec3 & p,float w,float h);
	void rectangle(const glm::vec2 & p,float w,float h);
	void rectangle(float x,float y,float w,float h);
	void rectangle(float x,float y,float z,float w,float h);

	void rectRounded(const ofRectangle & b, float r);
	void rectRounded(const glm::vec3 & p, float w, float h, float r);
	void rectRounded(const glm::vec2 & p, float w, float h, float r);
	void rectRounded(float x, float y, float w, float h, float r);
	void rectRounded(const glm::vec3 & p, float w, float h, float topLeftRadius,
	                                                        float topRightRadius,
	                                                        float bottomRightRadius,
	                                                        float bottomLeftRadius);
	void rectRounded(const glm::vec2 & p, float w, float h, float topLeftRadius,
															float topRightRadius,
															float bottomRightRadius,
															float bottomLeftRadius);
	void rectRounded(const ofRectangle & b, float topLeftRadius,
	                                          float topRightRadius,
	                                          float bottomRightRadius,
	                                          float bottomLeftRadius);
	void rectRounded(float x, float y, float z, float w, float h, float topLeftRadius,
                                                      float topRightRadius,
                                                      float bottomRightRadius,
                                                      float bottomLeftRadius);
	/// \}
	/// \name Winding Mode
	/// \{

	/// \brief Set the way that the points in the sub paths are connected.
	///
	/// OpenGL can only render convex polygons which means that any shape that
	/// isn't convex, i.e. that has points which are concave, going inwards,
	/// need to be tessellated into triangles so that OpenGL can render them.
	/// If you're using filled shapes with your ofPath this is done
	/// automatically for you.
	///
	/// The possible options you can pass in are:
	///
	///     OF_POLY_WINDING_ODD
	///     OF_POLY_WINDING_NONZERO
	///     OF_POLY_WINDING_POSITIVE
	///     OF_POLY_WINDING_NEGATIVE
	///     OF_POLY_WINDING_ABS_GEQ_TWO
	void setPolyWindingMode(ofPolyWindingMode mode);

	/// \brief Get the poly winding mode currently in use.
	ofPolyWindingMode getWindingMode() const;

	/// \}
	/// \name Drawing Mode
	/// \{

	/// \brief Set whether the path should be drawn as wireframes or filled.
	void setFilled(bool hasFill); // default true

	/// \brief Set the stroke width of the line if the ofPath is to be drawn
	/// not in wireframe.
	void setStrokeWidth(float width); // default 0

	/// \brief Set the color of the path. This affects both the line if the
	/// path is drawn as wireframe and the fill if the path is drawn with
	/// fill. All subpaths are affected.
	void setColor( const ofColor& color );

	/// \brief Set the color of the path. This affects both the line if the path is
	/// drawn as wireframe and the fill if the path is drawn with fill. All
	/// subpaths are affected.
	void setHexColor( int hex );

	/// \brief Set the fill color of the path. This has no affect if the path is
	/// drawn as wireframe.
	void setFillColor(const ofColor & color);

	/// \brief Set the fill color of the path. This has no affect if the path is
	/// drawn as wireframe.
	void setFillHexColor( int hex );

	/// \brief Set the stroke color of the path. This has no affect if the path
	/// is drawn filled.
	void setStrokeColor(const ofColor & color);

	/// \brief Set the stroke color of the path. This has no affect if the path
	/// is drawn filled.
	void setStrokeHexColor( int hex );

	/// \brief Get whether the path is using a fill or not.
	///
	/// The default value is `true`
	bool isFilled() const;

	/// \brief Get the ofColor fill of the ofPath
	ofColor getFillColor() const;

	/// \brief Get the stroke color of the ofPath
	ofColor getStrokeColor() const;

	/// \brief Get the stroke width of the ofPath
	///
	/// The default value is `0
	float getStrokeWidth() const;

	bool hasOutline() const { return strokeWidth>0; }

	void setCurveResolution(int curveResolution);
	int getCurveResolution() const;

	void setCircleResolution(int circleResolution);
	int getCircleResolution() const;

	OF_DEPRECATED_MSG("Use setCircleResolution instead.", void setArcResolution(int res));
	OF_DEPRECATED_MSG("Use getCircleResolution instead.", int getArcResolution() const);

	void setUseShapeColor(bool useColor);
	bool getUseShapeColor() const;

	/// \}
	/// \name Drawing
	/// \{

	/// \brief Draws the path at 0,0. Calling draw() also calls tessellate()
	void draw() const;

	/// \brief Draws the path at x,y. Calling draw() also calls tessellate()
	void draw(float x, float y) const;

	/// \}
	/// \name Functions
	/// \{

	/// \brief Get an ofPolyline representing the outline of the ofPath.
	const std::vector<ofPolyline> & getOutline() const;

	void tessellate();

	const ofMesh & getTessellation() const;

	void simplify(float tolerance=0.3f);

	void translate(const glm::vec3 & p);

	void rotateDeg(float degrees, const glm::vec3& axis);
	void rotateRad(float radians, const glm::vec3& axis);
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", void rotate(float degrees, const glm::vec3& axis ));

	void translate(const glm::vec2 & p);

	void rotateDeg(float degrees, const glm::vec2& axis);
	void rotateRad(float radians, const glm::vec2& axis);
	OF_DEPRECATED_MSG("Use Deg/Rad versions.", void rotate(float degrees, const glm::vec2& axis ));

	/// \brief Change the size of either the ofPolyline or ofSubPath instances that
	/// the ofPath contains. These changes are non-reversible, so for instance
	/// scaling by 0,0 zeros out all data.
	void scale(float x, float y);

	void append(const ofPath & path);

	/// \}
	/// \name Path Mode
	/// \{

	enum Mode{
		COMMANDS,
		POLYLINES
	};

	void setMode(Mode mode);
	Mode getMode();

	/// \}
	/// \name Path Commands
	/// \{

	struct Command{
		enum Type{
			moveTo,
			lineTo,
			curveTo,
			bezierTo,
			quadBezierTo,
			arc,
			arcNegative,
			close
		};

		/// for close
		Command(Type type);

		/// for lineTo and curveTo
		Command(Type type , const glm::vec3 & p);

		/// for bezierTo
		Command(Type type , const glm::vec3 & p, const glm::vec3 & cp1, const glm::vec3 & cp2);

		///for arc
		Command(Type type , const glm::vec3 & centre, float radiusX, float radiusY, float angleBegin, float angleEnd);


		Type type;
		glm::vec3 to;
		glm::vec3 cp1, cp2;
		float radiusX, radiusY, angleBegin, angleEnd;
	};

	std::vector<Command> & getCommands();
	const std::vector<Command> & getCommands() const;

	/// \}

private:

	ofPolyline & lastPolyline();
	void addCommand(const Command & command);
	void generatePolylinesFromCommands();

	// only needs to be called when path is modified externally
	void flagShapeChanged();
	bool hasChanged();

	// path description
	//vector<ofSubPath>		paths;
	std::vector<Command> 	commands;
	ofPolyWindingMode 	windingMode;
	ofColor 			fillColor;
	ofColor				strokeColor;
	float				strokeWidth;
	bool				bFill;
	bool				bUseShapeColor;

	// polyline / tessellation
	std::vector<ofPolyline>  polylines;
	std::vector<ofPolyline>  tessellatedContour; // if winding mode != ODD

#ifdef TARGET_OPENGLES
	ofMesh				cachedTessellation;
#else
	ofVboMesh			cachedTessellation;
#endif
#if defined(TARGET_EMSCRIPTEN)
	static ofTessellator tessellator;
#elif HAS_TLS
	static thread_local ofTessellator tessellator;
#else
	ofTessellator tessellator;
#endif
	bool				bHasChanged;
	int					prevCurveRes;
	int					curveResolution;
	int					circleResolution;
	bool 				bNeedsTessellation;
	bool				bNeedsPolylinesGeneration;

	Mode				mode;
};

#line 0 "../libs/openFrameworks/gl/ofLight.h"
/*
 *  ofLight.h
 *  openFrameworksLib
 *
 *  Created by Memo Akten on 14/01/2011.
 *  Copyright 2011 MSA Visuals Ltd. All rights reserved.
 *
 */

// TODO:


#pragma once

/* #include "ofNode.h" */
/* #include "ofColor.h" */

class ofBaseGLRenderer;

enum ofLightType {
	OF_LIGHT_POINT=0,
	OF_LIGHT_DIRECTIONAL=1,
	OF_LIGHT_SPOT=2,
	OF_LIGHT_AREA=3 // Only programmable renderer
};

void ofEnableLighting();
void ofDisableLighting();
void ofEnableSeparateSpecularLight();
void ofDisableSeparateSpecularLight();
bool ofGetLightingEnabled();
void ofSetSmoothLighting(bool b);
void ofSetGlobalAmbientColor(const ofFloatColor& c);
const ofFloatColor & ofGetGlobalAmbientColor();

//----------------------------------------
// Use the public API of ofNode for all transformations
class ofLight : public ofNode {
public:
	ofLight();
	
    void setup();
	void enable();
	void disable();
	bool getIsEnabled() const;
	
	void setDirectional();
	bool getIsDirectional() const;
	
	void setSpotlight( float spotCutOff=45.f, float exponent=0.f );
	bool getIsSpotlight() const;
	void setSpotlightCutOff( float spotCutOff );
    float getSpotlightCutOff() const;
	void setSpotConcentration( float exponent );
    float getSpotConcentration() const;
	
	void setPointLight();
	bool getIsPointLight() const;
	void setAttenuation( float constant=1.f, float linear=0.f, float quadratic=0.f );
    float getAttenuationConstant() const;
    float getAttenuationLinear() const;
    float getAttenuationQuadratic() const;

    void setAreaLight(float width, float height);
    bool getIsAreaLight() const;
	
	int getType() const;
	
	void setAmbientColor(const ofFloatColor& c);
	void setDiffuseColor(const ofFloatColor& c);
	void setSpecularColor(const ofFloatColor& c);
	
	ofFloatColor getAmbientColor() const;
	ofFloatColor getDiffuseColor() const;
	ofFloatColor getSpecularColor() const;
	
	int getLightID() const;

	class Data{
	public:
		Data();
		~Data();

		ofFloatColor ambientColor;
		ofFloatColor diffuseColor;
		ofFloatColor specularColor;

	    float attenuation_constant;
	    float attenuation_linear;
	    float attenuation_quadratic;

		ofLightType lightType;

		int glIndex;
		int isEnabled;
	    float spotCutOff;
	    float exponent;
		glm::vec4 position;
		glm::vec3 direction;

	    float width;
	    float height;
		glm::vec3 up;
		glm::vec3 right;
		/// weak link back to renderer for which this light was created/setup
		std::weak_ptr<ofBaseGLRenderer> rendererP;
	};
	
private:
	void customDraw(const ofBaseRenderer * renderer) const;
	std::shared_ptr<Data> data;
	// update opengl light 
	// this method overrides ofNode to catch the changes and update glLightv(GL_POSITION)
	virtual void onPositionChanged();
	virtual void onOrientationChanged();
};


std::vector<std::weak_ptr<ofLight::Data> > & ofLightsData();

#line 0 "../libs/openFrameworks/gl/ofShader.h"
#pragma once


/*
 todo: add support for attachment of multiple shaders
 if a uniform or attribute isn't available, this will cause an error
 make sure to catch and report that error.
 */

/* #include "ofConstants.h" */
/* #include "ofFileUtils.h" */
#include "glm/fwd.hpp"
#include <unordered_map>
#include <map>

class ofTexture;
class ofMatrix3x3;
class ofParameterGroup;
class ofBufferObject;
class ofBaseHasTexture;

template<typename T>
class ofColor_;
typedef ofColor_<float> ofFloatColor;

enum ofLogLevel: short;

struct ofShaderSettings {
    std::map<GLuint, std::filesystem::path> shaderFiles;
    std::map<GLuint, std::string> shaderSources;
    std::map<std::string, int> intDefines;
    std::map<std::string, float> floatDefines;
    std::filesystem::path sourceDirectoryPath;
    bool bindDefaults = true;
};

class ofShader {

	struct Source{
		Source(GLuint type, const std::string & source, const std::filesystem::path & directoryPath)
			:type(type)
			,source(source)
			,directoryPath(directoryPath){}

		Source(){}

		GLuint type;
		std::string source;
		std::string expandedSource;
		std::filesystem::path directoryPath;
		std::map<std::string, int>   intDefines;
		std::map<std::string, float> floatDefines;
	};

public:
	ofShader();
	~ofShader();
	ofShader(const ofShader & shader);
	ofShader & operator=(const ofShader & shader);
	ofShader(ofShader && shader);
	ofShader & operator=(ofShader && shader);

	bool load(const std::filesystem::path& shaderName);
	bool load(const std::filesystem::path& vertName, const std::filesystem::path& fragName, const std::filesystem::path& geomName="");
#if !defined(TARGET_OPENGLES) && defined(glDispatchCompute)
	bool loadCompute(const std::filesystem::path& shaderName);
#endif

#if !defined(TARGET_OPENGLES)
	struct TransformFeedbackSettings {
		std::map<GLuint, std::filesystem::path> shaderFiles;
		std::map<GLuint, std::string> shaderSources;
		std::vector<std::string> varyingsToCapture;
		std::map<std::string, int> intDefines;
		std::map<std::string, float> floatDefines;
		std::filesystem::path sourceDirectoryPath;
		bool bindDefaults = true;
		GLuint bufferMode = GL_INTERLEAVED_ATTRIBS; // GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS
	};

	/// a range of the buffer will be bound with glBindBufferRange
	///
	/// @see: https://www.opengl.org/sdk/docs/man4/html/glBindBufferRange.xhtml
	struct TransformFeedbackRangeBinding {
		TransformFeedbackRangeBinding(const ofBufferObject & buffer, GLuint offset, GLuint size);

		GLuint index = 0;
		GLuint offset = 0;
		GLuint size;
	private:
		const ofBufferObject & buffer;
		friend class ofShader;
	};

	/// full buffer will be bound with glBindBufferBase
	///
	/// @see: https://www.opengl.org/sdk/docs/man4/html/glBindBufferBase.xhtml
	struct TransformFeedbackBaseBinding {
		TransformFeedbackBaseBinding(const ofBufferObject & buffer);

		GLuint index = 0;
	private:
		const ofBufferObject & buffer;
		friend class ofShader;
	};
#endif

	bool setup(const ofShaderSettings & settings);
#if !defined(TARGET_OPENGLES)
	bool setup(const TransformFeedbackSettings & settings);
#endif

	// these are essential to call before linking the program with geometry shaders
	void setGeometryInputType(GLenum type); // type: GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_EXT, GL_TRIANGLES, GL_TRIANGLES_ADJACENCY_EXT
	void setGeometryOutputType(GLenum type); // type: GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP
	void setGeometryOutputCount(int count);	// set number of output vertices

	int getGeometryMaxOutputCount() const;		// returns maximum number of supported vertices


	void unload();

	bool isLoaded() const;

	void begin() const;
	void end() const;

#if !defined(TARGET_OPENGLES)
	void beginTransformFeedback(GLenum mode) const;
	void beginTransformFeedback(GLenum mode, const TransformFeedbackRangeBinding & binding) const;
	void beginTransformFeedback(GLenum mode, const std::vector<TransformFeedbackRangeBinding> & binding) const;
	void beginTransformFeedback(GLenum mode, const TransformFeedbackBaseBinding & binding) const;
	void beginTransformFeedback(GLenum mode, const std::vector<TransformFeedbackBaseBinding> & binding) const;
	void endTransformFeedback() const;
	void endTransformFeedback(const TransformFeedbackRangeBinding & binding) const;
	void endTransformFeedback(const std::vector<TransformFeedbackRangeBinding> & binding) const;
	void endTransformFeedback(const TransformFeedbackBaseBinding & binding) const;
	void endTransformFeedback(const std::vector<TransformFeedbackBaseBinding> & binding) const;
#endif

#if !defined(TARGET_OPENGLES) && defined(glDispatchCompute)
	void dispatchCompute(GLuint x, GLuint y, GLuint z) const;
#endif

	// set a texture reference
	void setUniformTexture(const std::string & name, const ofBaseHasTexture& img, int textureLocation) const;
	void setUniformTexture(const std::string & name, const ofTexture& img, int textureLocation) const;
	void setUniformTexture(const std::string & name, int textureTarget, GLint textureID, int textureLocation) const;

	// set a single uniform value
	void setUniform1i(const std::string & name, int v1) const;
	void setUniform2i(const std::string & name, int v1, int v2) const;
	void setUniform3i(const std::string & name, int v1, int v2, int v3) const;
	void setUniform4i(const std::string & name, int v1, int v2, int v3, int v4) const;

	void setUniform1f(const std::string & name, float v1) const;
	void setUniform2f(const std::string & name, float v1, float v2) const;
	void setUniform3f(const std::string & name, float v1, float v2, float v3) const;
	void setUniform4f(const std::string & name, float v1, float v2, float v3, float v4) const;

	void setUniform2f(const std::string & name, const glm::vec2 & v) const;
	void setUniform3f(const std::string & name, const glm::vec3 & v) const;
	void setUniform4f(const std::string & name, const glm::vec4 & v) const;
	void setUniform4f(const std::string & name, const ofFloatColor & v) const;

	// set an array of uniform values
	void setUniform1iv(const std::string & name, const int* v, int count = 1) const;
	void setUniform2iv(const std::string & name, const int* v, int count = 1) const;
	void setUniform3iv(const std::string & name, const int* v, int count = 1) const;
	void setUniform4iv(const std::string & name, const int* v, int count = 1) const;

	void setUniform1fv(const std::string & name, const float* v, int count = 1) const;
	void setUniform2fv(const std::string & name, const float* v, int count = 1) const;
	void setUniform3fv(const std::string & name, const float* v, int count = 1) const;
	void setUniform4fv(const std::string & name, const float* v, int count = 1) const;

	void setUniforms(const ofParameterGroup & parameters) const;

	// note: it may be more optimal to use a 4x4 matrix than a 3x3 matrix, if possible
	void setUniformMatrix3f(const std::string & name, const glm::mat3 & m, int count = 1) const;
	void setUniformMatrix4f(const std::string & name, const glm::mat4 & m, int count = 1) const;

	GLint getUniformLocation(const std::string & name) const;

	// set attributes that vary per vertex (look up the location before glBegin)
	GLint getAttributeLocation(const std::string & name) const;

#ifndef TARGET_OPENGLES
#ifdef GLEW_ARB_uniform_buffer_object
	GLint getUniformBlockIndex(const std::string & name) const;
	GLint getUniformBlockBinding(const std::string & name) const;
	void bindUniformBlock(GLuint bindind, const std::string & name) const;
	void printActiveUniformBlocks() const;
#endif
#endif

#ifndef TARGET_OPENGLES
	void setAttribute1s(GLint location, short v1) const;
	void setAttribute2s(GLint location, short v1, short v2) const;
	void setAttribute3s(GLint location, short v1, short v2, short v3) const;
	void setAttribute4s(GLint location, short v1, short v2, short v3, short v4) const;
#endif

	void setAttribute1f(GLint location, float v1) const;
	void setAttribute2f(GLint location, float v1, float v2) const;
	void setAttribute3f(GLint location, float v1, float v2, float v3) const;
	void setAttribute4f(GLint location, float v1, float v2, float v3, float v4) const;

#ifndef TARGET_OPENGLES
	void setAttribute1d(GLint location, double v1) const;
	void setAttribute2d(GLint location, double v1, double v2) const;
	void setAttribute3d(GLint location, double v1, double v2, double v3) const;
	void setAttribute4d(GLint location, double v1, double v2, double v3, double v4) const;
#endif

	void setAttribute1fv(const std::string & name, const float* v, GLsizei stride=sizeof(float)) const;
	void setAttribute2fv(const std::string & name, const float* v, GLsizei stride=sizeof(float)*2) const;
	void setAttribute3fv(const std::string & name, const float* v, GLsizei stride=sizeof(float)*3) const;
	void setAttribute4fv(const std::string & name, const float* v, GLsizei stride=sizeof(float)*4) const;

	void bindAttribute(GLuint location, const std::string & name) const;

	void printActiveUniforms() const;
	void printActiveAttributes() const;


	// advanced use

	// these methods create and compile a shader from source or file
	// type: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_GEOMETRY_SHADER_EXT etc.
	bool setupShaderFromSource(GLenum type, std::string source, std::string sourceDirectoryPath = "");
	bool setupShaderFromFile(GLenum type, const std::filesystem::path& filename);

	// links program with all compiled shaders
	bool linkProgram();

	// binds default uniforms and attributes, only useful for
	// fixed pipeline simulation under programmable renderer
	// has to be called before linking
	bool bindDefaults();

	GLuint getProgram() const;
	GLuint getShader(GLenum type) const;

	bool operator==(const ofShader & other) const;
	bool operator!=(const ofShader & other) const;


	// these are used only for openGL ES2 or GL3/4 using the programmable GL renderer
	enum defaultAttributes{
		POSITION_ATTRIBUTE=0,  // tig: was =1, and BOY, what a performance hog this was!!! see: http://www.chromium.org/nativeclient/how-tos/3d-tips-and-best-practices
		COLOR_ATTRIBUTE,
		NORMAL_ATTRIBUTE,
		TEXCOORD_ATTRIBUTE,
		INDEX_ATTRIBUTE  // usually not used except for compute shades
	};

	/// @brief returns the shader source as it was passed to the GLSL compiler
	/// @param type (GL_VERTEX_SHADER | GL_FRAGMENT_SHADER | GL_GEOMETRY_SHADER_EXT) the shader source you'd like to inspect.
	std::string getShaderSource(GLenum type) const;


private:
	GLuint program = 0;
	bool bLoaded = false;

	struct Shader{
		GLuint id;
		Source source;
	};

	std::unordered_map<GLenum, Shader> shaders;
	std::unordered_map<std::string, GLint> uniformsCache;
	mutable std::unordered_map<std::string, GLint> attributesBindingsCache;

#ifndef TARGET_OPENGLES
	std::unordered_map<std::string, GLint> uniformBlocksCache;
#endif

	bool setupShaderFromSource(Source && source);
	ofShader::Source sourceFromFile(GLenum type, const std::filesystem::path& filename);
	void checkProgramInfoLog();
	bool checkProgramLinkStatus();
	void checkShaderInfoLog(GLuint shader, GLenum type, ofLogLevel logLevel);
	template<typename T>
	void setDefineConstantTemp(const std::string & name, T value);
	template<typename T>
	void setConstantTemp(const std::string & name, const std::string & type, T value);
	
	static std::string nameForType(GLenum type);

	/// @brief			Mimics the #include behaviour of the c preprocessor
	/// @description	Includes files specified using the
	///					'#pragma include <filepath>' directive.
	/// @note			Include paths are always specified _relative to the including file's current path_
	///	@note			Recursive #pragma include statements are possible
	/// @note			Includes will be processed up to 32 levels deep
	static std::string parseForIncludes( const std::string& source, const std::filesystem::path& sourceDirectoryPath = "");
	static std::string parseForIncludes( const std::string& source, std::vector<std::string>& included, int level = 0, const std::filesystem::path& sourceDirectoryPath = "");

	void checkAndCreateProgram();
#ifdef TARGET_ANDROID
	void unloadGL();
	void reloadGL();
#endif
};


#line 0 "../libs/openFrameworks/gl/ofMaterial.h"
#pragma once
/* #include "ofColor.h" */
/* #include "ofShader.h" */
/* #include "ofConstants.h" */
#include "glm/fwd.hpp"

// Material concept: "Anything graphical applied to the polygons"
//
// Diederick Huijbers <diederick[at]apollomedia[dot]nl>
//
// references:
//   * Wavefront material file spec: http://people.sc.fsu.edu/~jburkardt/data/mtl/mtl.html
//   * Ogre3D: http://www.ogre3d.org/docs/manual/manual_11.html#SEC14
//   * assim material: http://assimp.sourceforge.net/lib_html/ai_material_8h.html#7dd415ff703a2cc53d1c22ddbbd7dde0

class ofGLProgrammableRenderer;

/// \class ofMaterialSettings
/// wrapper for material color properties and other settings
///
/// customUniforms: adds some uniforms to the shader so they can be accessed
/// from the postFragment function
///
/// postFragment: Adds a function to the material shader that will get
/// executed after all lighting and material calculations
///
/// The source passed has to include a function with the
/// signature:
///
/// vec4 postFragment(vec4 localColor){
///     return localColor;
/// }
///
/// which will receive the final color after calculating all
/// the lights and material and can modify it and return a new color
///
/// The function has access to the following variables:
///
///     vec2 v_texcoord;          // texture coordinate
///     vec3 v_normal;            // normal at this fragment
///     vec3 v_transformedNormal; // normal multiplied by the normal matrix
///     vec3 v_eyePosition;       // position of this fragment in eye coordinates
///     vec3 v_worldPosition;     // position of this fragment in world coordinates
///     vec4 v_color;             // color interpolated from the vertex colors
///     SAMPLER tex0;             // the bound texture if there's any
///
///     vec4 mat_ambient;         // material ambient color
///     vec4 mat_diffuse;         // material diffuse color
///     vec4 mat_specular;        // material specular
///     vec4 mat_emissive;        // material emissive
///     float mat_shininess;      // material shininess
///
///     vec4 global_ambient;      // global ambient light
///     mat4 modelViewMatrix;     // model view matrix
///     mat4 projectionMatrix;    // projection matrix
///     mat4 textureMatrix;       // texture matrix
///     mat4 modelViewProjectionMatrix; // model view projection matrix
///
///     MAX_LIGHTS                // the total number of lights in the scen
///
/// And an array of lights
/// each light has the following properties:
///
///     float lights[i].enabled;
///     vec4 lights[i].ambient;
///     float lights[i].type;     // 0 = pointlight
///                               // 1 = directionlight
///                               // 2 = spotlight
///                               // 3 = area
///     vec4 lights[i].position;  // where are we
///     vec4 lights[i].diffuse;   // how diffuse
///     vec4 lights[i].specular;  // what kinda specular stuff we got going on?
///
///     // attenuation, how the light attenuates with the distance
///     float lights[i].constantAttenuation;
///     float lights[i].linearAttenuation;
///     float lights[i].quadraticAttenuation;
///
///     // only for spot
///     float lights[i].spotCutoff;
///     float lights[i].spotCosCutoff;
///     float lights[i].spotExponent;
///
///     // spot and area
///     vec3 lights[i].spotDirection;
///
///     // only for directional
///     vec3 lights[i].halfVector;
///
///     // only for area
///     float lights[i].width;
///     float lights[i].height;
///     vec3 lights[i].right;
///     vec3 lights[i].up;
///
struct ofMaterialSettings {
    ofFloatColor diffuse{ 0.8f, 0.8f, 0.8f, 1.0f }; ///< diffuse reflectance
    ofFloatColor ambient{ 0.2f, 0.2f, 0.2f, 1.0f }; ///< ambient reflectance
    ofFloatColor specular{ 0.0f, 0.0f, 0.0f, 1.0f }; ///< specular reflectance
    ofFloatColor emissive{ 0.0f, 0.0f, 0.0f, 1.0f }; ///< emitted light intensity
    float shininess{ 0.2f }; ///< specular exponent
    std::string postFragment;
    std::string customUniforms;
};

/// \class ofBaseMaterial
/// \brief material parameter properties that can be applied to vertices in the OpenGL lighting model
/// used in determining both the intensity and color of reflected light based on the lighting model in use
/// and if the vertices are on a front or back sided face
class ofBaseMaterial{
public:

	virtual ~ofBaseMaterial(){};

	/// \return the diffuse reflectance
	virtual ofFloatColor getDiffuseColor() const=0;

	/// \return the ambient reflectance
	virtual ofFloatColor getAmbientColor() const=0;

	/// \return the specular reflectance
	virtual ofFloatColor getSpecularColor() const=0;

	/// \return the emitted light intensity
	virtual ofFloatColor getEmissiveColor() const=0;

	/// \return the specular exponent
	virtual float getShininess() const=0;

	/// \brief begin using this material's properties
	virtual void begin() const=0;

	/// \brief end using this material's properties
	virtual void end() const=0;

	/// \brief create and return a shader used to implement the materials effect for a given renderer
	/// \param textureTarget an implementation-specific value to specify the type of shader to use
	/// \param renderer programmable renderer instance to create the material shader for
	virtual const ofShader & getShader(int textureTarget, bool geometryHasColor, ofGLProgrammableRenderer & renderer) const=0;

	/// \brief upload the given renderer's normal matrix to the material shader
	/// \param shader the material shader, created by getShader()
	/// \param renderer programmable renderer instance that uses the material shader
	virtual void uploadMatrices(const ofShader & shader,ofGLProgrammableRenderer & renderer) const;

	/// \brief update the material properties to the material shader
	/// \param shader the material shader, created by getShader()
	/// \param renderer programmable renderer instance that uses the material shader
	virtual void updateMaterial(const ofShader & shader,ofGLProgrammableRenderer & renderer) const=0;

	/// \brief update the given renderer's lights to the material shader
	/// \param shader the material shader, created by getShader()
	/// \param renderer programmable renderer instance that uses the material shader
	virtual void updateLights(const ofShader & shader,ofGLProgrammableRenderer & renderer) const=0;
};


/// \class ofMaterial
/// \brief material parameter properties that can be applied to vertices in the OpenGL lighting model
/// used in determining both the intensity and color of reflected light based on the lighting model in use
/// and if the vertices are on a front or back sided face
class ofMaterial: public ofBaseMaterial {
public:
	ofMaterial();
	virtual ~ofMaterial(){};

	/// \brief setup using settings struct
	/// \param settings color & other properties struct
	void setup(const ofMaterialSettings & settings);
	
	/// \brief set all material colors: reflectance type & light intensity
	/// \param oDiffuse the diffuse reflectance
	/// \param oAmbient the ambient reflectance
	/// \param oSpecular the specular reflectance
	/// \param oEmmissive the emitted light intensity
	void setColors(ofFloatColor oDiffuse, ofFloatColor oAmbient, ofFloatColor oSpecular, ofFloatColor emissive);
	
	/// \brief set the diffuse reflectance
	/// \param oDiffuse the diffuse reflectance
	void setDiffuseColor(ofFloatColor oDiffuse);
	
	/// \brief set the ambient reflectance
	/// \param oAmbient the ambient reflectance
	void setAmbientColor(ofFloatColor oAmbient);
	
	/// \brief set the specular reflectance
	/// \param oSpecular the specular reflectance
	void setSpecularColor(ofFloatColor oSpecular);
	
	/// \brief set the emitted light intensity
	/// \param oEmmissive the emitted light intensity
	void setEmissiveColor(ofFloatColor oEmmisive);
	
	/// \brief set the specular exponent
	void setShininess(float nShininess);

	// documented in ofBaseMaterial
	ofFloatColor getDiffuseColor() const;
	ofFloatColor getAmbientColor() const;
	ofFloatColor getSpecularColor() const;
	ofFloatColor getEmissiveColor() const;
	float getShininess() const;
	
	/// \return material color properties data struct
	typedef ofMaterialSettings Data;
	OF_DEPRECATED_MSG("Use getSettings() instead", Data getData() const);
	ofMaterialSettings getSettings() const;
	
	/// \brief set the material color properties data struct
	OF_DEPRECATED_MSG("Use setup(settings) instead", void setData(const ofMaterial::Data& data));
	
	// documented in ofBaseMaterial
	void begin() const;
	void end() const;


	void setCustomUniform1f(const std::string & name, float value);
	void setCustomUniform2f(const std::string & name, glm::vec2 value);
	void setCustomUniform3f(const std::string & name, glm::vec3 value);
	void setCustomUniform4f(const std::string & name, glm::vec4 value);
	void setCustomUniformMatrix4f(const std::string & name, glm::mat4 value);
	void setCustomUniformMatrix3f(const std::string & name, glm::mat3 value);

	void setCustomUniform1i(const std::string & name, int value);
	void setCustomUniform2i(const std::string & name, glm::tvec2<int, glm::precision::defaultp> value);
	void setCustomUniform3i(const std::string & name, glm::tvec3<int, glm::precision::defaultp> value);
	void setCustomUniform4i(const std::string & name, glm::tvec4<int, glm::precision::defaultp> value);
	void setCustomUniformTexture(const std::string & name, const ofTexture & value, int textureLocation);
	void setCustomUniformTexture(const std::string & name, int textureTarget, GLint textureID, int textureLocation);



private:
	void initShaders(ofGLProgrammableRenderer & renderer) const;
	const ofShader & getShader(int textureTarget, bool geometryHasColor, ofGLProgrammableRenderer & renderer) const;
	void updateMaterial(const ofShader & shader,ofGLProgrammableRenderer & renderer) const;
	void updateLights(const ofShader & shader,ofGLProgrammableRenderer & renderer) const;

	ofMaterialSettings data;

	struct Shaders{
		ofShader noTexture;
		ofShader color;
		ofShader texture2DColor;
		ofShader textureRectColor;
		ofShader texture2D;
		ofShader textureRect;
		size_t numLights;
	};
	struct TextureUnifom{
		int textureTarget;
		GLint textureID;
		int textureLocation;
	};

	mutable std::map<ofGLProgrammableRenderer*,std::shared_ptr<Shaders>> shaders;
	static std::map<ofGLProgrammableRenderer*, std::map<std::string,std::weak_ptr<Shaders>>> shadersMap;
	static std::string vertexShader;
	static std::string fragmentShader;
	std::map<std::string, float> uniforms1f;
	std::map<std::string, glm::vec2> uniforms2f;
	std::map<std::string, glm::vec3> uniforms3f;
	std::map<std::string, glm::vec4> uniforms4f;
	std::map<std::string, float> uniforms1i;
	std::map<std::string, glm::tvec2<int, glm::precision::defaultp>> uniforms2i;
	std::map<std::string, glm::tvec3<int, glm::precision::defaultp>> uniforms3i;
	std::map<std::string, glm::tvec4<int, glm::precision::defaultp>> uniforms4i;
	std::map<std::string, glm::mat4> uniforms4m;
	std::map<std::string, glm::mat3> uniforms3m;
	std::map<std::string, TextureUnifom> uniformstex;
};

#line 0 "../libs/openFrameworks/gl/ofTexture.h"
#pragma once

/* #include "ofConstants.h" */
#include "glm/mat4x4.hpp"
/* #include "ofGraphicsBaseTypes.h" */

class ofRectangle;

template<typename T>
class ofPixels_;

typedef ofPixels_<unsigned char> ofPixels;
typedef ofPixels_<unsigned short> ofShortPixels;
typedef ofPixels_<float> ofFloatPixels;

class ofTexture;
class ofBufferObject;

/// \file
/// ofTexture is used to create OpenGL textures that live on your graphics card
/// (GPU). While you can certainly use ofTexture directly to manipulate and
/// textures, more often ofTexture will be used internally by classes like
/// ofImage or ofVideoGrabber.  That said, ofImage and other classes that use
/// ofTexture internally often provide access to the ofTexture.
///
/// ofTexture allows use of non-power of 2 textures in OpenGL and has a set
/// of functions simplify the process of transfering pixel data to and from
/// the GPU in various formats.
///
/// Users must _allocate_ the texture before drawing it or loading data into it.



/// \section Global Texture Settings
/// \brief Check whether OF is using GL_TEXTURE_RECTANGLE rectangular or GL_TEXTURE_2D textures.
/// \sa ofEnableArbTex()
/// \returns true if using GL_TEXTURE_RECTANGLE textures, false if using GL_TEXTURE_2D textures.
bool ofGetUsingArbTex();

/// \brief Use GL_TEXTURE_RECTANGLE textures.
///
/// GL_TEXTURE_RECTANGLE textures are more intuitive since they allow pixel
/// based coordinates and are enabled by default.
///
/// GL_TEXTURE_2D textures use normalised texture coordinates (a float value
/// between 0 and 1 is used to express texture coordinates along width and
/// height).
///
/// GL_TEXTURE_2D textures are more widely supported and allow advanced features
/// such as mipmaps and texture compression.
///
/// \sa ofDisableArbTex()
/// \warning GL_TEXTURE_RECTANGLE is not available in OpenGL ES.
/// \warning GL_TEXTURE_RECTANGLE does not support mipmaps.
void ofEnableArbTex();

/// \brief Use GL_TEXTURE_2D textures.
///
/// GL_TEXTURE_2D is OpenGL's default way of handling textures and supports a
/// wider range of core OpenGL features such as mipmaps.
///
/// \sa ofEnableArbTex()
void ofDisableArbTex();

/// \brief Check whether OF is using normalized or pixel texture coordinates.
/// \sa ofEnableNormalizedTexCoords()
/// \returns true if using normalized (0 - 1) texture coordinates.
bool ofGetUsingNormalizedTexCoords();

/// \brief Use normalized (0 - 1) texture coordinates.
///
/// By default, textures in OF work with pixel-based coordinates based on given
/// content dimensions (images size, fbo size, etc). Normalized (0 - 1)
/// coordinates are the traditional OpenGL default as they allow working with
/// internal texture data without having to worry about specific dimensions of
/// the content.
///
/// This overrides individual ofTexture wrap settings.
///
/// \sa http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml
void ofEnableNormalizedTexCoords();

/// \brief Use pixel-based texture coordinates.
/// \sa ofEnableNormalizedTexCoords()
void ofDisableNormalizedTexCoords();

/// \brief Set custom global texture wrapping.
///
/// By default, textures are clamped to their edges with GL_CLAMP_TO_EDGE.
/// Setting a repeat mode like GL_REPEAT allows you to create tiled backgrounds
/// with small textures.
///
/// This overrides individual ofTexture wrap settings.
///
/// \sa ofTexture::setTextureWrap
/// \sa http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml
///
/// \warning Deprecated. Use member methods instead.
///
/// \param wrapS wrap parameter for texture coordinate s.
/// \param wrapT wrap parameter for texture coordinate t.
OF_DEPRECATED_MSG("Use member method ofTexture::setTextureWrap() instead.",void ofSetTextureWrap(GLfloat wrapS = GL_CLAMP_TO_EDGE, GLfloat wrapT = GL_CLAMP_TO_EDGE));

/// \brief Check whether OF is using custom global texture wrapping.
///
/// \warning Deprecated. Use member methods instead.
///
/// \sa ofSetTextureWrap()
/// \returns true if OF is currently using custom global texture wrapping. 
OF_DEPRECATED_MSG("Use member method ofTexture::setTextureWrap() instead.",bool ofGetUsingCustomTextureWrap());

/// \brief Removes global custom texture wrapping.
///
/// Restores individual ofTexture wrap settings.
///
/// \warning Deprecated. Use member methods instead.
///
/// \sa ofSetTextureWrap()
OF_DEPRECATED_MSG("Use member method ofTexture::setTextureWrap() instead.",void ofRestoreTextureWrap());

/// \brief Set custom global texture minification/magnification scaling filters.
///
/// This setting allows global control over how OpenGL scales textures. It
/// overrides individual ofTexture min & mag filter settings.
///
/// \warning Deprecated. Use member methods instead.
///
/// \sa ofTexture::setTextureMinMagFilter()
/// \param minFilter minifying filter for scaling a pixel to a smaller area.
/// \param magFilter magnifying filter for scaling a pixel to a larger area.
OF_DEPRECATED_MSG("Use member method ofTexture::setTextureMinMagFilter() instead.",void ofSetMinMagFilters(GLfloat minFilter = GL_LINEAR, GLfloat magFilter = GL_LINEAR));

/// \brief Check whether OF is using custom global texture scaling filters.
/// \returns true if OF is currently using custom texture scaling filters.
/// \warning Deprecated. Use member methods instead.
OF_DEPRECATED_MSG("Use member method ofTexture::setTextureMinMagFilter() instead.",bool ofGetUsingCustomMinMagFilters());

/// \brief Removes global custom texture wrapping.
///
/// Restores individual ofTexture min mag filter settings.
/// \warning Deprecated. Use member methods instead.
OF_DEPRECATED_MSG("Use member method ofTexture::setTextureMinMagFilter() instead.",void ofRestoreMinMagFilters());

/// \brief Texture compression types.
///
/// Compression is only available through OpenGL for textures using
/// GL_TEXTURE_2D, *not* GL_TEXTURE_RECTANGLE, also note that most compression
/// algorithms work on blocks of 4x4 pixels, and therefore expect compressed
/// textures to have multiple-of-four dimensions.
enum ofTexCompression {
	OF_COMPRESS_NONE,	///< No compression.
	OF_COMPRESS_SRGB,	///< sRGB compression.
	OF_COMPRESS_ARB		///< ARB compression.
};


/// \class ofTextureData
/// \advanced
/// \brief Internal texture data structure.
///
/// Used by ofTexture internally. You won't need to work with this in most cases.
class ofTextureData {
public:
	ofTextureData() {
		textureID = 0;
#ifndef TARGET_OPENGLES
		glInternalFormat = GL_RGB8;
		textureTarget = GL_TEXTURE_RECTANGLE_ARB;
#else
		glInternalFormat = GL_RGB;
		textureTarget = GL_TEXTURE_2D;
#endif

		tex_t = 0;
		tex_u = 0;
		tex_w = 0;
		tex_h = 0;
		width = 0;
		height = 0;
		
		bFlipTexture = false;
		compressionType = OF_COMPRESS_NONE;
		bAllocated = false;
		bUseExternalTextureID = false;
		useTextureMatrix = false;
		
		minFilter = GL_LINEAR;
		magFilter = GL_LINEAR;
		
		wrapModeHorizontal = GL_CLAMP_TO_EDGE;
		wrapModeVertical = GL_CLAMP_TO_EDGE;
		hasMipmap = false;
		bufferId = 0;

	}

	unsigned int textureID; ///< GL internal texture ID.
	int textureTarget; ///< GL texture type, either GL_TEXTURE_2D or
	                   ///< GL_TEXTURE_RECTANGLE_ARB.
	int glInternalFormat; ///< GL internal format, e.g. GL_RGB8.
                        ///< \sa http://www.opengl.org/wiki/Image_Format
	
	float tex_t; ///< Texture horizontal coordinate, ratio of width to display width.
	float tex_u; ///< Texture vertical coordinate, ratio of height to display height.
	float tex_w; ///< Texture width (in pixels).
	float tex_h; ///< Texture height (in pixels).
	float width, height; ///< Texture display size.
	
	bool bFlipTexture; ///< Should the texture be flipped vertically?
	ofTexCompression compressionType; ///< Texture compression type.
	bool bAllocated; ///< Has the texture been allocated?

	GLint minFilter; ///< Filter to use for minification (reduction).
	GLint magFilter; ///< Filter to use for magnification (enlargement).

	GLint wrapModeHorizontal; ///< How will the texture wrap around horizontally?
	GLint wrapModeVertical; ///< How will the texture wrap around vertically?
	
	unsigned int bufferId; ///< Optionally if the texture is backed by a buffer so we can bind it
private:
	std::shared_ptr<ofTexture> alphaMask; ///< Optional alpha mask to bind
	bool bUseExternalTextureID; ///< Are we using an external texture ID? 
	glm::mat4 textureMatrix; ///< For required transformations.
	bool useTextureMatrix; ///< Apply the transformation matrix?
	bool hasMipmap; ///< True if mipmap has been generated for this texture, false by default.

	friend class ofTexture;

};

/// \endcond

/// \brief Enable the global texture "edge hack" to compensate for edge artifacts.
///
/// Adds a 2 pixel offset to avoid possible edge artifacts (typically a black or
/// white border). This *very slightly* alters the image by scaling.  This is
/// enabled by default.
void ofEnableTextureEdgeHack();

/// \todo Add docs on why the "edge hack" is needed.

/// \brief Disable global texture "edge hack".
/// \sa ofEnableTextureEdgeHack()
void ofDisableTextureEdgeHack();

/// \brief Check whether OF is using the texture "edge hack".
/// \sa ofEnableTextureEdgeHack()
/// \returns true if OF is currently using the texture "edge hack".
bool ofIsTextureEdgeHackEnabled();

/// \class ofTexture
/// \brief A wrapper class for an OpenGL texture.
class ofTexture : public ofBaseDraws {
	public :

	/// \section Construction and Allocation
	/// \brief Construct an ofTexture instance.
	ofTexture();

	/// \brief Construct an ofTexture from an existing ofTexture.
	/// \param mom The ofTexture to copy. Reuses internal GL texture ID.
	ofTexture(const ofTexture & mom);
    ofTexture(ofTexture && mom);

	/// \brief Allocate the texture using the given settings.
	///
	/// This is useful if you need manual control over loading a number of
	/// textures with the same settings. Make sure to set the texture data 
	/// parameters first.
	///
	/// \param textureData The settings to use when allocating the ofTexture.
	virtual void allocate(const ofTextureData & textureData);

	/// \brief Allocate the texture using the given settings and custom format.
	/// \param textureData The settings to use when allocating the ofTexture.
	/// \param glFormat GL texture format: GL_RGBA, GL_LUMINANCE, etc.
	/// \param pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.
	virtual void allocate(const ofTextureData & textureData, int glFormat, int pixelType);

	/// \brief Allocate texture of a given size and format.
	///
	/// The width (w) and height (h) do not necessarily need to be powers of 2,
	/// but they do need to be large enough to contain the data you will upload
	/// to the texture.
	///
	/// The internal data type `glFormat` describes how OpenGL will store this
	/// texture internally. For example, if you want a grayscale texture, you
	/// can use `GL_LUMINANCE`. You can upload what ever type of data you want
	/// (using `loadData()`) but internally, opengl will store the information
	/// as grayscale. Other types include: `GL_RGB`, `GL_RGBA`.
	///
	/// This method applies the currently set OF texture type and defaults to
	/// ARB rectangular textures if they are supported. (They are not supported
	/// on OpenGL ES).
	///
	/// \param w Desired width in pixels.
	/// \param h Desired height in pixels.
	/// \param glInternalFormat OpenGL internal data format: `GL_RGBA`, `GL_LUMINANCE`, etc.
	virtual void allocate(int w, int h, int glInternalFormat);

	/// \brief Allocate texture of a given size and format.
	///
	/// \sa allocate(int w, int h, int glInternalFormat)
	/// \param w Desired width in pixels.
	/// \param h Desired height in pixels.
	/// \param glInternalFormat The internal openGL format.
	/// \param glFormat The openGL format.
	/// \param pixelType GL pixel type: GL_UNSIGNED_BYTE, GL_FLOAT, etc.
	virtual void allocate(int w, int h, int glInternalFormat, int glFormat, int pixelType);
	
	/// \brief Allocate texture of a given size and format. Specify texture type.
	///
	/// This allows to enable the ARBE extension for this texture.
	/// This will overide the default OF texture type, in case you need a
	/// square texture (`GL_TEXTURE_2D`).
	///
	/// \warning ARB textures are not available in OpenGL ES.
	/// \sa ofEnableArbTex()
	/// \sa allocate(int w, int h, int glInternalFormat)
	/// \param w Desired width in pixels.
	/// \param h Desired height in pixels.
	/// \param glInternalFormat The internal openGL format.
	/// \param bUseARBExtension Set to true to use rectangular textures.
	virtual void allocate(int w, int h, int glInternalFormat, bool bUseARBExtension);

	/// \brief Allocate texture of a given size, format, & type.
	///
	/// \sa allocate(int w, int h, int glInternalFormat)
	/// \param w Desired width in pixels.
	/// \param h Desired height in pixels.
	/// \param glInternalFormat OpenGL data format: `GL_RGBA`, `GL_LUMINANCE`, etc.
	/// \param bUseARBExtension Set to true to use rectangular textures.
	/// \param glFormat The OpenGL format.
	/// \param pixelType OpenGL pixel type: `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc.
	virtual void allocate(int w, int h, int glInternalFormat, bool bUseARBExtension, int glFormat, int pixelType);

	/// \todo Not sure how the two texture format parameters are different:
	/// glFormat & glInternalFormat.

	/// \brief Allocate texture using an ofPixels instance.
	///
	/// Pixel type and OpenGL format are determined from pixel settings.
	///
	/// \param pix Reference to ofPixels instance.
	virtual void allocate(const ofPixels& pix);

	/// \brief Allocate texture using an ofPixels instance and type.
	///
	/// This lets you overide the default OF texture type in case you need a
	/// square GL_TEXTURE_2D texture.
	///
	/// \warning ARB textures are not available in OpenGL ES.
	/// \sa ofEnableArbTex()
	/// \sa allocate(const ofPixels& pix)
	/// \param pix Reference to ofPixels instance.
	/// \param bUseARBExtension Set to true to use rectangular textures.
	virtual void allocate(const ofPixels& pix, bool bUseARBExtension);
	
	/// \brief Allocate texture using an ofShortPixels instance.
	///
	/// Same as void allocate(const ofPixels& pix), except using ofShortPixels.
	///
	/// \sa allocate(const ofPixels& pix)
	/// \param pix Reference to ofShortPixels instance.
	virtual void allocate(const ofShortPixels& pix);

	/// \brief Allocate texture using an ofShortPixels instance and type.
	///
	/// Same as void void allocate(const ofPixels& pix), except using ofShortPixels.
	///
	/// \sa allocate(const ofShortPixels& pix)
	/// \param pix Reference to ofShortPixels instance.
	/// \param bUseARBExtension Set to true to use rectangular textures.
	virtual void allocate(const ofShortPixels& pix, bool bUseARBExtension);
	
	/// \brief Allocate texture using an ofFloatPixels instance.
	///
	/// Same as void allocate(const ofPixels& pix), except using ofFloatPixels.
	///
	/// \sa allocate(const ofPixels& pix)
	/// \param pix Reference to ofFloatPixels instance.
	virtual void allocate(const ofFloatPixels& pix);

	/// \brief Allocate texture using an ofShortPixels instance and type.
	///
	/// Same as void void allocate(const ofPixels& pix), except using ofShortPixels.
	///
	/// \sa allocate(const ofFloatPixels& pix)
	/// \param pix Reference to ofFloatPixels instance.
	/// \param bUseARBExtension Set to true to use rectangular textures.
	virtual void allocate(const ofFloatPixels& pix, bool bUseARBExtension);

#ifndef TARGET_OPENGLES
	/// \brief Allocate texture as a Buffer Texture.
	///
	/// Uses a GPU buffer as data for the texture instead of pixels in RAM
	/// Allows to use texture buffer objects (TBO) which make it easier to send big
	/// amounts of data to a shader as a uniform.
	/// 
	/// Buffer textures are 1D textures, and may only be sampled using texelFetch 
	/// in GLSL.
	///
	/// See textureBufferInstanceExample and https://www.opengl.org/wiki/Buffer_Texture
	///
	/// \sa allocate(const ofBufferObject & buffer, int glInternalFormat)
	/// \param buffer Reference to ofBufferObject instance.
	/// \param glInternalFormat Internal pixel format of the data.
	void allocateAsBufferTexture(const ofBufferObject & buffer, int glInternalFormat);
#endif


	/// \brief Determine whether the texture has been allocated.
	///
	/// This lets you check if a texture is safe to draw.  The texture can both
	/// be allocated by using `allocate()` or loading it with data `loadData()`.
	///
	/// \returns true if the texture has been allocated.
	bool isAllocated() const;


	/// \brief Has the texture been allocated?
	///
	/// Legacy function for backwards compatibility.
	///
	/// \returns true if the texture has been allocated.
	OF_DEPRECATED_MSG("Use isAllocated instead",bool bAllocated() const);

	/// \brief Destroy an ofTexture instance.
	///
	/// ofTexture keeps a reference count for the internal OpenGL texture ID.
	/// Thus, the texture ID is only released if there are no additional
	/// references to the internal texture ID.
	virtual ~ofTexture();

	/// \section Update Texture
	/// \brief Copy a given ofTexture into this texture.
	/// \param mom The ofTexture to copy from. Reuses internal GL texture ID.
	ofTexture& operator=(const ofTexture & mom);
    ofTexture& operator=(ofTexture && mom);


	/// \brief Clears the texture.
	///
	/// Clears / frees the texture memory, if something was already allocated.
	/// Useful if you need to control the memory on the graphics card.
	///
	/// The internal GL texture ID is only released if this is the last texture
	/// using it.
	void clear();

	/// \brief Set the texture ID.
	///
	/// Allows you to point the texture id to an externally allocated id
	/// (perhaps from another texture). It's up to you to set the rest of the
	/// textData parameters manually. 
	///
	/// \warning When setting an external texture ID, the user must set the
	/// remaining ofTextureData parameters manually.
	/// \param externTexID New texture ID.
	void setUseExternalTextureID(GLuint externTexID);

	/// \brief Load byte pixel data.
	///
	/// glFormat can be different to the internal format of the texture on each
	/// load, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the
	/// number of channels need to match according to the OpenGL standard.
	/// 
	/// \param data Pointer to byte pixel data. Must not be nullptr.
	/// \param w Pixel data width.
	/// \param h Pixel data height.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	void loadData(const uint8_t* const data, int w, int h, int glFormat);

	/// \brief Load short (2 byte) pixel data.
	/// \sa loadData(const unsigned char* const data, int w, int h, int glFormat)
	/// \param data Pointer to byte pixel data. Must not be nullptr.
	/// \param w Pixel data width.
	/// \param h Pixel data height.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	void loadData(const uint16_t* data, int w, int h, int glFormat);
	void loadData(const uint32_t* data, int w, int h, int glFormat);

	void loadData(const int8_t * data, int w, int h, int glFormat);
	void loadData(const int16_t * data, int w, int h, int glFormat);
	void loadData(const int32_t * data, int w, int h, int glFormat);

	/// \brief Load float pixel data.
	/// \sa loadData(const unsigned char* const data, int w, int h, int glFormat)
	/// \param data Pointer to byte pixel data. Must not be nullptr.
	/// \param w Pixel data width.
	/// \param h Pixel data height.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	void loadData(const float* data, int w, int h, int glFormat);

	/// \brief Load pixels from an ofPixels instance.
	/// \param pix Reference to ofPixels instance.
	void loadData(const ofPixels & pix);

	/// \brief Load pixels from an ofShortPixels instance.
	///
	/// Same as loadData(ofPixels &) but for ofShortPixels.
	///
	/// \sa loadData(const ofPixels & pix)
	/// \param pix Reference to ofShortPixels instance.
	void loadData(const ofShortPixels & pix);

	/// \brief Load pixels from an ofFloatPixels instance.
	///
	/// Same as loadData(ofPixels &) but for ofFloatPixels.
	///
	/// \sa loadData(const ofPixels & pix)
	/// \param pix Reference to ofFloatPixels instance.
	void loadData(const ofFloatPixels & pix);

	/// \brief Load pixels from an ofPixels instance and specify the format.
	///
	/// glFormat can be different to the internal format of the texture on each
	/// load, ie. we can upload GL_BGRA pixels into a GL_RGBA texture, but the
	/// number of channels need to match according to the OpenGL standard.
	///
	/// \param pix Reference to ofPixels instance.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	void loadData(const ofPixels & pix, int glFormat);

	/// \brief Load pixels from an ofShortPixels instance & specify the format.
	///
	/// \sa loadData(const ofPixels & pix, int glFormat)
	/// \param pix Reference to ofShortPixels instance.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	void loadData(const ofShortPixels & pix, int glFormat);

	/// \brief Load pixels from an ofFloatPixels instance and specify the format.
	///
	/// \sa loadData(const ofPixels & pix, int glFormat)
	/// \param pix Reference to ofFloatPixels instance.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	void loadData(const ofFloatPixels & pix, int glFormat);

	/// \brief Load byte pixel data.
	///
	/// glFormat can be different to the internal format of the texture on each
	/// load, i.e. we can upload GL_BGRA pixels into a GL_RGBA texture but the
	/// number of channels need to match according to the OpenGL standard.
	///
	/// \param data Pointer to byte pixel data. Must not be nullptr.
	/// \param w Pixel data width.
	/// \param h Pixel data height.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	/// \param glType the OpenGL type of the data.
    void loadData(const void * data, int w, int h, int glFormat, int glType);
	
#ifndef TARGET_OPENGLES
	/// \brief Load pixels from an ofBufferObject
	///
	/// This is different to allocate(ofBufferObject,internal). That
	/// creates a texture which data lives in GL buffer while this
	/// copies the data from the buffer to the texture.
	///
	/// This is usually used to upload data to be shown asynchronously
	/// by using a buffer object binded as a PBO
	///
	/// \param buffer The buffer to load.
	/// \param glFormat GL pixel type: GL_RGBA, GL_LUMINANCE, etc.
	/// \param glType the GL type to load.
	void loadData(const ofBufferObject & buffer, int glFormat, int glType);
#endif

	/// \brief Copy an area of the screen into this texture.
	///
	/// Specifiy the position (x,y) you wish to grab from, with the width (w)
	/// and height (h) of the region.
	///
	/// Make sure that you have allocated your texture (using `allocate()`)
	/// to be large enough to hold the region of the screen you wish to load.
	///
	/// \sa http://www.opengl.org/sdk/docs/man4/html/glCopyTexSubImage2D.xhtml
	///
	/// \param x Upper left corner horizontal screen position.
	/// \param y Upper left corner vertical screen position.
	/// \param w Width of the area to copy in pixels.
	/// \param h Height of the area to copy in pixels.
	void loadScreenData(int x, int y, int w, int h);
	
	using ofBaseDraws::draw;
	
	/// \section Drawing
	void draw(float x, float y) const;
	void draw(float x, float y, float z) const;
	void draw(const glm::vec3 & pos) const;

	void draw(float x, float y, float w, float h) const;

	/// \brief Draw the texture at a given size witdh and depth.
	///
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	/// \param z Draw position on the z axis.
	/// \param w Draw width.
	/// \param h Draw height.
	void draw(float x, float y, float z, float w, float h) const;
	void draw(const glm::vec3 & pos, float w, float h) const;
	
	/// \brief Draws the texture at 4 points passed in as if you created 4 glVertices.
	///
	/// \param p1 Upper left position on the x axis.
	/// \param p2 Upper left position on the y axis.
	/// \param p3 Lower right position on the x axis.
	/// \param p4 Lower right position on the y axis.
	void draw(const glm::vec3 & p1, const glm::vec3 & p2, const glm::vec3 & p3, const glm::vec3 & p4) const;

	/// \brief Draw a subsection of the texture.
	///
	/// Like ofRect() depend on the current `OF_RECT_MODE`:
	///
	/// * `OF_RECT_MODE_CORNER`: drawn with the upper left corner = (x,y)
	/// * `OF_RECT_MODE_CENTER`: drawn centered on (x,y)
	///
	/// \sa ofSetRectMode()
	///
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	/// \param w Draw width.
	/// \param h Draw height.
	/// \param sx Subsection x axis offset within the texture.
	/// \param sy Subsection y axis offset within the texture.
	void drawSubsection(float x, float y, float w, float h, float sx, float sy) const;

	/// \brief Draw a subsection of the texture with depth.
	///
	/// \sa drawSubsection(float x, float y, float w, float h, float sx, float sy)
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	/// \param z Draw position on the z axis.
	/// \param w Draw width.
	/// \param h Draw height.
	/// \param sx Subsection x axis offset within the texture.
	/// \param sy Subsection y axis offset within the texture.
	void drawSubsection(float x, float y, float z, float w, float h, float sx, float sy) const;

	/// \brief Draw a subsection of the texture with an offset.
	///
	/// \sa drawSubsection(float x, float y, float w, float h, float sx, float sy)
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	/// \param w Draw width.
	/// \param h Draw height.
	/// \param sx Subsection x axis offset within the texture.
	/// \param sy Subsection y axis offset within the texture.
	/// \param sw Subsection width within the texture.
	/// \param sh Subsection height within the texture.
	void drawSubsection(float x, float y, float w, float h, float sx, float sy, float sw, float sh) const;

	/// \brief Draw a subsection of the texture with an offset.
	///
	/// \sa drawSubsection(ofRectangle& drawBounds, ofRectangle& subsectionBounds)
	/// \param drawBounds Draw position and dimensions.
	/// \param subsectionBounds Subsection position and dimensions within the texture.
	void drawSubsection(const ofRectangle& drawBounds, const ofRectangle& subsectionBounds) const;
	
	/// \brief Draw a subsection of the texture with an offset and depth.
	///
	/// \sa drawSubsection(float x, float y, float w, float h, float sx, float sy)
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	/// \param z Draw position on the z axis.
	/// \param w Draw width.
	/// \param h Draw height.
	/// \param sx Subsection x axis offset within the texture.
	/// \param sy Subsection y axis offset within the texture.
	/// \param sw Subsection width within the texture.
	/// \param sh Subsection height within the texture.
	void drawSubsection(float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;

	ofMesh getQuad(const glm::vec3 & p1, const glm::vec3 & p2, const glm::vec3 & p3, const glm::vec3 & p4) const;

	/// \brief Get a mesh that has the texture coordinates set.
	///
	/// \sa drawSubsection(float x, float y, float w, float h, float sx, float sy)
	/// \param x Draw position on the x axis.
	/// \param y Draw position on the y axis.
	/// \param z Draw position on the z axis.
	/// \param w Draw width.
	/// \param h Draw height.
	/// \param sx Subsection x axis offset within the texture.
	/// \param sy Subsection y axis offset within the texture.
	/// \param sw Subsection width within the texture.
	/// \param sh Subsection height within the texture.
	/// \param vflipped Takes into account the flipped state in OF.
	/// \param rectMode rectMode Taking x,y as the center or the top left corner.
	ofMesh getMeshForSubsection(float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh, bool vflipped, ofRectMode rectMode) const;

	/// \brief Bind the texture.
	///
	/// For advanced users who need to manually manage texture drawing without
	/// calling ofTexture::draw.
	///
	/// \sa http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml
	void bind(int textureLocation=0) const;
	
	/// \brief Unbind the texture.
	///
	/// For advanced users who need to manually manage texture drawing without
	/// calling ofTexture::draw.
	///
	/// \sa http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml
	///
	void unbind(int textureLocation=0) const;

#if !defined(TARGET_OPENGLES) && defined(glBindImageTexture)
	/// Calls glBindImageTexture on the texture
	///
	/// Binds the texture as an read or write image, only available since OpenGL 4.2
	/// \warning This is not available in OpenGLES
	/// \sa http://www.opengl.org/wiki/GLAPI/glBindImageTexture
	void bindAsImage(GLuint unit, GLenum access, GLint level=0, GLboolean layered=0, GLint layer=0);
#endif

	const ofTexture * getAlphaMask() const;

	/// \section Size and Coordinates
	/// \brief Display height of texture.
	///
	/// Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.
	///
	/// \sa ofEnabledNormalizedTextures()
	///
	/// \returns Display height of texture in pixels.
	float getHeight() const;

	/// \brief Display width of texture.
	///
	/// Return value is pixel size (default) or normalized (0 - 1) if ofEnableNormalizedTextures() is set to true.
	///
	/// \sa ofEnabledNormalizedTextures()
	///
	/// \returns Display width of texture in pixels.
	float getWidth() const;

	/// \brief Set the anchor point the texture is drawn around as a percentage.
	///
	/// This can be useful if you want to rotate an image around a particular
	/// point.
	///
	/// \param xPct Horizontal texture position as a percentage (0 - 1).
	/// \param yPct Vertical texture position as a percentage (0 - 1).
	void setAnchorPercent(float xPct, float yPct);

	/// \brief Set the anchor point the texture is drawn around in pixels.
	///
	/// This can be useful if you want to rotate an image around a particular
	/// point.
	///
	/// \param x Horizontal texture position in pixels.
	/// \param y Vertical texture position in pixels.
	void setAnchorPoint(float x, float y);

	/// \brief Reset the anchor point to (0, 0).
	void resetAnchor();

	/// \brief Helper to convert display coordinate to texture coordinate.
	/// \param xPos Horizontal position in pixels.
	/// \param yPos Vertical position in pixels.
	/// \returns Texture coordinate or zero if texture is not allocated.
	glm::vec2 getCoordFromPoint(float xPos, float yPos) const;
	
	/// \brief Helper to convert display coordinate to texture coordinate.
	/// \param xPts Horizontal position in a normalized percentage (0 - 1).
	/// \param yPts Vertical position in a normalized percentage (0 - 1).
	/// \returns Texture coordinate or zero if texture is not allocated.
	glm::vec2 getCoordFromPercent(float xPts, float yPts) const;

	/// \section Texture Settings
	/// \brief Set another ofTexture to use as an alpha mask.
	/// \param mask The texture to use as alpha mask.
	void setAlphaMask(ofTexture & mask);

	/// \brief Disable the alpha mask.
	void disableAlphaMask();

	/// \brief Set texture wrapping.
	///
	/// By default, textures are clamped to their edges with `GL_CLAMP_TO_EDGE`.
	/// Setting a repeat mode like `GL_REPEAT` allows you to create tiled
	/// backgrounds with small textures.
	///
	/// \sa ofTextureSetWrap()
	/// \sa http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml
	///
	/// \warning May be overridden.
	///
	/// \param wrapModeHorizontal wrap parameter for texture coordinate s.
	/// \param wrapModeVertical wrap parameter for texture coordinate t.
	void setTextureWrap(GLint wrapModeHorizontal, GLint wrapModeVertical);

	/// \brief Set texture minification/magnification scaling filters.
	///
	/// Controls how OpenGL will scale this texture.
	///
	/// \sa http://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml
	/// \sa ofTextureSetMinMagFilters()
	///
	/// \warning May be overridden.
	///
	/// \param minFilter minifying filter for scaling a pixel to a smaller area.
	/// \param magFilter magnifying filter for scaling a pixel to a larger area.
	void setTextureMinMagFilter(GLint minFilter, GLint magFilter);

	/// \brief Sets a texture matrix to be uploaded whenever the texture is bound.
	/// \param m The 4x4 texture matrix.
	void setTextureMatrix(const glm::mat4 & m);

	const glm::mat4 & getTextureMatrix() const;

	bool isUsingTextureMatrix() const;

	/// Disable the texture matrix.
	/// \brief Disable the texture matrix.
	void disableTextureMatrix();

	/// \brief Set the texture compression.
	///
	/// \warning: not yet implemented.
	/// \sa ofTexCompression
	void setCompression(ofTexCompression compression);

	/// \todo Define Swizzle in the documentation.
	/// \brief Swizzle RGBA to grayscale with alpha in the red channel.
	///
	/// Use 1 channel GL_R as luminance instead of red channel in OpenGL 3+.
	///
	/// \warning This is not supported in OpenGL ES and does nothing.
	/// \sa https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)
	void setRGToRGBASwizzles(bool rToRGBSwizzles);

	/// \brief Swizzle a channel to another
	///
	/// Example:
	///
	/// ~~~~~
	/// ofTexture tex;
	/// tex.setSwizzle(GL_TEXTURE_SWIZZLE_R,GL_ALPHA);
	/// ~~~~~
	///
	/// will make channel 0 appear as alpha in the shader.
	///
	/// \warning This is not supported in OpenGL ES and does nothing.
	/// \sa https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)
	void setSwizzle(GLenum srcSwizzle, GLenum dstChannel);

	/// \section Read Pixel Data
	/// \brief Read current texture data from the GPU into pixels.
	///
	/// \warning This is not supported in OpenGL ES and does nothing.
	///
	/// \param pixels Target ofPixels reference.
	void readToPixels(ofPixels & pixels) const;

	/// \brief Read current texture data from the GPU into pixels.
	///
	/// \warning This is not supported in OpenGL ES and does nothing.
	///
	/// \param pixels Target pixels reference.
	void readToPixels(ofShortPixels & pixels) const;

	/// \brief Read current texture data from the GPU into pixels.
	///
	/// \warning This is not supported in OpenGL ES and does nothing.
	///
	/// \param pixels Target pixels reference.
	void readToPixels(ofFloatPixels & pixels) const;

#ifndef TARGET_OPENGLES
	/// \brief Copy the texture to an ofBufferObject.
	/// \param buffer the target buffer to copy to.
	void copyTo(ofBufferObject & buffer) const;
#endif

	/// \section Texture Data
	/// \brief Internal texture data access.
	///
	/// This returns the internal texture data for this texture, for instance,
	/// its textureID, type of texture, whether it's been allocated and other
	/// data about the state of the texture.
	///
	/// \returns a reference to the internal texture data struct.
	ofTextureData& getTextureData();

	/// \brief Const version of getTextureData().
	/// \sa ofTextureData::getTextureData()
	const ofTextureData& getTextureData() const;

	/// \section Mipmapping
	/// \brief Sets flag allowing texture to auto-generate a mipmap.
	///
	/// By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.
	/// If you want to change your minFilter later use setTextureMinMagFilter()
	///
	///	If you want to generate a mipmap later, or at a specific
	/// point in your code, use generateMipmap() instead.
	///
	/// \sa generateMipmap()
	/// \sa disableMipmap()
	/// \sa setTextureMinMagFilter()
	void enableMipmap();

	/// \brief Sets flag disallowing texture to auto-generate mipmap.
	///
	/// By default, this will set your minFilter to GL_LINEAR_MIPMAP_LINEAR.
	/// If you want to change your minFilter later use setTextureMinMagFilter()
	///
	///	If you want to generate a mipmap later, or at a specific
	/// point in your code, use ofTexture::generateMipmap() instead.
	///
	/// \sa generateMipmap()
	/// \sa enableMipmap()
	/// \sa setTextureMinMagFilter()
	void disableMipmap();
	

	/// \brief Generate mipmap for the current texture.
	///
	/// \warning Only GL_TEXTURE_RECTANGLE - which is the default openFrameworks
	/// texture target - does *not* support mipmaps, so make sure to call
	/// ofDisableArbTex() before loading texture
	/// data for a texture you want to generate mipmaps for.
	///
	/// \sa ofEnableArbTex()
	/// \sa ofDisableArbTex()
	void generateMipmap();

	/// \brief Find out if a mipmap has been generated for the current texture.
	///
	/// \sa generateMipmap()
	/// \sa enableMipmap()
	bool hasMipmap() const;
	
	/// \internal
	ofTextureData texData; ///< Internal texture data access.
	                       ///< For backwards compatibility.

protected:

	/// \brief Enable a texture target.
	/// \param textureLocation the OpenGL texture ID to enable as a target.
	void enableTextureTarget(int textureLocation) const;

	/// \brief Disable a texture target.
	/// \param textureLocation the OpenGL texture ID to enable as a target.
	void disableTextureTarget(int textureLocation) const;

	glm::vec3 anchor; ///< The texture's anchor point.

	bool bAnchorIsPct; ///< Is the anchor point represented as a normalized
					   ///< (0 - 1) coordinate?

private:
	bool bWantsMipmap; ///< Should mipmaps be created?
	
};

#line 0 "../libs/openFrameworks/graphics/ofImage.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofTexture.h" */
/* #include "ofPixels.h" */
/* #include "ofGLBaseTypes.h" */
/* #include "ofGraphicsConstants.h" */

class ofFile;
class ofBuffer;


/// \file
/// ofImage is used for loading, saving and drawing images in openFrameworks.
/// ofImage is a convenient class that lets you both draw images to the screen
/// and manipulate their pixel data. The ofImage allows you to load an image
/// from disk, manipulate the pixels, and create an OpenGL texture that you
/// can display and manipulate on the graphics card. Loading a file into the
/// ofImage allocates an ofPixels object and creates the ofTexture to display
/// the pixels.
///

/// \brief Used for controlling the save quality of JPEGs.
///
/// These values are directly mapped to FreeImage's JPEG quality flags.
/// \sa http://freeimage.sourceforge.net/fnet/html/E77CD483.htm
enum ofImageQualityType {
    /// \brief Equivalent to FreeImage's JPEG_QUALITYSUPERB (100:1 ratio)
    OF_IMAGE_QUALITY_BEST,
    /// \brief Equivalent to FreeImage's JPEG_QUALITYGOOD (75:1 ratio)
    OF_IMAGE_QUALITY_HIGH,
    /// \brief Equivalent to FreeImage's JPEG_QUALITYNORMAL (50:1 ratio)
    OF_IMAGE_QUALITY_MEDIUM,
    /// \brief Equivalent to FreeImage's JPEG_QUALITYAVERAGE (25:1 ratio)
    OF_IMAGE_QUALITY_LOW,
    /// \brief Equivalent to FreeImage's JPEG_QUALITYBAD (10:1 ratio)
    OF_IMAGE_QUALITY_WORST
};

/// \todo Needs documentation.
enum ofImageFormat {
    OF_IMAGE_FORMAT_BMP     = 0,
    OF_IMAGE_FORMAT_ICO     = 1,
    OF_IMAGE_FORMAT_JPEG    = 2,
    OF_IMAGE_FORMAT_JNG     = 3,
    OF_IMAGE_FORMAT_KOALA   = 4,
    OF_IMAGE_FORMAT_LBM     = 5,
    OF_IMAGE_FORMAT_IFF = OF_IMAGE_FORMAT_LBM,
    OF_IMAGE_FORMAT_MNG     = 6,
    OF_IMAGE_FORMAT_PBM     = 7,
    OF_IMAGE_FORMAT_PBMRAW  = 8,
    OF_IMAGE_FORMAT_PCD     = 9,
    OF_IMAGE_FORMAT_PCX     = 10,
    OF_IMAGE_FORMAT_PGM     = 11,
	OF_IMAGE_FORMAT_PGMRAW  = 12,
    OF_IMAGE_FORMAT_PNG     = 13,
    OF_IMAGE_FORMAT_PPM     = 14,
    OF_IMAGE_FORMAT_PPMRAW  = 15,
    OF_IMAGE_FORMAT_RAS     = 16,
    OF_IMAGE_FORMAT_TARGA   = 17,
    OF_IMAGE_FORMAT_TIFF    = 18,
    OF_IMAGE_FORMAT_WBMP    = 19,
    OF_IMAGE_FORMAT_PSD     = 20,
    OF_IMAGE_FORMAT_CUT     = 21,
    OF_IMAGE_FORMAT_XBM     = 22,
    OF_IMAGE_FORMAT_XPM     = 23,
    OF_IMAGE_FORMAT_DDS     = 24,
    OF_IMAGE_FORMAT_GIF     = 25,
    OF_IMAGE_FORMAT_HDR     = 26,
    OF_IMAGE_FORMAT_FAXG3   = 27,
    OF_IMAGE_FORMAT_SGI     = 28,
    OF_IMAGE_FORMAT_EXR     = 29,
    OF_IMAGE_FORMAT_J2K     = 30,
    OF_IMAGE_FORMAT_JP2     = 31,
    OF_IMAGE_FORMAT_PFM     = 32,
    OF_IMAGE_FORMAT_PICT    = 33,
    OF_IMAGE_FORMAT_RAW     = 34
};

inline std::string ofImageFormatExtension(ofImageFormat format){
    switch(format){
    case OF_IMAGE_FORMAT_BMP: return "bmp";
    case OF_IMAGE_FORMAT_ICO: return "ico";
    case OF_IMAGE_FORMAT_JPEG: return "jpg";
    case OF_IMAGE_FORMAT_JNG: return "jng";
    case OF_IMAGE_FORMAT_KOALA: return "koala";
    case OF_IMAGE_FORMAT_LBM: return "lbm";
    case OF_IMAGE_FORMAT_MNG: return "mng";
    case OF_IMAGE_FORMAT_PBM: return "pbm";
    case OF_IMAGE_FORMAT_PBMRAW: return "pbm";
    case OF_IMAGE_FORMAT_PCD: return "pcd";
    case OF_IMAGE_FORMAT_PCX: return "pcx";
    case OF_IMAGE_FORMAT_PGM: return "pgm";
    case OF_IMAGE_FORMAT_PGMRAW: return "pgm";
    case OF_IMAGE_FORMAT_PNG: return "png";
    case OF_IMAGE_FORMAT_PPM: return "ppm";
    case OF_IMAGE_FORMAT_PPMRAW: return "ppm";
    case OF_IMAGE_FORMAT_RAS: return "ras";
    case OF_IMAGE_FORMAT_TARGA: return "tga";
    case OF_IMAGE_FORMAT_TIFF: return "tif";
    case OF_IMAGE_FORMAT_WBMP: return "wbmp";
    case OF_IMAGE_FORMAT_PSD: return "psd";
    case OF_IMAGE_FORMAT_CUT: return "cut";
    case OF_IMAGE_FORMAT_XBM: return "xbm";
    case OF_IMAGE_FORMAT_XPM: return "xpm";
    case OF_IMAGE_FORMAT_DDS: return "dds";
    case OF_IMAGE_FORMAT_GIF: return "gif";
    case OF_IMAGE_FORMAT_HDR: return "hdr";
    case OF_IMAGE_FORMAT_FAXG3: return "faxg3";
    case OF_IMAGE_FORMAT_SGI: return "sgi";
    case OF_IMAGE_FORMAT_EXR: return "exr";
    case OF_IMAGE_FORMAT_J2K: return "j2k";
    case OF_IMAGE_FORMAT_JP2: return "jp2";
    case OF_IMAGE_FORMAT_PFM: return "pfm";
    case OF_IMAGE_FORMAT_PICT: return "pict";
    case OF_IMAGE_FORMAT_RAW: return "raw";
	default: return "unkown";
    }
}


/// \todo Needs documentation.
struct ofImageLoadSettings {
	bool accurate = false;
	bool exifRotate = false;
	bool grayscale = false;
	bool separateCMYK = false;
};

//----------------------------------------------------
// FreeImage based stuff


/// \todo Needs documentation.
bool ofLoadImage(ofPixels & pix, const std::filesystem::path& path, const ofImageLoadSettings &settings = ofImageLoadSettings());
bool ofLoadImage(ofPixels & pix, const ofBuffer & buffer, const ofImageLoadSettings &settings = ofImageLoadSettings());
bool ofLoadImage(ofFloatPixels & pix, const std::filesystem::path& path, const ofImageLoadSettings &settings = ofImageLoadSettings());
bool ofLoadImage(ofFloatPixels & pix, const ofBuffer & buffer, const ofImageLoadSettings &settings = ofImageLoadSettings());
bool ofLoadImage(ofShortPixels & pix, const std::filesystem::path& path, const ofImageLoadSettings &settings = ofImageLoadSettings());
bool ofLoadImage(ofShortPixels & pix, const ofBuffer & buffer, const ofImageLoadSettings &settings = ofImageLoadSettings());

/// \todo Needs documentation.
bool ofLoadImage(ofTexture & tex, const std::filesystem::path& path, const ofImageLoadSettings &settings = ofImageLoadSettings());
bool ofLoadImage(ofTexture & tex, const ofBuffer & buffer, const ofImageLoadSettings &settings = ofImageLoadSettings());

/// \todo Needs documentation.
bool ofSaveImage(const ofPixels & pix, const std::filesystem::path& path, ofImageQualityType qualityLevel = OF_IMAGE_QUALITY_BEST);
bool ofSaveImage(const ofPixels & pix, ofBuffer & buffer, ofImageFormat format = OF_IMAGE_FORMAT_PNG, ofImageQualityType qualityLevel = OF_IMAGE_QUALITY_BEST);

/// \todo Needs documentation.
bool ofSaveImage(const ofFloatPixels & pix, const std::filesystem::path& path, ofImageQualityType qualityLevel = OF_IMAGE_QUALITY_BEST);
bool ofSaveImage(const ofFloatPixels & pix, ofBuffer & buffer, ofImageFormat format = OF_IMAGE_FORMAT_PNG, ofImageQualityType qualityLevel = OF_IMAGE_QUALITY_BEST);

/// \todo Needs documentation.
bool ofSaveImage(const ofShortPixels & pix, const std::filesystem::path& path, ofImageQualityType qualityLevel = OF_IMAGE_QUALITY_BEST);
bool ofSaveImage(const ofShortPixels & pix, ofBuffer & buffer, ofImageFormat format = OF_IMAGE_FORMAT_PNG, ofImageQualityType qualityLevel = OF_IMAGE_QUALITY_BEST);

/// \brief Deallocates FreeImage resources.
///
/// Used internally during shutdown.
void ofCloseFreeImage();

/// \brief A class representing an image using memory and gpu based pixels.
/// \tparam PixelType The data type used to represent a single pixel value.
template<typename PixelType>
class ofImage_ : public ofBaseImage_<PixelType>{
public:
    /// \name Image Construction
    /// \{

    ofImage_();

    ofImage_(const ofPixels_<PixelType> & pix);
	ofImage_(const std::filesystem::path & fileName, const ofImageLoadSettings &settings = ofImageLoadSettings());
    ofImage_(const ofImage_<PixelType>& mom);
    ofImage_(ofImage_<PixelType>&& mom);

    template<typename SrcType>
    ofImage_(const ofImage_<SrcType>& mom);


    /// This allocates space in the ofImage, both the ofPixels and the
    /// ofTexture that the ofImage contains.
    ///
    /// You don't need to call this before loading an image, but for when you
    /// want to allocate. space ahead of when you are going to use the image.
    ///
    /// The types of images can be `OF_IMAGE_COLOR`, `OF_IMAGE_COLOR_ALPHA`
    /// or `OF_IMAGE_GRAYSCALE`.
    ///
    /// You need to call update() to update the texture after updating
    /// the pixels manually.
    ///
    /// \param w Width of image to allocate.
    /// \param h Height of image to allocate.
    /// \param type The ofImageType.
    void allocate(int w, int h, ofImageType type);

    /// \brief Whether the image has been allocated either by a call to
    /// allocate or by loading pixel data into the image.
    /// \returns true if the image has been allocated.
    bool isAllocated() const {return pixels.isAllocated();}

    /// \brief Whether the image has been allocated either by a call to
    /// allocate or by loading pixel data into the image.
    /// \deprecated Use isAllocated() instead
    /// \returns true if the image has been allocated.
    OF_DEPRECATED_MSG("Use isAllocated()", bool bAllocated());

    /// \brief This clears the texture and pixels contained within the ofImage.
	void clear();

    /// \brief Loads an image given by fileName.
    /// \param fileName Program looks for image given by fileName, relative to
    /// the data folder.
    /// \param settings Load options
    /// \returns true if image loaded correctly.
	bool load(const std::filesystem::path& fileName, const ofImageLoadSettings &settings = ofImageLoadSettings());

    /// \brief Loads an image from an ofBuffer instance created by, for
    /// instance, ofFile::readToBuffer().
    ///
    /// This actually loads the image data into an ofPixels object and then
    /// into the texture.
	bool load(const ofBuffer & buffer, const ofImageLoadSettings &settings = ofImageLoadSettings());

    OF_DEPRECATED_MSG("Use load instead",bool loadImage(const std::string& fileName));
    OF_DEPRECATED_MSG("Use load instead",bool loadImage(const ofBuffer & buffer));
    OF_DEPRECATED_MSG("Use load instead",bool loadImage(const ofFile & file));

    virtual ~ofImage_();

    /// \}
    /// \name Drawing
    /// \{

    using ofBaseDraws::draw;

    /// \brief Draw the image at it's normal size.
    ///
    /// \param x Draw position on the x axis.
    /// \param y Draw position on the y axis.
    void draw(float x, float y) const;

    /// \brief Draw the texture at it's normal size with depth.
    ///
    /// \param x Draw position on the x axis.
    /// \param y Draw position on the y axis.
    /// \param z Draw position on the z axis.
    void draw(float x, float y, float z) const;

	void draw(const glm::vec3 & pos) const;

    /// \brief Draw the image at a given size.
    ///
    /// \param x Draw position on the x axis.
    /// \param y Draw position on the y axis.
    /// \param w Draw width.
    /// \param h Draw height.
    void draw(float x, float y, float w, float h) const;

    /// \brief Draw the image at a given size with depth.
    ///
    /// \param x Draw position on the x axis.
    /// \param y Draw position on the y axis.
    /// \param z Draw position on the z axis.
    /// \param w Draw width.
    /// \param h Draw height.
    void draw(float x, float y, float z, float w, float h) const;

	void draw(const glm::vec3 & pos, float w, float h) const;

    /// \brief Draws a subsection of the image.
    ///
    /// This functions like a clipping mask. Does not altering any pixel
    /// data.
    ///
    /// \param x X position to draw cropped image at.
    /// \param y Y position to draw cropped image at.
    /// \param w Width of subsection to draw.
    /// \param h Height of subsection to draw.
    /// \param sx X position in image to begin cropping from.
    /// \param sy Y position in image to begin cropping from.
    void drawSubsection(float x, float y, float w, float h, float sx, float sy) const;

    /// \brief Draws a subsection of the image.
    ///
    /// This functions like a clipping mask. Does not altering any pixel
    /// data.
    ///
    /// \param x X position to draw cropped image at.
    /// \param y Y position to draw cropped image at.
    /// \param z Z position to draw cropped image at.
    /// \param w Width of subsection to draw.
    /// \param h Height of subsection to draw.
    /// \param sx X position in image to begin cropping from.
    /// \param sy Y position in image to begin cropping from.
    void drawSubsection(float x, float y, float z, float w, float h, float sx, float sy) const;

    /// \brief Draws a subsection of the image.
    ///
    /// This functions like a clipping mask. Does not altering any pixel
    /// data.
    ///
    /// \param x X position to draw cropped image at.
    /// \param y Y position to draw cropped image at.
    /// \param w Width of subsection to draw.
    /// \param h Height of subsection to draw.
    /// \param sx X position in image to begin cropping from.
    /// \param sy Y position in image to begin cropping from.
    /// \param sw Source width of cropped area.
    /// \param sh Source height of cropped area.
    void drawSubsection(float x, float y, float w, float h, float sx, float sy, float sw, float sh) const;

    /// \brief Draws a subsection of the image.
    ///
    /// This functions like a clipping mask. Does not altering any pixel
    /// data.
    ///
    /// \param x X position to draw cropped image at.
    /// \param y Y position to draw cropped image at.
    /// \param z Z position to draw cropped image at.
    /// \param w Width of subsection to draw.
    /// \param h Height of subsection to draw.
    /// \param sx X position in image to begin cropping from.
    /// \param sy Y position in image to begin cropping from.
    /// \param sw Source width of cropped area.
    /// \param sh Source height of cropped area.
    void drawSubsection(float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;

    /// \}
    /// \name Texture
    /// \{

    /// \brief Call to ensure that changes to pixels are reflected in the ofTexture of the image.
    ///
    /// Many of the ofImage methods call this after they change the pixels,
    /// but if you directly manipulate  the pixels of the ofImage, then you
    /// should make sure to call update() before trying to draw the  texture
    /// of the image to the screen.
    void update();

    /// \brief Turns on or off the allocation and use of a texture.
    ///
    /// \param bUse Allocate and use a texture or not.
    void setUseTexture(bool bUse);

    /// \brief Returns whether the ofImage has a texture or not.
    ///
    /// If the ofImage doesn't have a texture, nothing will be drawn to the screen.
    /// \returns true if the ofImage is using a texture.
    bool isUsingTexture() const;

    /// \brief Returns a reference to the texture that the ofImage contains.
    ///
    /// You can use this to directly manipulate the texture itself, but keep in
    /// mind that if you manipulate the texture directly, there is no simple way
    /// to copy the data from the texture back to the pixels and keep the ofImage in sync.
    ///
    /// \returns A reference to the texture that the ofImage contains.
    ofTexture & getTexture();

	/// \brief Returns a const reference to the texture that the ofImage contains.
	/// \returns A const reference to the texture that the ofImage contains.
    const ofTexture & getTexture() const;

    OF_DEPRECATED_MSG("Use getTexture",ofTexture & getTextureReference());
    OF_DEPRECATED_MSG("Use getTexture",const ofTexture & getTextureReference() const);

    /// \brief Binds the oftexture instance that the ofImage contains so that
    /// it can be used for advanced drawing.
    void bind(int textureLocation=0) const;

    /// \brief Unbinds the ofTexture instance that the ofImage contains.
    ///
    /// Call this after you call bind().
    void unbind(int textureLocation=0) const;

    /// \brief This sets the compression level used when creating mipmaps for
    /// the ofTexture contained by the ofImage.
    /// \param compression The ofTexCompression to set.
    void setCompression(ofTexCompression compression);


    /// \}
    /// \name Pixel Getters
    /// \{

    /// \brief Returns a raw pointer to the pixel data.
    ///
    /// This function will give you access to a continuous block of pixels.
    /// you can grab the data and do what you like with it. If you have a
    /// grayscale image, you will have (width*height)  number of pixels. Color
    /// images will have (width*height*3) number of pixels (interlaced R,G,B),
    /// and coloralpha images will have (width*height*4) number of pixels
    /// (interlaced R,G,B,A).
    ///
    /// \warning This is a raw pointer. It's up to you to get this right.
    ///
    /// \returns A raw pointer to the pixel data.
    ofPixels_<PixelType> & getPixels();
    const ofPixels_<PixelType> & getPixels() const;

    /// \brief This returns an ofPixels reference that you can use to
    /// manipulate the raw pixel data of the ofImage.
    ///
    /// Make sure you call either update() after making changes to the ofPixels.
    ///
    /// \returns An ofPixels reference that you can use to manipulate the raw pixel data of the ofImage.
    OF_DEPRECATED_MSG("Use getPixels() instead ", ofPixels_<PixelType> & getPixelsRef());
    OF_DEPRECATED_MSG("Use getPixels() instead ", const ofPixels_<PixelType> & getPixelsRef() const);

    operator ofPixels_<PixelType>&();

    /// \brief This returns the ofColor representing the pixels at the x and y
    /// position passed in.
    /// \param x x position of pixel
    /// \param y y position of pixel
    /// \returns The ofColor representing the pixels at the x and y position passed in.
    ofColor_<PixelType> getColor(int x, int y) const;

	/// \brief This returns the ofColor representing the pixels at the index
	/// passed in.
	/// \param index index into pixel data
	/// \returns The ofColor representing the pixels at the index position passed in.
	ofColor_<PixelType> getColor(int index) const;

    /// \brief Get height of image as a float.
    /// \returns Height of image as float.
    float getHeight() const;

    /// \brief Get width of image as a float.
    /// \returns Width of image as float.
    float getWidth() const;

    /// \}
    /// \name Pixel Setters
    /// \{

    /// \brief Sets the pixel at the x,y position passed in.
    ///
    /// The ofColor type needs to match the ofImage type, i.e. ofFloatImage
    /// requires that you use ofFloatPixels.
    ///
    /// \param x x position of pixel.
    /// \param y y position of pixel.
    /// \param color Color to set pixel to.
    void setColor(int x, int y, const ofColor_<PixelType>& color);

    /// \brief Sets the pixel at the given pixel buffer index
    ///
    /// \param index Index of pixel to set.
    /// \param color Color to set pixel to.
    void setColor(int index, const ofColor_<PixelType>& color);

    /// \brief Sets all pixels to a color.
    /// \param color Color to set pixel to.
    void setColor(const ofColor_<PixelType>& color);

    /// \brief Sets the pixels of the image from an array of values.
    ///
    /// Set the pixels of the image from an array of values, for an
    /// ofFloatImage these need to be floats, for an ofImage  these need to be
    /// unsigned chars. The w and h values are important so that the correct
    /// dimensions are set in the  image. This assumes that you're setting the
    /// pixels from 0,0 or the upper left hand corner of the image. The
    /// bOrderIsRGB flag allows you pass in pixel data that is BGR by setting
    /// bOrderIsRGB=false.
    ///
    /// \param pixels Array of pixel values.
    /// \param w Width of image being passed in.
    /// \param h Height of image being passed in.
    /// \param type The image type can be OF_IMAGE_GRAYSCALE, OF_IMAGE_COLOR, or OF_IMAGE_COLOR_ALPHA.
    /// \param bOrderIsRGB Pass in pixel data that is BGR by setting bOrderIsRGB=false.
    void setFromPixels(const PixelType * pixels, int w, int h, ofImageType type, bool bOrderIsRGB = true);

    /// \brief Set the pixels of the image from an ofPixels instance.
    ///
    /// Set the pixels of the image from an ofPixels instance, for an
    /// ofFloatImage these need to be ofFloatPixels, for an ofImage these need
    /// to be unsigned chars.
    void setFromPixels(const ofPixels_<PixelType> & pixels);

    /// \brief Grabs pixels from the opengl window specified by the region
    /// (x, y, w, h) and turns them into an image.
    ///
    /// It resizes or allocates the ofImage if it's necessary.
    ///
    /// \warning Uses glReadPixels() which can be slow.
    ///
    /// \param x x position of upper-left corner of region.
    /// \param y y position of upper-left corner of region.
    /// \param w Width of region.
    /// \param h Height of region.
    void grabScreen(int x, int y, int w, int h);

    /// \brief Set type of image to one of the following: OF_IMAGE_GRAYSCALE,
    /// OF_IMAGE_COLOR, OF_IMAGE_COLOR_ALPHA
    ///
    /// This does cause the image to be reallocated and the texture to be
    /// updated, so it can be an expensive operation  if done frequently.
    /// Converting down, for example from color to grayscale, loses
    /// information and is a destructive change.
    ///
    /// \param type The type of image, one of the following:
    /// `OF_IMAGE_GRAYSCALE`, `OF_IMAGE_COLOR`, `OF_IMAGE_COLOR_ALPHA`
    void setImageType(ofImageType type);
    ofImageType getImageType() const;

    /// \}
    /// \name Modifiers
    /// \{

    /// \brief Resizes the image to a new size (w, h); Can be used to scale up
    /// or down an image.
    ///
    /// \param newWidth New width of image.
    /// \param newHeight New height of image.
    void resize(int newWidth, int newHeight);

    /// \brief This crops the image to the w,h passed in from the x,y position.
    ///
    /// This does an in place crop and **allocates memory**.
    ///
    /// \param x x position of upper-left corner of region to crop.
    /// \param y y position of upper-left corner of region to crop.
    /// \param w Width of region to crop.
    /// \param h Height of region to crop.
    void crop(int x, int y, int w, int h);

    /// \brief Replaces region in caller image specified by w,h,x,y with pixels from otherImage.
    ///
    /// The w,h are measured from the x,y, so passing 100, 100, 300, 300 will grab
    /// a 300x300 pixel block of data starting from 100, 100.
    ///
    /// \param otherImage Image to crop from.
    /// \param x x position of upper-left corner of region to crop.
    /// \param y y position of upper-left corner of region to crop.
    /// \param w Width of region to crop.
    /// \param h Height of region to crop.
    void cropFrom(const ofImage_<PixelType>& otherImage, int x, int y, int w, int h);

    /// \brief Rotates the image by a multiple of 90 degrees.
    /// \param rotation Amount to rotate in multiples of 90. For instance, if you pass
    /// in 2, then the image will be rotated 180 degrees.
    void rotate90(int rotation);

    /// \brief This reflects the pixels of the image across the vertical and/or horizontal axis.
    /// \param vertical Set to true to reflect image across vertical axis.
    /// \param horizontal Set to true to reflect image across horizontal axis.
    void mirror(bool vertical, bool horizontal);

    /// \}
    /// \name Anchor
    /// \{

    /// \brief Change the drawing anchor from top-left corner to a position
    /// specified by xPct and yPct.
    ///
    /// Changes the drawing position specified by draw() from the normal top-
    /// left corner of the image to a position specified by xPct and yPct in
    /// relation to the dimensions of the image. This can be useful  for
    /// aligning and centering images as well as rotating an image around its
    /// center. Note: range of  xPct and yPct is 0.0 to 1.0. For xPct, 1.0
    /// represents the width of the image. For yPct, 1.0 represents  the
    /// height of the image. These values are not capped.
    ///
    /// \param xPct X position of the new anchor, specified as a percent of the width of the image.
    /// \param yPct Y position of the new anchor, specified as a percent of the height of the image.
    void setAnchorPercent(float xPct, float yPct);

    /// \brief Changes drawing position from top-left corner to position specified by x,y.
    ///
    /// Changes the drawing position specified by draw() from the normal top-
    /// left corner of the image to a  position specified by x and y, measured
    /// in pixels. This can be useful for aligning and centering  images as
    /// well as rotating an image around its center.
    ///
    /// \param x X position of the new anchor.
    /// \param y Y position of the new anchor.
    void setAnchorPoint(float x, float y);

    /// \brief Removes anchor positioning.
    ///
    /// Resets the anchor to (0, 0) so the image will be drawn from its
    /// upper left hand corner.
    void resetAnchor();

    /// \}

    /// \name Saving
    /// \{


    /// \brief Saves the image to the file path in fileName with the image
    /// quality specified by compressionLevel.
    ///
    /// \param fileName Saves image to this path, relative to the data folder.
    /// \param compressionLevel The ofImageQualityType.
	bool save(const std::filesystem::path & fileName, ofImageQualityType compressionLevel = OF_IMAGE_QUALITY_BEST) const;

    /// \brief This saves the image to the ofBuffer passed with the image
    /// quality specified by compressionLevel.
    ///
    /// \param buffer ofBuffer to save image to.
    /// \param compressionLevel The ofImageQualityType.
	bool save(ofBuffer & buffer, ofImageFormat imageFormat = OF_IMAGE_FORMAT_PNG, ofImageQualityType compressionLevel = OF_IMAGE_QUALITY_BEST) const;

    OF_DEPRECATED_MSG("Use save instead",void saveImage(const std::string& fileName, ofImageQualityType compressionLevel = OF_IMAGE_QUALITY_BEST) const);
    OF_DEPRECATED_MSG("Use save instead",void saveImage(ofBuffer & buffer, ofImageQualityType compressionLevel = OF_IMAGE_QUALITY_BEST) const);
    OF_DEPRECATED_MSG("Use save instead",void saveImage(const ofFile & file, ofImageQualityType compressionLevel = OF_IMAGE_QUALITY_BEST) const);

    /// \}
    /// \name Operators
    /// \{

    ofImage_<PixelType> & operator=(ofPixels_<PixelType> & pixels);

    // default copy overwriting (for = or std::vector)
    ofImage_<PixelType>& operator= (const ofImage_<PixelType>& mom);

    template<typename SrcType>
    ofImage_<PixelType>& operator= (const ofImage_<SrcType>& mom);

    //move assignment
    ofImage_<PixelType>& operator=(ofImage_<PixelType>&& mom);

    /// \}
    ///< \sa ofImageType

protected:
    /// \cond INTERNAL
    void changeTypeOfPixels(ofPixels_<PixelType> &pix, ofImageType type);
    void resizePixels(ofPixels_<PixelType> &pix, int newWidth, int newHeight);
    void unloadTexture();

    ofPixels_<PixelType> pixels;
    bool bUseTexture;
    ofTexture tex;

    int width;  ///< \brief Image width in pixels.
    int height; ///< \brief Image Height in pixels.
    int bpp;    ///< \brief Bits per image pixel.
    ofImageType type;   ///< \brief Image type.

	template<typename SrcType>
	void clone(const ofImage_<SrcType> &mom);
    /// \endcond
};

/// \name Variants
/// \{
typedef ofImage_<unsigned char> ofImage;
typedef ofImage_<float> ofFloatImage;
typedef ofImage_<unsigned short> ofShortImage;
/// \}



//----------------------------------------------------------
template<typename PixelType>
template<typename SrcType>
ofImage_<PixelType>& ofImage_<PixelType>::operator=(const ofImage_<SrcType>& mom) {
	clone(mom);
    return *this;
}

//----------------------------------------------------------
template<typename PixelType>
template<typename SrcType>
ofImage_<PixelType>::ofImage_(const ofImage_<SrcType>& mom) {
    clear();
	clone(mom);
}

//------------------------------------
template<typename PixelType>
template<typename SrcType>
void ofImage_<PixelType>::clone(const ofImage_<SrcType> &mom){
    pixels = mom.getPixels();

    tex.clear();
    bUseTexture = mom.isUsingTexture();
    if (bUseTexture == true && mom.getTexture().isAllocated()){
        tex.allocate(pixels.getWidth(), pixels.getHeight(), ofGetGLInternalFormat(pixels));
    }

    update();
}


template<typename T>
std::string ofToString(const T & v);
template<>
std::string ofToString(const ofImageType & imgType);

#line 0 "../libs/openFrameworks/graphics/ofBitmapFont.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofRectangle.h" */
/* #include "ofPixels.h" */
/* #include "ofTexture.h" */
/* #include "ofGraphics.h" */


/*
 
 note, the data in this code is taken from freeglut, and included in OF for compatability 
 with non glut windowing toolkits.  see .cpp for license info
 
 also, note that while this is used internally in ofGraphics, it's not really useful for end user usage.
 
 */

class ofBitmapFont{
public:
	ofBitmapFont();
	~ofBitmapFont();
	ofMesh getMesh(const std::string & text, int x, int y, ofDrawBitmapMode mode=OF_BITMAPMODE_MODEL_BILLBOARD, bool vFlipped=true) const;
	const ofTexture & getTexture() const;
	ofRectangle getBoundingBox(const std::string & text, int x, int y, ofDrawBitmapMode mode = ofGetStyle().drawBitmapMode, bool vFlipped = ofIsVFlipped()) const;
private:
	static void init();
	static ofPixels pixels;
	void unloadTexture();
	mutable ofTexture texture;
};

#line 0 "../libs/openFrameworks/graphics/ofTrueTypeFont.h"
#pragma once

/* #include "ofConstants.h" */
#include <unordered_map>
/* #include "ofRectangle.h" */
/* #include "ofPath.h" */
/* #include "ofTexture.h" */
/* #include "ofMesh.h" */
/* #include "ofPixels.h" */

/// \file
/// The ofTrueTypeFont class provides an interface to load fonts into
/// openFrameworks. The fonts are converted to textures, and can be drawn on
/// screen. There are some options when you load the font - what size the
/// font is rendered at, whether or not it is anti-aliased, and whether the
/// font object will be the full character set or a subset (i.e., extended
/// ASCII, which can include diacritics like umlauts, or ASCII). The default
/// is anti-aliased, non-full character set. The library uses freetype, which
/// has certain patent problems in regards to true type hinting, especially
/// at small sizes, so non-anti-aliased type doesn't always render
/// beautifully. But we find it quite adequate, and at larger sizes it seems
/// to works well.


/// \cond INTERNAL


typedef struct FT_FaceRec_*  FT_Face;

/// \endcond

/// \name Fonts
/// \{
static const std::string OF_TTF_SANS = "sans-serif";
static const std::string OF_TTF_SERIF = "serif";
static const std::string OF_TTF_MONO = "monospace";
/// \}


void ofTrueTypeShutdown();

class ofUnicode{
public:
	struct range{
		std::uint32_t begin;
		std::uint32_t end;
		
		std::uint32_t getNumGlyphs() const{
			return end - begin + 1;
		}
	};

	static const range Space;
	static const range IdeographicSpace;
	static const range Latin;
	static const range Latin1Supplement;
	static const range LatinA;
	static const range Greek;
	static const range Cyrillic;
	static const range Arabic;
	static const range ArabicSupplement;
	static const range ArabicExtendedA;
	static const range Devanagari;
	static const range HangulJamo;
	static const range VedicExtensions;
	static const range LatinExtendedAdditional;
	static const range GreekExtended;
	static const range GeneralPunctuation;
	static const range SuperAndSubScripts;
	static const range CurrencySymbols;
	static const range LetterLikeSymbols;
	static const range NumberForms;
	static const range Arrows;
	static const range MathOperators;
	static const range MiscTechnical;
	static const range BoxDrawing;
	static const range BlockElement;
	static const range GeometricShapes;
	static const range MiscSymbols;
	static const range Dingbats;
	static const range Hiragana;
	static const range Katakana;
	static const range HangulCompatJamo;
	static const range KatakanaPhoneticExtensions;
	static const range CJKLettersAndMonths;
	static const range CJKUnified;
	static const range DevanagariExtended;
	static const range HangulExtendedA;
	static const range HangulSyllables;
	static const range HangulExtendedB;
	static const range AlphabeticPresentationForms;
	static const range ArabicPresFormsA;
	static const range ArabicPresFormsB;
	static const range KatakanaHalfAndFullwidthForms;
	static const range KanaSupplement;
	static const range RumiNumericalSymbols;
	static const range ArabicMath;
	static const range MiscSymbolsAndPictographs;
	static const range Emoticons;
	static const range TransportAndMap;
	static const range EnclosedCharacters;
	static const range Uncategorized;
	static const range AdditionalEmoticons;
	static const range AdditionalTransportAndMap;
	static const range OtherAdditionalSymbols;
};

class ofAlphabet{
public:
	static const std::initializer_list<ofUnicode::range> Emoji;
	static const std::initializer_list<ofUnicode::range> Japanese;
	static const std::initializer_list<ofUnicode::range> Chinese;
	static const std::initializer_list<ofUnicode::range> Korean;
	static const std::initializer_list<ofUnicode::range> Arabic;
	static const std::initializer_list<ofUnicode::range> Devanagari;
	static const std::initializer_list<ofUnicode::range> Latin;
	static const std::initializer_list<ofUnicode::range> Greek;
	static const std::initializer_list<ofUnicode::range> Cyrillic;
};

enum ofTrueTypeFontDirection : uint32_t {
    OF_TTF_LEFT_TO_RIGHT,
    OF_TTF_RIGHT_TO_LEFT
};

struct ofTrueTypeFontSettings{

    std::filesystem::path     fontName;
    int                       fontSize = 0;
    bool                      antialiased = true;
    bool                      contours = false;
    float                     simplifyAmt = 0.3f;
    int                       dpi = 0;
    ofTrueTypeFontDirection direction = OF_TTF_LEFT_TO_RIGHT;
    std::vector<ofUnicode::range> ranges;

    ofTrueTypeFontSettings(const std::filesystem::path & name, int size)
    :fontName(name)
    ,fontSize(size){}

    void addRanges(std::initializer_list<ofUnicode::range> alphabet){
        ranges.insert(ranges.end(), alphabet);
    }

    void addRange(const ofUnicode::range & range){
        ranges.push_back(range);
    }
};

class ofTrueTypeFont{

public:

	/// \brief Construct a default ofTrueTypeFont.
	ofTrueTypeFont();

	/// \brief Destroy the ofTrueTypeFont.
	virtual ~ofTrueTypeFont();

	ofTrueTypeFont(const ofTrueTypeFont& mom);
	ofTrueTypeFont & operator=(const ofTrueTypeFont& mom);

	ofTrueTypeFont(ofTrueTypeFont&& mom);
	ofTrueTypeFont & operator=(ofTrueTypeFont&& mom);

	/// \name Load Font
	/// \{
				
	/// \brief Loads the font specified by filename, allows you to control size, aliasing, and other parameters.
	///
	/// loads a font, and allows you to set the following parameters: the filename, the size, if the font is anti-aliased,
	/// if it has a full character set, if you need it to have contours (for getStringPoints) and parameters that control 
	/// the simplification amount for those contours and the dpi of the font.
	/// 
	/// default (without dpi), non-full char set, anti aliased, 96 dpi
    ///
	/// \param filename The name of the font file to load.
    /// \param fontsize The size in pixels to load the font.
    /// \param _bAntiAliased true if the font should be anti-aliased.
    /// \param _bFullCharacterSet true if the full character set should be cached.
    /// \param makeControus true if the vector contours should be cached.
    /// \param simplifyAmt the amount to simplify the vector contours.  Larger number means more simplified.
    /// \param dpi the dots per inch used to specify rendering size.
	/// \returns true if the font was loaded correctly.
    bool load(const std::filesystem::path& filename,
                  int fontsize,
                  bool _bAntiAliased=true,
                  bool _bFullCharacterSet=true,
                  bool makeContours=false,
                  float simplifyAmt=0.3f,
				  int dpi=0);

	OF_DEPRECATED_MSG("Use load instead",bool loadFont(std::string filename,
                  int fontsize,
                  bool _bAntiAliased=true,
                  bool _bFullCharacterSet=false,
                  bool makeContours=false,
                  float simplifyAmt=0.3f,
				  int dpi=0));
	
	bool load(const ofTrueTypeFontSettings & settings);

	/// \brief Has the font been loaded successfully?
	/// \returns true if the font was loaded.
	bool isLoaded() const;

	/// \}
	/// \name Font Settings
	/// \{
	
	/// \brief Set the default dpi for all typefaces.
	static void setGlobalDpi(int newDpi);
	
	/// \brief Is the font anti-aliased?
	/// \returns true if the font was set to be anti-aliased.
	bool isAntiAliased() const;

	/// \brief Does the font have a full character set?
	/// \returns true if the font was allocated with a full character set.
	bool hasFullCharacterSet() const;
	
	/// \brief Get the number of characters in the loaded character set.
	/// 
	/// If you allocate the font using different parameters, you can load in partial 
	/// and full character sets, this helps you know how many characters it can represent.
	///
	/// \returns Number of characters in loaded character set.
	std::size_t	getNumCharacters() const;

	/// \}
	/// \name Font Size
	/// \{

	/// \brief Returns the size of the font.
	/// \returns Size of font, set when font was loaded.
	int getSize() const;
	
	/// \brief Computes line height based on font size.
	/// \returns the current line height.
	float getLineHeight() const;

	/// \brief Sets line height for text drawn on screen. 
	///
	/// Note the line height is automatically computed based on the font size, when you load in the font.
	///
	/// \param height Line height for text drawn on screen.
	void setLineHeight(float height);

	/// \brief Get the ascender distance for this font.
	///
	/// The ascender is the vertical distance from the baseline to the highest "character" coordinate.
	/// The meaning of "character" coordinate depends on the font. Some fonts take accents into account,
	/// others do not, and still others define it simply to be the highest coordinate over all glyphs.
	///
	/// \returns the font ascender height in pixels.
	float getAscenderHeight() const;

	/// \brief Get the descender distance for this font.
	///
	/// The descender is the vertical distance from the baseline to the lowest "character" coordinate.
	/// The meaning of "character" coordinate depends on the font. Some fonts take accents into account,
	/// others do not, and still others define it simply to be the lowest coordinate over all glyphs.
	/// This value will be negative for descenders below the baseline (which is typical).
	///
	/// \returns the font descender height in pixels.
	float getDescenderHeight() const;

	/// \brief Get the global bounding box for this font.
	///
	/// The global bounding box is the rectangle inside of which all glyphs in the font can fit.
    /// Glyphs are drawn starting from (0,0) in the returned box (though note that the box can
    /// extend in any direction out from the origin).
    ///
	/// \returns the font descender height in pixels.
    const ofRectangle & getGlyphBBox() const;

	/// \brief Returns letter spacing of font object.
	///
	/// You can control this by the ofTrueTypeFont::setLetterSpacing() function. 1.0 = default spacing, 
	/// less then 1.0 would be tighter spacing, greater then 1.0 would be wider spacing.
	///
	/// \returns the letter spacing of font object.
	float getLetterSpacing() const;

	/// \brief Sets the letter spacing of the font object.
	/// 
	/// 1.0 = default spacing, less then 1.0 would be tighter spacing, greater then 1.0 would be wider spacing.
	/// \param spacing Spacing of font object. 
	void setLetterSpacing(float spacing);

	/// \brief Returns a variable that represents how wide spaces are.
	///
	/// It's a scalar for the width of the letter 'p', so 1.0 means that a space will be the size of the lower 
	/// case 'p' of that font. 2.0 means that it's 2 times the size of the lower case 'p', etc.
	///
	/// \returns the width of the space.
	float getSpaceSize() const;

	/// \brief Sets the size of the space ' ' character. 
	/// 
	/// This number, which defaults to 1.0, scales the width of the letter 'p' for the space.
	///
	/// \param size Scales the width of the letter 'p' for the space. 
	void setSpaceSize(float size);

	/// \brief Returns the string width.
	///
	/// This is essentially the width component of the ofTrueTypeFont::getStringBoundingBox() rectangle.
	///
	/// \param s The string to get the width of.
	/// \returns the string width. 
	float stringWidth(const std::string& s) const;

	/// \brief Returns the string height.
	///
	/// This is essentially the height component of the ofTrueTypeFont::getStringBoundingBox() rectangle.
	///
	/// \param s The string to get the height of.
	/// \returns the string height.
	float stringHeight(const std::string& s) const;

	/// \brief Returns the bounding box of a string as a rectangle.
	/// \param s The string to get bounding box of.
	/// \param x X position of returned rectangle.
	/// \param y Y position of returned rectangle.
	/// \returns the bounding box of a string as a rectangle.
	ofRectangle getStringBoundingBox(const std::string& s, float x, float y, bool vflip=true) const;

	/// \}
	/// \name Drawing
	/// \{

	/// \brief Draw a string s at position x,y
	/// \param s String to draw
	/// \param x X position of string
	/// \param y Y position of string
	void drawString(const std::string& s, float x, float y) const;

	/// \brief Draws the string as if it was geometrical shapes.
	/// 
	/// Uses the information contained in ofTTFContour and ofTTFCharacter.
	/// 
	/// \param x X position of shapes
	/// \param y Y position of shapes
	void drawStringAsShapes(const std::string& s, float x, float y) const;
	
	/// \todo
	ofPath getCharacterAsPoints(uint32_t character, bool vflip=true, bool filled=true) const;
	std::vector<ofPath> getStringAsPoints(const std::string &  str, bool vflip=true, bool filled=true) const;
	const ofMesh & getStringMesh(const std::string &  s, float x, float y, bool vflip=true) const;
	const ofTexture & getFontTexture() const;
	ofTexture getStringTexture(const std::string &  s, bool vflip=true) const;
	glm::vec2 getFirstGlyphPosForTexture(const std::string & str, bool vflip) const;
	bool isValidGlyph(uint32_t) const;
	/// \}

    /// \returns current font direction
	void setDirection(ofTrueTypeFontDirection direction);

protected:
	/// \cond INTERNAL
	
	bool bLoadedOk;
	
	std::vector <ofPath> charOutlines;
	std::vector <ofPath> charOutlinesNonVFlipped;
	std::vector <ofPath> charOutlinesContour;
	std::vector <ofPath> charOutlinesNonVFlippedContour;

	float lineHeight;
	float ascenderHeight;
	float descenderHeight;
	ofRectangle glyphBBox;
	float letterSpacing;
	float spaceSize;
	float fontUnitScale;

	struct glyphProps{
		std::size_t characterIndex;
		uint32_t glyph;
		long height;
		long width;
		long bearingX, bearingY;
		long xmin, xmax, ymin, ymax;
		long advance;
		float tW,tH;
		float t1,t2,v1,v2;
	};

	struct glyph{
		glyphProps props;
		ofPixels pixels;
	};

	std::vector<glyphProps> cps; // properties for each character

	ofTrueTypeFontSettings settings;
	std::unordered_map<uint32_t,size_t> glyphIndexMap;

    int getKerning(uint32_t c, uint32_t prevC) const;
	void drawChar(uint32_t c, float x, float y, bool vFlipped) const;
	void drawCharAsShape(uint32_t c, float x, float y, bool vFlipped, bool filled) const;
	void createStringMesh(const std::string & s, float x, float y, bool vFlipped) const;
	glyph loadGlyph(uint32_t utf8) const;
	const glyphProps & getGlyphProperties(uint32_t glyph) const;
	void iterateString(const std::string & str, float x, float y, bool vFlipped, std::function<void(uint32_t, glm::vec2)> f) const;
	size_t indexForGlyph(uint32_t glyph) const;

	ofTexture texAtlas;
	mutable ofMesh stringQuads;

	/// \endcond

private:
#if defined(TARGET_ANDROID) || defined(TARGET_OF_IOS)
	friend void ofUnloadAllFontTextures();
	friend void ofReloadAllFontTextures();
#endif
	std::shared_ptr<struct FT_FaceRec_>	face;
	static const glyphProps invalidProps;
	void		unloadTextures();
	void		reloadTextures();
	static bool	initLibraries();
	static void finishLibraries();

	friend void ofExitCallback();
};

#line 0 "../libs/openFrameworks/gl/ofGLRenderer.h"
#pragma once
/* #include "ofGraphicsBaseTypes.h" */
/* #include "ofPolyline.h" */
/* #include "of3dGraphics.h" */
/* #include "ofBitmapFont.h" */
/* #include "ofMatrixStack.h" */
/* #include "ofPath.h" */
/* #include "ofGLBaseTypes.h" */

class ofShapeTessellation;
class ofFbo;
class of3dPrimitive;

class ofGLRenderer: public ofBaseGLRenderer{
public:
	ofGLRenderer(const ofAppBaseWindow * window);
	~ofGLRenderer(){}

	static const std::string TYPE;
	const std::string & getType(){ return TYPE; }

    void setup();

	void startRender();
	void finishRender();

	using ofBaseRenderer::draw;
	using ofBaseGLRenderer::draw;
	void draw(const ofMesh & vertexData, ofPolyRenderMode renderType, bool useColors, bool useTextures, bool useNormals) const;
    void draw(const of3dPrimitive& model, ofPolyRenderMode renderType) const;
    void draw(const ofNode& model) const;
	void draw(const ofPolyline & poly) const;
	void draw(const ofPath & path) const;
	void draw(const ofImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
	void draw(const ofFloatImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
	void draw(const ofShortImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
	void draw(const ofTexture & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
	void draw(const ofBaseVideoDraws & video, float x, float y, float w, float h) const;
	void draw(const ofVbo & vbo, GLuint drawMode, int first, int total) const;
	void drawElements(const ofVbo & vbo, GLuint drawMode, int amt, int offsetelements = 0) const;
	void drawInstanced(const ofVbo & vbo, GLuint drawMode, int first, int total, int primCount) const;
	void drawElementsInstanced(const ofVbo & vbo, GLuint drawMode, int amt, int primCount) const;
	void draw(const ofVboMesh & mesh, ofPolyRenderMode renderType) const;
	void drawInstanced(const ofVboMesh & mesh, ofPolyRenderMode renderType, int primCount) const;
	ofPath & getPath();



	//--------------------------------------------
	// transformations
	void pushView();
	void popView();

	// setup matrices and viewport (upto you to push and pop view before and after)
	// if width or height are 0, assume windows dimensions (ofGetWidth(), ofGetHeight())
	// if nearDist or farDist are 0 assume defaults (calculated based on width / height)
	void viewport(ofRectangle viewport);
	void viewport(float x = 0, float y = 0, float width = -1, float height = -1, bool vflip=true);
	void setOrientation(ofOrientation orientation, bool vFlip);
	void setupScreenPerspective(float width = -1, float height = -1, float fov = 60, float nearDist = 0, float farDist = 0);
	void setupScreenOrtho(float width = -1, float height = -1, float nearDist = -1, float farDist = 1);
	ofRectangle getCurrentViewport() const;
	ofRectangle getNativeViewport() const;
	int getViewportWidth() const;
	int getViewportHeight() const;
	bool isVFlipped() const;
	bool texturesNeedVFlip() const;

	void setCoordHandedness(ofHandednessType handedness);
	ofHandednessType getCoordHandedness() const;

	//our openGL wrappers
	void pushMatrix();
	void popMatrix();
	void translate(float x, float y, float z = 0);
	void translate(const glm::vec3 & p);
	void scale(float xAmnt, float yAmnt, float zAmnt = 1);
	void rotateDeg(float radians, float vecX, float vecY, float vecZ);
	void rotateXDeg(float radians);
	void rotateYDeg(float radians);
	void rotateZDeg(float radians);
	void rotateDeg(float radians);
	void rotateRad(float radians, float vecX, float vecY, float vecZ);
	void rotateXRad(float radians);
	void rotateYRad(float radians);
	void rotateZRad(float radians);
	void rotateRad(float radians);
	void matrixMode(ofMatrixMode mode);
	void loadIdentityMatrix (void);
	void loadMatrix (const glm::mat4 & m);
	void loadMatrix (const float * m);
	void multMatrix (const glm::mat4 & m);
	void multMatrix (const float * m);
	void loadViewMatrix(const glm::mat4 & m);
	void multViewMatrix(const glm::mat4 & m);

	glm::mat4 getCurrentMatrix(ofMatrixMode matrixMode_) const;
	glm::mat4 getCurrentOrientationMatrix() const;
	glm::mat4 getCurrentViewMatrix() const;
	glm::mat4 getCurrentNormalMatrix() const;
	
	// screen coordinate things / default gl values
	void setupGraphicDefaults();
	void setupScreen();

	// drawing modes
	void setFillMode(ofFillFlag fill);
	ofFillFlag getFillMode();
	void setCircleResolution(int res);
	void setRectMode(ofRectMode mode);
	ofRectMode getRectMode();
	void setLineWidth(float lineWidth);
	void setDepthTest(bool depthTest);
	void setLineSmoothing(bool smooth);
	void setBlendMode(ofBlendMode blendMode);
	void enablePointSprites();
	void disablePointSprites();
	void enableAntiAliasing();
	void disableAntiAliasing();

	// color options
	void setColor(int r, int g, int b); // 0-255
	void setColor(int r, int g, int b, int a); // 0-255
	void setColor(const ofColor & color);
	void setColor(const ofColor & color, int _a);
	void setColor(int gray); // new set a color as grayscale with one argument
	void setHexColor( int hexColor ); // hex, like web 0xFF0033;

	void setBitmapTextMode(ofDrawBitmapMode mode);

	// bg color
	ofColor getBackgroundColor();
	void setBackgroundColor(const ofColor & c);
	void background(const ofColor & c);
	void background(float brightness);
	void background(int hexColor, float _a=255.0f);
	void background(int r, int g, int b, int a=255);

	void setBackgroundAuto(bool bManual);		// default is true
	bool getBackgroundAuto();

	void clear();
	void clear(float r, float g, float b, float a=0);
	void clear(float brightness, float a=0);
	void clearAlpha();

	ofStyle getStyle() const;
	void pushStyle();
	void popStyle();
	void setStyle(const ofStyle & style);
	void setCurveResolution(int resolution);
	void setPolyMode(ofPolyWindingMode mode);


	// drawing
	void drawLine(float x1, float y1, float z1, float x2, float y2, float z2) const;
	void drawRectangle(float x, float y, float z, float w, float h) const;
	void drawTriangle(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) const;
	void drawCircle(float x, float y, float z, float radius) const;
	void drawEllipse(float x, float y, float z, float width, float height) const;
	void drawString(std::string text, float x, float y, float z) const;
	void drawString(const ofTrueTypeFont & font, std::string text, float x, float y) const;


	// gl specifics
	void enableTextureTarget(const ofTexture & tex, int textureLocation);
	void disableTextureTarget(int textureTarget, int textureLocation);
	void setAlphaMaskTex(const ofTexture & tex);
	void disableAlphaMask();

	// lighting globals
	void enableLighting();
	void disableLighting();
	void enableSeparateSpecularLight();
	void disableSeparateSpecularLight();
	bool getLightingEnabled();
	void setSmoothLighting(bool b);
	void setGlobalAmbientColor(const ofColor& c);

	// lighting per light
	void enableLight(int lightIndex);
	void disableLight(int lightIndex);
	void setLightSpotlightCutOff(int lightIndex, float spotCutOff);
	void setLightSpotConcentration(int lightIndex, float exponent);
	void setLightAttenuation(int lightIndex, float constant, float linear, float quadratic );
	void setLightAmbientColor(int lightIndex, const ofFloatColor& c);
	void setLightDiffuseColor(int lightIndex, const ofFloatColor& c);
	void setLightSpecularColor(int lightIndex, const ofFloatColor& c);
	void setLightPosition(int lightIndex, const glm::vec4 & position);
	void setLightSpotDirection(int lightIndex, const glm::vec4 & direction);


	void bind(const ofBaseVideoDraws & video);
	void bind(const ofBaseMaterial & material);
	void bind(const ofShader & shader);
	void bind(const ofTexture & texture, int location);
	void bind(const ofCamera & camera, const ofRectangle & viewport);
	void unbind(const ofBaseVideoDraws & video);
	void unbind(const ofBaseMaterial & material);
	void unbind(const ofShader & shader);
	void unbind(const ofTexture & texture, int location);
	void unbind(const ofCamera & camera);

    void begin(const ofFbo & fbo, ofFboMode mode);
	void end(const ofFbo & fbo);

	void bind(const ofFbo & fbo);
#ifndef TARGET_OPENGLES
	void bindForBlitting(const ofFbo & fboSrc, ofFbo & fboDst, int attachmentPoint);
#endif
	void unbind(const ofFbo & fbo);

	int getGLVersionMajor();
	int getGLVersionMinor();

	void saveScreen(int x, int y, int w, int h, ofPixels & pixels);
	void saveFullViewport(ofPixels & pixels);

	const of3dGraphics & get3dGraphics() const;
	of3dGraphics & get3dGraphics();
private:
	void startSmoothing();
	void endSmoothing();


	bool bBackgroundAuto;

	mutable std::vector<glm::vec3> linePoints;
	mutable std::vector<glm::vec3> rectPoints;
	mutable std::vector<glm::vec3> triPoints;
	mutable std::vector<glm::vec3> circlePoints;
	ofPolyline circlePolyline;

	ofMatrixStack matrixStack;
	bool normalsEnabled;
	bool lightingEnabled;
        bool materialBound;
	std::set<int> textureLocationsEnabled;

	int alphaMaskTextureTarget;

	ofStyle currentStyle;
	std::deque <ofStyle> styleHistory;
	of3dGraphics graphics3d;
	ofBitmapFont bitmapFont;
	ofPath path;
	const ofAppBaseWindow * window;

	std::deque<GLuint> framebufferIdStack;	///< keeps track of currently bound framebuffers
	GLuint defaultFramebufferId;		///< default GL_FRAMEBUFFER_BINDING, windowing frameworks might want to set this to their MSAA framebuffer, defaults to 0
	GLuint currentFramebufferId;		///< the framebuffer id currently bound to the GL_FRAMEBUFFER target

};

#line 0 "../libs/openFrameworks/gl/ofGLProgrammableRenderer.h"
#pragma once
/* #include "ofGLBaseTypes.h" */
/* #include "ofPolyline.h" */
/* #include "ofShader.h" */
/* #include "ofMatrixStack.h" */
/* #include "ofVboMesh.h" */
/* #include "of3dGraphics.h" */
/* #include "ofBitmapFont.h" */
/* #include "ofPath.h" */
/* #include "ofMaterial.h" */


class ofShapeTessellation;
class ofFbo;
class ofVbo;
static const int OF_NO_TEXTURE=-1;

class ofGLProgrammableRenderer: public ofBaseGLRenderer{
public:
    ofGLProgrammableRenderer(const ofAppBaseWindow * window);

	void setup(int glVersionMajor, int glVersionMinor);

    static const std::string TYPE;
	const std::string & getType(){ return TYPE; }
    
    void startRender();
    void finishRender();

	using ofBaseRenderer::draw;
	using ofBaseGLRenderer::draw;
	void draw(const ofMesh & vertexData, ofPolyRenderMode renderType, bool useColors, bool useTextures, bool useNormals) const;
    void draw(const of3dPrimitive& model, ofPolyRenderMode renderType) const;
    void draw(const ofNode& node) const;
	void draw(const ofPolyline & poly) const;
	void draw(const ofPath & path) const;
	void draw(const ofImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
	void draw(const ofFloatImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
	void draw(const ofShortImage & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
	void draw(const ofTexture & image, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;
    void draw(const ofBaseVideoDraws & video, float x, float y, float w, float h) const;
	void draw(const ofVbo & vbo, GLuint drawMode, int first, int total) const;
	void drawElements(const ofVbo & vbo, GLuint drawMode, int amt, int offsetelements = 0) const;
	void drawInstanced(const ofVbo & vbo, GLuint drawMode, int first, int total, int primCount) const;
	void drawElementsInstanced(const ofVbo & vbo, GLuint drawMode, int amt, int primCount) const;
	void draw(const ofVboMesh & mesh, ofPolyRenderMode renderType) const;
	void drawInstanced(const ofVboMesh & mesh, ofPolyRenderMode renderType, int primCount) const;
    ofPath & getPath();
    
    
    
	//--------------------------------------------
	// transformations
	void pushView();
    void popView();
    
	// setup matrices and viewport (upto you to push and pop view before and after)
	// if width or height are 0, assume windows dimensions (ofGetWidth(), ofGetHeight())
	// if nearDist or farDist are 0 assume defaults (calculated based on width / height)
	void viewport(ofRectangle viewport);
	void viewport(float x = 0, float y = 0, float width = -1, float height = -1, bool vflip=true);
	void setupScreenPerspective(float width = -1, float height = -1, float fov = 60, float nearDist = 0, float farDist = 0);
	void setupScreenOrtho(float width = -1, float height = -1, float nearDist = -1, float farDist = 1);
	void setOrientation(ofOrientation orientation, bool vFlip);
	ofRectangle getCurrentViewport() const;
	ofRectangle getNativeViewport() const;
	int getViewportWidth() const;
	int getViewportHeight() const;
	bool isVFlipped() const;
    
	void setCoordHandedness(ofHandednessType handedness);
	ofHandednessType getCoordHandedness() const;
    
	//our openGL wrappers
	void pushMatrix();
	void popMatrix();
	void translate(float x, float y, float z = 0);
	void translate(const glm::vec3 & p);
	void scale(float xAmnt, float yAmnt, float zAmnt = 1);
	void rotateRad(float radians, float vecX, float vecY, float vecZ);
	void rotateXRad(float radians);
	void rotateYRad(float radians);
	void rotateZRad(float radians);
	void rotateRad(float radians);
	void matrixMode(ofMatrixMode mode);
	void loadIdentityMatrix (void);
	void loadMatrix (const glm::mat4 & m);
	void loadMatrix (const float * m);
	void multMatrix (const glm::mat4 & m);
	void multMatrix (const float * m);
	void loadViewMatrix(const glm::mat4 & m);
	void multViewMatrix(const glm::mat4 & m);

    /// \brief Queries the current OpenGL matrix state
    ///
    /// Returns the specified matrix as held by the renderer's current matrix
    /// stack.
    ///
    /// You can query one of the following:
    ///
    /// [OF_MATRIX_MODELVIEW | OF_MATRIX_PROJECTION | OF_MATRIX_TEXTURE]
    ///
    /// Each query will return the state of the matrix as it was uploaded to
    /// the shader currently bound.
    ///
    /// \param	matrixMode_ Which matrix mode to query
    /// \note   If an invalid matrixMode is queried, this method will return the
    ///         identity matrix, and print an error message.
	glm::mat4 getCurrentMatrix(ofMatrixMode matrixMode_) const;
	glm::mat4 getCurrentOrientationMatrix() const;
	glm::mat4 getCurrentViewMatrix() const;
	glm::mat4 getCurrentNormalMatrix() const;
	
	// screen coordinate things / default gl values
	void setupGraphicDefaults();
	void setupScreen();
    
	// drawing modes
	void setFillMode(ofFillFlag fill);
	ofFillFlag getFillMode();
	void setCircleResolution(int res);
	void setRectMode(ofRectMode mode);
	ofRectMode getRectMode();
	void setLineWidth(float lineWidth);
	void setDepthTest(bool depthTest);
	void setLineSmoothing(bool smooth);
	void setBlendMode(ofBlendMode blendMode);
	void enablePointSprites();
	void disablePointSprites();
	void enableAntiAliasing();
	void disableAntiAliasing();
    
	// color options
	void setColor(int r, int g, int b); // 0-255
	void setColor(int r, int g, int b, int a); // 0-255
	void setColor(const ofColor & color);
	void setColor(const ofColor & color, int _a);
	void setColor(int gray); // new set a color as grayscale with one argument
	void setHexColor( int hexColor ); // hex, like web 0xFF0033;

	void setBitmapTextMode(ofDrawBitmapMode mode);
    
	// bg color
	ofColor getBackgroundColor();
	void setBackgroundColor(const ofColor & c);
	void background(const ofColor & c);
	void background(float brightness);
	void background(int hexColor, float _a=255.0f);
	void background(int r, int g, int b, int a=255);

	bool getBackgroundAuto();
	void setBackgroundAuto(bool bManual);		// default is true
    
	void clear();
	void clear(float r, float g, float b, float a=0);
	void clear(float brightness, float a=0);
	void clearAlpha();
    
    
	// drawing
	void drawLine(float x1, float y1, float z1, float x2, float y2, float z2) const;
	void drawRectangle(float x, float y, float z, float w, float h) const;
	void drawTriangle(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) const;
	void drawCircle(float x, float y, float z, float radius) const;
	void drawEllipse(float x, float y, float z, float width, float height) const;
	void drawString(std::string text, float x, float y, float z) const;
	void drawString(const ofTrueTypeFont & font, std::string text, float x, float y) const;


	void enableTextureTarget(const ofTexture & tex, int textureLocation);
	void disableTextureTarget(int textureTarget, int textureLocation);
	void setAlphaMaskTex(const ofTexture & tex);
	void disableAlphaMask();
	GLenum getCurrentTextureTarget();

	const ofShader & getCurrentShader() const;

	void bind(const ofBaseMaterial & material);
	void bind(const ofShader & shader);
	void bind(const ofTexture & texture, int location);
	void bind(const ofBaseVideoDraws & video);
	void bind(const ofCamera & camera, const ofRectangle & viewport);
	void unbind(const ofBaseMaterial & material);
	void unbind(const ofShader & shader);
	void unbind(const ofTexture & texture, int location);
	void unbind(const ofBaseVideoDraws & video);
	void unbind(const ofCamera & camera);

	void bind(const ofFbo & fbo);
#ifndef TARGET_OPENGLES
	void bindForBlitting(const ofFbo & fboSrc, ofFbo & fboDst, int attachmentPoint);
#endif
	void unbind(const ofFbo & fbo);

    void begin(const ofFbo & fbo, ofFboMode mode);
	void end(const ofFbo & fbo);

	ofStyle getStyle() const;
	void pushStyle();
	void popStyle();
	void setStyle(const ofStyle & style);
	void setCurveResolution(int resolution);
	void setPolyMode(ofPolyWindingMode mode);

	const ofShader * getVideoShader(const ofBaseVideoDraws & video) const;
	void setVideoShaderUniforms(const ofBaseVideoDraws & video, const ofShader & shader) const;

    void enableLighting();
    void disableLighting();
    bool getLightingEnabled();
    void enableSeparateSpecularLight(){}
    void disableSeparateSpecularLight(){}
	void setSmoothLighting(bool b){}
	void setGlobalAmbientColor(const ofColor& c){}
    void enableLight(int lightIndex);
    void disableLight(int lightIndex);
	void setLightSpotlightCutOff(int lightIndex, float spotCutOff){}
	void setLightSpotConcentration(int lightIndex, float exponent){}
	void setLightAttenuation(int lightIndex, float constant, float linear, float quadratic ){}
	void setLightAmbientColor(int lightIndex, const ofFloatColor& c){}
	void setLightDiffuseColor(int lightIndex, const ofFloatColor& c){}
	void setLightSpecularColor(int lightIndex, const ofFloatColor& c){}
	void setLightPosition(int lightIndex, const glm::vec4 & position){}
	void setLightSpotDirection(int lightIndex, const glm::vec4 & direction){}

	std::string defaultVertexShaderHeader(GLenum textureTarget);
	std::string defaultFragmentShaderHeader(GLenum textureTarget);

	int getGLVersionMajor();
	int getGLVersionMinor();

	void saveScreen(int x, int y, int w, int h, ofPixels & pixels);
	void saveFullViewport(ofPixels & pixels);

	const of3dGraphics & get3dGraphics() const;
	of3dGraphics & get3dGraphics();

private:


	ofPolyline circlePolyline;
	mutable ofMesh circleMesh;
	mutable ofMesh triangleMesh;
	mutable ofMesh rectMesh;
	mutable ofMesh lineMesh;
	mutable ofVbo meshVbo;

	void uploadCurrentMatrix();


	void startSmoothing();
	void endSmoothing();

	void beginDefaultShader();
	void uploadMatrices();
	void setDefaultUniforms();

	void setAttributes(bool vertices, bool color, bool tex, bool normals);
	void setAlphaBitmapText(bool bitmapText);

    
	ofMatrixStack matrixStack;

	bool bBackgroundAuto;
	int major, minor;
	
	const ofShader * currentShader;

	bool verticesEnabled, colorsEnabled, texCoordsEnabled, normalsEnabled, bitmapStringEnabled;
	bool usingCustomShader, settingDefaultShader, usingVideoShader;
	int currentTextureTarget;

	bool wrongUseLoggedOnce;
	bool uniqueShader;

	const ofBaseMaterial * currentMaterial;
	int alphaMaskTextureTarget;

	ofStyle currentStyle;
	std::deque <ofStyle> styleHistory;
	of3dGraphics graphics3d;
	ofBitmapFont bitmapFont;
	ofPath path;
	const ofAppBaseWindow * window;

	ofShader defaultTexRectColor;
	ofShader defaultTexRectNoColor;
	ofShader defaultTex2DColor;
	ofShader defaultTex2DNoColor;
	ofShader defaultNoTexColor;
	ofShader defaultNoTexNoColor;
	ofShader defaultUniqueShader;
#ifdef TARGET_ANDROID
	ofShader defaultOESTexColor;
	ofShader defaultOESTexNoColor;
#endif
	
	ofShader alphaMaskRectShader;
	ofShader alphaMask2DShader;
	
	ofShader bitmapStringShader;
	
	ofShader shaderPlanarYUY2;
	ofShader shaderNV12;
	ofShader shaderNV21;
	ofShader shaderPlanarYUV;
	ofShader shaderPlanarYUY2Rect;
	ofShader shaderNV12Rect;
	ofShader shaderNV21Rect;
	ofShader shaderPlanarYUVRect;

	//void setDefaultFramebufferId(const GLuint& fboId_); ///< windowing systems might use this to set the default framebuffer for this renderer.

	//void pushFramebufferId(); // pushes currentFramebuffer onto framebufferStack
	//const GLuint& popFramebufferId(); /// returns topmost element in framebufferIdStack or 0, removes topmost element from stack.
	//const GLuint& getFramebufferId(); ///< returns current target bound to GL_FRAMEBUFFER_BINDING, initially set to defaultFramebufferId
	//void setFramebufferId(const GLuint& fboId_); // sets the current framebuffer id

	// framebuffer binding state
	std::deque<GLuint> framebufferIdStack;	///< keeps track of currently bound framebuffers
	GLuint defaultFramebufferId;		///< default GL_FRAMEBUFFER_BINDING, windowing frameworks might want to set this to their MSAA framebuffer, defaults to 0
    GLuint currentFramebufferId;		///< the framebuffer id currently bound to the GL_FRAMEBUFFER target
};

#line 0 "../libs/openFrameworks/graphics/ofRendererCollection.h"
#pragma once

/* #include "ofGraphicsBaseTypes.h" */
/* #include "of3dGraphics.h" */
/* #include "ofPath.h" */

class ofRendererCollection: public ofBaseRenderer{
public:
	 ofRendererCollection():graphics3d(this){}
	 ~ofRendererCollection(){}

	 static const std::string TYPE;
	 const std::string & getType(){ return TYPE; }

	 std::shared_ptr<ofBaseGLRenderer> getGLRenderer();

	 bool rendersPathPrimitives();

	 void startRender();

	 void finishRender();


	 using ofBaseRenderer::draw;

	 void draw(const ofPolyline & poly) const;
	 void draw(const ofPath & shape) const;

	 void draw(const ofMesh & vertexData, ofPolyRenderMode mode, bool useColors, bool useTextures, bool useNormals) const;

	void draw(const  of3dPrimitive& model, ofPolyRenderMode renderType ) const ;

	void draw(const  ofNode& node) const ;

	void draw(const ofImage & img, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;

	void draw(const ofFloatImage & img, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;

	void draw(const ofShortImage & img, float x, float y, float z, float w, float h, float sx, float sy, float sw, float sh) const;

	void draw(const ofBaseVideoDraws & video, float x, float y, float w, float h) const;

	/*void bind(const ofBaseVideoDraws & video) const{
		for(int i=0;i<(int)renderers.size();i++){
			renderers[i]->bind(video);
		}
	}

	void unbind(const ofBaseVideoDraws & video) const{
		for(int i=0;i<(int)renderers.size();i++){
			renderers[i]->unbind(video);
		}
	}*/


	glm::mat4 getCurrentMatrix(ofMatrixMode matrixMode_) const;


	glm::mat4 getCurrentOrientationMatrix() const;

	glm::mat4 getCurrentNormalMatrix() const;

	//--------------------------------------------
	// transformations
	 void pushView();

	 void popView();
	// setup matrices and viewport (upto you to push and pop view before and after)
	// if width or height are 0, assume windows dimensions (ofGetWidth(), ofGetHeight())
	// if nearDist or farDist are 0 assume defaults (calculated based on width / height)
	void viewport(ofRectangle viewport);

	 void viewport(float x = 0, float y = 0, float width = -1, float height = -1, bool vflip=true);

	 void setupScreenPerspective(float width = -1, float height = -1, float fov = 60, float nearDist = 0, float farDist = 0);

	 void setupScreenOrtho(float width = -1, float height = -1, float nearDist = -1, float farDist = 1);

	 ofRectangle getCurrentViewport() const;

	 ofRectangle getNativeViewport() const;

	 int getViewportWidth() const;
	 int getViewportHeight() const;

	 void setCoordHandedness(ofHandednessType handedness);
	 ofHandednessType getCoordHandedness() const;

	//our openGL wrappers
	 void pushMatrix();
	 void popMatrix();
	 void translate(float x, float y, float z = 0);
	 void translate(const glm::vec3 & p);
	 void scale(float xAmnt, float yAmnt, float zAmnt = 1);

	 void rotateDeg(float degrees, float vecX, float vecY, float vecZ);
	 void rotateXDeg(float degrees);
	 void rotateYDeg(float degrees);
	 void rotateZDeg(float degrees);
	 void rotateDeg(float degrees);

	 void rotateRad(float radians, float vecX, float vecY, float vecZ);
	 void rotateXRad(float radians);
	 void rotateYRad(float radians);
	 void rotateZRad(float radians);
	 void rotateRad(float radians);
	void loadIdentityMatrix (void);

	void loadMatrix (const glm::mat4 & m);

	void loadMatrix (const float * m);

	void multMatrix (const glm::mat4 & m);

	void multMatrix (const float * m);

	void setOrientation(ofOrientation orientation, bool vflip);

	bool isVFlipped() const;

	void matrixMode(ofMatrixMode mode);

	void loadViewMatrix(const glm::mat4& m);

	void multViewMatrix(const glm::mat4& m);

	glm::mat4 getCurrentViewMatrix() const;


	// screen coordinate things / default gl values
	 void setupGraphicDefaults();

	 void setupScreen();

	// color options
	void setColor(int r, int g, int b);

	void setColor(int r, int g, int b, int a);

	void setColor(const ofColor & color);

	void setColor(const ofColor & color, int _a);

	void setColor(int gray);

	void setHexColor( int hexColor );

	// bg color
	ofColor getBackgroundColor();

	void setBackgroundColor(const ofColor & color);

	bool getBackgroundAuto();

	void background(const ofColor & c);

	void background(float brightness);

	void background(int hexColor, float _a=255.0f);

	void background(int r, int g, int b, int a=255);

	void setBackgroundAuto(bool bManual);

	void clear();

	void clear(float r, float g, float b, float a=0);

	void clear(float brightness, float a=0);

	void clearAlpha();

	// drawing modes
	void setRectMode(ofRectMode mode);

	ofRectMode getRectMode();

	void setFillMode(ofFillFlag fill);

	ofFillFlag getFillMode();

	void setLineWidth(float lineWidth);

	void setDepthTest(bool depthTest);

	void setBlendMode(ofBlendMode blendMode);
	void setLineSmoothing(bool smooth);
	void setCircleResolution(int res);
	void enablePointSprites();
	void disablePointSprites();

	void enableAntiAliasing();

	void disableAntiAliasing();

	void setBitmapTextMode(ofDrawBitmapMode mode);

	ofStyle getStyle() const;

	void pushStyle();

	void popStyle();

	void setStyle(const ofStyle & style);

	void setCurveResolution(int res);

	void setPolyMode(ofPolyWindingMode mode);

	// drawing
	void drawLine(float x1, float y1, float z1, float x2, float y2, float z2) const;

	void drawRectangle(float x, float y, float z, float w, float h) const;

	void drawTriangle(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) const;

	void drawCircle(float x, float y, float z, float radius) const;

	void drawEllipse(float x, float y, float z, float width, float height) const;

	void drawString(std::string text, float x, float y, float z) const;

	void drawString(const ofTrueTypeFont & font, std::string text, float x, float y) const;

	virtual void bind(const ofCamera & camera, const ofRectangle & viewport);
	virtual void unbind(const ofCamera & camera);

	const of3dGraphics & get3dGraphics() const;

	of3dGraphics & get3dGraphics();

	ofPath & getPath();

	std::vector<std::shared_ptr<ofBaseRenderer> > renderers;
	of3dGraphics graphics3d;
	ofPath path;
};

#line 0 "../libs/openFrameworks/gl/ofFbo.h"
#pragma once

/* #include "ofTexture.h" */
/* #include "ofGLBaseTypes.h" */

/// ofFbo mode(s) when binding
enum ofFboMode : short {
    OF_FBOMODE_NODEFAULTS  = 0, ///< base GL fbo, no OF defaults
    OF_FBOMODE_PERSPECTIVE = 1, ///< set OF perspective and viewport
    OF_FBOMODE_MATRIXFLIP  = 2  ///< flip vertically
};

inline ofFboMode operator | (ofFboMode m1, ofFboMode m2){
    return static_cast<ofFboMode>(short(m1) | short(m2));
}

inline bool operator & (ofFboMode m1, ofFboMode m2){
    return static_cast<bool>(short(m1) & short(m2));
}

/// ofFbo internal settings
struct ofFboSettings {
    int width;                        ///< width of images attached to fbo
    int height;                       ///< height of images attached to fbo
    int numColorbuffers;              ///< how many color buffers to create
    std::vector<GLint> colorFormats;  ///< format of the color attachments for MRT.
    bool useDepth;                    ///< whether to use depth buffer or not
    bool useStencil;                  ///< whether to use stencil buffer or not
    bool depthStencilAsTexture;       ///< use a texture instead of a renderbuffer for depth (useful to draw it or use it in a shader later)
    GLenum textureTarget;             ///< GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB
    GLint internalformat;             ///< GL_RGBA, GL_RGBA16F_ARB, GL_RGBA32F_ARB, GL_LUMINANCE32F_ARB etc.
    GLint depthStencilInternalFormat; ///< GL_DEPTH_COMPONENT(16/24/32)
    int wrapModeHorizontal;           ///< GL_REPEAT, GL_MIRRORED_REPEAT, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER etc.
    int wrapModeVertical;             ///< GL_REPEAT, GL_MIRRORED_REPEAT, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER etc.
    int minFilter;                    ///< GL_NEAREST, GL_LINEAR etc.
    int maxFilter;                    ///< GL_NEAREST, GL_LINEAR etc.
    int numSamples;                   ///< number of samples for multisampling (set 0 to disable)
    ofFboSettings(std::shared_ptr<ofBaseGLRenderer> renderer=nullptr);
    bool operator!=(const ofFboSettings & other);
private:
    std::weak_ptr<ofBaseGLRenderer> renderer;
    friend class ofFbo;
};

class ofFbo : public ofBaseDraws, public ofBaseHasTexture {
public:

	ofFbo();
	ofFbo(const ofFbo & mom);
	ofFbo & operator=(const ofFbo & fbo);
    ofFbo(ofFbo && mom);
    ofFbo & operator=(ofFbo && fbo);
	virtual ~ofFbo();

	/// ofFbo::Settings is currently deprecated in favor of the ofFboSettings struct
	typedef ofFboSettings Settings;

	void allocate(int width, int height, int internalformat = GL_RGBA, int numSamples = 0);
	//void allocateForShadow(int width, int height);
	void allocate(ofFboSettings settings = ofFboSettings(nullptr));
	bool isAllocated() const;

	OF_DEPRECATED_MSG("Use clear() instead",void destroy());
	void clear();

#ifndef TARGET_OPENGLES
	/// glClearBufferfv(GL_COLOR, 0...)
	///
	/// @see: https://www.opengl.org/wiki/GLAPI/glClearBuffer
	void clearColorBuffer(const ofFloatColor & color);

	/// glClearBufferfv(GL_COLOR, buffer_idx...)
	///
	/// @see: https://www.opengl.org/wiki/GLAPI/glClearBuffer
	void clearColorBuffer(size_t buffer_idx, const ofFloatColor & color);

	/// glClearBufferfv(GL_DEPTH...)
	///
	/// @see: https://www.opengl.org/wiki/GLAPI/glClearBuffer
	void clearDepthBuffer(float value);

	/// glClearBufferiv(GL_STENCIL...)
	///
	/// @see: https://www.opengl.org/wiki/GLAPI/glClearBuffer
	void clearStencilBuffer(int value);

	/// glClearBufferfi(GL_DEPTH_STENCIL...)
	///
	/// @see: https://www.opengl.org/wiki/GLAPI/glClearBuffer
	void clearDepthStencilBuffer(float depth, int stencil);
#endif

	using ofBaseDraws::draw;
	void draw(float x, float y) const;
	void draw(float x, float y, float width, float height) const;

	void setAnchorPercent(float xPct, float yPct);
    void setAnchorPoint(float x, float y);
	void resetAnchor();

	void setDefaultTextureIndex(int defaultTexture);
	int getDefaultTextureIndex() const;

	OF_DEPRECATED_MSG("Use getTexture()",ofTexture & getTextureReference());
	OF_DEPRECATED_MSG("Use getTexture()",ofTexture & getTextureReference(int attachmentPoint));
	ofTexture & getTexture();
	ofTexture & getTexture(int attachmentPoint);
	ofTexture & getDepthTexture();
	OF_DEPRECATED_MSG("Use getTexture()",const ofTexture & getTextureReference() const);
	OF_DEPRECATED_MSG("Use getTexture()",const ofTexture & getTextureReference(int attachmentPoint) const);
	const ofTexture & getTexture() const ;
	const ofTexture & getTexture(int attachmentPoint) const;
	const ofTexture & getDepthTexture() const;
	void setUseTexture(bool){ /*irrelevant*/ };
	bool isUsingTexture() const {return true;}

    /// Sets up the framebuffer and binds it for rendering.
    ///
	/// \warning  This is a convenience method, and is considered unsafe 
	///           in multi-window and/or multi-renderer scenarios.
	///           If you use more than one renderer, use each renderer's
    ///           explicit void ofBaseGLRenderer::begin(const ofFbo & fbo, ofFboMode mode)
	///           method instead.
    /// \sa       void ofBaseGLRenderer::begin(const ofFbo & fbo, ofFboMode mode)
    OF_DEPRECATED_MSG("Use begin(OF_FBOMODE_NODEFAULTS) instead", void begin(bool setupScreen) const);

    /// Sets up the framebuffer and binds it for rendering.
    ///
    /// The mode parameter indicates which defaults are set when binding
    /// the fbo.
    ///
    /// The default OF_FBOMODE_PERSPECTIVE | OF_FBOMODE_MATRIXFLIP
    /// will set the screen perspective to the OF default for the fbo size, the
    /// correct viewport to cover the full fbo and will flip the orientation
    /// matrix in y so when drawing the fbo later or accesing it from a shader
    /// it's correctly oriented
    ///
    /// Passing OF_FBOMODE_PERSPECTIVE will only set perspective and viewport
    ///
    /// Passing OF_FBOMODE_MATRIXFLIP won't set the perspective but will flip
    /// the matrix.
    ///
    /// Passing OF_FBOMODE_NODEFAULTS won't change anything and just bind the fbo
    /// and set it as current rendering surface in OF
    ///
    /// \warning  This is a convenience method, and is considered unsafe
    ///           in multi-window and/or multi-renderer scenarios.
    ///           If you use more than one renderer, use each renderer's
    ///           explicit void ofBaseGLRenderer::begin(const ofFbo & fbo, ofFboMode mode)
    ///           method instead.
    /// \sa       void ofBaseGLRenderer::begin(const ofFbo & fbo, ofFboMode mode)
    void begin(ofFboMode mode = OF_FBOMODE_PERSPECTIVE | OF_FBOMODE_MATRIXFLIP);

	/// \brief    Ends the current framebuffer render context.
	/// \sa       void begin(bool setupScreen=true) const;
	void end() const;

	void readToPixels(ofPixels & pixels, int attachmentPoint = 0) const;
	void readToPixels(ofShortPixels & pixels, int attachmentPoint = 0) const;
	void readToPixels(ofFloatPixels & pixels, int attachmentPoint = 0) const;

#ifndef TARGET_OPENGLES
	/// \brief Copy the fbo to an ofBufferObject.
	/// \param buffer the target buffer to copy to.
	void copyTo(ofBufferObject & buffer) const;
#endif
	
	float getWidth() const;
	float getHeight() const;

	// advanced functions

	/// \brief    Bind OpenGL GL_FRAMEBUFFER target to this ofFbo
	/// \warning  If you use this method, you need to manually keep track of the
	///           currently bound framebuffer, if you ever want to restore state.
	///           * use ofBaseGLRenderer::getCurrentFramebuffer() to query the current
	///           framebuffer binding state within the renderer.
	///           * Better, use the renderer's explicit method:
	///           ofBaseGLRenderer::bind(const ofFbo & fbo) to bind the fbo, to allow
	///           the renderer to keep track of any bound fbos.
	/// \sa       unbind()
	/// \sa       virtual void ofBaseGLRenderer::bind(const ofFbo & fbo)
	void bind() const;

	/// \brief    Unbinds OpenGL framebuffer target and restores the OpenGL framebuffer 
	///           render target to whatever this ofFbo stores in previousFramebufferBinding.
	/// \sa       bind()
	/// \sa       void setPreviousFramebufferBinding(const GLuint& previousFramebufferBinding_) const
	void unbind() const;

	void flagDirty() const; ///< check whether attached MSAA buffers need updating

	/// \brief    Explicityl resolve MSAA render buffers into textures 
	/// \note     if using MSAA, we will have rendered into a colorbuffer, not directly 
	///           into the texture call this to blit from the colorbuffer into the texture 
	///           so we can use the results for rendering, or input to a shader etc.
	/// \note     This will get called implicitly upon getTexture();
	void updateTexture(int attachmentPoint);

	bool checkStatus() const;
	void createAndAttachTexture(GLenum internalFormat, GLenum attachmentPoint);
    void attachTexture(ofTexture & texture, GLenum internalFormat, GLenum attachmentPoint);
	GLuint createAndAttachRenderbuffer(GLenum internalFormat, GLenum attachmentPoint);
	void createAndAttachDepthStencilTexture(GLenum target, GLint internalformat, GLenum attachment );
	void createAndAttachDepthStencilTexture(GLenum target, GLint internalformat, GLenum attachment, GLenum transferFormat, GLenum transferType );
	
	int	getNumTextures() const;

	void setActiveDrawBuffer(int i);
	void setActiveDrawBuffers(const std::vector<int>& i);
	void activateAllDrawBuffers();

	OF_DEPRECATED_MSG("Use getId()", GLuint getFbo() const);

	/// returns id of the underlying GL object for advanced actions
	GLuint getId() const;

	/// returns id of Fbo for texture attachments
	/// which is different when the fbo is using MSAA
	GLuint getIdDrawBuffer() const;

	static bool	checkGLSupport();
	static int maxColorAttachments();	// return max color attachments
	static int maxDrawBuffers();		// return max simultaneous draw buffers
	static int maxSamples();			// return max MSAA samples

	GLuint getDepthBuffer() const { return depthBuffer; }
	GLuint getStencilBuffer() const { return stencilBuffer; }

private:
	ofFboSettings settings;

	GLuint				fbo;			// main fbo which we bind for drawing into, all renderbuffers are attached to this
	GLuint				fboTextures;	// textures are attached to this (if MSAA is disabled, this is equal to fbo, otherwise it's a new fbo)
	GLuint				depthBuffer;
	GLuint				stencilBuffer;

	std::vector<GLuint>		colorBuffers;
	std::vector<ofTexture>	textures;			

	ofTexture			depthBufferTex;

	static int			_maxColorAttachments;
	static int			_maxDrawBuffers;
	static int			_maxSamples;

	std::vector<GLenum>		activeDrawBuffers;  ///< table of currently active color draw buffers, allocate() defaults it to size(textures), with GL_COLOR_ATTACHMENT0..n as members, in order of allocation

	/// \brief  Flags used internally to keep track of MSAA renderbuffers / textures
	/// \note   The dirty flags are only used when dealing if the framebuffer has MSAA 
	///         enabled attachments, i.e. numSamples is > 0 and extra Textures have
	///         been bound so that the multisampled renderbuffers can be resolved to 
	///         textures.
	///         The flags are read whenever an attached texture is accessed. If the texture
	///         is dirty, i.e. it has not yet been resolved from its associated renderbuffer
	///         the texture will be resolved through blitting the renderbuffer into it.
	mutable std::vector<bool> dirty;

	int 				defaultTextureIndex; //used for getTextureReference
	bool				bIsAllocated;
	void reloadFbo();
#ifdef TARGET_OPENGLES
	static bool bglFunctionsInitialized;
#endif

};



#line 0 "../libs/openFrameworks/sound/ofSoundBuffer.h"
/*
 * ofSoundBuffer.h
 *
 *  Created on: 25/07/2012
 *      Author: arturo
 */

#ifndef OFSOUNDBUFFER_H_
#define OFSOUNDBUFFER_H_

/* #include "ofConstants.h" */


/*! 
 
 @brief Buffer for audio samples and associated metadata.
 
 ofSoundBuffer stores audio as an array of interleaved floating point samples, with a given sample rate for playback.

 #### How sound recording works
 
 Physically speaking, what we call _sound_ is simply changes in air pressure perceived by a listener. These changes in sound pressure are converted 
 by a microphone into changes in voltage that can be recorded, making a _sound recording_. A sound recording is therefore a recording of changes in air 
 pressure at a particular point in space (ie where the microphone was positioned). When it is played back through a speaker, the speaker reproduces the 
 same pattern of changes in air pressure as were recorded by the microphone, but this time at a different point in space (ie where the speaker is positioned).

 In digital audio these changes in air pressure are recorded as a set of discrete numbers (_samples_), each number representing a snapshot of the air pressure
 at a particular point in time. For high quality audio there are typically 44,100 snapshots recorded every second. This is called the _sample rate_ and is 
 expressed in _Hz_ (44100Hz) or _kHz_ (44.1kHz).
 
 Because humans have two ears, rather than one, sound is usually recorded in stereo. The simplest stereo sound recording is two _channels_ of sound 
 recorded by two microphones at two different points in space. More channels can also be recorded (eg with 5.1 surround sound systems or Ambisonics).
 
 
 #### Frames, channels and samples
 
 Data in an ofSoundBuffer is stored _interleaved_ as an array of floats. Interleaved audio is analogous to how different color channels are stored side by side 
 in an ofImage or ofPixels object. 
 
 The functions and function arguments in ofSoundBuffer that deal with this interleaved data are based on 3 key terms:

 _channels_ refers to the number of channels or individual streams of interleaved audio samples in the buffer. A mono recording has 1 channel, a stereo 
 recording has 2 channels.
 
 _samples_ refers to the actual raw data. One _sample_ is a single floating point number between -1 and 1, which represents a snapshot of sound pressure at 
 a single moment in time. A 0.1 second long buffer at 44100Hz contains 4410 _samples_ if it has 1 channel, 8820 _samples_ if it has 2 channels, 13230 
 _samples_ if it has 3 channels, and so on.
 
 _frames_ refers to the number of multi-channel sets of interleaved sample data there are in the buffer. A 0.1 second long buffer at 44100Hz always has 
 4410 _frames_, regardless of how many channels it has. To get the number of _samples_ in a buffer you multiply the number of _channels_ by the number of _frames_.
  

 If I have an ofSoundBuffer with 8 _frames_ of mono (1 _channel_) audio, the underlying array contains 8 _samples_ (ie it is 8 floats long),
 and the samples are arranged like this:
 
		 L L L L L L L L 
 
 where `L` represents a single sample.
 
 
 If I have an ofSoundBuffer with 8 _frames_ of stereo (2 _channel_) audio, then the underlying array contains 16 _samples_ ((getNumFrames()*getNumChannels(), 
 ie 8*2) arranged in an _interleaved_ pattern:
 
         L R L R L R L R L R L R L R L R

 where `L` represents a single sample for the left channel, and `R` represents a single sample for the right channel. Grouping the frames together for clarity:
 
		 LR LR LR LR LR LR LR LR
 
 
 If I have an ofSoundBuffer with 8 frames of 5.1 surround (6 _channel_) audio, then the underlying array of floats contains 48 _samples_ (getNumFrames()*getNumChannels(), 
 ie 8*6) and is usually arranged in an _interleaved_ pattern like this:
 
         L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe L C R Ls Rs Lfe 
 
 where `L` represents a single sample for the left channel, `C` for centre, `R` for right, `Ls` for left surround, `Rs` for right surround and `Lfe` for the subwoofer. 
 Grouping the frames together for clarity:

		 LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe LCRLsRsLfe 

 */


class ofSoundBuffer {
public:
	ofSoundBuffer();
	ofSoundBuffer(short * shortBuffer, std::size_t numFrames, std::size_t numChannels, unsigned int sampleRate);

	enum InterpolationAlgorithm{
		Linear,
		Hermite
	};
	static InterpolationAlgorithm defaultAlgorithm;  //defaults to Linear for mobile, Hermite for desktop

	void allocate(size_t numSamples, size_t numChannels);

	/// sample rate of the audio in this buffer
	unsigned int getSampleRate() const { return samplerate; }
	void setSampleRate(unsigned int rate);
	/// resample by changing the playback speed, keeping the same sampleRate
	void resample(float speed, InterpolationAlgorithm algorithm=defaultAlgorithm);
	/// the number of channels per frame
	std::size_t getNumChannels() const { return channels; }
	/// set the number of channels. does not change the underlying data, ie causes getNumFrames() to return a different result.
	void setNumChannels(int channels);
	/// the number of frames, ie the number of sets of (getNumChannels()) samples
	std::size_t getNumFrames() const { return size()/getNumChannels(); }
	
	/// return the tickCount that was assigned by ofSoundStream (if this buffer originated from an ofSoundStream).
	uint64_t getTickCount() const { return tickCount; }
	void setTickCount(uint64_t tick){ tickCount = tick; }
	
	/// return the duration of audio in this buffer in milliseconds (==(getNumFrames()/getSampleRate())*1000)
	uint64_t getDurationMS() const;
	uint64_t getDurationMicros() const;
	uint64_t getDurationNanos() const;
	
	/// return the ID of the device which generated this buffer
	int getDeviceID() const { return soundStreamDeviceID; }
	void setDeviceID(int id){ soundStreamDeviceID = id; }

	/// access the sample at the given position in the buffer.
	/// to retrieve the sample for channel channelIndex of frame frameIndex, do the following:
	/// ofSoundBuffer myBuffer;
	/// ...
	/// float sample = myBuffer[(frameIndex*myBuffer.getNumChannels()) + channelIndex];
	float & operator[](std::size_t samplePos);
	const float & operator[](std::size_t samplePos) const;
	
	/// access the sample at frameIndex on a soecific channel
	float & getSample(std::size_t frameIndex, std::size_t channel);
	const float & getSample(std::size_t frameIndex, std::size_t channel) const;

	/// return a new buffer containing the contents of this buffer multiplied by value.
	ofSoundBuffer operator*(float value);
	/// multiply everything in this buffer by value, in-place.
	ofSoundBuffer & operator*=(float value);

	/// assuming a 2-channel buffer, apply a stereo pan by multiplying channel 0 by left and channel 1 by right.
	void stereoPan(float left, float right);

	/// copy length samples from shortBuffer and interpret as interleaved with the given number of channels at the given samplerate
	void copyFrom(const short * shortBuffer, std::size_t numFrames, std::size_t numChannels, unsigned int sampleRate);

	void copyFrom(const float * floatBuffer, std::size_t numFrames, std::size_t numChannels, unsigned int sampleRate);

	void copyFrom(const std::vector<short> & shortBuffer, std::size_t numChannels, unsigned int sampleRate);
	
	void copyFrom(const std::vector<float> & floatBuffer, std::size_t numChannels, unsigned int sampleRate);

	void toShortPCM(std::vector<short> & dst) const;
	void toShortPCM(short * dst) const;

	/// resize outBuffer to outNumFrames with outNumChannels, and then copy outNumFrames of data from us to outBuffer.
	/// fromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled outBuffer.
	/// if outBuffer has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.
	/// if outBuffer has more channels than our buffer, loop through our channels repeatedly until done. 
	void copyTo(ofSoundBuffer & outBuffer, std::size_t outNumFrames, std::size_t outNumChannels, std::size_t fromFrame, bool loop = false) const;
	/// as copyTo but mixes source audio with audio in `outBuffer` by adding samples together (+), instead of overwriting.
	void addTo(ofSoundBuffer & outBuffer, std::size_t outNumFrames, std::size_t outNumChannels, std::size_t fromFrame, bool loop = false) const;

	/// as copyTo above but reads outNumFrames and outNumChannels from outBuffer
	void copyTo(ofSoundBuffer & outBuffer, std::size_t frameFrame = 0, bool loop = false) const;
	/// as addTo above but reads outNumFrames and outNumChannels from outBuffer
	void addTo(ofSoundBuffer & outBuffer, std::size_t fromFrame = 0, bool loop = false) const;

	void append(ofSoundBuffer & other);

	/// copy sample data to out, where out is already allocated to match outNumFrames and outNumChannels (ie outNumFrames*outNumChannels samples).
	/// fromFrame is a frame offset. if we don't have enough source data, loop with fromFrame=0 until we have filled the out buffer.
	/// if out has fewer channels than our buffer, just copy the first outNumChannels of our data and skip the rest.
	/// if out has more channels than our buffer, loop through our channels repeatedly until done.
	void copyTo(float * outBuffer, std::size_t outNumFrames, std::size_t outNumChannels, std::size_t fromFrame, bool loop = false) const;
	/// as copyTo but mixes source audio with audio in `out` by adding samples together (+), instead of overwriting
	void addTo(float * outBuffer, std::size_t outNumFrames, std::size_t outNumChannels, std::size_t fromFrame, bool loop = false) const;

	/// resample our data to outBuffer at the given target speed, starting at fromFrame and copying numFrames of data. resize outBuffer to fit.
	/// speed is relative to current speed (ie 1.0f == no change). lower speeds will give a larger outBuffer, higher speeds a smaller outBuffer.
	void resampleTo(ofSoundBuffer & outBuffer, std::size_t fromFrame, std::size_t numFrames, float speed, bool loop = false, InterpolationAlgorithm algorithm = defaultAlgorithm) const;
	
	/// copy the requested channel of our data to outBuffer. resize outBuffer to fit.
	void getChannel(ofSoundBuffer & outBuffer, std::size_t sourceChannel) const;
	/// copy data from inBuffer to the given channel. resize ourselves to match inBuffer's getNumFrames().
	void setChannel(const ofSoundBuffer & inBuffer, std::size_t channel);
	
	float getRMSAmplitude() const;
	float getRMSAmplitudeChannel(std::size_t channel) const;
	
	void linearResampleTo(ofSoundBuffer & buffer, std::size_t fromFrame, std::size_t numFrames, float speed, bool loop) const;
	void hermiteResampleTo(ofSoundBuffer & buffer, std::size_t fromFrame, std::size_t numFrames, float speed, bool loop) const;
	
	/// fills the buffer with random noise between -amplitude and amplitude. useful for debugging.
	void fillWithNoise(float amplitude = 1.0f);
	
	/// fills the buffer with a sine wave. useful for debugging.
	float fillWithTone(float pitchHz = 440.0f, float phase = 0.0f);
	
	/// amplifies samples so that the maximum amplitude is equal to 'level'
	void normalize(float level = 1);
	
	/// removes initial / ending silence from the buffer
	bool trimSilence(float threshold = 0.0001f, bool trimStart = true, bool trimEnd = true);
	
	/// return the total number of samples in this buffer (==getNumFrames()*getNumChannels())
	std::size_t size() const { return buffer.size(); }
	/// resize this buffer to exactly this many samples. it's up to you make sure samples matches the channel count.
	void resize(std::size_t numSamples, float val = float());
	/// remove all samples, preserving channel count and sample rate.
	void clear();
	/// swap the contents of this buffer with otherBuffer
	void swap(ofSoundBuffer & otherBuffer);
	/// set everything in this buffer to value, preserving size, channel count and sample rate.
	void set(float value);
	
	/// return the underlying buffer. careful!
	std::vector<float> & getBuffer();
	const std::vector<float> & getBuffer() const;

protected:

	// checks that size() and number of channels are consistent, logs a warning if not. returns consistency check result.
	bool checkSizeAndChannelsConsistency(const std::string& function="" );

	std::vector<float> buffer;
	std::size_t channels;
	unsigned int samplerate;

	uint64_t tickCount;
	int soundStreamDeviceID;
};

namespace std{
	void swap(ofSoundBuffer & src, ofSoundBuffer & dst);
}

#endif /* OFSOUNDBUFFER_H_ */

#line 0 "../libs/openFrameworks/sound/ofSoundUtils.h"
/*
 * ofSoundUtils.h
 *
 *  Created on: 30/07/2012
 *      Author: arturo
 */

#ifndef OFSOUNDUTILS_H_
#define OFSOUNDUTILS_H_

/* #include "ofMath.h" */
/* #include "ofSoundBuffer.h" */

inline void ofStereoVolumes(float volume, float pan, float & left, float & right){
	pan = ofClamp(pan, -1, 1);
	// calculates left/right volumes from pan-value (constant panning law)
	// see: Curtis Roads: Computer Music Tutorial p 460
	// thanks to jasch
	float angle = pan * 0.7853981633974483f; // in radians from -45. to +45.
	float cosAngle = cos(angle);
	float sinAngle = sin(angle);
	left  = (cosAngle - sinAngle) * 0.7071067811865475 * volume; // multiplied by sqrt(2)/2
	right = (cosAngle + sinAngle) * 0.7071067811865475 * volume; // multiplied by sqrt(2)/2
}

#endif /* OFSOUNDUTILS_H_ */

#line 0 "../libs/openFrameworks/sound/ofQtSoundPlayer.h"
#pragma once

/* #include "ofConstants.h" */

#ifdef OF_SOUND_PLAYER_QT
/* #include "ofSoundBaseTypes.h" */
/* #include "ofFileUtils.h" */


// ---------------------------------------------------------------------------- SOUND SYSTEM Qt

// --------------------- global functions:
void ofQtSoundStopAll();
void ofQtSoundSetVolume(float vol);
void ofQtSoundUpdate();
float * ofQtSoundGetSpectrum(int nBands);
void ofQtSetBuffersize(unsigned int bs);


// --------------------- player functions:
class ofQtSoundPlayer : public ofBaseSoundPlayer {

	public:

		ofQtSoundPlayer();
		virtual ~ofQtSoundPlayer();

		bool load(const std::filesystem::path& fileName, bool stream = false);
		void unload();
		void play();
		void stop();

		void setVolume(float vol);
		void setPan(float vol);
		void setSpeed(float spd);
		void setPaused(bool bP);
		void setLoop(bool bLp);
		void setMultiPlay(bool bMp);
		void setPosition(float pct); // 0 = start, 1 = end;
		void setPositionMS(int ms);

		float getPosition() const;
		int getPositionMS() const;
		bool isPlaying() const;
		float getSpeed() const;
		float getPan() const;
		float getVolume() const;
		bool isLoaded() const;

		static void initializeQt();
		static void closeQt();
	
		bool isStreaming;
		bool bMultiPlay;
		bool bLoop;
		bool bLoadedOk;
		bool bPaused;
		float pan; // -1 to 1
		float volume; // 0 - 1
		float internalFreq; // 44100 ?
		float speed; // -n to n, 1 = normal, -1 backwards
		unsigned int length; // in samples;
};

#endif // OF_SOUND_PLAYER_QT

#line 0 "../libs/openFrameworks/sound/ofSoundPlayer.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofSoundBaseTypes.h" */

/// \brief Stops all active sound players on FMOD-based systems (windows, osx).
void ofSoundStopAll();

/// \brief Cleans up FMOD (windows, osx).
void ofSoundShutdown();

/// \brief Sets global volume for FMOD-based sound players (windows, osx).
/// \param vol range is 0 to 1.
void ofSoundSetVolume(float vol);

/// \brief Call in your app's update() to update FMOD-based sound players.
void ofSoundUpdate();

/// \brief Gets a frequency spectrum sample, taking all current sound players into account.
///
/// Each band will be represented as a float between 0 and 1.
///
/// \warning This isn't implemented on mobile & embedded platforms.
/// \param nBands number of spectrum bands to return, max 512.
/// \return pointer to an FFT sample, sample size is equal to the nBands parameter.
float * ofSoundGetSpectrum(int nBands);



#ifdef OF_SOUND_PLAYER_QUICKTIME
#include "ofQuicktimeSoundPlayer.h"
#define OF_SOUND_PLAYER_TYPE ofQuicktimeSoundPlayer
#endif

#ifdef OF_SOUND_PLAYER_FMOD
#include "ofFmodSoundPlayer.h"
#define OF_SOUND_PLAYER_TYPE ofFmodSoundPlayer
#endif

#ifdef OF_SOUND_PLAYER_OPENAL
#include "ofOpenALSoundPlayer.h"
#define OF_SOUND_PLAYER_TYPE ofOpenALSoundPlayer
#endif

#ifdef TARGET_OF_IOS
#include "ofxiOSSoundPlayer.h"
#define OF_SOUND_PLAYER_TYPE ofxiOSSoundPlayer
#endif

#ifdef TARGET_ANDROID
#include "ofxAndroidSoundPlayer.h"
#define OF_SOUND_PLAYER_TYPE ofxAndroidSoundPlayer
inline void ofSoundShutdown(){}
#endif

#ifdef OF_SOUND_PLAYER_EMSCRIPTEN
#include "ofxEmscriptenSoundPlayer.h"
#define OF_SOUND_PLAYER_TYPE ofxEmscriptenSoundPlayer
#endif

#ifdef QT_MULTIMEDIA_LIB
/* #include "ofQtSoundPlayer.h" */
#define OF_SOUND_PLAYER_TYPE ofQtSoundPlayer
#endif


#ifdef TARGET_LINUX_ARM
inline void ofSoundShutdown(){}
#endif

/// \class ofSoundPlayer
/// \brief Plays sound files.
///
/// ofSoundPlayer handles simple playback of sound files, with controls for
/// volume, pan, speed, seeking and multiplay.  This is a common cross-platform
/// sound player interface which is inherited by each of the platform-specific
/// sound player implementations.
class ofSoundPlayer : public ofBaseSoundPlayer {
public:
    ofSoundPlayer();

    void setPlayer(std::shared_ptr<ofBaseSoundPlayer> newPlayer);
    std::shared_ptr<ofBaseSoundPlayer> getPlayer();

    /// \brief Tells the sound player which file to play.
    ///
    /// Codec support varies by platform but wav, aif, and mp3 are safe.
    ///
    /// \param fileName Path to the sound file, relative to your app's data folder.
    /// \param stream set "true" to enable streaming from disk (for large files).
    bool load(const std::filesystem::path& fileName, bool stream = false);
    OF_DEPRECATED_MSG("Use load",bool loadSound(std::string fileName, bool stream = false));

    /// \brief Stops and unloads the current sound.
    void unload();
    OF_DEPRECATED_MSG("Use load",void unloadSound());
    
    /// \brief Starts playback.
    void play();

    /// \brief Stops playback.
    void stop();

    /// \brief Sets playback volume.
    /// \param vol range is 0 to 1.
    void setVolume(float vol);

    /// \brief Sets stereo pan.
    /// \param pan range is -1 to 1 (-1 is full left, 1 is full right).
    void setPan(float pan);

    /// \brief Sets playback speed.
    /// \param speed set > 1 for faster playback, < 1 for slower playback.
    void setSpeed(float speed);

    /// \brief Enables pause / resume.
    /// \param paused "true" to pause, "false" to resume.
    void setPaused(bool paused);

    /// \brief Sets whether to loop once the end of the file is reached.
    /// \param loop "true" to loop, default is false.
    void setLoop(bool loop);
    
    /// \brief Enables playing multiple simultaneous copies of the sound.
    /// \param multiplay "true" to enable, default is false.
    void setMultiPlay(bool multiplay);

    /// \brief Sets position of the playhead within the file (aka "seeking").
    /// \param percent range is 0 (beginning of file) to 1 (end of file).
    void setPosition(float percent);
    
    /// \brief Sets position of the playhead within the file (aka "seeking").
    /// \param ms number of milliseconds from the start of the file.
    void setPositionMS(int ms);

    /// \brief Gets position of the playhead.
    /// \return playhead position in milliseconds.
    int getPositionMS() const;

    /// \brief Gets position of the playhead.
    /// \return playhead position as a float between 0 and 1.
    float getPosition() const;

    /// \brief Gets current playback state.
    /// \return true if the player is currently playing a file.
    bool isPlaying() const;
    OF_DEPRECATED_MSG("Use isPlaying",bool getIsPlaying() const);

    /// \brief Gets playback speed.
    /// \return playback speed (see ofSoundPlayer::setSpeed()).
    float getSpeed() const;
    
    /// \brief Gets stereo pan.
    /// \return stereo pan in the range -1 to 1.
    float getPan() const;

    /// \brief Gets current volume.
    /// \return current volume in the range 0 to 1.
    float getVolume() const;

    /// \brief Queries the player to see if its file was loaded successfully.
    /// \return whether or not the player is ready to begin playback.
    bool isLoaded() const;

protected:
    std::shared_ptr<ofBaseSoundPlayer> player;

};

#line 0 "../libs/openFrameworks/sound/ofSoundStream.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofBaseApp.h" */
/* #include "ofSoundBaseTypes.h" */
#include <climits>
#include <functional>


class ofSoundStreamSettings;


///// \brief Sets up and starts a global ofSoundStream.
/////
///// This will set up a sound stream with a default sample rate of 44100, a
///// buffer size of 256 samples, and a queue of 4 buffers.
/////
///// \param nOutputChannels number of requested output channels (i.e. 2 for stereo).
///// \param nInputChannels number of requested input channels.
///// \param appPtr pointer to the app which will own the sound stream (optional).
OF_DEPRECATED_MSG("Use an ofSoundStreamSettings object instead of directly passing the parameters",
	void ofSoundStreamSetup(int nOutputChannels, int nInputChannels, ofBaseApp * appPtr = nullptr));

///// \brief Sets up and starts a global ofSoundStream.
///// \param nOutputChannels number of requested output channels (i.e. 2 for stereo).
///// \param nInputChannels number of requested input channels.
///// \param sampleRate requested sample rate (44100 is typical).
///// \param bufferSize requested buffer size (256 is typical). Smaller values
/////        will be more responsive, but less stable.
///// \param nBuffers number of buffers to queue. Less buffers will be more responsive, but less stable.
OF_DEPRECATED_MSG("Use an ofSoundStreamSettings object instead of directly passing the parameters",
	void ofSoundStreamSetup(int nOutputChannels, int nInputChannels, int sampleRate, int bufferSize, int nBuffers));

///// \brief Sets up and starts a global ofSoundStream.
///// \param nOutputChannels number of requested output channels (i.e. 2 for stereo).
///// \param nInputChannels number of requested input channels.
///// \param appPtr pointer to the app which will own the sound stream (optional).
///// \param sampleRate requested sample rate (44100 is typical).
///// \param bufferSize requested buffer size (256 is typical). Smaller values
/////        will be more responsive, but less stable.
///// \param nBuffers number of buffers to queue. Less buffers will be more
/////        responsive, but less stable.
OF_DEPRECATED_MSG("Use an ofSoundStreamSettings object instead of directly passing the parameters",
	void ofSoundStreamSetup(int nOutputChannels, int nInputChannels, ofBaseApp * appPtr, int sampleRate, int bufferSize, int nBuffers));

void ofSoundStreamSetup(ofSoundStreamSettings & settings);

/// \brief Stops the sound stream (audioIn() / audioOut() will stop being called)
void ofSoundStreamStop();

/// \brief Starts the sound stream (audioIn() / audioOut() will start being called)
void ofSoundStreamStart();

/// \brief Stops the sound stream and also cleans up the stream's resources
void ofSoundStreamClose();

/// \brief Prints a list of all available audio devices
/// \return all sound devices found on the system
std::vector<ofSoundDevice> ofSoundStreamListDevices();

/// \class ofSoundStream
/// \brief Gives access to audio input and output devices
///
/// ofSoundStream controls access to your computer's audio input and output
/// devices. For example, you could use an ofSoundStream to get live input from
/// a microphone, or generate sound in realtime for your computer's speakers.
///
/// A typical openFrameworks app will use just one ofSoundStream, and you might
/// not even need to use this class directly at all if you don't need to query
/// things like the sample rate or buffer size. In order to start receiving or
/// generating audio, your ofApp should implement either ofBaseApp::audioIn() or
/// ofBaseApp::audioOut() respectively, and then call ofSoundStreamSetup(). You
/// can find examples of this in either the audioInputExample or the
/// audioOutputExample.
///
/// Starting a stream with 0 input or output channels will prevent audioIn() or
/// audioOut() from being called, respectively.
///
/// Some platforms (iOS, for example) will expose additional platform-specific
/// sound stream functionality. See the platform-specific examples for demos.
///
/// \warning Be aware that audioIn() and audioOut() will be called on a different
/// thread from your app's update() / draw() thread.
class ofSoundStream {
public:
	ofSoundStream();

	void setSoundStream(std::shared_ptr<ofBaseSoundStream> soundStreamPtr);
	std::shared_ptr<ofBaseSoundStream> getSoundStream();

	/// \brief Prints a list of available audio devices to the console
	void printDeviceList() const;

	/// \brief Retrieves a list of available audio devices
	std::vector<ofSoundDevice> getDeviceList(ofSoundDevice::Api api = ofSoundDevice::Api::DEFAULT) const;

	/// \brief Get all devices which match the arguments (name can be a partial match)
	std::vector<ofSoundDevice> getMatchingDevices(const std::string& name, unsigned int inChannels = UINT_MAX, unsigned int outChannels = UINT_MAX, ofSoundDevice::Api api = ofSoundDevice::Api::DEFAULT) const;

	/// \brief sets the device represented by the stream, see ofSoundStream::getDeviceList().
	OF_DEPRECATED_MSG("Use an ofSoundStreamSettings object instead of directly passing the parameters",
		void setDeviceID(int deviceID));

	/// \brief sets the device represented by the stream, see ofSoundStream::getDeviceList().
	OF_DEPRECATED_MSG("Use an ofSoundStreamSettings object instead of directly passing the parameters",
		void setDevice(const ofSoundDevice& device));

	bool setup(const ofSoundStreamSettings & settings);

	///// \brief Sets up and starts the stream.
	///// \param app pointer to the app which will own the sound stream.
	///// \param outChannels number of requested output channels (i.e. 2 for stereo).
	///// \param inChannels number of requested input channels.
	///// \param sampleRate requested sample rate (44100 is typical).
	///// \param bufferSize requested buffer size (256 is typical). Smaller
	/////        values will be more responsive, but less stable.
	///// \param nBuffers number of buffers to queue. Less buffers will be more
	/////        responsive, but less stable.
	///// \return true on success
	OF_DEPRECATED_MSG("Use an ofSoundStreamSettings object instead of directly passing the parameters",
		bool setup(ofBaseApp * app, int outChannels, int inChannels, int sampleRate, int bufferSize, int nBuffers));

	///// \brief Sets up and starts the stream.
	///// \param outChannels number of requested output channels (i.e. 2 for stereo).
	///// \param inChannels number of requested input channels.
	///// \param sampleRate requested sample rate (44100 is typical).
	///// \param bufferSize requested buffer size (256 is typical). Smaller values
	/////        will be more responsive, but less stable.
	///// \param nBuffers number of buffers to queue. Less buffers will be more
	/////        responsive, but less stable.
	///// \return true on success
	OF_DEPRECATED_MSG("Use an ofSoundStreamSettings object instead of directly passing the parameters",
		bool setup(int outChannels, int inChannels, int sampleRate, int bufferSize, int nBuffers));

	/// \brief Sets the object which will have audioIn() called when the device receives audio.
	void setInput(ofBaseSoundInput * soundInput);

	/// \brief Sets the object which will have audioIn() called when the device receives audio.
	void setInput(ofBaseSoundInput &soundInput);

	/// \brief Sets the object which will have audioOut() called when the device requests audio.
	void setOutput(ofBaseSoundOutput * soundOutput);

	/// \brief Sets the object which will have audioOut() called when the device requests audio.
	void setOutput(ofBaseSoundOutput &soundOutput);

	/// \brief Starts a stream (note that setup() will start the stream on its own).
	void start();

	/// \brief Stops the stream.
	void stop();

	/// \brief stops the stream and cleans up its resources.
	void close();

	/// \brief Queries the number of "ticks" passed since the stream started.
	///
	/// This is a representation of how many buffers have passed through the
	/// stream since it started. This can be converted to seconds with the
	/// following formula:
	///
	///    secondsOfPlayback = (tickCount * bufferSize) / sampleRate
	///
	/// \return number of buffers passed through the stream since it started.
	uint64_t getTickCount() const;

	/// \brief Queries the stream's number of input channels.
	/// \return the number of input channels (e.g. 2 for stereo).
	int getNumInputChannels() const;

	/// \brief Queries the stream's number of output channels.
	/// \return the number of output channels (e.g. 2 for stereo).
	int getNumOutputChannels() const;

	/// \brief Queries the stream's sample rate
	/// \return the current sample rate of the stream
	/// \note The returned sample rate may differ from the requested sample rate.
	int getSampleRate() const;

	/// \brief Queries the stream's buffer size.
	/// \return the current buffer size of the stream.
	int getBufferSize() const;

	/// \brief Retrieves a list of available audio devices and prints device descriptions to the console
	OF_DEPRECATED_MSG("Use printDeviceList instead", std::vector<ofSoundDevice> listDevices() const);

protected:
	std::shared_ptr<ofBaseSoundStream> soundStream;
	int tmpDeviceId = -1;

};


#line 0 "../libs/openFrameworks/video/ofVideoPlayer.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofTexture.h" */
/* #include "ofVideoBaseTypes.h" */

#ifdef OF_VIDEO_PLAYER_QT
	/* #include "ofQtMediaPlayer.h" */
	#define OF_VID_PLAYER_TYPE ofQtMediaPlayer
#endif

#ifdef OF_VIDEO_PLAYER_GSTREAMER
	#include "ofGstVideoPlayer.h"
	#define OF_VID_PLAYER_TYPE ofGstVideoPlayer
#endif

#ifdef OF_VIDEO_PLAYER_QUICKTIME
	#include "ofQuickTimePlayer.h"
	#define OF_VID_PLAYER_TYPE ofQuickTimePlayer
#endif

#ifdef OF_VIDEO_PLAYER_QTKIT
	#include "ofQTKitPlayer.h"
	#define OF_VID_PLAYER_TYPE ofQTKitPlayer
#endif

#ifdef OF_VIDEO_PLAYER_AVFOUNDATION
    #include "ofAVFoundationPlayer.h"
    #define OF_VID_PLAYER_TYPE ofAVFoundationPlayer
#endif

#ifdef OF_VIDEO_PLAYER_DIRECTSHOW
    #include "ofDirectShowPlayer.h"
    #define OF_VID_PLAYER_TYPE ofDirectShowPlayer
#endif

#ifdef OF_VIDEO_PLAYER_IOS
	#include "ofxiOSVideoPlayer.h"
	#define OF_VID_PLAYER_TYPE ofxiOSVideoPlayer
#endif

#ifdef OF_VIDEO_PLAYER_ANDROID
	#include "ofxAndroidVideoPlayer.h"
	#define OF_VID_PLAYER_TYPE ofxAndroidVideoPlayer
#endif

#ifdef OF_VIDEO_PLAYER_EMSCRIPTEN
	#include "ofxEmscriptenVideoPlayer.h"
	#define OF_VID_PLAYER_TYPE ofxEmscriptenVideoPlayer
#endif

//---------------------------------------------
class ofVideoPlayer : public ofBaseVideoPlayer,public ofBaseVideoDraws{

	public:

		ofVideoPlayer ();


		bool 				load(std::string name);
		void				loadAsync(std::string name);
		OF_DEPRECATED_MSG("Use load instead",bool loadMovie(std::string name));


		/// \brief Get the path to the loaded video file.
		///
		/// If no video file is loaded this returns an empty string.
		///
		/// \returns A path to the loaded video or an empty string if not loaded.
		std::string				getMoviePath() const;

		bool				setPixelFormat(ofPixelFormat pixelFormat);
		ofPixelFormat		getPixelFormat() const;

		/// \brief Closes the movie file and releases its resources.
		///
		/// This is an alias for close().
		///
		/// \sa close()
		void 				closeMovie();
		/// \brief Closes the movie file releases its resources.
		///
		/// This is an alias for closeMovie().
		///
		/// \sa closeMovie()
		void 				close();

		/// \brief Update the video player's internal state to continue playback.
		///
		/// If normal video playback is desired, this method is usually called
		/// once per animation frame inside of ofApp::update().
		void				update();
		void 				play();
		void 				stop();

		bool 				isFrameNew() const;
		ofPixels& 			getPixels();
		const ofPixels&		getPixels() const;
        OF_DEPRECATED_MSG("Use getPixels() instead", ofPixels&	getPixelsRef());
        OF_DEPRECATED_MSG("Use getPixels() instead", const ofPixels&  getPixelsRef() const);
		float 				getPosition() const;
		float 				getSpeed() const;
		float 				getDuration() const;
		bool				getIsMovieDone() const;

		void 				setPosition(float pct);
		void 				setVolume(float volume);
		void 				setLoopState(ofLoopType state);
		ofLoopType			getLoopState() const;
		void   				setSpeed(float speed);
		void				setFrame(int frame);

		void 				setUseTexture(bool bUse);
		bool 				isUsingTexture() const;
		ofTexture &			getTexture();
		const ofTexture &	getTexture() const;
		OF_DEPRECATED_MSG("Use getTexture",ofTexture &			getTextureReference());
		OF_DEPRECATED_MSG("Use getTexture",const ofTexture &	getTextureReference() const);
		std::vector<ofTexture> & getTexturePlanes();
		const std::vector<ofTexture> & getTexturePlanes() const;
		void 				draw(float x, float y, float w, float h) const;
		void 				draw(float x, float y) const;
		using ofBaseDraws::draw;
		/// \brief Binds the video texture to the current rendering context.
		///
		/// For advanced users who need to manually manage texture drawing
		/// without calling draw(). Only binds the texture if one exists.
		///
		/// \sa ofTexture::bind()
		/// \sa http://www.opengl.org/sdk/docs/man4/html/glBindTexture.xhtml
		void 				bind() const;
		/// \brief Unbinds the video texture from the current rendering context.
		///
		/// For advanced users who need to manually manage texture drawing
		/// without calling draw(). Only binds the texture if one exists.
		///
		/// \sa ofTexture::unbind()
		void 				unbind() const;

        void				setAnchorPercent(float xPct, float yPct);
        void				setAnchorPoint(float x, float y);
        void				resetAnchor();

		void 				setPaused(bool bPause);

		int					getCurrentFrame() const;
		int					getTotalNumFrames() const;

		void				firstFrame();
		void				nextFrame();
		void				previousFrame();

		float 				getHeight() const;
		float 				getWidth() const;

		bool				isPaused() const;
		bool				isLoaded() const;
		bool				isPlaying() const;
		bool 				isInitialized() const;

		/// \brief Set the internal video player implementation.
		///
		/// Advanced users may find it useful to set a custom internal video
		/// player implementation. The custom video player must implment the
		/// ofBaseVideoPlayer interface.
		///
		/// \param newPlayer Shared pointer to the new video player that extends
		/// from ofBaseVideoPlayer.
		void				setPlayer(std::shared_ptr<ofBaseVideoPlayer> newPlayer);
		/// \brief Get a pointer to the internal video player implementation.
		///
		/// This returns a pointer to the ofBaseVideoPlayer interface. For
		/// implementation-specfic features, this can be cast to the subtype
		/// using dynamic_cast<MyVideoPlayerImplementation>(getPlayer()) or the
		/// templated getPlayer<MyVideoPlayerImplementation>() method.
		///
		/// \returns A pointer to the internal video player implementation.
		std::shared_ptr<ofBaseVideoPlayer>	getPlayer();
		/// \brief Get a const pointer to the internal video player implementation.
		///
		/// This returns a pointer to the ofBaseVideoPlayer interface. For
		/// implementation-specfic features, this can be cast to the subtype
		/// using dynamic_pointer_cast<MyVideoPlayerImplementation>(getPlayer())
		/// or the templated getPlayer<MyVideoPlayerImplementation>() method.
		///
		/// \returns A const pointer to the internal video player implementation.
		const std::shared_ptr<ofBaseVideoPlayer>	getPlayer() const;

		/// \brief Get a pointer to the internal video player implementation.
		///
		/// Calling getPlayer<MyVideoPlayerImplementation>() is equivalent to
		/// dynamic_pointer_cast<MyVideoPlayerImplementation>(getPlayer()).
		///
		/// \returns A pointer to the internal video player implementation or
		///			 nullptr if the cast fails.
		template<typename PlayerType>
		std::shared_ptr<PlayerType> getPlayer(){
			return std::dynamic_pointer_cast<PlayerType>(getPlayer());
		}

		/// \brief Get a const pointer to the internal video player implementation.
		///
		/// Calling getPlayer<MyVideoPlayerImplementation>() is equivalent to
		/// dynamic_pointer_cast<MyVideoPlayerImplementation>(getPlayer()).
		///
		/// \returns A const pointer to the internal video player implementation
		///			 or nullptr if the cast fails.
		template<typename PlayerType>
		const std::shared_ptr<PlayerType> getPlayer() const{
			return std::dynamic_pointer_cast<PlayerType>(getPlayer());
		}

	private:
		/// \brief Initialize the default player implementations.
		void initDefaultPlayer();
		/// \brief A pointer to the internal video player implementation.
		std::shared_ptr<ofBaseVideoPlayer>		player;
		/// \brief A collection of texture planes used by the video player.
		std::vector<ofTexture> tex;
		/// \brief A pointer to the internal player's texture if available.
		///
		/// Video players that implement ofBaseVideoPlayer::getTexturePtr()
		/// can provide a pointer to an internal texture. When possible,
		/// ofVideoPlayer will use the internal texture to avoid extra pixel
		/// copies.
		ofTexture * playerTex;
		/// \brief True if the video player is using a texture.
		bool bUseTexture;
		/// \brief The internal pixel format.
		mutable ofPixelFormat internalPixelFormat;
		/// \brief The stored path to the video's path.
		std::string moviePath;
};

#line 0 "../libs/openFrameworks/video/ofQtMediaPlayer.h"

#pragma once 

/* #include "ofVideoPlayer.h" */

class QMediaPlayer;
class QMediaPlaylist;
class QtFrameGrabber;

class ofQtMediaPlayer : public ofBaseVideoPlayer{
    public:
		ofQtMediaPlayer();
		~ofQtMediaPlayer();
		ofQtMediaPlayer(const ofQtMediaPlayer&) = delete;
		ofQtMediaPlayer & operator=(const ofQtMediaPlayer&) = delete;
		ofQtMediaPlayer(ofQtMediaPlayer &&);
		ofQtMediaPlayer & operator=(ofQtMediaPlayer&&);

        bool                load(std::string path);
        void                update();

        void                close();
    
        void                play();
        void                stop();     
    
        bool                isFrameNew() const;

        const ofPixels &    getPixels() const;
        ofPixels &          getPixels();
    
        float               getWidth() const;
        float               getHeight() const;
    
        bool                isPaused() const;
        bool                isLoaded() const;
        bool                isPlaying() const;
    
        bool                setPixelFormat(ofPixelFormat pixelFormat);
        ofPixelFormat       getPixelFormat() const;

        float               getPosition() const;
        float               getSpeed() const;
        float               getDuration() const;
        bool                getIsMovieDone() const;
    
        void                setPaused(bool bPause);
        void                setPosition(float pct);
        void                setVolume(float volume); // 0..1
        void                setLoopState(ofLoopType state);
        bool                isLooping() const;
        void                setSpeed(float speed);
        void                setFrame(int frame);  // frame 0 = first frame...
    
        int                 getCurrentFrame() const;
        int                 getTotalNumFrames() const;
        ofLoopType          getLoopState() const;
    
        qreal               videoFrameRate();
        void                firstFrame();
        void                nextFrame();
        void                previousFrame();

    protected:
        QMediaPlayer  *player;
        QMediaPlaylist *playlist;
        QtFrameGrabber *frameGrabber;
};

#line 0 "../libs/openFrameworks/app/ofIcon.h"
/* GIMP RGBA C-Source image dump 1-byte-run-length-encoded (icon.c) */
#pragma once

#define GIMP_IMAGE_RUN_LENGTH_DECODE(image_buf, rle_data, size, bpp) do \
{ unsigned int __bpp; unsigned char *__ip; const unsigned char *__il, *__rd; \
  __bpp = (bpp); __ip = (image_buf); __il = __ip + (size) * __bpp; \
  __rd = (rle_data); if (__bpp > 3) { /* RGBA */ \
    while (__ip < __il) { unsigned int __l = *(__rd++); \
      if (__l & 128) { __l = __l - 128; \
        do { memcpy (__ip, __rd, 4); __ip += 4; } while (--__l); __rd += 4; \
      } else { __l *= 4; memcpy (__ip, __rd, __l); \
               __ip += __l; __rd += __l; } } \
  } else { /* RGB */ \
    while (__ip < __il) { unsigned int __l = *(__rd++); \
      if (__l & 128) { __l = __l - 128; \
        do { memcpy (__ip, __rd, 3); __ip += 3; } while (--__l); __rd += 3; \
      } else { __l *= 3; memcpy (__ip, __rd, __l); \
               __ip += __l; __rd += __l; } } \
  } } while (0)
static const struct{
  unsigned int 	 width;
  unsigned int 	 height;
  unsigned int 	 bytes_per_pixel; /* 3:RGB, 4:RGBA */ 
  unsigned char	 rle_pixel_data[63984 + 1];
} ofIcon = {
	128, 128, 4,
	  "\31\20\21\20\376\30\34\34\3769=@\376KOS\376\15\17\17\376\30\33\35\376\14"
	  "\15\15\376\13\15\15\376\16\17\17\376\16\21\21\37618<\376.03\376\37\"#\376"
	  "\22\24\24\37636:\376\32\33\34\376\21\22\21\376*-0\376\34\35\36\376\15\15"
	  "\15\376`dj\376135\376\24\25\25\376#%'\376\31\32\33\376\202\31\33\35\3765"
	  "\24\27\27\376\23\25\25\376\37\"$\376#%'\376\10\12\11\376\21\23\24\376\35"
	  "\40\"\376\12\13\13\376\21\23\24\376\20\22\23\376\25\27\30\376\27\31\33\376"
	  "#&(\376\21\22\23\376\33\35\36\376\24\25\27\376\17\21\22\376\20\22\22\376"
	  "\23\26\26\376)-0\376.02\376\36\"#\376,03\376\17\21\21\376\14\16\16\376\13"
	  "\15\15\376\34\40!\376\17\21\22\376\20\22\23\376\22\24\26\376\23\25\27\376"
	  "\17\21\22\376\37#$\376,.0\376\23\25\26\376,02\37636:\376/35\376\24\24\25"
	  "\376\26\30\32\376\25\27\30\376!#%\376\24\25\25\376\30\33\34\376\40#%\376"
	  "\21\23\23\376\27\32\33\376\36\40\"\376\31\34\36\376\34\37!\376\15\16\17\376"
	  "\13\14\15\376\14\15\16\376\202\23\25\26\376\177+.1\376>@D\376'*-\376\"&("
	  "\376\13\13\14\376\31\34\37\376,/3\376\32\34\36\376\33\36\40\376\"&(\376!"
	  "$&\376\13\14\14\376\22\24\26\376?CH\376ru}\376\24\25\26\376\36!$\376\34\37"
	  "!\376\12\15\13\376\22\31\30\376\16\17\20\376\17\20\21\376\17\21\22\376\37"
	  "!$\376\21\22\23\376;>B\376249\376\31\33\35\376-/3\376\30\31\34\376\10\11"
	  "\11\376\40$&\376'*-\376EFL\376\12\12\13\376\20\21\22\3768;?\376\35\40#\376"
	  ":?C\376'*-\376\15\16\17\376\22\23\24\376\30\33\35\376\32\35\37\376\40$&\376"
	  "%(+\376,04\376\35\35\37\377#'(\377\32\34\35\377\33\36\40\377&(*\377\24\30"
	  "\30\377\16\17\17\377\13\14\14\377125\377%(+\377\32\34\35\377bgl\377\12\14"
	  "\13\377\37%'\377\16\16\15\377\16\17\17\377\34\40!\377\21\21\22\377\24\27"
	  "\30\377\"&'\377%&'\3776<?\377/12\377\15\16\15\377\36!\"\377&),\377\16\17"
	  "\17\377\17\21\21\377\35\37\"\377\16\21\22\377\27\31\33\377\21\22\22\377\23"
	  "\26\30\377\22\24\26\377\15\16\17\377\33\37!\377BEH\377\10\12\12\377\12\13"
	  "\13\377\26\30\32\37727:\377\23\25\25\377\13\14\14\377\15\16\16\377\"%(\377"
	  "-24\377\230\233\240\377\13\14\13\377\35!#\377\12\13\14\377\16\17\17\377\15"
	  "\17\17\377&+.\377\27\31\32\377\17\20\20\377\16\20\21\377\13\15\15\377(+."
	  "\377-14\377\15\14\14\377\23\25\26\3778=A\377$(*\377EHL\377\36\36\37\377\21"
	  "\24\25\377\25\31\31\377\15\17\17\377\31\34\35\377\34\37!\377*-1\377\20\21"
	  "\21\377\16\20\20\377\32\36\37\377347\377=CH\377\14\14\15\377\13\14\13\377"
	  "\15\15\16\377\26\30\33\377\177\16\17\20\377&'*\377W\\a\377.04\377\36\37\""
	  "\377\14\15\15\377\32\35!\377\12\13\13\377\40#$\377$(*\377\27\31\33\377\35"
	  "\37\"\377\14\15\15\377\24\27\31\377'+0\377\36\40\"\377\15\16\17\377+.2\377"
	  "\26\31\33\377137\377\6\15\10\377\26\27\30\377\21\23\25\377\14\15\16\377\12"
	  "\13\14\377?BE\377\24\26\30\377\16\17\20\377GMS\377\11\12\11\377\34\36!\377"
	  "\27\30\32\377\34\35\40\3779>B\377\13\14\15\377\13\16\17\377\10\11\11\377"
	  "8=@\377\21\24\25\377#')\377\"&)\377(*-\377\27\31\32\377!#&\377\13\14\14\377"
	  ")-0\377359\377\31\33\34\376\30\33\35\377\20\23\23\377),.\377\40$%\377\36"
	  "\40!\377\20\22\23\377\16\20\21\377\14\17\17\377$'*\377\34\35\36\377\35\36"
	  "\37\377\26\31\32\377\24\27\27\377\17\17\15\377.45\377\24\24\24\377\21\20"
	  "\17\3775:=\377\33\36\40\377\16\17\17\377\22\23\23\377-25\377#%'\377\40!\""
	  "\377\15\15\15\377\27\32\35\377\27\32\32\377\24\26\27\377\10\11\10\377\"%"
	  "&\377359\377\22\24\24\377\15\16\15\377\16\20\21\377\21\23\24\377$)-\377>"
	  "AF\377\7\11\11\377\11\12\12\377\24\27\30\377tz\201\377\14\16\16\377\17\22"
	  "\22\377\14\15\15\377NTX\377\32\36!\377MPU\377\16\17\17\377\13\13\13\377\15"
	  "\20\21\377\13\14\15\377\36!$\377!\"$\377!$&\377\25\26\27\377\12\14\14\377"
	  "\30\31\32\3778;@\377\22\24\26\377\20\22\22\377\17\20\21\377FKO\377RVZ\377"
	  "*/1\377&(+\377\21\22\23\377\14\16\17\377\27\31\31\377\32\34\35\377\30\31"
	  "\32\377\31\34\35\377+.2\377\31\32\33\377\27\27\27\377\30\33\35\377\33\35"
	  "\40\377\20\21\21\377\12\12\13\377\15\15\15\377Q\13\14\14\377\36\"$\37726"
	  "9\377\30\32\33\3776:?\377\30\30\32\377\"&(\377\17\21\23\377\30\33\35\377"
	  "\12\13\13\377)-/\377\23\23\25\377\15\16\17\377NSV\3779<?\377\37\"%\377\20"
	  "\21\23\377\23\27\31\377\21\24\26\377!$&\377\17\20\22\377\13\24\21\377\11"
	  "\14\15\377\30\34\36\377\12\12\13\377\31\34\36\377!$'\377DHK\377%'*\377\30"
	  "\32\34\377\22\22\24\377\11\11\11\377<?C\377BGL\377\11\11\11\377\13\16\16"
	  "\377\17\21\22\377\14\17\20\377\15\16\17\377\22\26\27\377\34\40\"\377\34\36"
	  "\40\377JMS\377048\377\33\34\36\377\24\24\26\377\22\24\25\377DJO\377\30\32"
	  "\33\376\21\23\22\377\40$&\377\31\34\36\377\17\17\17\3778>C\377\16\17\20\377"
	  "\24\25\26\3778=A\377\16\20\17\377\20\22\23\377\32\35\37\377\40\"$\377\23"
	  "\22\21\377KQT\377225\377\20\20\17\377\30\31\32\377BGL\377\27\27\30\377\32"
	  "\36\36\377/25\377\20\22\21\377KPT\377\23\25\26\377\22\23\24\377\17\22\22"
	  "\377GLQ\377\20\21\22\377\16\17\20\377\14\20\20\377\22\24\26\377\30\34\35"
	  "\377\202\20\23\24\377\177/27\377\12\14\14\377\16\20\21\377\10\11\10\377\20"
	  "\22\23\377\12\14\14\377+03\377\37!#\377\14\16\17\377\17\23\23\377\40#%\377"
	  "\16\22\24\377\30\33\36\377\21\22\23\377\24\30\32\377\23\24\25\377\32\35\37"
	  "\377\21\22\23\377*.2\377\16\20\21\377\23\26\30\377\13\14\15\377\31\32\34"
	  "\377\16\17\20\377\35\37\"\377*.0\3778<?\377\21\21\22\377]ch\377036\377\15"
	  "\17\17\377\14\14\13\3775:<\377>@D\377\17\21\22\377\20\22\22\377\"%(\3779"
	  "=A\377%')\377$'*\377\14\15\15\377\16\16\16\377\33\35\37\377\"%'\377\12\13"
	  "\13\377'+.\377(+-\377\27\32\32\37758<\377\35\37\40\377vy\201\377\17\20\21"
	  "\377:?C\377\10\12\12\377\17\21\22\377\14\14\15\377\40$'\377+/1\377\36\40"
	  "#\377/04\377\23\25\26\377?EI\377\16\17\21\377\25\30\31\377\40!$\377\25\26"
	  "\30\377\33#!\37728=\377\11\12\12\377\13\14\15\377\25\31\33\377(*-\37757<"
	  "\377238\377\10\10\11\377\23\24\26\377RW]\377\20\21\22\377\31\32\34\377\15"
	  "\17\21\377\13\13\13\377&)-\377\37!#\377\22\22\23\377\33\34\37\377\"%'\377"
	  "147\377;=A\377&(+\377HMR\377\21\22\22\377\20\21\23\377\20\22\23\377\36#&"
	  "\376\26\26\27\37759<\377\25\31\31\377\17\21\21\377\13\16\14\377\35\37\40"
	  "\377_di\377\21\24\24\3775;<\377\21\24\23\377\16\17\16\377\21\22\23\377\26"
	  "\30\31\377JNR\377\33\36\36\377\37\37\37\377,/2\377\23\25\23\377\27\32\33"
	  "\377\37\"%\377\25\26\26\377\16\21\20\377\20\21\20\377!$&\377\17\21\21\377"
	  "\27\32\34\377\12\13\12\377\32\36\36\377\26\30\32\377\37#$\377\16\20\17\377"
	  "\15\17\20\377*-0\377\177\31\34\36\377\14\16\16\377\10\11\11\377\26\30\32"
	  "\377\11\13\12\377&*-\377\12\13\14\377\11\12\12\377\14\17\16\3776;?\377\15"
	  "\20\20\377\12\14\14\377\11\12\14\377\30\34\36\377\15\17\17\377/48\377ru}"
	  "\377\20\22\22\377\12\13\13\377\15\16\17\377\35\40#\377'+.\377\32\34\37\377"
	  "\11\12\11\377\26\32\33\377\23\25\26\377dio\377+,/\377!$%\377\32\36\37\377"
	  "\35\37!\377\16\17\17\377\25\30\31\377\15\17\17\377EHM\377\31\33\34\377\17"
	  "\17\20\377#&)\377248\377',-\377\36\40\"\377\14\15\14\377\23\24\24\377\33"
	  "\35\36\377\17\20\21\3778<?\377\15\16\16\377\21\24\26\377\20\21\22\377\11"
	  "\11\12\377DFK\377\30\31\33\377#(*\377\13\15\14\377\27\30\32\377\12\11\11"
	  "\37737;\377(*,\377SW^\377\30\31\33\377\16\17\20\377knw\377\30\32\33\377\37"
	  "\40$\377\12\14\14\377\30\33\36\377&)*\377\14\23\21\377\26\31\32\377\32\35"
	  "\36\377\17\21\22\377\27\32\32\377\24\27\30\377\24\25\27\377\22\23\24\377"
	  "\33\35\36\377\16\20\22\377#'+\377\20\22\22\377\12\13\13\377\31\33\35\377"
	  "+/1\377\25\26\30\377\36!\"\377+.2\377\31\35\37\377\15\16\16\377=?E\377/3"
	  "5\377#%(\37727:\377\20\22\24\377\27\31\33\377\17\21\22\377\27\33\34\376#"
	  "$&\377\27\31\31\377\23\26\27\377\16\17\17\377\17\21\22\377'+0\377\40#%\377"
	  "\32\35\36\377&*,\377\21\23\23\377\17\21\20\377\27\32\32\377#$&\377\20\23"
	  "\22\377`ek\3777;=\377\17\17\16\377\37#%\377\31\32\33\377\15\16\15\377,.1"
	  "\377\26\31\32\377&'*\377\24\27\30\377346\377\20\23\23\377\17\23\23\377\30"
	  "\34\35\377\24\26\26\377\30\33\34\377\12\14\15\377\13\15\15\377).47\377\17"
	  "\23\24\377\12\13\13\377\22\24\26\377\22\25\26\377\11\13\13\377\24\27\31\377"
	  "\21\22\22\377\11\13\13\377\13\15\15\377,15\377\24\27\30\377\10\11\10\377"
	  "\11\12\14\377\31\33\37\377\"&'\377HLR\377-04\377')+\377\11\12\12\377\40!"
	  "%\377\27\33\35\377\33\34\36\377\34\37!\377\33\35\37\377\26\31\32\377\37!"
	  "#\377\16\20\20\377fip\377\24\26\26\377\20\23\25\377\16\17\17\377\31\32\34"
	  "\377\36\37!\377\25\27\30\377\17\17\17\377148\377,.1\377\40#$\377-14\377\36"
	  "\40\"\377\202\20\21\22\377L\17\20\20\377\20\20\20\377025\377,/3\377\33\35"
	  "\37\377\17\17\20\377\13\15\16\377\12\13\12\377\"%&\377=@D\377\17\21\23\377"
	  "\34\37!\377\12\12\12\377\40#&\377\16\20\20\377ORX\377\23\24\25\377\27\31"
	  "\33\377\35\40\"\377\36!#\377258\377\10\11\11\377\12\13\14\377\22\23\24\377"
	  ".27\377\21\30\25\377\14\17\20\377`cj\377$&*\377\33\35\37\377\11\12\12\377"
	  "\12\13\13\377\25\26\30\377JOR\377\34\36\"\377\12\13\14\377\11\14\14\377\40"
	  "#&\377\13\15\16\377#&*\37747:\377\12\13\14\377%(-\377\24\27\32\377\13\16"
	  "\17\377\13\14\14\377@DI\377\36\40\"\377+02\377\24\25\30\377&(+\377\15\17"
	  "\20\377\21\23\23\376\15\17\17\377\31\35\37\377\13\15\14\377\37\"#\377&+-"
	  "\377\25\24\25\377\32\34\36\377+.0\377\24\25\24\377\21\22\21\377\20\22\22"
	  "\377\34\36\40\377\17\20\17\377035\3776=@\377..0\377\37$$\37799<\377\14\16"
	  "\15\377\35\34\34\377\13\14\13\377!')\377%(*\377\202\11\12\12\377cKQV\377"
	  "JKN\377\31\32\34\377\31\34\35\377\11\12\12\377\12\13\13\377.47\377\14\15"
	  "\15\377\15\20\20\377\26\32\33\377\15\20\21\377!$%\377\10\11\11\377\16\22"
	  "\21\377\11\13\13\377Y^b\377\14\15\15\377\13\15\15\377\14\17\20\377\10\12"
	  "\12\377\14\15\17\3777:@\377.24\377\37#&\377<?C\377\16\20\21\377\26\27\31"
	  "\377\35\40!\377\40\"$\377\15\17\20\377\21\21\22\377\32\35\37\377KLQ\377\32"
	  "\34\35\377\24\27\30\377\16\17\20\377\14\16\16\377\15\16\17\377\32\34\35\377"
	  "\35\37\40\377\31\33\35\377\32\34\36\377\27\31\33\377#&(\377:>C\377\21\22"
	  "\23\377\27\31\31\377\17\17\16\377\17\21\23\377\20\23\25\377\27\32\34\377"
	  "!#&\377\15\16\16\377\31\33\35\377\37#%\377\16\17\20\377\14\15\16\377\24\26"
	  "\27\377\13\14\14\377\25\27\30\377\14\15\15\377\17\20\20\377148\377\34\35"
	  "\37\377VY]\377\11\12\12\377%()\377569\377..2\377\25\27\31\377\14\15\16\377"
	  "\13\15\16\377DFJ\377\24\26\31\377\15\16\16\377\22\33\31\377')-\377/35\377"
	  "\\`g\377\16\17\17\377\12\14\14\377\22\24\25\377\34\36\"\377\20\21\21\377"
	  "\40#%\377\22\24\26\377\25\30\32\377\30\33\35\377\21\23\24\377'*,\377\36\40"
	  "\"\377\33\36\40\377\13\15\16\377058\377\14\16\17\377\36\"$\377\12\13\15\377"
	  "\30\32\35\377%)-\377\202\16\20\21\377\177\17\21\22\377\25\32\33\376\26\27"
	  "\27\377\16\20\21\377\30\34\35\377>AE\377\21\22\23\377\20\20\21\377\20\22"
	  "\21\377\13\15\15\377\16\20\20\377\31\31\32\377\30\32\33\377\20\22\22\377"
	  "\36\40!\377\32\35\36\377014\377\24\26\26\377\31\35\36\377GJO\377\26\26\25"
	  "\377\15\15\14\377$(*\377\15\16\15\377147\377\13\15\14\377\14\16\16\377?B"
	  "E\377%')\377\17\22\23\377\13\14\14\377\30\35\35\377\37\"$\377\32\37!\377"
	  "\13\15\15\377\27\31\32\377\22\25\26\377\21\24\25\377\16\20\20\377\10\10\11"
	  "\377\10\11\11\377\35!#\377FJL\377\25\27\30\377\14\15\15\377\10\11\11\377"
	  "\14\17\20\377,/4\377\26\31\34\377'*-\377NRX\377\15\16\17\377&*,\377\23\25"
	  "\26\377#$(\377\21\23\24\377\17\21\21\377\11\13\12\377\36\40\"\377036\377"
	  "\30\31\33\377)-/\377\10\11\11\377\14\14\15\377\40$&\377\27\31\34\377\26\30"
	  "\27\377\26\27\30\377\33\36\40\377=BE\377\23\25\27\377\30\32\34\377\21\23"
	  "\24\377\17\20\21\377\32\32\33\377\23\26\27\377\36\40!\377INQ\377\35\40!\377"
	  "\40\"%\377\20\22\22\377\14\15\15\377\25\26\30\377-03\377\12\13\13\377\20"
	  "\21\22\377\13\14\14\377\20\21\21\377RV[\377\37\"%\377\16\20\21\377\17\20"
	  "\21\377-/3\377#%'\377\37\"#\377\26\27\30\377\13\15\17\377\15\16\20\377\14"
	  "\17\21\377\14\15\16\377\27\30\32\377\22\25\26\377\27\37\35\377\201\206\216"
	  "\377/26\377\20\21\22\377\34\36!\377\10\12\12\377\25\27\31\377\16\17\21\377"
	  "\27\31\32\377\17\20\22\377JPS\377\12\13\13\377\20\22\23\377\31\33\35\377"
	  "\37\40#\377\27\31\33\377+.1\377=AF\377\30\31\33\377\"&)\377\23\25\27\377"
	  "27;\377\20\22\23\377\24\26\27\377\15\16\17\377\177\16\20\21\377\21\24\26"
	  "\377\17\22\23\376\32\34\36\377\23\26\26\377ail\377358\377*13\377\\]c\377"
	  "\15\15\15\377\13\15\14\377'*+\377\34\36\37\377\25\26\26\377?DG\377347\377"
	  "\17\20\20\377\32\35\36\3776:=\377\32\34\35\377-02\377\23\26\26\377\34\35"
	  "\36\377\12\12\11\377\20\22\23\377\13\14\15\377\32\36\37\377>AE\377\21\23"
	  "\24\377GKO\377\23\26\27\377\17\20\21\377\22\25\27\377\32\34\35\377\12\14"
	  "\13\377%(*\377\12\15\15\377\13\15\14\377\23\30\31\377\26\31\33\377\14\15"
	  "\15\377%+.\377\20\21\22\377\23\26\27\377),.\377\16\20\20\377\11\12\13\377"
	  "\13\15\16\377DIN\377\26\31\35\377\20\21\22\377,13\377EHM\377\16\20\20\377"
	  "\"%'\377\27\32\33\377\24\26\27\377\14\16\17\377BIM\377\16\16\17\377025\377"
	  "9<?\377\15\16\16\377\25\27\32\377\12\12\12\377%(,\377\16\20\20\377\14\15"
	  "\15\377\21\22\23\377?CG\377+.1\377LMQ\377\14\13\13\377\20\21\21\377*-/\377"
	  "\27\27\30\377!%'\377,.2\377;<@\377(+-\377\25\27\30\377\25\30\31\377\12\12"
	  "\12\377\17\20\20\377#'*\377\23\26\27\377\20\21\21\377\13\13\13\377\15\16"
	  "\17\377PTZ\377\13\15\15\377\11\13\13\377358\377@CF\377\25\27\27\377\16\16"
	  "\20\377\14\15\16\377\12\14\14\377\14\16\17\377\40!$\377.02\377\25\27\32\377"
	  "'+0\377\30\37\36\377,/2\377\23\25\30\377\10\11\12\377\32\35\40\377_dk\377"
	  "\10\11\11\377\33\36!\377\14\15\15\377\40#&\377\14\14\15\377\17\21\23\377"
	  "\34\36\40\377+-2\377\35\40\"\377\37!#\377\14\17\17\377Y_e\3777;@\377\13\13"
	  "\14\377\40#&\377\20\23\24\377\17\21\21\377\24\26\30\377\177\17\20\20\377"
	  "&(,\377\30\31\33\377\15\17\17\376\20\23\24\377?EI\377\17\20\20\3777?A\377"
	  "437\377\14\16\14\377\13\16\15\377\13\14\13\377\27\31\30\377%(*\377),.\377"
	  "&+-\377\17\21\20\377\21\24\26\377\25\30\30\377\31\33\32\377\16\15\14\377"
	  "\31\35\36\3779;?\377\20\23\23\377\10\12\12\377\11\12\11\377,.1\377\20\21"
	  "\22\377\11\13\13\377\20\24\25\377\11\12\10\377\24\30\31\377#&)\377\25\30"
	  "\32\377\14\15\15\377,-1\377\14\16\16\377\20\23\24\377\16\20\20\377\10\12"
	  "\12\3778=A\377')+\377\13\15\15\377\12\15\15\377\14\16\15\377\32\34\36\377"
	  "\33\40#\377\13\15\15\377\10\11\11\377%'*\377&',\377\26\32\31\377148\377\35"
	  "!#\377\32\36\37\377\20\23\23\377>BF\377\27\33\33\377!#&\377\12\15\15\377"
	  "\22\24\26\377)+,\377\30\32\33\377\31\32\34\377\14\14\15\377\13\14\13\377"
	  "\13\12\12\377\30\33\34\377\33\35\37\377\34\36\40\377<@D\377<=A\377\13\14"
	  "\15\377\17\20\20\377\23\23\23\377<>B\377\27\30\32\377\40!\"\377\37\40\"\377"
	  "@CH\377\37#$\377\23\27\30\377\24\25\26\377\34\37!\377\17\20\20\377\25\27"
	  "\31\377\26\27\30\377\17\20\20\377\15\20\21\377\15\16\17\377\23\24\26\377"
	  "\15\17\20\377\22\25\25\377+/2\377\25\30\31\377\25\31\33\377\11\11\11\377"
	  "\12\14\14\377!$'\377\13\14\15\377\12\13\14\377).3\377\16\20\22\377HIP\377"
	  "\31\37\35\377\14\14\15\377\27\32\33\377GJQ\377\15\16\17\377\30\34\33\377"
	  "48<\377\21\23\25\377\25\30\32\377\13\15\15\377\15\16\17\377\23\25\27\377"
	  ":?A\377\40$(\377\16\20\22\377\15\16\17\377#'*\377\20\22\23\377',/\377\33"
	  "\40\"\377\17\17\17\377\23\24\25\377\13\14\15\377\17758=\377\14\16\20\377"
	  "\22\23\24\377\22\23\25\377\27\35\36\376\25\27\27\377\15\20\20\377<AD\377"
	  "DEI\377\21\25\25\377\14\16\16\377!$&\377\13\14\13\377\23\25\27\377\36\40"
	  "!\377269\377\16\20\20\377\36#\"\377\15\17\17\377CFL\377\35\40!\377\17\21"
	  "\21\377STZ\377\11\13\13\377\21\23\25\377\12\14\13\377\20\21\21\377\13\14"
	  "\15\377\11\13\12\377\27\30\32\377\35\"!\377--/\377\21\24\24\377\31\33\35"
	  "\377\21\24\24\377\35\36!\377\21\23\23\377(,0\377\11\14\13\377\13\16\17\377"
	  "\11\13\13\377'.1\377\24\26\27\377\17\17\17\377\33\35\37\377\15\20\20\377"
	  "\30\32\34\377\40%(\377148\377\17\17\17\377\13\15\17\377\17\21\23\377\177"
	  "\202\213\377\15\16\17\377BFM\377\23\25\26\377\27\32\33\3777>@\377egp\377"
	  "\13\16\16\377\17\20\20\377\21\22\24\377\27\31\32\377\10\10\10\377\27\30\32"
	  "\377#$'\377\17\20\21\377\14\16\16\377\12\14\13\377<?D\377\34\37\40\377),"
	  "/\377\17\21\20\377\20\21\21\377\36\40\"\377\33\32\34\377\16\16\16\377\37"
	  "\40!\377<>A\377\11\13\12\377?CF\377.26\377\21\22\23\377\30\33\35\377\17\20"
	  "\20\377\26\30\32\377\14\15\15\377\13\13\14\377&),\377\25\27\30\377\11\12"
	  "\11\377\12\13\13\377\35\37!\377\15\17\20\377\13\15\15\377\33\35\37\377\7"
	  "\10\10\377\14\16\20\377\23\24\27\377\12\12\13\377\23\25\26\377\27\30\33\377"
	  "\14\16\20\3778<A\377\32\35\40\377\14\24\20\377!#$\377\21\22\24\377\17\20"
	  "\21\377\13\16\17\377\22\26\27\377\17\23\24\377.03\377\11\11\13\377\25\26"
	  "\31\377$%'\377\34\35\37\377)+.\377\37!$\377\15\20\21\377\30\32\34\377\13"
	  "\14\14\377\40\"%\377-03\377\12\16\20\377\16\17\20\377\15\15\16\377\177\12"
	  "\14\14\377\13\14\15\377\21\21\23\377\20\23\24\377\21\23\25\377\20\22\23\376"
	  "\20\23\23\377\27\33\34\377\36!$\377\24\27\27\377\14\15\15\377!%&\377\15\16"
	  "\15\377\14\15\15\377\23\25\25\377.13\377\15\16\15\3776;=\377$&(\377\14\17"
	  "\15\377\27\32\32\37767:\377\11\12\12\377\13\15\16\377\17\22\22\377\14\16"
	  "\16\377\21\23\24\377\23\24\26\377\36\"$\377\13\16\16\377\13\14\14\377\40"
	  "#&\3778=B\377\15\20\20\377\7\10\7\377\27\33\35\377\30\33\34\37738<\377\14"
	  "\15\15\377\15\16\17\377\12\14\15\3778>B\377\11\13\13\377\24\27\30\377\22"
	  "\24\26\377\17\20\21\377\20\21\22\377-.2\377\16\20\21\377\24\27\31\377\20"
	  "\22\22\377\13\15\16\377\20\21\23\377$')\377]`c\377\13\13\14\377\35\37\"\377"
	  "349\377\37#'\377\22\24\26\377\31\32\34\377\25\26\27\377\7\10\7\377\12\12"
	  "\11\377\17\20\21\377\22\25\27\377\17\21\21\377\15\16\16\377\26\30\32\377"
	  "\13\16\16\377\10\12\12\377\27\32\35\377\31\33\33\377\17\20\21\3779;?\377"
	  "#%&\377\13\15\15\377\24\25\27\377\40!#\377FJO\377146\377'*-\377\22\22\23"
	  "\377\33\36!\377\20\21\23\377+,/\377\17\20\20\377\27\32\33\377\21\24\25\377"
	  "\25\26\31\377\13\14\14\377\11\12\11\377\12\12\12\377\14\15\15\377\21\22\23"
	  "\37726:\377\13\14\14\377\24\27\31\377\36!\"\377\20\21\22\377\21\23\24\377"
	  "*-1\377\11\11\11\377+/2\377\20\22\24\377\37\"$\377\10\16\11\377),0\377\16"
	  "\17\20\377\13\14\15\377#'(\377#&(\377\22\22\23\377\23\25\27\377\25\27\31"
	  "\377\20\23\25\377\33\35\40\377\21\23\24\377\21\24\26\377$&)\377*.2\377\13"
	  "\15\16\377\30\32\33\377DIL\377\20\22\23\377\15\16\20\377$(+\377\177\27\32"
	  "\34\377\11\14\14\377\14\16\17\377\13\14\14\377X]b\377\22\26\30\377\16\21"
	  "\21\376\16\20\20\377\24\26\27\377\22\25\25\377\24\25\25\377\22\26\26\377"
	  "**-\377#)*\377\16\17\15\377168\377\20\20\17\377\24\26\26\377\35\37!\377\34"
	  "\37\40\377\15\16\16\377\34!\"\377148\377\10\11\11\377\13\14\14\377\7\10\10"
	  "\377\10\11\11\377\7\10\10\377(-/\377VZ_\377\7\10\10\377\36!\"\377\33\40!"
	  "\377\24\27\30\377\14\16\17\377\12\13\13\377\14\17\17\377aek\377%,.\377\17"
	  "\22\23\377\14\15\15\377\26\27\31\377\11\13\13\377MRW\377\21\22\24\377\10"
	  "\11\10\377)-.\377\14\20\20\377!%(\377\11\13\12\377\15\20\21\377\23\25\26"
	  "\377eim\377\10\11\13\377%(*\377\35\40#\377?BG\377\16\17\20\377\31\32\34\377"
	  "\13\14\14\377\16\20\21\377\31\31\35\377*03\377\13\13\14\377\14\15\15\377"
	  "\35\40\"\377\13\14\14\377\12\13\13\377\10\10\10\3776:<\37726;\377\14\14\14"
	  "\377\10\10\10\377\14\14\14\377\33\35\37\377\22\23\24\377\20\22\22\377\17"
	  "\20\20\377/47\377\17\17\20\377EIL\377X[`\377\15\16\16\377\32\33\35\377\13"
	  "\13\13\377HMP\377\14\15\16\377\13\14\14\377+/3\377\22\24\26\377\13\14\14"
	  "\377\13\13\13\377\13\14\14\377\11\13\13\377\12\12\12\377\13\15\16\377\14"
	  "\15\16\377\16\21\21\377\16\20\21\377\13\15\16\377$%(\377\15\16\20\377\10"
	  "\12\13\377\11\12\12\377\"%'\377\22\24\26\377\25\30\31\377\24\33\32\377\12"
	  "\14\14\377\13\14\14\377\22\24\26\377\15\17\17\3777:?\377')-\377',/\377\25"
	  "\27\32\377\17\21\22\377\21\23\24\377!$'\37726:\377\17\21\23\377\16\20\22"
	  "\377\20\22\23\377&),\377\27\31\33\377\34\36\40\377\24\27\30\377\177\34\34"
	  "\37\377\36#%\377\14\14\15\377\14\16\17\377\24\26\27\377\12\13\13\377/46\377"
	  "\25\30\31\376\34\37!\377\13\16\16\377\14\16\15\377\37$%\377@BG\377%*,\377"
	  "\13\15\14\377\17\21\22\377\12\13\13\377\37\"$\377\20\21\21\377\16\20\16\377"
	  "\37!$\377\23\25\25\377HNS\377\20\22\22\377\7\11\11\377\31\33\35\377\7\7\6"
	  "\377\10\10\10\377\14\16\17\377\21\23\23\377\24\26\27\377\20\24\24\377\15"
	  "\16\17\377\40#%\377\13\14\14\377\13\15\15\377\7\13\12\377\16\22\23\377\13"
	  "\14\14\377\27\32\32\377\26\31\34\377\16\20\20\377\10\11\10\377\24\30\31\377"
	  "%'*\377\16\21\20\377\15\20\20\377\20\23\24\377\27\33\34\377((*\377\17\20"
	  "\21\377\10\11\12\377\21\23\24\377\35\40\"\377/24\377\15\20\21\377.15\377"
	  "*,-\377\10\10\7\377\11\11\11\37736;\377=?C\377\17\17\20\377\15\20\20\377"
	  "\21\23\24\377\17\20\21\377\10\7\7\377\11\11\10\377\30\31\32\377#'*\377\20"
	  "\22\23\3779:>\377\11\12\12\377\12\12\12\377\23\25\26\377\"$(\377\35\40!\377"
	  "\16\16\16\377).0\377\36\40\"\3779;?\377\32\33\35\377\27\30\31\377\20\21\22"
	  "\377\15\16\17\377\20\22\24\377\16\16\15\377\30\30\33\377\24\27\31\377\22"
	  "\25\25\377+-0\377\16\20\21\377\17\20\20\377\11\12\12\377\27\31\32\377\12"
	  "\11\11\377\16\16\17\377\10\10\10\377+/2\377!#%\377\31\33\35\377\34\37!\377"
	  "\10\12\12\377\27\33\35\377\10\10\10\377\30\31\33\377&')\377\22\24\26\377"
	  "\7\15\10\377\16\16\17\377\30\31\34\377\13\14\15\377\15\15\14\377!%&\377@"
	  "DJ\377\20\23\25\377\21\22\23\377$(,\377\14\14\15\377\37\40#\377hmt\377\14"
	  "\16\17\377\32\35\36\3779;?\377\16\17\17\377\33\37\40\377\36!$\377\177\13"
	  "\15\16\377\13\14\14\377!\"%\377:>B\377\16\21\23\377\14\15\16\377*/4\377\16"
	  "\21\21\377\17\21\22\376\15\17\20\377\13\15\15\3778=@\377:<@\377\20\23\23"
	  "\377+/2\377\24\25\26\377\14\14\14\377#()\377\33\35\36\377\13\14\13\377$'"
	  ")\377\16\20\17\377\37!#\377\14\15\14\377)-1\377\7\10\10\377\16\20\21\377"
	  "\21\22\22\377\11\14\14\377\13\14\14\377\7\10\10\377\14\15\15\377\21\25\27"
	  "\377#&)\377\10\12\12\377\13\14\14\377\17\20\21\377\14\17\17\377\37#&\377"
	  "\12\13\12\377\26\31\33\377\30\34\36\377\21\23\25\377\15\16\17\377\15\17\20"
	  "\377\30\32\34\377\21\24\25\377\30\32\32\377EHN\377\10\13\13\37769>\377\15"
	  "\17\20\377\16\20\21\377\7\10\10\377&*.\377\16\17\20\377\15\17\17\377\22\25"
	  "\25\377\21\22\24\377\12\12\13\377\11\12\11\377\23\25\27\377\27\31\32\377"
	  "\7\7\10\377\13\14\15\377\26\32\33\377\11\13\12\377\10\10\7\377-03\377RU["
	  "\377\21\22\24\377)(,\377\13\13\12\377\11\11\11\377\35!\"\377\14\14\15\377"
	  "\25\25\27\377\30\31\32\377\31\34\35\377\20\23\22\377ORX\377*+.\377\36\37"
	  "!\377\14\13\14\377\20\20\21\377\22\23\24\377\10\10\10\377!#$\377\26\31\32"
	  "\377\23\26\26\377\33\34\37\377\13\12\13\377\25\26\30\377\16\20\21\377\14"
	  "\15\14\377\20\22\23\377\6\7\7\377\10\10\10\377\32\34\36\377\14\16\16\377"
	  "\23\26\27\377).1\377\11\12\13\377\20\22\23\377!\"%\377\31\32\34\377\34\36"
	  "\40\377*-/\377\15\17\20\377\7\16\11\377\24\27\30\377\25\27\30\377\12\13\14"
	  "\377\12\13\13\377&(+\377\21\23\25\377?BD\377\24\26\31\377\24\26\27\3779?"
	  "D\377\20\23\25\377\15\17\20\377\24\27\31\377\16\20\21\377\36\37\40\377)+"
	  ".\377,/2\377L\22\24\26\377\10\11\11\377&*-\377\24\30\32\377\26\30\30\377"
	  "JNS\377\24\26\30\377\16\20\21\377\31\34\36\377\23\25\26\376\40#%\377\31!"
	  "\"\377\27\30\32\377\25\32\32\377((+\377,24\377\30\32\32\377\15\17\17\377"
	  "\14\16\17\377\26\31\31\377\17\20\21\377\16\21\20\377\"$%\377\10\11\10\377"
	  "\24\30\32\377\14\15\15\377\13\14\15\377\14\17\17\377\16\22\23\377\34\34\36"
	  "\377\6\6\6\377\11\12\13\377\16\21\23\377\20\23\24\377\11\14\14\377\10\10"
	  "\10\377\17\21\21\377\14\16\17\377\11\13\13\377\12\15\15\377\27\32\34\377"
	  "\12\15\15\377\31\35\36\377KLR\377\12\14\14\377\13\15\17\377(,.\377\17\20"
	  "\21\377\35!#\377\31\36\36\377\14\16\16\377\21\24\25\377#%(\377\12\13\13\377"
	  "\15\16\17\377\11\12\12\377\21\24\25\377(),\377\30\32\33\377\7\7\10\377\11"
	  "\11\12\377\24\26\30\377\10\10\10\377\10\11\11\377\25\30\31\377\22\25\27\377"
	  "\22\24\24\377\14\15\16\377\33\36\37\377\12\13\12\377\25\27\30\377\10\11\10"
	  "\377\22\23\25\377\14\15\15\377\34\35\37\377\21\23\25\377\202\15\16\16\377"
	  "\177\27\33\33\377#&(\3778:>\377\20\22\22\377\17\17\20\377\12\12\12\377\15"
	  "\17\16\377\13\14\13\377\14\15\14\377\35\37\"\377\16\20\21\377\"#&\377\27"
	  "\31\33\3778:?\377\15\17\17\377\24\25\26\377'(,\377\14\16\16\377\10\10\10"
	  "\377\11\11\12\377\15\14\14\377\26\26\31\377\36!\"\377\12\14\15\377\25\30"
	  "\32\377048\377\7\10\7\377\14\15\15\377\11\12\13\377+-2\377\13\14\15\377\26"
	  "\30\32\377\34\40\40\377\15\15\16\377\17\20\21\377\21\25\25\377\17\20\21\377"
	  "\13\16\16\377\22\23\24\377\40#$\377\32\34\36\377,/3\377\30\33\35\377,.2\377"
	  "\11\12\12\377\31\34\35\3778;>\377\20\22\22\377137\377\13\15\16\377\25\26"
	  "\30\377\16\20\22\377\10\12\11\377\20\23\25\377\32\35\37\377;@D\377\20\23"
	  "\25\377\17\22\23\377\12\12\12\377\17\21\21\376\20\24\25\377&*,\377#(+\377"
	  "\37\40\"\377\40$&\377\22\24\24\377\16\21\21\377\15\17\17\377\20\22\22\377"
	  "7:=\377\13\13\14\377\25\27\27\377\11\12\11\377\13\14\14\377\11\11\10\377"
	  "\32\34\36\377\10\11\10\377`ek\377\31\32\34\377\12\12\13\377\11\12\12\377"
	  "\6\10\10\377+.0\377\10\10\7\377\6\7\7\377\36\"$\377*/1\377\23\25\25\377\10"
	  "\12\11\377\25\30\32\377\23\24\24\377\30\33\33\377\11\13\13\377\12\13\12\377"
	  "\15\17\20\377\17\22\23\377.15\377\22\26\27\377\17\20\21\377:>B\377\20\22"
	  "\22\377:<?\377\10\11\11\377\10\11\12\377\11\12\11\377\17\21\23\377\13\13"
	  "\15\377\14\15\15\377\10\11\10\377\11\12\12\377\7\10\7\377\21\23\23\377\6"
	  "\6\6\377\21\25\26\377\22\24\26\377\21\21\22\377\7\7\7\377\31\34\34\377\20"
	  "\22\23\377\10\11\11\377\10\10\10\377\11\11\11\377\13\15\15\377<>B\377\10"
	  "\10\11\377\13\15\16\377\14\14\14\377\6\32\34\35\377\10\12\11\377\15\15\15"
	  "\377\20\22\22\377\25\25\27\377\24\26\27\377\202\16\17\20\377\177\32\33\35"
	  "\377\16\17\16\377\14\17\17\377VZ`\377\12\13\11\377\17\21\22\377\36\"%\377"
	  "$&)\377\15\16\16\377\20\20\20\377\22\23\25\377\16\17\20\377\10\7\7\377\11"
	  "\11\11\377\31\32\33\377\30\31\33\377\10\10\11\377%(*\3779;@\377\21\24\26"
	  "\377\10\10\11\377\12\12\12\377\10\11\12\377\15\15\16\377\24\27\30\377\30"
	  "\35\35\377*,0\377\21\22\22\377\15\17\17\377\14\16\16\377\22\26\30\377\21"
	  "\21\23\377\12\13\14\377\37\"%\377!\"&\377\"')\377\12\13\13\377*-0\377\12"
	  "\12\13\377/14\377:=A\377\11\12\12\377=>C\377!%'\377\14\15\16\377\32\35\37"
	  "\377\33\35\37\377\40%'\377/36\377\14\15\15\377\17\20\21\377!#%\377\16\20"
	  "\20\376\23\25\27\377\15\21\21\377&,/\3777<?\377\36!#\377\30\32\33\377\20"
	  "\23\24\377\30\34\34\377\14\15\15\377\13\14\14\377\13\15\15\377\10\11\10\377"
	  "\21\22\22\377\12\13\14\377\21\23\24\377\10\10\10\377\24\27\31\37706:\377"
	  "\31\32\34\377\25\30\31\377\11\12\12\377\6\7\7\377\6\6\6\377\10\11\11\377"
	  "\14\16\16\377\25\27\30\377).1\377\13\14\14\377\33\40!\377\27\30\31\377\11"
	  "\11\12\377\16\20\21\377\20\23\23\377\22\24\25\377\40#$\37738<\377@CF\377"
	  "\12\13\13\377\24\25\26\377\12\13\12\377\11\12\12\377\10\12\12\377\15\20\21"
	  "\377\7\10\10\377\10\11\12\377\20\21\23\377\6\7\7\377\6\6\6\377\11\12\12\377"
	  "\23\25\26\377\16\17\20\377\6\6\6\377.04\377\24\30\31\377\10\11\11\377\12"
	  "\12\12\377\20\22\23\377\23\25\26\377\17\21\21\377\16\17\17\377\11\11\10\377"
	  "\11\10\10\377024\377\37\37!\377\13\14\15\377\13\14\14\377\11\11\11\377\14"
	  "\16\17\377\37#%\377\23\24\25\377\14\13\12\377\21\22\23\377\20\20\21\377\17"
	  "\22\23\377\26\32\34\35\377\10\10\10\377]ch\377\31\31\33\377\27\31\34\377"
	  "\25\26\27\377\10\10\10\377\27\30\31\377;>B\377\15\15\16\377\21\22\22\377"
	  "\17\21\22\377\7\10\10\377\10\7\10\377\6\6\6\377\17\21\22\377\10\11\12\377"
	  "\11\13\13\377\22\24\26\377\15\17\20\377\12\14\15\377158\377\202\7\7\7\377"
	  "\177\20\22\22\377\14\16\16\377\20\26\24\377-04\377\21\23\24\377\15\16\17"
	  "\377\40\"$\377+/2\377\24\27\31\377\14\16\17\377\13\13\14\377\24\25\25\377"
	  "$&)\377\16\16\16\377\26\31\32\377048\377\27\31\32\377\23\24\25\377!$'\377"
	  "\40!$\377\30\31\33\377\15\17\20\377+,/\377\36#%\377\15\16\17\377\20\23\23"
	  "\377\12\12\13\377\14\15\16\377\21\23\25\377\21\24\25\376\22\26\27\377\22"
	  "\25\26\3777:>\377<@D\377.13\377\16\17\20\377\20\24\24\377\22\24\24\377\11"
	  "\12\11\377\14\16\17\377\7\10\7\377\15\20\20\377\12\13\13\377\10\10\10\377"
	  "\16\21\21\377*.2\377\21\22\23\377\36\36\37\377\15\17\17\377%),\377\21\22"
	  "\22\377\5\6\6\377\7\7\7\377\12\13\13\377\36\40!\377\12\14\14\377\13\16\15"
	  "\377)-1\377\6\7\6\377\22\27\30\377(*,\377\13\15\15\377258\377#%(\377\10\11"
	  "\10\377\7\11\10\377\11\13\13\377\15\16\16\377\14\15\16\377\24\26\27\377\11"
	  "\12\11\377\"')\377\13\15\15\377\11\13\13\377\6\7\6\377\7\7\10\377\7\11\11"
	  "\377\11\11\11\377\24\25\27\377\24\26\30\377\10\12\11\377JPU\377\27\27\30"
	  "\377\25\25\25\377\7\10\10\377\37#%\377\20\22\22\377\13\14\14\377\10\10\7"
	  "\377\40#%\377\17\21\22\377\17\20\20\377\10\10\7\377\12\12\11\377\17\17\21"
	  "\377HLR\377\33\35\36\377\12\13\13\377\14\15\15\377\16\16\16\377\15\17\17"
	  "\377\17\21\21\377\25\27\31\377269\377;=A\377\14\16\17\37778;\377\"$%\377"
	  "\17\17\20\377\13\13\13\377\12\12\11\377\21\22\23\377\11\13\12\377\20\20\21"
	  "\377\11\11\10\377\20\20\21\377\10\11\10\377\13\14\15\377\11\13\13\377\6\7"
	  "\7\377\12\13\13\377\30\32\34\377\11\12\12\377\15\16\20\377\25\27\31\377\7"
	  "\10\10\377\14\15\16\377?\11\11\12\377\10\10\11\377\30\33\35\377\11\17\14"
	  "\377\16\20\20\377\16\16\17\377\24\25\27\377\13\12\13\37759=\377\20\22\24"
	  "\377\20\21\22\377\20\22\23\377\11\11\11\377\22\23\24\377!%(\377$'*\377\24"
	  "\25\26\377\25\27\30\377\23\25\26\377EHL\377\15\15\16\377\15\16\20\377'+/"
	  "\377\13\14\15\377##'\377\12\12\12\377\6\7\7\377\12\13\13\377147\377\23\25"
	  "\27\377!&)\376\15\20\17\377\20\22\22\377!%'\377\33\35\36\377CJM\377\35\37"
	  "!\377\25\30\30\377\12\12\11\377\10\11\10\377\13\15\16\377\13\14\15\377\14"
	  "\15\15\377\20\22\23\377\15\16\17\377\31\34\35\377/25\377\36\37!\377\10\12"
	  "\12\377\10\12\11\377\6\7\6\377\6\6\6\377\6\7\7\377\17\22\23\377\16\17\20"
	  "\377\13\15\14\377\14\15\15\377\7\10\7\377\6\7\6\377.36\377\17\20\21\377\40"
	  "%&\377146\377\202\11\12\12\3779\6\7\6\377\7\10\10\377\36\40\"\377\23\23\23"
	  "\377\25\30\30\377\13\16\15\377\10\12\11\377\22\23\21\377\10\11\10\377\7\7"
	  "\6\377\10\11\10\377\11\12\13\377\14\15\16\377\22\25\26\3777:<\377\7\7\6\377"
	  "\10\10\7\377\30\34\36\377\12\12\12\377\6\6\7\377\11\14\14\377\16\20\21\377"
	  "\7\10\10\377\10\11\10\377\22\24\26\377\6\6\6\377\33\36\37\377\23\30\30\377"
	  "\12\12\12\377\16\16\16\377\31\33\35\377\20\21\21\377\11\12\11\377\7\7\7\377"
	  "\6\6\6\377\7\10\10\377\37\"$\377\13\13\12\377\24\26\27\377DFH\37746:\377"
	  "\33\33\34\377\22\24\25\377\20\20\20\377\13\13\13\377\25\27\27\377\21\22\23"
	  "\377\25\27\30\377\12\13\13\377\13\14\14\377\14\15\15\377\"%'\377\26\26\26"
	  "\377\25\30\33\377\12\13\13\377\12\14\15\377\10\10\10\377\202\11\11\11\377"
	  "5\10\11\11\377\7\7\6\377\14\16\17\377\12\12\12\377\11\11\12\377\12\13\14"
	  "\377\15\20\21\377\11\20\15\377\25\26\27\377!#%\377')+\377\34\37\"\377\36"
	  "!!\377MTY\377\37!$\377\13\12\12\377\16\20\21\377\11\11\11\377247\37776:\377"
	  "\22\23\24\377\40!$\377\17\20\21\377\10\10\10\377ADJ\377\22\24\25\377\10\10"
	  "\11\377\12\12\12\377\10\11\10\377\11\12\12\377\33\35\40\377\23\25\25\377"
	  "\37\"#\377SX]\377\36\40#\376\14\17\20\377\13\15\15\377\14\16\16\377\20\23"
	  "\23\377EHK\377\14\16\16\377\12\13\12\377\12\14\13\377\17\20\21\377\14\17"
	  "\17\377+-1\377\13\14\14\377\13\15\16\377ILS\377\31\33\34\377\13\15\15\377"
	  "\6\10\10\377\10\12\12\377\202\7\10\10\377L\12\14\14\377\17\23\23\377\17\22"
	  "\23\377\15\16\17\377\5\6\6\377\6\6\6\377\10\12\12\377\22\25\26\377&)+\377"
	  "\12\14\14\377\16\17\17\377\20\23\23\377\7\7\7\377\13\15\14\377\21\23\23\377"
	  "\11\12\12\377\13\15\16\377\22\23\24\377\23\26\26\377\13\14\14\377\6\7\6\377"
	  "\34\37\"\377\22\24\24\377\6\6\5\377\7\7\7\377\6\7\7\377\16\20\21\377\12\13"
	  "\13\377\7\10\7\377')-\377\11\13\13\377\7\7\7\377\11\12\12\377\31\33\35\377"
	  "\12\13\13\377\10\10\11\377\16\17\17\377\7\10\10\377\10\10\10\377:<A\377\14"
	  "\15\15\377\33\35\36\377\7\10\10\377\10\10\10\377\11\12\13\377\12\14\13\377"
	  "\10\11\10\377\10\12\12\377\10\10\10\377\12\11\11\377\12\13\13\377\11\13\12"
	  "\377\30\31\32\377\13\14\14\377'+,\377\24\25\26\377\40\40\"\377\13\13\13\377"
	  "\22\22\23\377%')\377\15\15\16\377\12\13\13\377\14\14\15\377\15\15\15\377"
	  "\21\21\23\377\21\23\25\377\32\34\35\377\16\20\20\377\11\12\12\377\33\34\36"
	  "\377\17\17\20\377\12\13\13\377\20\22\23\377\6\7\6\377\16\17\17\377\12\12"
	  "\13\377\202\10\11\11\377\177\16\20\21\377\10\11\12\377\17\26\25\377\11\12"
	  "\12\377-13\377\26\31\31\377\16\20\21\377\14\17\17\377\16\17\21\377\11\11"
	  "\11\377\10\10\11\377\11\10\10\377\15\15\16\377\6\7\7\377\15\16\17\377\13"
	  "\13\13\377\11\11\11\377\32\34\35\377\33\34\36\377\37\"$\377\11\11\11\377"
	  "\11\12\12\377\17\21\22\377\16\17\20\377\24\30\32\377\13\15\16\377\20\21\22"
	  "\377\32\33\36\377#&'\377\13\15\15\376\21\24\25\377\13\15\14\377\16\17\17"
	  "\377\25\30\31\377\21\22\23\377\10\10\11\377\21\24\25\377\12\13\13\377\21"
	  "\22\23\377\26\31\31\377\15\16\16\377\"%'\377\16\21\21\377EKO\377\35\35\37"
	  "\377\6\6\5\377\7\10\10\377\11\13\13\377\16\20\20\377\10\11\10\377\16\23\24"
	  "\377\23\26\27\377\11\12\11\377\6\6\6\377\5\6\6\377\6\6\6\377-25\377NPS\377"
	  "\10\11\11\377\15\17\17\377\21\25\26\377\17\20\20\377\33\36\37\377\15\16\16"
	  "\377()+\377\12\14\14\377\26\31\32\377\12\12\12\377\6\7\6\377\13\14\15\377"
	  "\11\13\13\377\21\23\23\377\10\11\12\377\6\6\6\377\13\15\16\377\16\21\23\377"
	  "%'*\377\6\6\6\377\11\13\13\377\6\7\7\377\7\7\6\377\10\10\10\377\12\14\13"
	  "\377\33\36!\377\16\20\21\377\6\7\6\377\7\10\10\377\12\14\13\377\33\35\36"
	  "\377\13\14\14\377\11\12\13\377\7\10\7\377\14\16\16\377\16\17\20\377\15\16"
	  "\15\377156\377\10\11\11\377\7\10\10\377\17\20\20\377\10\11\10\377\27\31\32"
	  "\377\16\20\20\377\17\21\21\377\35\37!\377\34\37!\377\12\13\13\377\14\14\14"
	  "\377?CG\377\16\17\17\377\36!$\377\14\14\14\377\21\22\23\377\20\21\24\377"
	  "\14\15\15\377\12\13\13\377#'(\377\12\12\13\377\11\12\13\377\13\16\16\377"
	  "\23\25\26\377\15\16\17\377\10\11\11\377\11\11\12\377\10\10\10\377\11\12\11"
	  "\377\30\31\34\377\13\14\15\377O\17\21\22\377\14\16\17\377%(*\377\11\20\14"
	  "\377\11\11\11\377\23\25\25\37747:\377\10\10\11\377\12\13\13\377\7\10\10\377"
	  "\34\36\37\377\15\17\20\377\14\15\16\377\10\10\11\377\10\11\10\377\10\7\10"
	  "\377\11\13\13\377\12\12\13\377\12\13\12\377\13\15\16\377\7\10\10\377\26\31"
	  "\31\377\30\33\34\377\11\12\12\377\27\32\34\377#')\377\15\20\21\377\10\11"
	  "\11\377\20\21\22\377\11\12\13\377\24\27\27\376\12\14\14\377*03\377\14\16"
	  "\16\377\11\12\10\377\11\13\12\377\11\12\11\377\13\15\15\377\32\35\36\377"
	  "56:\377\10\11\10\377\13\14\14\377.47\377(*,\377\10\11\11\377\10\13\12\377"
	  "\13\14\15\377\10\11\11\377\14\16\17\377\12\12\11\377\14\17\17\377!#%\377"
	  "\10\11\12\377\7\10\10\377\14\16\16\377\7\7\7\377\22\26\26\377\12\13\14\377"
	  "\6\10\7\377\11\13\13\377\17\22\22\377\25\25\27\377\36\"%\377\15\17\16\377"
	  "CGK\377\11\13\12\377\15\16\17\377\12\14\15\377\22\25\25\377\11\13\13\377"
	  "\12\13\13\377\7\7\7\377\11\12\11\377\10\11\11\377\5\6\5\377\10\11\11\377"
	  "\11\13\15\377\10\10\11\377\22\25\26\377\202\16\20\20\377b\10\11\10\377\16"
	  "\20\21\377\12\13\13\377\7\7\7\377\20\22\24\377\36!\"\377\10\10\7\377\11\11"
	  "\11\377\11\13\13\377\11\12\12\377\22\25\26\377\10\10\10\377\10\11\11\377"
	  "\12\13\13\377\7\7\7\377\10\10\10\377\16\20\21\377\15\16\17\377\11\11\10\377"
	  ".12\377\14\14\15\377\20\21\22\377\13\13\14\377\17\20\20\377\11\11\11\377"
	  "\13\12\11\377\22\24\24\377347\377(+-\377\24\24\25\377\14\15\15\377\13\13"
	  "\13\377;=@\377\30\27\31\377\7\7\10\377',/\3778=A\377\30\31\31\377#%'\377"
	  "\34\36!\377\14\15\15\377\7\7\7\377\6\6\6\377\12\12\12\377\30\31\33\37758"
	  ";\377(,.\377\12\14\15\377\15\16\21\377\25\26\30\377\5\13\7\377\14\15\15\377"
	  "\14\15\16\377\15\17\20\377/25\377\10\11\10\377\13\13\14\377\12\12\13\377"
	  "\13\13\13\377\31\33\34\377\12\13\13\377\11\11\11\377\10\10\10\377\11\11\10"
	  "\377#$(\377\30\34\36\377\12\12\12\377\14\16\17\377\11\12\13\377\10\11\11"
	  "\377#&(\377\20\21\22\377\15\15\16\377!%&\377\34\36\40\377\12\12\12\377\36"
	  "#$\377\15\16\15\376\13\14\14\377\16\20\20\377\15\16\17\377\16\16\16\377\14"
	  "\15\14\377\12\12\11\377\7\10\7\377V[`\377\21\21\21\377\17\22\22\377\26\27"
	  "\30\377\16\21\21\377\30\32\33\377\16\17\20\377\6\10\7\377\30\33\35\377\31"
	  "\32\33\377\7\10\7\377\7\6\6\377\11\14\14\377\202\10\11\11\377z\22\26\27\377"
	  "\13\13\13\377\15\16\16\377\7\11\11\377\14\15\15\377\11\12\12\377\13\14\14"
	  "\377\12\12\12\377\15\20\20\377\16\21\21\377\17\21\23\377\11\13\12\377QUZ"
	  "\377\27\31\33\377\36\"$\377\12\12\12\377\10\11\11\377\11\13\12\377\10\12"
	  "\11\377\17\20\20\377\6\6\6\377\10\11\11\377\15\16\17\377\7\10\11\377\20\23"
	  "\26\37716<\377\7\7\6\377\10\7\7\377,03\377\26\26\27\377\14\15\16\377\10\11"
	  "\10\377\11\12\11\377\20\23\23\377\22\23\24\377\6\6\6\377\11\13\13\377\26"
	  "\30\30\377\25\27\30\3777:@\377'')\377\11\10\7\377\17\21\22\377\7\10\7\377"
	  "\11\12\11\377\14\15\15\377\10\10\7\377\6\10\10\377\20\22\22\377\7\10\10\377"
	  "\15\20\21\377\12\12\12\377\17\16\16\377\14\14\13\377\32\34\36\377\17\20\20"
	  "\377\14\15\15\377&')\377\15\15\16\377\30\32\33\377\33\35\36\377\35\36!\377"
	  "\14\14\15\377\14\15\15\377\23\25\26\377\12\12\12\377\7\10\7\377\14\14\15"
	  "\377\13\15\16\377\7\10\7\377\10\7\7\377\13\14\13\3777;?\377(*.\377\14\16"
	  "\16\377\13\15\15\377\21\22\23\377\20\21\21\377',.\377\34\37#\377\13\14\15"
	  "\377\10\10\10\377\10\11\11\377&)+\377\22\22\24\377\10\10\10\377\14\15\16"
	  "\377\11\12\12\377\37!\"\377\13\14\14\377\15\16\17\377\32\35\36\377\17\20"
	  "\20\377&')\377\17\20\22\377\11\11\11\377\13\14\14\377\16\20\20\377\10\12"
	  "\11\377.14\377\16\20\21\377\16\17\21\377\31\34\36\377<@C\377\12\12\12\377"
	  "59<\376\14\14\15\377\12\14\13\377\12\13\12\377\15\15\16\377\11\12\11\377"
	  "\24\30\27\377\17\20\20\377\14\15\15\377%)+\377\13\15\14\377\17\21\22\377"
	  "\12\12\12\377\15\17\17\377\31\35\37\377\27\32\34\377\14\16\15\377\202\6\7"
	  "\6\377\6\15\16\17\377\12\13\13\377\12\15\15\377\26\31\33\377\10\12\11\377"
	  "\17\22\22\377\202\7\10\10\377\37\11\13\12\377\14\16\16\377\13\15\16\377\17"
	  "\20\21\377\30\31\32\377\11\11\11\377\27\31\32\377\12\15\15\377168\377+-0"
	  "\377\21\21\22\377259\377\14\14\14\377\5\6\6\377\6\7\7\377\6\10\10\377\7\11"
	  "\11\377\11\12\11\377\6\7\7\377\13\14\16\377\25\31\34\377\14\16\16\377\23"
	  "\25\25\377\26\27\27\377()+\377\10\10\11\377\7\7\7\377\16\20\20\377\11\12"
	  "\11\377\13\15\16\377\14\15\15\377\202\7\7\7\377m\20\22\23\377\34\37!\377"
	  "\30\34\36\377\16\17\20\377\11\13\12\377\6\7\6\377\11\12\11\377\11\11\11\377"
	  "\20\22\22\377147\377\16\16\17\377\11\11\11\377#$'\377\13\12\11\377\14\14"
	  "\14\377\13\13\14\377\21\21\23\377\27\30\31\377%')\377\21\20\21\37736:\377"
	  "\15\15\15\377\31\33\34\377\14\16\16\377\11\12\12\377\11\11\12\377\10\11\11"
	  "\377\10\10\10\377\12\14\15\377\30\33\35\377\6\7\7\377\7\7\6\377\10\10\10"
	  "\377\7\7\7\377\10\10\10\377\12\13\14\377\11\11\11\377\32\33\36\377\27\32"
	  "\34\377\11\11\12\377\14\16\16\377\36%$\377\24\26\30\377\10\10\10\377\13\14"
	  "\15\377\13\15\16\377\16\21\22\377\21\22\23\377\15\15\15\377\10\10\10\377"
	  "\25\27\31\377ORW\377!\"&\377\10\12\13\377\12\15\16\377\17\21\22\377\16\16"
	  "\17\377\13\14\14\377\22\24\25\377\10\11\12\377\24\26\26\377\15\17\17\377"
	  "HLQ\377$&)\377\12\14\14\377\14\15\15\377\17\21\22\377\11\13\13\377\21\24"
	  "\24\376\14\15\14\377\13\16\15\377\32\33\35\377\14\14\13\377\40$%\377\26\31"
	  "\32\377\35\35\36\377\11\13\12\377\14\15\15\377#&(\377\40\40!\377\12\14\14"
	  "\377\14\15\15\377\"&)\377.14\377\6\7\6\377\7\7\7\377\17\21\22\377\6\7\7\377"
	  "\30\32\34\377\12\13\12\377\12\12\13\377\12\13\14\377\7\10\7\377\12\15\14"
	  "\377\15\17\17\377\10\10\7\377\13\15\15\377\12\12\12\377\10\10\10\377\11\12"
	  "\12\377\16\21\20\377\16\17\17\377\23\30\31\377\26\31\31\377\16\16\16\377"
	  "\16\21\20\377\35\36!\377\30\32\33\377\10\10\7\377\202\12\13\14\377\10\11"
	  "\13\13\377\15\17\16\377\7\10\11\377\31\36\37\377\12\14\14\377\13\15\15\377"
	  "\12\14\14\377\10\12\12\377\202\10\11\11\377S\11\14\14\377\13\15\15\377\23"
	  "\25\27\377\10\10\10\377\24\25\27\377**.\377\20\22\22\377\14\16\16\377\33"
	  "\36\40\377\33\34\35\377\12\13\12\377\11\12\11\377\10\10\10\377\11\11\10\377"
	  "\22\22\24\377\17\21\22\377\24\26\26\377=@D\377\16\20\20\377\10\10\7\377&"
	  ")+\377()+\377\"\"&\377\11\11\11\377\20\21\22\377\10\11\11\377\26\26\27\377"
	  "\11\10\7\377\14\14\13\377\13\13\13\377\12\12\12\377\10\10\10\377\10\7\7\377"
	  "\11\12\12\377\11\11\11\377\24\25\26\377\25\26\27\377\6\6\6\377\6\7\7\377"
	  "\14\15\15\37745;\377\14\15\16\377\6\7\7\377\12\14\15\377\10\11\10\377\17"
	  "\21\20\377128\377\11\13\14\377\21\30\27\377\21\24\25\377\12\14\15\377\12"
	  "\13\13\377\13\14\15\377\7\10\7\377\40#%\377\27\31\33\377)-/\377\16\20\21"
	  "\377),0\377&)-\377\34\35!\377\13\13\14\377\11\11\12\377\10\11\11\377\22\24"
	  "\24\377\24\27\31\377\13\15\15\377\15\17\17\377\34\36\40\377\34\37!\377(,"
	  "0\377\13\15\15\377\7\7\7\377\12\11\12\377\40\"&\377\24\27\30\376\12\13\13"
	  "\377\13\16\16\377\10\11\11\377\15\20\20\377GKQ\377\37\40!\377\11\11\10\377"
	  "\202\15\17\17\377\177\11\12\11\377\14\15\15\377\10\11\11\377\32\34\36\377"
	  "\10\12\12\377\7\10\7\377\10\12\12\377\13\15\15\377\10\12\11\377\13\14\14"
	  "\377\7\7\7\377\23\24\25\377\16\21\21\377\12\14\15\377\26\31\32\377\13\15"
	  "\15\377\20\22\23\377\33\34\35\377\7\7\7\377\10\10\10\377\10\10\7\377\10\10"
	  "\10\377'*-\377\14\15\15\377\31\34\35\377\17\22\21\377\23\24\25\377\35!$\377"
	  "\11\11\10\377\7\10\10\377\21\24\25\377\37\"%\377\20\22\22\377\12\13\13\377"
	  "\26\30\31\377\15\17\20\377\22\23\25\377\7\11\11\377\10\12\11\377\10\11\11"
	  "\377\13\14\15\377\40#%\377\7\10\7\377\35!#\377\21\23\24\377\10\7\7\377\10"
	  "\11\10\377\17\21\21\377/23\377\30\31\33\377\20\22\21\377\12\12\12\377\17"
	  "\22\23\377\21\23\22\377\7\7\7\377\12\13\14\377\27\31\31\377\27\33\33\377"
	  "\10\12\12\377\36\40#\37759=\377\14\13\14\377\27\32\32\377\14\14\15\377\20"
	  "\20\21\377\12\13\12\377*-.\377\11\11\10\377\14\13\12\377\13\12\11\37759:"
	  "\377\15\15\15\377\15\16\20\377\13\13\13\377\22\25\26\377\17\21\22\377\11"
	  "\12\12\377\21\23\24\377\12\13\14\377\7\7\6\377\11\12\13\377\15\15\16\377"
	  "\16\17\21\377\15\17\20\377\16\16\20\377\15\16\16\377\20\22\23\377\13\14\16"
	  "\377\27\31\34\377\16\21\22\377369\377\5\13\7\377\12\14\13\377\22\24\25\377"
	  "\20\22\23\377\11\12\13\377\15\17\20\377\20\22\24\377\16\17\21\377359\377"
	  "!%'\377\12\13\14\377\15\16\20\377\17\21\21\377\12\12\13\377\15\15\16\377"
	  "\30\33\34\377\40$&\377\13\13\14\377(-1\377\36!$\377\14\15\16\377\21\24\25"
	  "\377\22\22\23\377\12\14\15\377\11\12\12\377\7\10\7\377\10\11\11\377\37\""
	  "$\376,/1\377\12\14\14\377\16\17\17\377\15\17\17\377\23\23\24\377\12\13\13"
	  "\377\14\15\15\377\10\11\11\377\27\11\12\11\377\20\23\24\377\20\20\21\377"
	  "\32\34\36\377\10\10\10\377\7\11\11\377\6\7\6\377\12\15\15\377\13\14\14\377"
	  "\12\14\15\377\6\7\7\377\31\33\33\377\12\14\14\377\7\10\10\377\20\21\22\377"
	  "\14\15\14\377\25\31\32\377\17\23\23\377\6\7\6\377\12\13\13\377\7\10\7\377"
	  "\7\7\7\377\11\11\10\377\202\12\13\13\377\177\22\23\24\377\23\24\25\377\34"
	  "\36\37\377\7\10\7\377\10\12\11\377\30\33\35\377\12\14\14\377&*-\377\12\13"
	  "\13\377\6\7\6\377\31\34\36\377\14\15\16\377\7\10\10\377\10\11\11\377\25\26"
	  "\30\377\24\27\30\377+-1\377\16\17\20\377\36\"$\377\14\15\16\377\12\13\13"
	  "\377\13\14\15\377\12\13\14\377\20\22\23\377\32\34\35\377:>B\377\11\11\11"
	  "\377\10\11\10\377\23\26\30\377\14\15\15\377\10\11\11\377)./\377?CH\377\11"
	  "\13\13\377$(*\377\11\11\11\377\10\10\11\377\30\32\33\377\20\21\22\377\13"
	  "\15\15\377\11\10\7\377\26\30\31\377\23\26\26\377\16\17\17\377\30\32\34\377"
	  "\22\24\25\377\14\14\14\377\24\26\30\377\13\14\13\377\15\15\16\377\12\12\12"
	  "\377\17\21\21\377\16\17\21\377\16\16\16\377\10\10\10\377\10\7\7\377\13\13"
	  "\13\377\22\24\25\377\11\12\12\377\11\13\13\377\22\23\25\377\37!%\377\6\6"
	  "\6\377\12\14\15\377\6\10\10\377\7\10\10\377\7\7\7\377\13\21\16\377\40#%\377"
	  "\20\17\20\377\23\25\30\377\17\17\17\377\13\15\15\377\12\12\13\377\13\14\15"
	  "\377\13\13\14\377\27\31\32\377\27\33\35\377\21\23\26\377\15\15\16\377\15"
	  "\20\21\377/27\377\31\35\40\377\34\40!\377AEH\377\13\14\15\377\21\22\24\377"
	  "\23\25\26\377\12\14\14\377\16\17\20\377\6\7\6\377\22\24\25\377\7\7\7\377"
	  "\13\13\13\377*-/\376\13\12\12\377\20\23\24\377\17\21\22\377\10\10\10\377"
	  "\11\11\7\377\30\33\35\377\17\22\23\377\16\20\17\377\16\20\20\377\20\21\22"
	  "\377$%(\377\10\11\12\377\7\7\10\377\7\10\7\377\25\32\32\377\11\13\12\377"
	  "\23\24\25\377\12\12\12\377\11\12\12\377\12\13\13\377\11\12\12\377\13\13\14"
	  "\377\13\15\15\377\21\24\25\377\32\34\36\377\11\12\13\377\12\13\13\377\13"
	  "\14\14\377\11\11\12\377\10\11\10\377\11\12\11\377\11\13\13\377k\7\10\6\377"
	  "$%(\377\17\21\22\377\11\12\11\377\12\14\15\377\21\22\23\377\33\35\36\377"
	  "\16\17\20\377\7\10\10\377\10\13\12\377\14\17\20\377\6\6\6\377\14\15\15\377"
	  "\10\12\12\377\10\7\10\377\12\13\13\377\21\23\23\377\20\21\21\377\10\11\11"
	  "\377\10\12\12\377\26\32\33\377\23\26\26\377\37#&\377\22\24\25\377\14\16\15"
	  "\377\16\21\21\377\12\12\11\377\13\15\16\377\"%'\377\21\22\22\377\13\13\12"
	  "\377\31\33\35\377\10\11\11\377\7\10\10\377\20\21\23\377\7\10\7\377)//\377"
	  "\13\14\13\377\14\16\16\377\13\15\15\377\7\10\7\377\10\10\10\377\11\12\11"
	  "\377\11\11\10\377\17\20\20\377\22\24\25\377\21\22\23\377\13\14\14\377\15"
	  "\16\16\377\12\14\15\377\11\12\11\377\12\12\11\377\40\"$\377\23\24\26\377"
	  "\12\12\12\377\10\11\11\377\21\23\24\377\21\21\23\377\15\16\17\377\15\15\16"
	  "\377\10\11\12\377\11\13\14\377\15\15\15\377\12\13\14\377\7\7\10\377\11\11"
	  "\12\377\10\10\10\377\13\15\16\377\17\27\24\377\17\21\22\377\36\40#\377\20"
	  "\21\22\377\27\32\34\377\10\11\11\377\14\15\15\377\27\30\33\377\24\27\32\377"
	  "\21\22\22\377(*/\377\11\12\12\377\13\14\14\377\16\21\23\377\35\40#\377\22"
	  "\24\26\377\31\33\34\377!$%\377#&(\377\14\16\17\377\22\23\25\377\35\40\"\377"
	  "\37\"#\377\20\22\23\377\14\15\16\377\25\27\30\377\24\30\31\377\20\22\21\376"
	  "\16\21\17\37789=\377\21\22\22\377\31\32\33\377\12\13\13\377\13\15\14\377"
	  "\20\22\22\377\27\30\31\377\7\10\10\377\14\16\16\377\10\10\7\377\202\7\10"
	  "\7\377'\7\10\10\377\26\32\32\377LNS\377\11\12\11\377\25\31\33\377\37\37\""
	  "\377\12\14\13\377\11\13\12\377\12\14\14\377\10\10\10\377\11\13\12\377\11"
	  "\12\11\377\10\11\10\377\12\13\13\377\7\10\10\377\11\12\12\377\13\15\15\377"
	  "\12\13\13\377\7\7\7\377\10\11\10\377\11\13\13\377\12\13\13\377\17\21\21\377"
	  "\32\35\40\377\34\36\40\377\11\12\12\377\23\25\26\377\10\12\12\377\13\14\14"
	  "\377\10\12\11\377\24\27\27\377\11\12\12\377\10\11\12\377\20\22\24\377\15"
	  "\17\20\377\15\15\16\377\7\10\10\377\13\14\14\377\14\14\14\377\202\7\10\10"
	  "\377\7\7\10\7\377\14\14\15\377\11\12\12\377\7\7\6\377\10\10\7\377\10\11\10"
	  "\377\14\15\15\377\202\7\7\7\3773\10\12\12\377\15\16\16\377\14\15\16\377\13"
	  "\14\14\377!#&\377\15\17\17\377\20\23\23\377\10\11\10\377\10\11\11\377\11"
	  "\12\11\377\33\36\40\377\35\36\40\377\34\36\37\377\24\26\30\377\35\40#\377"
	  "\34\37!\377\22\25\26\377\13\13\13\377\14\16\16\377\25\27\30\377),/\377\10"
	  "\11\11\377\11\10\10\377\22\22\23\377\30\33\35\377\15\16\17\377\26\30\32\377"
	  "\10\10\11\377\15\16\16\377\12\13\13\377\10\11\11\377\37\"%\377\13\14\15\377"
	  "\14\15\15\377\11\12\12\377\17\22\23\377\15\16\20\377\15\24\21\377\15\17\17"
	  "\377)/2\377\24\26\30\377\13\14\15\377!#&\377\11\12\12\377\30\31\33\377\36"
	  "\37\"\377\13\14\14\377\20\21\22\377$'*\377\10\11\11\377\16\17\20\377\202"
	  "\11\12\12\377\3\14\14\15\377\16\17\17\377\10\12\13\377\202\12\13\13\377>"
	  "FIN\377%'+\377\7\7\10\377-/3\377*+/\377\32\36\37\377\32\35\36\3765:=\377"
	  "\35\40\"\377\14\16\15\377-/2\377\13\15\15\377\10\10\10\377\13\14\13\377\11"
	  "\12\11\377\12\12\11\377\6\6\5\377\12\13\14\377\10\11\10\377\7\11\11\377\12"
	  "\14\14\377\20\22\22\377\16\21\21\377\33\37\40\377\13\13\12\377\13\15\15\377"
	  "\10\12\11\377\23\26\27\377\21\22\24\377\7\7\7\377\12\14\14\377\11\13\11\377"
	  "\10\11\10\377\10\11\12\377\13\14\15\377\10\11\11\377\6\7\6\377\7\7\6\377"
	  "\12\13\13\377\10\11\11\377\11\11\11\377\12\12\11\377\34\40\"\377\36\40#\377"
	  "\11\12\11\377\15\16\17\377\13\15\15\377\10\11\11\377\11\12\12\377\11\13\14"
	  "\377\27\31\33\377\10\11\11\377\16\21\22\377049\377\32\33\34\377\10\10\10"
	  "\377\37#%\377\31\33\35\377\15\17\17\377\27\32\33\377\32\33\34\377\14\16\17"
	  "\377\202\11\11\11\377`\12\13\12\377\22\22\24\377\7\7\10\377\10\10\10\377"
	  "\11\12\12\377\17\20\21\377\10\10\10\377\13\13\13\377\12\11\11\377\14\16\16"
	  "\377\24\25\25\377\7\7\6\377\21\22\23\377\7\10\10\377\6\7\7\377\7\10\10\377"
	  "\6\7\7\377\11\13\12\377\11\13\13\377\10\11\10\377\11\11\12\377\10\11\11\377"
	  "\12\14\14\377\13\15\16\377\7\7\6\377\15\17\21\377\10\11\11\377\7\7\6\377"
	  "\10\7\7\377\22\24\25\377\21\23\24\377\16\20\21\377\10\10\10\377\11\11\12"
	  "\377\12\14\15\377\32\33\36\377\"%)\377\11\13\14\377\12\14\14\377\31\34\36"
	  "\377\7\11\11\377\36\"#\377\13\15\15\377\5\15\10\377\33\35\37\377\31\33\36"
	  "\377\31\34\36\377\13\14\16\377\36!$\377\12\13\13\377\16\16\17\377\13\14\15"
	  "\377\24\25\26\377\32\34\35\377BGL\377\11\12\12\377\14\14\15\377\15\16\17"
	  "\377%&)\377\13\15\16\377\34\36!\377\12\13\13\377\23\25\27\377'(+\377\7\11"
	  "\11\377+.2\377\14\15\16\377148\377\31\35\37\377;>B\377\15\16\16\376\16\21"
	  "\21\377\13\16\16\377\30\33\35\377\7\11\10\377\25\25\27\377\26\31\33\377\12"
	  "\12\12\377\7\7\6\377\10\12\11\377\20\21\22\377\10\10\10\377\12\14\14\377"
	  "\13\13\14\377-14\377\13\14\14\377\23\26\26\377$&(\377\13\16\16\377\7\10\10"
	  "\377\13\14\14\377\17\17\21\377\30\33\35\377\16\21\21\377\10\10\7\377\11\13"
	  "\12\377\202\12\13\13\377'\10\10\7\377\11\10\10\377\10\10\7\377\7\7\7\377"
	  "\22\25\26\377\13\12\12\377\6\6\6\377\27\32\34\377\34\36\40\377\13\14\15\377"
	  "\12\13\13\377\10\11\10\377\13\13\13\377\11\13\13\377\11\13\12\377\15\17\21"
	  "\377\11\12\11\377\17\21\21\377\16\21\23\377\11\13\14\377\12\13\14\377\17"
	  "\21\21\377\14\16\17\377\13\14\13\377\14\15\15\377\11\13\12\377\22\25\25\377"
	  "\23\25\27\377\22\23\23\377\11\12\12\377\6\6\6\377\7\7\7\377\6\7\7\377\6\6"
	  "\6\377\5\7\6\377\6\10\7\377\6\6\6\377\5\6\5\377\7\11\10\377\202\5\5\5\377"
	  "\177\5\6\6\377\5\5\5\377\6\7\7\377\6\6\5\377\11\10\10\377\7\10\7\377\11\12"
	  "\12\377\10\11\11\377\7\11\10\377\10\10\10\377\14\15\15\377\10\11\10\377\11"
	  "\12\12\377\14\14\16\377\10\10\7\377\11\12\12\377\11\11\11\377\17\20\20\377"
	  "+03\377+.2\377\24\25\25\377\20\21\21\377\17\17\20\377\12\12\12\377\30\32"
	  "\34\377\20\21\22\377\11\10\10\377\16\20\20\377\14\17\20\377\10\12\11\377"
	  "\17\21\22\377\11\11\11\377\10\17\14\377\13\15\15\377\25\26\27\377\30\32\34"
	  "\377\31\32\35\377\10\11\12\377\13\14\16\377\11\11\11\377\10\10\10\377\23"
	  "\25\27\377\21\24\26\377\7\7\10\377\12\15\15\377\40!$\377\11\12\13\377\16"
	  "\20\20\377\12\14\14\377\6\7\7\377\12\14\15\377\11\14\15\377\10\11\11\377"
	  "\23\24\25\377\17\20\21\377(,1\377\26\30\31\377.25\377\22\22\24\377\34\40"
	  "!\376\23\25\27\377\17\21\22\377\13\15\15\377279\377\21\25\26\377'*,\377\12"
	  "\13\13\377\14\15\15\377\12\14\14\377\7\11\10\377\21\21\21\377\7\10\7\377"
	  "\14\16\17\377\11\10\10\377\40#'\377\30\31\33\377\7\7\7\377\10\11\11\377\7"
	  "\10\10\377\10\11\10\377\20\24\25\377\14\15\15\377\13\15\15\377\11\12\12\377"
	  "\10\11\10\377\15\20\20\377\33\34\37\377\11\11\10\377\13\14\14\377\15\16\17"
	  "\377$(*\377\22\24\24\377\13\14\14\377\10\12\11\377\15\16\16\377\12\13\12"
	  "\377\7\10\7\377\7\10\10\377\11\12\12\377\12\12\13\377\13\14\13\377\30\31"
	  "\34\377\10\11\11\377\16\17\20\377\27\35\36\377\22\24\27\377\21\22\25\377"
	  "'),\377\30\33\34\377\12\13\13\377\24\26\27\377\25\30\30\377\12\14\13\377"
	  "\16\17\20\377\10\11\10\377\10\10\10\377\6\10\7\377\6\6\6\377\10\12\12\377"
	  "\24\27\27\377+-0\377\7\11\11\377\6\7\7\377\14\16\16\377\11\12\11\377\5\6"
	  "\5\377\7\10\10\377\177\15\20\21\377\10\10\10\377\15\16\20\377\12\13\13\377"
	  "\21\22\23\377\6\7\7\377\27\31\32\377\10\10\11\377\10\10\10\377\7\7\7\377"
	  "\5\6\6\377\6\6\6\377\11\13\14\377\13\13\13\377\33\36\37\377\7\6\7\377\12"
	  "\12\12\377\10\11\11\377\15\16\16\377\20\21\22\377\16\16\20\377\14\17\20\377"
	  "\10\12\12\377\6\7\7\377\7\10\10\377\10\11\11\377\5\6\6\377\16\21\21\377\11"
	  "\12\13\377\37\"#\377\20\22\23\377\17\20\21\377!$'\377\5\16\11\377\14\16\17"
	  "\377\22\24\25\377\34\36!\377+.1\377\23\25\27\377\14\16\20\377\10\11\12\377"
	  "\16\21\22\377\12\13\13\377\7\10\10\377\12\13\13\377\14\15\16\377\21\21\23"
	  "\377\14\15\16\377\13\14\14\377\11\12\12\377$+,\377\11\11\12\377\11\12\13"
	  "\377\15\17\20\377,03\377137\377\25\27\27\377%'+\377\24\26\30\377\21\24\26"
	  "\377+/1\376\16\20\20\377\23\26\26\377\20\23\23\377\33\37\40\377#$'\377\10"
	  "\11\10\377\14\16\16\377\31\33\36\377\21\22\23\377\20\21\21\377\14\16\15\377"
	  "\14\15\16\377\10\10\10\377\13\13\13\377\7\10\7\377\7\10\10\377\16\20\20\377"
	  "\7\11\11\377\16\17\20\377\33\35\40\377\24\26\30\377\14\16\15\377\10\11\10"
	  "\377\11\13\12\377\11\12\12\377\30\31\32\377\11\12\12\377\11\11\10\377\15"
	  "\17\20\377\11\12\12\377\23\27\25\377\16\20\21\377\11\13\14\377\22\25\26\377"
	  "\12\13\12\377\14\14\14\377\13\15\14\377\14\15\15\377\10\11\10\377\21\23\25"
	  "\377\16\21\21\377\14\13\13\377\33\35\37\377\40\"#\377\11\12\12\377\31\35"
	  "\37\377\12\12\13\377\7\11\10\377\10\11\11\377\10\10\10\377\10\11\10\377\14"
	  "\16\16\377\12\14\14\377\13\15\15\377\12\13\13\377\7\10\7\377\10\11\11\377"
	  "\7\7\7\377\16\20\21\377\7\7\6\377\6\7\7\377\6\7\6\377\7\7\7\377\12\14\13"
	  "\377\10\10\10\377\6\7\7\377D\7\10\10\377\15\20\20\377\17\21\22\377\11\12"
	  "\13\377\31\32\33\377\15\20\21\377\11\13\13\377\7\10\10\377\11\12\12\377\12"
	  "\14\13\377\12\13\13\377\11\13\14\377\10\7\7\377\11\11\12\377\13\13\13\377"
	  "\7\10\7\377\7\10\10\377\7\7\7\377\7\10\10\377\10\10\10\377\14\14\14\377\14"
	  "\16\16\377\6\7\7\377\10\10\10\377\11\11\12\377\7\10\7\377\7\7\7\377\7\10"
	  "\10\377\7\6\7\377\6\7\10\377\20\21\21\377\15\16\16\377\15\17\20\377\6\10"
	  "\10\377\10\20\14\377\12\13\14\377\14\15\16\377\13\14\14\377\12\12\12\377"
	  "\13\16\16\377\16\17\20\377\15\16\17\377\10\11\11\377\12\11\12\377\7\7\7\377"
	  "\24\24\25\377\13\13\14\377\11\12\12\377\16\17\21\377\10\12\13\377\16\16\17"
	  "\377\7\10\11\377\12\13\14\377\10\10\10\377\13\14\15\377\23\25\27\377\"#'"
	  "\377\24\30\31\377\25\26\30\377\14\15\16\377\13\16\16\377\26\32\32\376\40"
	  "#%\377\13\15\14\377\20\23\23\377\36!#\377\11\13\13\377\12\13\13\377\202\12"
	  "\14\13\377\7\12\12\12\377\14\14\14\377\15\15\16\377\25\27\27\377\33\37\40"
	  "\377\12\14\13\377\10\11\11\377\202\14\15\15\3776\13\13\14\377\15\16\16\377"
	  "\14\17\20\377\11\12\12\377\7\10\7\377\11\11\10\377\10\11\10\377\10\11\11"
	  "\377\11\14\14\377\10\12\11\377\15\17\17\377\27\32\32\377\21\23\24\377\21"
	  "\23\23\377\11\13\13\377\16\17\20\377\6\6\6\377\5\5\5\377\4\4\4\377\6\7\6"
	  "\377\5\5\5\377\23\24\25\377\22\24\25\377\17\20\21\377\25\27\31\377\23\25"
	  "\27\377\22\25\26\377\25\31\32\377\36\40#\377\23\26\31\377\21\22\24\377\11"
	  "\13\13\377$%)\377\15\16\16\377\16\20\21\377\14\15\15\377\10\12\12\377\7\11"
	  "\11\377\7\10\7\377\17\22\23\377\10\11\11\377\14\14\15\377\11\13\12\377\7"
	  "\7\7\377\33\36\40\377%'*\377\6\6\5\377\12\13\13\377\12\13\14\377\21\22\24"
	  "\377\7\11\11\377\1\1\1\377\3\2\2\377\2\2\2\377\202\3\3\3\377\5\2\3\2\377"
	  "\2\2\2\377\6\6\7\377\4\4\4\377\2\3\2\377\202\2\2\2\377\202\3\3\3\377\1\4"
	  "\4\4\377\202\2\2\2\377\1\1\2\2\377\202\2\2\2\377\7\2\2\3\377\2\2\2\377\2"
	  "\3\3\377\1\2\2\377\1\1\2\377\2\2\2\377\3\4\4\377\202\13\14\15\377F\6\7\10"
	  "\377\4\5\4\377\3\4\3\377\3\11\6\377\10\12\12\377\23\24\26\377\10\11\11\377"
	  "\16\20\21\377\7\10\10\377\11\13\14\377\6\6\6\377\4\4\4\377\4\5\5\377\3\4"
	  "\5\377\5\5\5\377\7\7\10\377\5\5\5\377\6\6\6\377\34\34\37\377\6\7\7\377\7"
	  "\7\10\377\11\12\12\377\5\6\6\377\11\13\13\377\14\17\20\377\17\21\21\377\16"
	  "\16\16\377%'*\377\21\24\26\377\11\13\14\37727:\376013\377\10\12\11\377\14"
	  "\15\15\377\10\11\10\377\23\23\24\377\13\16\16\377+/2\377\14\16\15\377\13"
	  "\14\14\377\21\22\23\377\15\16\16\377-14\377\13\15\15\377\11\12\12\377\6\6"
	  "\5\377\5\6\6\377\7\7\7\377\10\12\11\377\10\11\10\377\11\13\13\377\10\10\11"
	  "\377\16\20\21\377\13\15\15\377\14\17\17\377\13\16\16\377\13\15\14\377\30"
	  "\34\36\377\12\12\13\377\10\12\12\377\2\2\3\377\0\0\0\377\3\3\3\377\20\20"
	  "\21\377\40\40!\377'')\377%&'\377\35\36\37\377\15\15\15\377\1\1\1\377\202"
	  "\0\0\0\377\6\14\16\16\377\6\6\6\377\35!#\377\25\30\33\377\26\31\34\377\22"
	  "\23\26\377\202\11\12\12\377\35\12\12\12\377\16\17\17\377\13\14\13\377\25"
	  "\27\30\377\10\12\12\377\11\12\12\377\13\16\15\377\13\15\15\377\15\16\16\377"
	  "\14\14\14\377\10\10\7\377\13\15\15\377\12\14\14\377\10\7\7\377\6\7\6\377"
	  "\7\10\10\377\27\32\34\377\21\22\22\377\0\0\0\377LMN\377deg\377ddg\377eeg"
	  "\377cdg\377deg\377deh\377ceg\377cdg\377ceg\377\202deh\377\22ddf\377deh\377"
	  "dfh\377deg\377dfh\377efi\377efh\377dfh\377eeh\377efi\377efh\377efi\377eg"
	  "i\377fgi\377;<=\377\5\6\6\377\5\6\7\377\26\27\27\377\204'()\377\1(()\377"
	  "\205'()\377\1(()\377\204'()\377\1(()\377\202'()\377\2''(\377(()\377\202'"
	  "()\377)()*\377\4\4\4\377\16\17\20\377\17\20\21\377\27\32\33\377\13\14\14"
	  "\377\16\16\17\377\20\21\20\376\15\16\16\377%'*\377\10\13\13\377\13\15\15"
	  "\377\20\23\24\37758=\377\12\14\13\377\16\16\17\377\27\31\31\377\11\11\10"
	  "\377\40%&\377\22\24\24\377\12\12\11\377\13\15\14\377\36!\"\377\13\16\16\377"
	  "\31\34\35\377\11\12\12\377\12\13\13\377\12\12\12\377\13\14\14\377\13\15\15"
	  "\377\14\16\15\377\7\7\6\377\5\5\4\377\0\0\0\377\6\7\7\377=>?\377xxz\377\247"
	  "\250\253\377\317\321\324\377\347\352\357\377\362\365\371\377\202\363\365"
	  "\371\377\21\361\364\370\377\357\362\367\377\357\361\366\377\342\344\347\377"
	  "\303\305\311\377\231\233\236\377hik\377,-/\377\2\2\2\377\6\7\7\377\4\4\4"
	  "\377\10\11\12\377\11\12\13\377\7\12\11\377\10\11\11\377\10\10\7\377\7\10"
	  "\10\377\202\6\7\7\377\20\5\6\5\377\10\10\10\377\13\13\12\377\13\13\13\377"
	  "\7\7\7\377*.0\377\16\20\20\377\7\11\12\377\12\13\14\377\6\7\7\377\12\15\16"
	  "\377\12\14\14\377\35\37!\377\0\0\0\377\261\263\270\377\352\354\361\377\202"
	  "\351\353\360\377\5\350\353\361\377\350\353\360\377\350\352\360\377\351\354"
	  "\362\377\350\352\360\377\203\351\353\361\377\1\351\352\360\377\202\351\354"
	  "\361\377\6\352\355\362\377\353\355\363\377\353\355\362\377\353\356\363\377"
	  "\353\355\363\377\352\355\362\377\202\354\356\363\377\10\354\356\364\377\355"
	  "\357\364\377\355\357\363\377\213\214\217\377\1\1\1\377\1\1\2\377\212\213"
	  "\216\377\357\361\366\377\202\357\362\367\377\15\360\363\367\377\357\362\367"
	  "\377\360\363\370\377\357\361\366\377\356\361\366\377\360\363\370\377\361"
	  "\363\367\377\357\362\367\377\357\362\366\377\360\362\366\377\357\361\366"
	  "\377\357\361\367\377\361\362\367\377\202\357\362\367\377/\356\362\367\377"
	  "\361\364\370\377\361\363\370\377\361\364\370\377\177\200\202\377\0\0\0\377"
	  "\14\13\14\377\13\13\15\377\14\15\16\377\20\23\25\377\37#&\377\21\23\23\376"
	  "\16\20\20\377\25\30\31\37759=\377\22\25\25\377\27\32\34\377\34\35\37\377"
	  "\12\13\13\377\16\20\17\377\14\16\15\377!#%\377\24\26\27\377\10\11\10\377"
	  "\13\15\15\377\17\20\20\377\15\17\17\377./1\377\10\11\11\377\14\14\13\377"
	  "\13\14\14\377\20\21\21\377\16\20\21\377\11\12\11\377\1\1\1\377\5\6\6\377"
	  "OOQ\377\244\245\250\377\351\352\355\377\364\366\372\377\362\365\371\377\362"
	  "\364\371\377\361\364\371\377\361\363\370\377\360\362\370\377\360\362\367"
	  "\377\357\361\366\377\202\356\361\366\3776\355\360\365\377\355\357\363\377"
	  "\355\357\364\377\355\360\365\377\355\357\365\377\356\361\366\377\327\331"
	  "\337\377\214\216\221\377889\377\1\1\1\377\2\2\1\377\11\11\11\377\10\10\7"
	  "\377\7\7\7\377\6\7\6\377\7\7\7\377\11\12\13\377\21\22\23\377\14\15\15\377"
	  "\7\11\11\377\10\10\7\377!#&\377\31\33\34\377\11\12\12\377\22\24\24\377\6"
	  "\7\7\377\10\10\7\377\10\12\12\377&),\377\7\7\7\377\0\0\0\377\262\264\271"
	  "\377\351\352\357\377\352\354\361\377\351\353\361\377\350\352\360\377\350"
	  "\353\360\377\350\353\361\377\347\353\360\377\351\353\360\377\351\354\362"
	  "\377\351\354\361\377\351\353\360\377\350\352\357\377\350\354\362\377\352"
	  "\356\362\377\352\354\362\377\352\353\360\377\353\354\362\377\353\355\363"
	  "\377\352\355\363\377\351\354\362\377\354\357\363\377\353\356\363\377\202"
	  "\353\355\363\377\2\355\357\364\377\213\214\217\377\202\1\1\1\377\1\211\212"
	  "\215\377\202\354\357\364\377\12\356\360\365\377\354\357\364\377\355\357\364"
	  "\377\355\357\365\377\354\357\364\377\354\356\364\377\354\356\363\377\356"
	  "\360\366\377\355\357\365\377\354\357\364\377\202\355\360\365\377\204\356"
	  "\360\365\377$\355\360\366\377\356\360\365\377\357\362\367\377{{~\377\0\0"
	  "\0\377\11\12\13\377\14\15\16\377\12\12\13\377\23\25\26\377\33\34\36\377\11"
	  "\12\12\377\11\13\12\376\11\11\12\377\27\32\33\377\23\26\27\377@EG\377\14"
	  "\15\16\377\13\14\13\377\21\23\23\377\14\14\14\377\25\30\32\377\20\20\20\377"
	  "\15\14\12\377\11\12\11\377\14\14\14\377\12\12\11\377\12\13\13\377\12\13\12"
	  "\377\12\12\12\377\16\20\20\377\13\14\13\377\7\10\7\377\1\1\1\377\22\22\23"
	  "\377}}\177\377\337\341\344\377\202\364\366\372\377\4\363\365\371\377\363"
	  "\364\371\377\361\364\371\377\361\363\370\377\202\360\363\370\377\1\357\362"
	  "\367\377\202\360\362\367\377\3\356\361\366\377\360\362\367\377\356\360\365"
	  "\377\202\355\357\364\377<\354\357\365\377\356\357\365\377\355\357\365\377"
	  "\354\357\365\377\354\357\364\377\356\360\365\377\306\310\313\377_`b\377\6"
	  "\6\6\377\1\1\1\377\5\5\5\377\7\10\10\377\10\11\11\377\6\7\7\377\33\36\40"
	  "\377\10\12\11\377\14\14\13\377\12\13\13\377\11\12\11\377\10\11\11\377\23"
	  "\25\25\377\5\6\6\377\10\10\10\377\26\30\31\377\30\32\34\377\7\10\10\377\10"
	  "\10\11\377\0\0\0\377\261\264\270\377\351\353\360\377\351\353\361\377\350"
	  "\353\361\377\350\353\360\377\351\354\361\377\351\353\361\377\350\353\361"
	  "\377\352\354\363\377\351\354\361\377\350\352\357\377\351\353\361\377\351"
	  "\354\362\377\350\354\361\377\352\355\362\377\352\353\357\377\352\355\362"
	  "\377\351\353\360\377\352\354\362\377\353\355\363\377\353\356\363\377\353"
	  "\355\363\377\351\354\362\377\351\354\361\377\352\355\363\377\352\355\362"
	  "\377\212\213\216\377\1\1\2\377\1\1\1\377\212\213\216\377\355\360\364\377"
	  "\354\357\364\377\202\355\357\365\377\6\355\357\364\377\355\357\365\377\354"
	  "\356\364\377\354\357\364\377\355\360\365\377\357\361\366\377\202\356\360"
	  "\365\377\13\355\360\365\377\354\357\364\377\355\360\365\377\356\360\365\377"
	  "\355\360\365\377\356\360\366\377\355\360\366\377\357\361\367\377xy|\377\0"
	  "\0\0\377\10\10\11\377\202\10\11\11\377\35\12\14\16\377\14\15\16\377\13\14"
	  "\15\377\12\13\13\377\13\14\13\376\13\14\14\377\15\17\17\377\25\30\31\377"
	  "\22\24\23\377\12\14\14\377\22\24\24\377\12\14\13\377\32\36\40\377\34\35\36"
	  "\377\13\14\13\377\12\13\13\377\22\24\25\377\13\13\13\377\15\15\14\377\22"
	  "\22\22\377\16\17\17\377,/1\377\31\33\33\377\2\2\2\377\12\12\12\377{|~\377"
	  "\351\352\356\377\364\365\372\377\362\365\371\377\202\363\365\371\377\202"
	  "\362\364\371\377\203\361\363\370\377\11\360\363\370\377\357\362\367\377\357"
	  "\361\366\377\356\361\365\377\360\362\366\377\357\361\366\377\355\360\364"
	  "\377\355\357\365\377\356\357\364\377\202\354\357\365\377\2\354\360\365\377"
	  "\354\357\365\377\202\354\357\364\377\30\353\356\363\377\354\356\363\377\321"
	  "\323\330\377XY\\\377\1\1\1\377\3\3\4\377\12\13\14\377\25\31\32\377\10\12"
	  "\12\377\11\13\13\377\16\17\17\377\12\13\13\377\7\10\10\377\23\24\24\377\7"
	  "\10\7\377\6\7\6\377\12\12\12\377\23\24\25\377\10\11\10\377\25\27\31\377\20"
	  "\20\21\377\0\0\0\377\261\263\267\377\352\354\361\377\202\350\353\361\377"
	  "\3\351\354\362\377\350\352\360\377\350\353\361\377\202\352\354\362\377\202"
	  "\351\353\361\377\4\353\355\362\377\352\354\362\377\347\353\360\377\350\354"
	  "\361\377\202\352\354\362\377\4\354\355\363\377\352\355\362\377\351\354\362"
	  "\377\352\355\362\377\202\352\354\362\377\4\352\354\363\377\353\356\364\377"
	  "\353\355\363\377\212\214\217\377\202\1\1\1\377\1\211\212\215\377\202\354"
	  "\356\364\377\12\355\360\365\377\354\356\363\377\354\357\364\377\354\357\365"
	  "\377\354\357\364\377\355\357\364\377\355\360\365\377\355\357\364\377\356"
	  "\360\365\377\355\360\365\377\202\356\360\365\377\203\355\360\365\377\"\356"
	  "\360\366\377\357\362\370\377uvy\377\0\0\0\377\10\11\11\377\12\13\13\377\12"
	  "\13\14\377\10\13\14\377\17\23\25\377\14\14\15\377\13\12\12\377\23\25\26\377"
	  "\16\17\17\376\20\21\21\377\20\21\22\377\15\15\14\377\12\13\13\377\25\27\27"
	  "\377\12\15\15\377\13\15\16\377\35\37\40\377\12\12\12\377\23\26\26\377\31"
	  "\32\34\377\11\11\11\377\13\14\14\377\14\14\14\377\14\15\15\377\17\21\21\377"
	  "\30\30\31\377\0\0\0\377KLM\377\332\333\337\377\364\366\373\377\202\363\365"
	  "\372\377\13\363\365\371\377\362\363\367\377\362\364\370\377\361\364\371\377"
	  "\362\364\371\377\360\363\370\377\362\364\371\377\361\363\370\377\361\362"
	  "\367\377\356\361\366\377\355\361\365\377\202\357\362\367\377(\355\360\365"
	  "\377\356\360\366\377\357\360\365\377\356\360\365\377\355\360\365\377\355"
	  "\357\365\377\354\357\364\377\355\357\365\377\355\357\364\377\352\356\363"
	  "\377\353\356\363\377\354\357\363\377\355\357\364\377\353\356\362\377\271"
	  "\273\277\377)*+\377\0\1\1\377\26\27\32\377\12\14\14\377\24\25\26\377\11\11"
	  "\11\377\13\14\14\377(*-\377\13\13\12\377\10\10\10\377\26\31\32\377\34\34"
	  "\36\377\12\13\13\377\14\16\17\377\35\40\"\377\31\33\35\377\0\0\0\377\262"
	  "\263\270\377\352\354\361\377\352\354\362\377\350\353\361\377\352\354\362"
	  "\377\351\353\361\377\347\352\360\377\350\353\361\377\202\351\353\362\377"
	  "\5\351\354\362\377\350\354\361\377\352\354\362\377\350\353\360\377\351\354"
	  "\361\377\203\352\354\362\377\11\353\355\363\377\352\354\362\377\353\354\362"
	  "\377\354\356\363\377\353\356\364\377\353\355\363\377\353\356\363\377\353"
	  "\355\363\377\213\214\217\377\202\1\2\2\377\10\211\212\215\377\355\357\365"
	  "\377\353\356\364\377\356\360\365\377\353\356\363\377\354\357\364\377\355"
	  "\357\365\377\354\357\364\377\202\355\360\365\377\202\355\357\365\377\2\355"
	  "\360\364\377\355\360\366\377\202\356\360\365\3773\356\360\366\377\356\361"
	  "\366\377\357\361\367\377stw\377\0\0\0\377\10\12\11\377\12\12\12\377\14\15"
	  "\15\377\15\16\20\377\21\23\24\377\15\17\20\377\14\15\15\377\16\16\20\377"
	  "\13\14\14\377&+.\376\30\31\33\377\35\37!\377\12\12\12\377\12\13\12\377\12"
	  "\15\15\377,/4\377\26\30\32\377\14\15\15\377\26\30\30\37778;\377\11\11\11"
	  "\377\13\16\16\377\12\13\13\377\12\14\13\377\16\17\17\377\4\5\5\377\13\13"
	  "\13\377\232\232\234\377\365\367\373\377\363\364\372\377\363\365\372\377\363"
	  "\366\372\377\363\365\371\377\363\364\371\377\362\363\370\377\361\363\370"
	  "\377\361\364\370\377\361\364\371\377\361\362\370\377\361\363\370\377\360"
	  "\363\367\377\357\362\367\377\356\361\366\377\357\361\365\377\357\361\367"
	  "\377\356\361\365\377\203\356\360\365\377/\356\361\365\377\356\360\365\377"
	  "\355\360\365\377\354\357\365\377\354\356\364\377\355\357\364\377\353\356"
	  "\364\377\355\357\364\377\354\356\363\377\355\357\364\377\353\356\363\377"
	  "\353\356\364\377\345\347\355\377klo\377\1\1\1\377\10\12\12\377\15\16\16\377"
	  "\11\12\11\377\37#%\377\20\20\20\377\10\11\10\377\12\12\12\377\14\15\15\377"
	  "\10\11\12\377\15\17\17\377\26\30\32\377\36\40\"\377\12\12\13\377\0\0\0\377"
	  "\261\263\270\377\352\354\361\377\351\353\361\377\351\353\362\377\351\354"
	  "\361\377\351\353\360\377\350\352\360\377\350\353\360\377\350\352\361\377"
	  "\351\353\360\377\351\353\361\377\350\352\361\377\347\352\360\377\351\354"
	  "\361\377\352\355\362\377\352\354\362\377\350\353\361\377\350\352\360\377"
	  "\202\352\355\362\377\3\351\355\363\377\352\355\363\377\354\356\364\377\202"
	  "\353\355\363\377\7\353\356\363\377\213\214\217\377\1\1\1\377\2\3\3\377\212"
	  "\213\216\377\355\360\365\377\355\357\365\377\202\354\357\364\377$\355\357"
	  "\364\377\355\360\365\377\354\357\365\377\355\357\365\377\355\360\365\377"
	  "\355\357\365\377\356\360\365\377\356\360\366\377\355\357\365\377\356\360"
	  "\365\377\355\360\365\377\356\361\366\377\357\361\367\377qqu\377\0\0\0\377"
	  "\23\25\27\377\16\17\21\377\27\33\35\377\17\22\24\377\23\26\30\377\12\13\13"
	  "\377\16\14\14\377\12\12\12\377\15\17\17\377\12\12\13\377:AD\376HKN\377\10"
	  "\10\7\377\13\14\13\377\12\13\14\377\26\27\31\377\22\23\25\377\13\14\13\377"
	  "\35!\"\377)+-\377\15\16\17\377\202\14\15\15\377\7\20\22\23\377\16\17\17\377"
	  "\4\3\3\377###\377\315\316\321\377\364\366\372\377\362\364\371\377\202\364"
	  "\366\372\377\5\363\365\372\377\362\364\371\377\363\364\371\377\362\364\371"
	  "\377\362\363\367\377\202\361\363\370\377\1\362\363\370\377\202\360\362\367"
	  "\377\1\360\363\367\377\202\355\360\365\3777\356\360\366\377\355\357\363\377"
	  "\355\360\365\377\355\357\364\377\356\360\365\377\355\357\364\377\356\357"
	  "\365\377\355\357\364\377\353\355\363\377\354\357\364\377\354\356\364\377"
	  "\355\357\364\377\354\356\363\377\354\356\362\377\354\356\363\377\353\356"
	  "\363\377\354\356\363\377\354\355\363\377\354\356\364\377\244\246\252\377"
	  "\13\14\14\377\3\3\2\377\20\21\22\377\20\20\20\377\13\14\15\377\10\12\12\377"
	  "\16\17\20\377\15\16\17\377\16\17\20\377INR\377\15\15\16\377\11\12\12\377"
	  "\12\12\12\377\0\0\0\377\262\264\271\377\352\355\362\377\351\353\361\377\350"
	  "\352\360\377\350\353\361\377\351\353\361\377\350\352\360\377\350\354\361"
	  "\377\347\352\360\377\347\352\357\377\350\353\360\377\351\354\362\377\350"
	  "\352\360\377\350\353\360\377\351\355\362\377\352\354\362\377\347\351\357"
	  "\377\351\353\362\377\351\355\363\377\352\354\362\377\351\354\362\377\202"
	  "\353\356\363\377\4\354\356\363\377\354\356\364\377\353\356\363\377\213\215"
	  "\220\377\202\1\1\1\377\7\211\213\215\377\354\357\364\377\355\356\364\377"
	  "\355\357\365\377\354\356\364\377\354\357\364\377\354\356\363\377\203\355"
	  "\360\364\377+\356\360\365\377\355\357\364\377\355\357\365\377\354\357\365"
	  "\377\356\361\366\377\356\360\365\377\357\362\367\377nor\377\1\2\2\377\11"
	  "\13\14\377\14\16\16\377\12\13\13\377\13\14\16\377\16\17\20\377\13\14\14\377"
	  "\12\11\11\377\13\13\12\377\12\12\12\377\14\14\14\377\25\27\30\377\23\24\25"
	  "\376\14\14\15\377\11\11\11\377\11\12\12\377\23\24\26\377\31\34\35\377\21"
	  "\22\22\377\14\15\15\377\32\34\35\377\14\16\15\377\13\14\14\377\12\14\14\377"
	  "\14\17\17\377\17\17\17\377\1\1\2\37799:\377\343\345\350\377\364\366\372\377"
	  "\364\366\373\377\363\365\372\377\364\366\373\377\364\365\372\377\363\365"
	  "\372\377\202\363\365\371\377\32\362\364\370\377\362\363\371\377\361\362\367"
	  "\377\360\362\367\377\357\361\366\377\360\362\367\377\357\361\366\377\357"
	  "\362\367\377\357\361\366\377\355\360\365\377\356\360\366\377\355\360\365"
	  "\377\355\357\365\377\355\360\365\377\356\360\366\377\355\357\364\377\354"
	  "\356\363\377\355\357\365\377\353\356\364\377\352\355\363\377\354\356\364"
	  "\377\353\355\363\377\353\355\362\377\354\356\363\377\355\357\364\377\354"
	  "\356\364\377\202\354\356\363\377\35\354\356\364\377\354\356\363\377\301\303"
	  "\307\377\30\30\31\377\2\2\2\377\11\11\11\377\10\10\10\377\15\17\17\377\15"
	  "\17\20\377\14\15\15\37736:\377\12\13\12\377\12\12\12\377\12\11\11\377\10"
	  "\11\11\377\0\0\0\377\262\265\271\377\350\353\361\377\350\353\360\377\351"
	  "\353\361\377\347\352\360\377\350\353\361\377\351\353\361\377\350\353\360"
	  "\377\351\353\361\377\351\353\360\377\347\351\357\377\352\354\361\377\351"
	  "\354\362\377\202\350\354\361\377\14\351\353\360\377\351\354\362\377\352\354"
	  "\361\377\351\355\363\377\351\354\362\377\353\356\363\377\352\355\363\377"
	  "\351\355\362\377\353\355\362\377\353\356\363\377\353\355\363\377\213\214"
	  "\217\377\202\1\2\2\377\4\212\213\216\377\356\360\365\377\354\356\365\377"
	  "\355\357\365\377\203\355\357\364\377\7\355\357\365\377\355\360\365\377\355"
	  "\360\364\377\355\360\365\377\355\357\365\377\356\360\365\377\355\360\365"
	  "\377\202\356\360\366\377\12lmp\377\0\0\0\377\24\25\30\377\12\13\13\377\20"
	  "\22\24\377\13\15\15\377\11\12\12\377\15\16\16\377\13\13\13\377\13\12\12\377"
	  "\202\11\11\11\377\30\13\13\13\37725:\377\16\16\16\376\13\13\13\377!#$\377"
	  "\21\24\25\377\16\17\17\377\16\16\16\377\12\14\13\3775:=\377\25\30\31\377"
	  "\15\20\17\377\15\16\17\377\15\17\17\377\15\16\16\377\1\2\2\377?@A\377\353"
	  "\355\361\377\365\367\373\377\364\366\372\377\365\366\373\377\365\366\372"
	  "\377\364\366\372\377\362\365\371\377\204\362\364\371\377\202\361\362\370"
	  "\377\202\357\361\366\377\7\361\362\367\377\357\362\366\377\356\360\366\377"
	  "\355\360\365\377\356\361\366\377\356\360\365\377\353\355\363\377\202\353"
	  "\356\363\377\2\355\360\365\377\355\357\364\377\202\354\357\364\377\4\353"
	  "\356\363\377\353\355\363\377\354\356\364\377\353\357\364\377\202\353\355"
	  "\363\377\5\354\356\363\377\353\356\363\377\353\355\363\377\354\355\363\377"
	  "\354\356\363\377\202\352\354\362\377\16\315\316\324\377\34\34\35\377\2\2"
	  "\2\377\12\13\14\377\7\7\7\377\10\7\7\377\22\23\25\377\12\13\12\377\10\10"
	  "\10\377\11\11\11\377\10\10\11\377\10\11\11\377\0\0\0\377\262\264\270\377"
	  "\202\351\353\361\377G\350\352\360\377\350\353\357\377\351\354\362\377\350"
	  "\352\360\377\351\354\362\377\352\354\362\377\351\353\361\377\351\354\361"
	  "\377\351\353\361\377\351\354\361\377\350\353\361\377\351\354\361\377\351"
	  "\353\361\377\351\354\362\377\350\353\361\377\352\355\362\377\352\354\362"
	  "\377\351\354\362\377\352\354\363\377\352\355\362\377\352\355\361\377\354"
	  "\356\363\377\354\357\364\377\212\214\217\377\1\2\2\377\2\2\3\377\212\213"
	  "\216\377\354\357\364\377\353\356\363\377\354\357\364\377\355\360\365\377"
	  "\354\357\363\377\354\357\364\377\354\357\365\377\354\357\363\377\355\360"
	  "\365\377\356\360\364\377\356\360\365\377\356\360\364\377\356\360\365\377"
	  "\357\362\367\377ikm\377\0\0\0\377\12\14\16\377\14\15\16\377\17\20\21\377"
	  "\13\14\15\377\15\16\17\377\14\17\20\377\13\13\13\377\10\11\11\377\25\26\26"
	  "\377\10\10\10\377\17\17\20\377\12\14\15\377\16\20\20\377\40#%\376\33\37!"
	  "\377\37#%\377\33\35!\377\14\14\14\377\11\12\12\377\12\13\14\37758<\377\31"
	  "\31\32\377158\377\15\17\17\377\33\34\36\377\3\3\3\37789:\377\353\355\357"
	  "\377\202\364\366\373\377\6\364\365\372\377\364\366\373\377\365\366\373\377"
	  "\364\365\372\377\363\365\372\377\361\364\371\377\202\361\363\370\377\5\360"
	  "\362\367\377\357\362\367\377\360\363\370\377\360\362\370\377\357\362\367"
	  "\377\202\360\362\367\377\5\357\361\367\377\356\361\366\377\356\360\366\377"
	  "\355\357\365\377\352\355\363\377\202\353\356\364\377\202\355\357\364\377"
	  "\3\354\356\364\377\355\357\364\377\353\356\363\377\202\353\356\364\377\30"
	  "\353\356\363\377\353\355\363\377\354\356\363\377\352\356\363\377\354\356"
	  "\364\377\353\356\363\377\353\354\362\377\353\355\363\377\352\355\362\377"
	  "\352\354\362\377\351\354\361\377\312\314\321\377\25\25\26\377\3\3\3\377\7"
	  "\10\7\377\25\27\30\377\15\17\17\377\10\11\11\377\14\14\14\377\7\7\7\377\10"
	  "\11\12\377\11\12\12\377\0\0\0\377\262\264\270\377\202\351\353\361\377\20"
	  "\351\354\361\377\351\353\361\377\351\354\362\377\351\354\361\377\351\355"
	  "\362\377\351\354\362\377\350\352\361\377\351\354\361\377\351\353\361\377"
	  "\350\352\360\377\351\354\361\377\351\355\361\377\350\353\360\377\351\354"
	  "\362\377\352\354\363\377\351\355\362\377\202\353\355\363\377\22\353\356\363"
	  "\377\353\356\362\377\352\355\363\377\354\356\364\377\353\356\363\377\213"
	  "\214\217\377\1\1\1\377\2\1\2\377\212\213\216\377\355\360\365\377\352\355"
	  "\363\377\353\356\364\377\355\357\365\377\354\357\365\377\354\357\364\377"
	  "\354\360\365\377\355\357\364\377\355\360\364\377\202\356\360\365\377!\355"
	  "\357\364\377\357\361\366\377hik\377\0\0\0\377\6\7\7\377\17\21\21\377#%'\377"
	  "\13\15\16\377\17\17\20\377\13\14\14\377\22\23\25\377\13\15\16\377\17\17\21"
	  "\377\11\12\12\377\14\14\15\377\12\12\12\377\12\13\14\377\12\12\13\37769="
	  "\376=BE\377\34\35\37\377\16\20\20\377\21\23\24\3777;?\377\11\13\12\377\12"
	  "\12\12\377\27\31\33\377\21\22\23\377\33\40#\377\7\7\10\377\"##\377\343\344"
	  "\350\377\364\366\372\377\202\363\365\372\377\2\363\366\372\377\364\366\372"
	  "\377\202\363\365\372\377\2\362\364\371\377\361\364\371\377\202\361\363\370"
	  "\377\2\360\362\367\377\356\361\366\377\202\360\362\367\377\203\357\361\366"
	  "\377\202\357\362\367\377\1\357\361\366\377\202\353\356\364\377\12\355\357"
	  "\365\377\354\356\364\377\355\357\365\377\355\357\364\377\352\355\363\377"
	  "\353\355\364\377\352\355\362\377\354\356\364\377\353\355\363\377\352\355"
	  "\363\377\202\353\356\363\377\6\353\355\362\377\352\355\362\377\353\355\363"
	  "\377\352\354\362\377\354\356\364\377\352\355\362\377\203\352\354\362\377"
	  "\22\272\275\301\377\10\10\10\377\6\7\10\377\11\13\13\377\14\15\15\377#$'"
	  "\377\7\7\10\377\7\11\11\377\10\11\11\377\13\13\14\377\0\0\0\377\262\264\270"
	  "\377\350\353\361\377\350\353\360\377\350\353\361\377\347\352\357\377\351"
	  "\354\361\377\352\355\362\377\202\351\353\361\377\12\351\354\362\377\350\353"
	  "\361\377\351\354\361\377\350\353\361\377\350\354\361\377\351\354\362\377"
	  "\351\353\361\377\351\354\362\377\352\355\362\377\353\355\362\377\202\353"
	  "\355\363\377\1\353\356\363\377\202\353\355\363\377\3\354\356\364\377\354"
	  "\357\364\377\213\214\217\377\202\1\1\1\377,\212\213\216\377\356\360\366\377"
	  "\354\356\364\377\354\357\364\377\355\357\364\377\354\357\364\377\355\357"
	  "\365\377\354\356\363\377\354\357\363\377\355\360\364\377\356\361\366\377"
	  "\357\361\366\377\356\360\365\377egi\377\0\0\0\377\7\10\7\377\17\17\20\377"
	  "'),\377\15\14\15\377\14\15\15\377$&(\377\32\33\35\377\14\15\16\377\14\16"
	  "\17\377\11\13\13\377')+\377\15\17\20\377\14\15\17\377\14\14\15\377\15\16"
	  "\15\377\21\23\23\376\26\30\31\377\16\20\20\377\17\20\20\377!$&\377\36\37"
	  "\"\377!%'\377\23\25\25\377\11\12\11\377\20\21\21\377\14\16\17\377\12\12\12"
	  "\377\313\315\320\377\362\365\372\377\203\363\365\372\377\1\362\365\371\377"
	  "\202\363\365\372\377\1\362\364\370\377\202\362\364\371\377\203\360\362\367"
	  "\377\12\356\361\366\377\357\361\366\377\360\361\366\377\357\361\366\377\355"
	  "\360\366\377\360\362\366\377\356\361\366\377\360\362\366\377\357\361\367"
	  "\377\354\357\365\377\202\354\357\364\377'\356\360\364\377\355\360\364\377"
	  "\354\356\364\377\353\356\364\377\354\357\364\377\351\355\362\377\352\355"
	  "\363\377\353\355\363\377\352\355\362\377\354\356\364\377\352\355\362\377"
	  "\353\355\362\377\353\355\363\377\353\356\364\377\354\356\364\377\352\354"
	  "\362\377\353\356\363\377\353\354\362\377\352\354\363\377\352\355\362\377"
	  "\352\355\363\377\226\230\234\377\0\0\0\377\7\6\6\377\13\13\13\377\7\7\7\377"
	  "\14\15\16\377\11\12\12\377\15\20\20\377\13\12\13\377\0\0\0\377\263\264\271"
	  "\377\350\353\361\377\352\353\361\377\350\352\360\377\351\353\361\377\350"
	  "\352\360\377\351\354\361\377\352\354\362\377\202\351\353\361\377\6\351\354"
	  "\362\377\351\353\362\377\350\353\361\377\352\355\362\377\351\355\362\377"
	  "\351\354\362\377\202\351\354\361\377\14\352\355\362\377\353\356\364\377\352"
	  "\355\361\377\352\355\363\377\354\356\364\377\354\357\364\377\355\357\365"
	  "\377\354\356\363\377\214\215\217\377\2\2\2\377\2\2\3\377\210\212\215\377"
	  "\202\354\357\364\377\2\355\357\365\377\354\357\365\377\202\355\357\365\377"
	  "\20\356\360\366\377\355\360\365\377\356\360\365\377\355\360\365\377\356\360"
	  "\366\377bce\377\0\0\0\377\6\7\10\377\17\20\22\377\31\33\36\377\15\15\16\377"
	  "\27\27\30\377\25\26\30\377\22\24\25\377\13\14\14\377\12\12\12\377\202\14"
	  "\15\16\377\35\11\12\11\377\14\15\15\377\12\13\13\377\20\22\24\377\25\27\27"
	  "\377\17\21\21\376\15\16\15\377\22\25\25\37749>\377\23\21\22\377\17\21\22"
	  "\377\35#$\377BCH\377\13\15\14\377\16\16\16\377\0\0\0\377\226\230\232\377"
	  "\364\366\373\377\363\366\373\377\363\365\371\377\363\365\372\377\363\365"
	  "\371\377\362\364\371\377\362\363\371\377\363\365\372\377\362\365\371\377"
	  "\361\363\370\377\361\363\367\377\357\362\367\377\202\360\362\367\377\1\356"
	  "\361\367\377\202\357\361\366\377\21\360\362\367\377\356\360\366\377\356\361"
	  "\366\377\357\361\366\377\357\362\367\377\355\357\365\377\357\360\366\377"
	  "\355\360\365\377\354\356\364\377\354\357\365\377\356\360\365\377\356\356"
	  "\364\377\354\356\363\377\354\356\364\377\351\354\362\377\353\356\364\377"
	  "\354\356\363\377\202\352\355\363\377\5\353\355\363\377\353\356\363\377\354"
	  "\356\364\377\353\356\363\377\353\355\363\377\202\353\355\362\377Y\352\354"
	  "\362\377\351\353\361\377\351\354\362\377\352\354\362\377\353\355\363\377"
	  "XY[\377\1\1\1\377\10\10\10\377\10\11\11\377\10\11\10\377\13\12\12\377\14"
	  "\14\14\377\13\14\15\377\0\0\0\377\262\264\271\377\351\353\361\377\352\354"
	  "\360\377\351\354\362\377\350\353\360\377\351\354\361\377\351\353\361\377"
	  "\353\355\362\377\352\354\363\377\351\353\361\377\352\354\362\377\347\352"
	  "\360\377\351\354\361\377\347\352\360\377\351\355\361\377\351\353\361\377"
	  "\350\353\361\377\352\354\362\377\352\356\363\377\352\355\363\377\351\354"
	  "\361\377\353\356\364\377\354\356\363\377\353\355\363\377\353\355\364\377"
	  "\354\356\364\377\213\215\220\377\2\2\2\377\2\2\3\377\211\212\216\377\356"
	  "\360\365\377\354\360\365\377\354\357\364\377\353\356\364\377\354\356\363"
	  "\377\354\357\365\377\356\360\365\377\355\360\365\377\356\360\365\377\355"
	  "\360\364\377_`c\377\0\0\0\377\14\14\15\377\17\17\20\377\20\20\21\377\12\12"
	  "\12\377\14\13\14\377\32\35\37\377\14\15\16\377\12\13\13\377\10\11\11\377"
	  "9<@\377\13\14\15\377\10\11\12\377\12\12\14\377\10\11\10\377\17\20\20\377"
	  "\23\26\30\377\13\15\15\377\16\17\17\376\16\16\15\377\14\15\15\377\34\37\40"
	  "\377+.1\377\21\22\22\377\33\35\37\377\15\16\15\377\32\37\40\377\6\7\7\377"
	  "GHI\377\364\366\372\377\363\366\372\377\363\365\372\377\363\364\371\377\362"
	  "\365\371\377\202\361\364\371\377\202\362\364\371\377\24\362\363\370\377\361"
	  "\364\370\377\361\363\370\377\361\363\367\377\360\362\367\377\361\363\370"
	  "\377\357\362\367\377\356\361\367\377\356\360\366\377\360\362\367\377\356"
	  "\360\366\377\356\361\366\377\356\362\366\377\357\362\367\377\355\360\366"
	  "\377\355\357\365\377\356\361\365\377\356\360\366\377\356\361\366\377\355"
	  "\357\365\377\202\355\357\364\377\10\354\357\364\377\351\354\363\377\352\355"
	  "\363\377\353\356\364\377\352\355\362\377\352\354\362\377\352\355\363\377"
	  "\353\355\362\377\202\352\355\362\377\5\353\355\363\377\353\354\362\377\352"
	  "\354\362\377\352\355\363\377\351\354\362\377\203\350\353\361\377\20\337\341"
	  "\346\377\31\32\33\377\10\10\11\377\10\10\10\377\11\10\10\377\7\7\7\377\16"
	  "\21\23\377\16\20\21\377\0\0\0\377\262\264\271\377\352\354\361\377\350\353"
	  "\360\377\352\354\362\377\347\352\357\377\351\354\361\377\352\355\362\377"
	  "\202\352\354\362\377\1\351\353\361\377\202\350\353\361\377\5\351\354\361"
	  "\377\350\354\362\377\351\355\361\377\351\353\361\377\352\355\363\377\202"
	  "\352\355\362\377#\351\354\362\377\352\355\363\377\353\355\362\377\354\356"
	  "\364\377\354\357\364\377\355\356\364\377\354\357\364\377\213\215\220\377"
	  "\2\2\2\377\3\3\3\377\212\213\215\377\355\360\365\377\355\357\364\377\354"
	  "\357\364\377\353\356\363\377\354\357\365\377\355\357\365\377\355\357\364"
	  "\377\355\360\365\377\354\357\364\377\\^_\377\2\2\3\377\15\16\16\377\14\16"
	  "\17\377\26\30\32\377\13\13\13\377\16\16\16\377\22\23\24\377\15\16\16\377"
	  "\11\11\11\377\13\13\14\377\14\15\15\377\25\31\32\377\25\27\31\377\7\7\7\377"
	  "\202\11\12\12\377\23\12\13\13\377\13\14\16\377\16\17\20\377\17\21\21\376"
	  "\15\17\17\377\23\26\26\377\15\17\20\377\15\16\16\37759<\377\14\14\15\377"
	  "\13\15\14\377\30\33\34\377\11\11\11\377\327\331\334\377\363\365\371\377\363"
	  "\366\372\377\364\366\373\377\362\364\370\377\362\365\371\377\202\362\364"
	  "\371\377\34\362\364\370\377\360\364\371\377\362\364\371\377\360\362\370\377"
	  "\361\363\370\377\360\363\370\377\361\363\366\377\361\363\370\377\360\362"
	  "\370\377\357\362\366\377\357\361\367\377\357\361\366\377\356\360\365\377"
	  "\356\361\366\377\357\361\366\377\356\361\366\377\355\360\366\377\355\357"
	  "\365\377\355\360\366\377\354\356\363\377\356\360\365\377\355\357\364\377"
	  "\353\357\364\377\354\357\365\377\353\355\364\377\353\356\364\377\353\355"
	  "\364\377\352\355\363\377\202\352\355\362\377\202\353\355\363\377\4\352\355"
	  "\363\377\352\355\362\377\353\355\363\377\352\355\363\377\202\352\354\362"
	  "\377\1\351\354\362\377\203\352\354\362\377\26\352\355\362\377\241\243\246"
	  "\377\0\0\0\377\11\10\11\377\12\12\13\377\7\7\10\377\27\32\35\377\14\15\16"
	  "\377\0\0\0\377\262\264\271\377\352\354\362\377\351\354\361\377\352\353\362"
	  "\377\351\354\362\377\353\355\362\377\352\355\363\377\352\355\362\377\352"
	  "\354\362\377\350\353\361\377\351\354\362\377\351\353\361\377\351\354\362"
	  "\377\202\351\355\362\377\5\351\353\361\377\351\354\361\377\351\354\362\377"
	  "\352\355\363\377\351\354\362\377\202\353\355\363\377\2\353\356\364\377\354"
	  "\356\364\377\202\354\357\364\377\1\214\215\220\377\202\2\2\2\377\5\211\213"
	  "\216\377\354\356\363\377\354\357\365\377\355\360\364\377\353\356\363\377"
	  "\202\355\357\364\377'\355\360\365\377\354\357\363\377Z[\\\377\0\0\1\377\21"
	  "\23\24\377\13\15\16\377\11\12\12\377\13\13\14\377\12\13\13\377\17\17\20\377"
	  "\13\13\14\377\14\15\14\377\13\13\13\377\27\31\34\377\11\12\12\377\26\31\34"
	  "\377\15\15\15\377\15\17\20\377\17\17\17\377\35\40#\377\10\11\11\377\10\10"
	  "\11\377),/\377\14\17\16\376\21\23\22\377045\377\11\13\13\377\16\17\17\377"
	  "\12\12\12\377\12\14\14\377\21\24\24\377\2\2\3\377wxy\377\363\366\372\377"
	  "\363\365\370\377\363\365\371\377\364\365\372\377\363\365\371\377\363\365"
	  "\372\377\202\362\364\371\377\34\361\363\370\377\362\364\371\377\361\363\371"
	  "\377\361\363\370\377\360\363\370\377\362\363\370\377\357\361\366\377\360"
	  "\362\367\377\357\362\367\377\357\361\367\377\360\362\367\377\357\362\367"
	  "\377\357\360\366\377\355\360\365\377\356\360\365\377\355\361\366\377\356"
	  "\360\366\377\356\357\366\377\356\360\366\377\354\357\365\377\355\360\365"
	  "\377\354\356\363\377\354\357\364\377\355\360\364\377\353\355\362\377\353"
	  "\355\363\377\352\355\364\377\352\355\363\377\202\352\355\362\377\33\352\354"
	  "\362\377\352\355\363\377\352\355\362\377\353\355\363\377\352\354\362\377"
	  "\352\355\363\377\352\354\362\377\353\355\363\377\352\354\363\377\350\353"
	  "\361\377\352\354\362\377\351\354\362\377\351\354\361\377\353\355\363\377"
	  ";;=\377\2\3\3\377\12\13\13\377\10\12\12\377\11\12\12\377\11\12\13\377\0\0"
	  "\0\377\262\265\272\377\353\355\363\377\351\353\361\377\350\352\361\377\352"
	  "\354\362\377\353\355\362\377\202\351\354\362\377\2\352\355\362\377\352\354"
	  "\362\377\202\352\354\361\377P\351\353\361\377\352\355\362\377\351\355\362"
	  "\377\352\355\362\377\351\353\361\377\352\354\362\377\350\354\361\377\353"
	  "\355\362\377\353\355\363\377\353\356\363\377\355\360\365\377\354\356\364"
	  "\377\354\357\364\377\355\357\364\377\214\215\217\377\1\1\2\377\1\2\2\377"
	  "\211\213\215\377\355\357\365\377\354\356\363\377\353\356\363\377\353\355"
	  "\364\377\354\356\363\377\356\360\366\377\353\356\363\377WXZ\377\0\0\0\377"
	  "\7\11\11\377\15\20\20\377\12\14\14\377\7\7\7\377\14\15\15\377\11\11\10\377"
	  "\14\14\15\377\20\21\22\377\16\16\17\377\22\25\26\377\27\31\34\377\13\16\17"
	  "\377\11\12\12\377\11\11\11\377\12\13\15\377\23\25\26\377\14\15\16\377\22"
	  "\25\26\377\11\11\11\377\10\11\11\377\23\26\26\376\23\23\23\377\13\15\15\377"
	  "\15\16\16\377\14\14\14\377\13\13\14\377EKO\377\12\12\13\377\17\20\20\377"
	  "\346\350\354\377\362\364\371\377\363\365\371\377\363\365\372\377\364\366"
	  "\372\377\363\365\372\377\361\363\370\377\362\364\371\377\362\365\371\377"
	  "\362\364\371\377\362\365\372\377\362\363\371\377\361\363\370\377\361\364"
	  "\371\377\361\362\367\377\361\363\370\377\360\363\370\377\360\362\370\377"
	  "\360\362\367\377\357\362\367\377\356\361\366\377\356\361\365\377\356\357"
	  "\365\377\356\361\366\377\202\356\361\365\377\2\355\357\365\377\355\360\365"
	  "\377\202\354\357\364\377\202\354\356\364\377\12\354\357\365\377\354\356\364"
	  "\377\353\356\363\377\351\355\363\377\354\356\364\377\352\355\363\377\352"
	  "\354\362\377\351\354\362\377\351\353\361\377\351\354\363\377\202\352\355"
	  "\362\377\32\353\355\363\377\353\354\362\377\352\355\362\377\352\354\362\377"
	  "\351\354\362\377\350\353\360\377\351\354\362\377\352\354\362\377\353\355"
	  "\362\377\266\267\274\377\0\0\0\377\11\12\12\377\10\10\10\377\11\12\12\377"
	  "\7\10\11\377\0\0\0\377\263\265\271\377\352\355\362\377\351\353\361\377\351"
	  "\354\362\377\352\355\362\377\353\354\362\377\351\354\362\377\352\355\362"
	  "\377\352\354\362\377\352\355\362\377\202\352\354\362\377\3\351\354\362\377"
	  "\351\355\362\377\350\354\361\377\202\352\354\362\377\3\352\355\363\377\351"
	  "\355\362\377\353\356\363\377\202\352\354\362\377\202\355\357\364\377\202"
	  "\353\356\363\377\6\213\214\217\377\1\2\2\377\2\2\3\377\211\212\216\377\354"
	  "\357\364\377\354\356\365\377\202\354\356\363\377%\354\357\364\377\353\355"
	  "\362\377UVW\377\0\1\1\377\4\6\6\377\12\13\12\377\15\15\15\377\12\12\13\377"
	  "\11\11\12\377\16\16\17\377\11\13\13\377\11\12\12\377\15\16\17\377\21\22\24"
	  "\377\25\27\30\377\20\21\23\377\13\12\12\377\11\12\13\377\10\10\11\377\7\10"
	  "\10\377\27\30\32\377\34\35!\377\26\30\31\377\12\13\14\377\10\10\10\377\34"
	  "\37\40\376\15\17\16\377\14\16\17\377\13\14\15\377\17\17\20\377\21\22\23\377"
	  "\16\17\17\377\1\2\1\377vvx\377\363\366\372\377\362\365\371\377\363\365\371"
	  "\377\203\363\365\372\377\1\362\364\371\377\202\363\365\371\377\10\362\363"
	  "\371\377\363\365\372\377\362\363\370\377\362\364\371\377\360\363\370\377"
	  "\360\362\370\377\361\363\370\377\360\363\367\377\202\360\362\367\377\15\357"
	  "\361\367\377\356\361\366\377\356\360\366\377\356\361\365\377\356\360\364"
	  "\377\356\361\365\377\353\356\363\377\355\357\365\377\354\356\364\377\353"
	  "\356\363\377\354\357\364\377\353\356\363\377\353\355\363\377\202\354\356"
	  "\364\377\36\353\355\362\377\352\355\363\377\354\356\364\377\352\355\363\377"
	  "\352\354\363\377\350\353\360\377\351\354\361\377\352\355\363\377\352\354"
	  "\362\377\351\354\361\377\352\354\363\377\353\355\363\377\352\355\363\377"
	  "\353\355\363\377\352\355\362\377\351\353\361\377\351\354\361\377\353\355"
	  "\363\377\352\355\362\377\353\355\363\3779:;\377\5\5\6\377\10\12\11\377#'"
	  "*\377\7\7\10\377\0\0\0\377\263\265\271\377\354\356\364\377\352\354\362\377"
	  "\353\355\362\377\202\352\354\362\377\1\352\354\363\377\202\353\355\363\377"
	  "\1\353\355\362\377\202\352\354\362\377\10\351\354\362\377\351\355\362\377"
	  "\350\355\362\377\352\355\362\377\351\354\361\377\353\355\362\377\351\354"
	  "\362\377\352\355\362\377\202\353\355\363\3770\355\357\364\377\355\357\365"
	  "\377\355\360\365\377\354\356\363\377\213\214\220\377\2\2\2\377\1\2\2\377"
	  "\211\213\216\377\355\357\365\377\353\357\364\377\353\357\363\377\354\357"
	  "\364\377\353\355\362\377RSU\377\0\0\0\377\7\7\10\377\11\12\12\377\22\24\25"
	  "\377\15\15\16\377\11\12\12\377\27\32\34\377\15\15\16\377\10\10\11\377\26"
	  "\27\31\377!$'\377\20\21\22\377\15\16\17\377\11\11\11\377\10\12\11\377\15"
	  "\17\20\377\13\14\14\377\11\10\11\377\23\25\27\377\15\16\16\377\13\13\13\377"
	  "\16\17\20\377\14\15\15\377(-/\376(+.\377\12\15\14\377\12\13\13\377\22\24"
	  "\25\377\23\25\26\377\12\12\12\377\4\4\4\377\333\335\340\377\362\365\371\377"
	  "\362\364\371\377\202\363\365\372\377\3\362\364\371\377\363\365\372\377\362"
	  "\365\371\377\202\363\365\372\377\2\362\364\371\377\361\363\371\377\202\361"
	  "\363\370\377\5\360\363\370\377\361\362\370\377\360\362\367\377\357\362\367"
	  "\377\360\362\367\377\202\356\361\366\377\26\356\360\365\377\357\361\366\377"
	  "\356\360\365\377\356\361\365\377\355\360\365\377\355\357\365\377\353\356"
	  "\364\377\354\356\364\377\353\356\363\377\354\356\363\377\354\356\364\377"
	  "\352\355\363\377\354\357\364\377\353\355\363\377\351\355\363\377\351\354"
	  "\362\377\352\354\362\377\352\355\362\377\352\354\362\377\353\356\363\377"
	  "\351\355\363\377\352\355\363\377\202\352\354\362\377\27\353\355\363\377\352"
	  "\354\362\377\353\355\363\377\352\355\362\377\351\354\362\377\352\355\362"
	  "\377\351\354\362\377\353\355\362\377\353\355\363\377\352\354\362\377\242"
	  "\243\247\377\0\0\0\377\12\12\13\377\10\11\11\377\10\12\12\377\0\0\0\377\262"
	  "\265\272\377\352\354\361\377\354\356\363\377\351\354\362\377\352\355\363"
	  "\377\352\354\362\377\353\356\363\377\203\353\355\363\377\202\352\355\363"
	  "\377?\352\354\362\377\352\355\363\377\351\355\362\377\353\355\362\377\352"
	  "\355\363\377\353\356\363\377\352\355\363\377\352\354\362\377\354\357\364"
	  "\377\353\356\364\377\355\357\365\377\355\360\365\377\355\357\365\377\355"
	  "\360\364\377\214\215\220\377\1\1\1\377\1\2\1\377\211\213\216\377\354\356"
	  "\364\377\354\357\364\377\354\356\364\377\352\354\361\377PQS\377\1\1\1\377"
	  "\11\12\11\377\10\7\10\377\20\21\22\377\22\23\25\377\20\21\22\377\16\16\17"
	  "\377\13\13\13\377\11\11\11\377\14\16\17\377\14\16\16\377\40!$\377\11\12\12"
	  "\377\11\11\11\377\7\7\10\377\35\40\"\377\7\11\11\377\37!$\377\7\10\11\377"
	  "\11\12\13\377\17\22\21\377\33\35\37\377\23\24\25\377.27\377\"%'\376\24\27"
	  "\27\377\13\15\14\377\13\15\15\377\15\16\16\377\15\16\15\377\5\7\6\377JJK"
	  "\377\364\366\372\377\361\364\370\377\362\364\371\377\361\364\370\377\362"
	  "\364\371\377\361\364\371\377\363\365\371\377\361\364\370\377\202\362\364"
	  "\371\377\11\362\364\370\377\361\363\370\377\362\364\371\377\361\363\370\377"
	  "\360\362\370\377\360\362\367\377\360\363\367\377\356\361\366\377\360\362"
	  "\367\377\202\356\361\366\377\7\356\360\366\377\357\361\366\377\354\357\364"
	  "\377\356\361\366\377\354\357\365\377\355\357\365\377\353\355\363\377\202"
	  "\353\356\364\377\16\354\356\365\377\354\356\364\377\353\356\363\377\353\356"
	  "\364\377\354\356\364\377\352\355\362\377\350\353\362\377\352\355\363\377"
	  "\351\354\362\377\352\355\362\377\353\356\364\377\355\357\365\377\353\355"
	  "\363\377\352\355\362\377\203\352\354\362\377\4\352\355\362\377\350\353\361"
	  "\377\350\354\362\377\351\353\361\377\202\351\354\362\377\22\352\355\363\377"
	  "\353\356\363\377\350\353\360\377\24\24\25\377\11\12\13\377\6\10\10\377\12"
	  "\13\15\377\0\0\0\377\263\265\272\377\352\354\361\377\353\355\362\377\352"
	  "\354\363\377\352\354\362\377\351\354\361\377\352\354\362\377\352\356\363"
	  "\377\352\354\362\377\352\355\363\377\202\353\355\363\377\3\352\354\362\377"
	  "\351\354\362\377\351\355\362\377\202\352\355\362\377\12\353\355\363\377\353"
	  "\356\364\377\353\356\363\377\353\355\363\377\354\357\364\377\355\357\364"
	  "\377\355\357\365\377\355\360\365\377\354\357\364\377\214\215\217\377\202"
	  "\1\2\2\377\7\211\213\216\377\354\357\365\377\353\356\364\377\352\354\361"
	  "\377NPP\377\1\1\1\377\12\13\14\377\202\14\15\15\377\37\13\17\20\377\15\16"
	  "\20\377\26\30\32\377\16\17\17\377\10\10\10\377\13\14\15\377\25\26\30\377"
	  "\15\16\17\377\12\12\13\377\12\13\13\377\7\7\10\377\17\20\20\377\11\12\12"
	  "\377\16\20\21\377\15\17\20\377\16\16\17\377\23\25\30\377\20\22\22\377\31"
	  "\33\35\377+.2\377\7\7\7\377\13\14\13\376\12\13\13\377\11\13\12\377\34\40"
	  "!\377\22\22\24\377\21\24\24\377\1\1\1\377\237\241\243\377\361\364\371\377"
	  "\361\363\370\377\203\360\363\370\377\4\361\364\371\377\362\364\370\377\361"
	  "\363\370\377\361\363\371\377\202\361\363\370\377\26\361\364\371\377\361\363"
	  "\370\377\360\362\370\377\360\362\367\377\357\361\366\377\360\362\367\377"
	  "\357\361\367\377\360\362\367\377\357\361\367\377\356\360\366\377\356\361"
	  "\366\377\357\361\366\377\354\357\365\377\354\356\364\377\354\357\365\377"
	  "\354\357\364\377\352\355\363\377\354\356\364\377\354\357\364\377\354\356"
	  "\364\377\353\356\363\377\354\356\364\377\202\353\355\363\377\37\353\356\363"
	  "\377\351\354\362\377\353\355\363\377\352\355\363\377\353\355\363\377\354"
	  "\357\364\377\353\356\363\377\354\356\364\377\354\356\363\377\351\354\361"
	  "\377\352\355\363\377\352\354\362\377\353\355\362\377\351\354\362\377\350"
	  "\353\361\377\351\354\362\377\352\355\361\377\353\355\362\377\352\355\362"
	  "\377\353\355\362\377\352\354\362\377bcf\377\2\2\2\377\12\14\14\377\12\13"
	  "\13\377\0\0\0\377\262\265\271\377\350\354\360\377\353\355\362\377\353\354"
	  "\363\377\352\355\363\377\202\352\354\361\377\1\354\356\363\377\202\353\355"
	  "\363\377E\352\355\363\377\353\355\363\377\352\355\362\377\351\354\362\377"
	  "\351\355\362\377\352\354\362\377\351\353\362\377\353\356\364\377\351\354"
	  "\362\377\353\355\363\377\353\355\362\377\353\355\363\377\354\357\364\377"
	  "\353\356\364\377\354\356\364\377\354\357\363\377\214\215\220\377\2\2\2\377"
	  "\3\3\4\377\212\213\216\377\354\357\364\377\347\352\357\377LMO\377\0\0\1\377"
	  "\17\21\22\377\17\17\20\377\13\15\15\377\11\13\13\377\14\15\16\377\20\22\24"
	  "\377\14\14\15\377\22\21\23\377\25\27\30\377\11\11\11\377\10\11\11\377\13"
	  "\14\14\377\10\12\12\377\22\22\24\377\13\15\16\377\11\12\12\377\22\25\26\377"
	  "\12\13\13\377\11\12\13\377\16\17\20\377\13\14\15\377\12\13\14\37769=\377"
	  "\10\10\10\377\36!#\377\16\20\20\376\10\10\10\377\25\27\27\377\21\24\24\377"
	  "\20\23\23\377\33\40!\377\5\5\5\377\345\346\352\377\362\364\371\377\361\363"
	  "\371\377\361\363\370\377\361\364\370\377\360\363\370\377\361\363\370\377"
	  "\362\363\370\377\360\363\367\377\362\363\371\377\361\364\370\377\362\363"
	  "\370\377\360\363\370\377\202\361\363\370\377\3\360\362\370\377\360\362\367"
	  "\377\356\361\366\377\202\357\362\367\377\15\357\361\366\377\356\360\366\377"
	  "\357\361\367\377\355\360\365\377\355\357\365\377\353\357\364\377\355\357"
	  "\364\377\355\360\364\377\354\356\364\377\354\357\364\377\354\356\364\377"
	  "\354\357\365\377\354\357\364\377\203\353\356\363\377\15\353\355\363\377\352"
	  "\355\363\377\352\355\362\377\353\355\362\377\354\356\364\377\355\357\365"
	  "\377\354\356\364\377\353\356\364\377\354\357\364\377\353\355\363\377\352"
	  "\355\363\377\351\354\362\377\353\355\362\377\202\350\352\360\377\22\351\353"
	  "\360\377\351\355\362\377\353\355\363\377\353\355\362\377\352\355\363\377"
	  "\354\356\363\377\253\254\261\377\0\0\0\377\10\11\12\377\12\12\14\377\0\0"
	  "\0\377\263\265\271\377\352\354\361\377\351\354\361\377\352\354\362\377\351"
	  "\354\362\377\353\355\363\377\352\354\361\377\202\353\355\363\377\1\354\356"
	  "\363\377\202\352\354\362\377\3\352\355\362\377\351\354\361\377\351\355\362"
	  "\377\202\351\354\362\377\7\353\356\363\377\352\355\362\377\353\355\363\377"
	  "\354\356\364\377\353\356\364\377\355\357\364\377\354\356\363\377\202\354"
	  "\357\364\377:\214\215\217\377\1\1\2\377\2\3\3\377\211\213\215\377\347\353"
	  "\360\377IJL\377\1\1\1\377\6\7\7\377\22\26\30\377\15\21\21\377\7\11\11\377"
	  "\11\12\13\377\14\15\16\377\36!$\377\13\16\17\377\13\14\16\377\16\20\21\377"
	  "\7\7\7\377\6\6\6\377\10\11\12\377\12\13\14\377\12\13\13\377\12\13\14\377"
	  "\12\12\13\377\11\11\12\377\10\11\10\377\30\31\32\377\11\12\12\377#%(\377"
	  "\24\26\27\377\13\13\13\37748;\377\32\33\35\377\27\31\32\376\22\24\24\377"
	  "\16\23\22\377\21\23\24\377\34\36\40\377\17\20\21\377778\377\364\365\371\377"
	  "\363\364\370\377\362\364\371\377\361\364\370\377\361\364\371\377\360\363"
	  "\370\377\360\362\370\377\360\362\367\377\360\362\370\377\361\363\371\377"
	  "\362\364\371\377\362\363\371\377\361\363\370\377\361\363\367\377\360\362"
	  "\367\377\361\362\367\377\360\361\367\377\360\362\365\377\202\357\361\366"
	  "\377\7\356\360\364\377\356\360\365\377\354\357\365\377\355\360\365\377\356"
	  "\360\365\377\355\360\365\377\353\357\364\377\203\355\357\365\377\11\354\356"
	  "\364\377\353\355\364\377\354\357\364\377\353\356\363\377\354\356\364\377"
	  "\352\355\362\377\353\355\363\377\353\356\364\377\353\355\363\377\202\352"
	  "\355\363\377\33\353\355\363\377\354\357\364\377\354\357\365\377\354\357\364"
	  "\377\353\355\362\377\353\355\363\377\352\355\363\377\352\354\362\377\351"
	  "\353\362\377\351\353\361\377\346\352\360\377\351\354\362\377\353\355\362"
	  "\377\352\355\362\377\352\355\363\377\353\354\361\377\343\346\353\377\7\7"
	  "\7\377\5\6\5\377!#&\377\0\0\0\377\262\265\271\377\352\354\361\377\351\353"
	  "\360\377\352\354\362\377\352\355\363\377\353\354\362\377\202\352\354\362"
	  "\377\20\354\356\363\377\352\355\362\377\353\355\362\377\352\354\362\377\351"
	  "\354\362\377\347\353\360\377\350\355\362\377\352\354\363\377\351\355\362"
	  "\377\353\355\363\377\351\354\362\377\354\356\364\377\354\356\363\377\355"
	  "\357\365\377\355\357\364\377\353\356\364\377\202\354\357\364\377-\213\215"
	  "\220\377\1\2\2\377\3\3\3\377\204\205\210\377HIK\377\6\7\7\377\26!\33\377"
	  "\25\30\30\377\21\24\26\377\23\25\27\377\22\23\24\377\12\13\13\377\10\10\11"
	  "\377\13\15\16\377\11\12\13\377\13\14\15\377\10\11\11\377\6\7\7\377\5\6\6"
	  "\377\13\15\16\377\7\7\10\377\10\11\12\377\7\10\10\377\14\14\15\377\10\10"
	  "\11\377\24\25\27\377\17\17\21\377\25\27\31\377\27\31\33\377\11\11\12\377"
	  "\15\20\21\377\32\35\37\377\40\"$\377\32\35\36\376\30\33\35\377\17\22\22\377"
	  "\23\23\24\377\23\25\26\377\6\7\7\377prt\377\362\364\371\377\363\365\372\377"
	  "\362\364\371\377\361\364\371\377\360\363\370\377\202\360\362\367\377\202"
	  "\357\362\367\377\16\361\363\370\377\362\364\370\377\363\364\371\377\362\364"
	  "\371\377\361\362\370\377\361\363\367\377\360\363\367\377\357\362\366\377"
	  "\356\361\366\377\360\362\367\377\357\361\366\377\356\360\365\377\355\360"
	  "\366\377\356\360\366\377\202\356\360\365\377+\354\357\365\377\354\356\363"
	  "\377\355\360\364\377\354\356\364\377\355\360\365\377\353\356\365\377\354"
	  "\355\363\377\352\355\363\377\353\356\363\377\353\355\362\377\353\355\363"
	  "\377\351\354\362\377\352\354\363\377\352\355\363\377\351\354\361\377\351"
	  "\353\362\377\352\354\362\377\352\355\363\377\353\355\363\377\352\354\362"
	  "\377\353\356\363\377\353\355\363\377\352\355\362\377\352\354\362\377\351"
	  "\353\361\377\352\354\362\377\351\353\361\377\347\352\361\377\351\353\361"
	  "\377\352\354\362\377\351\354\362\377\352\354\362\377\353\357\364\377456\377"
	  "\4\4\5\377\16\17\17\377\0\0\0\377\263\265\271\377\351\352\357\377\351\353"
	  "\360\377\351\353\361\377\351\354\361\377\352\355\363\377\202\352\355\362"
	  "\377\14\353\355\363\377\352\355\362\377\353\356\363\377\352\355\363\377\352"
	  "\355\362\377\350\354\360\377\350\354\361\377\351\354\362\377\352\354\362"
	  "\377\353\355\363\377\352\355\363\377\352\355\362\377\202\354\356\364\377"
	  "\2\354\356\363\377\354\356\364\377\202\354\357\364\377\15\212\214\217\377"
	  "\1\2\2\377\3\3\3\377\16\16\17\377\1\1\1\377\30\32\33\377\15\34\25\377\13"
	  "\16\16\377\25\27\32\377+-2\377\10\11\11\377\10\12\13\377\11\14\15\377\202"
	  "\11\11\11\377\32\11\12\13\377\5\5\5\377\4\5\5\377%(+\377\5\6\6\377\7\7\10"
	  "\377\14\15\16\377\15\16\17\377\10\11\11\377\"#&\377\12\13\13\377\22\23\25"
	  "\377\15\17\21\377\11\12\12\377\27\31\34\377\26\30\32\377\12\13\13\377\31"
	  "\34\35\377\12\14\14\376\15\17\20\377\33\37\40\377\30\32\34\377\26\31\32\377"
	  "\2\3\3\377\241\242\244\377\361\363\370\377\202\362\364\371\377\2\361\364"
	  "\370\377\361\363\370\377\202\357\362\366\377\6\356\361\367\377\360\362\367"
	  "\377\361\363\370\377\361\363\367\377\361\363\370\377\361\363\371\377\202"
	  "\361\363\370\377\6\357\362\367\377\357\361\366\377\357\361\367\377\357\361"
	  "\366\377\356\361\366\377\356\360\365\377\202\356\360\366\377\16\355\357\364"
	  "\377\355\357\365\377\355\360\365\377\355\357\364\377\354\357\365\377\355"
	  "\357\365\377\355\360\365\377\354\356\364\377\353\356\364\377\353\356\363"
	  "\377\354\356\363\377\353\356\364\377\354\356\364\377\353\356\363\377\202"
	  "\353\355\363\377\1\352\355\363\377\202\353\355\363\377\36\354\356\364\377"
	  "\353\356\363\377\353\355\363\377\355\357\364\377\354\356\363\377\352\354"
	  "\362\377\352\355\362\377\353\355\363\377\352\355\363\377\352\354\363\377"
	  "\351\355\362\377\352\355\362\377\351\354\362\377\352\354\362\377\351\354"
	  "\362\377\352\354\363\377deh\377\4\5\5\377\24\26\31\377\0\0\0\377\262\264"
	  "\270\377\350\353\360\377\351\354\361\377\351\353\361\377\351\354\362\377"
	  "\353\355\363\377\352\354\362\377\351\354\362\377\352\354\362\377\351\354"
	  "\362\377\202\352\354\362\377?\352\354\361\377\353\355\362\377\350\354\360"
	  "\377\351\354\361\377\350\353\361\377\351\354\362\377\353\355\363\377\354"
	  "\356\364\377\353\355\363\377\353\356\364\377\352\355\363\377\354\356\364"
	  "\377\354\356\363\377\353\355\363\377\213\214\217\377\2\3\3\377\11\12\14\377"
	  "\2\2\2\377\6\7\10\377\17\21\22\377\5\17\13\377\7\11\12\377\15\16\17\377\7"
	  "\7\7\377\10\11\11\377\6\7\10\377\7\10\10\377\10\10\11\377\4\5\5\377\5\5\4"
	  "\377\2\3\3\377\7\7\10\377\10\11\11\377\4\4\4\377\6\7\6\377EDJ\377\13\13\13"
	  "\377\21\22\24\377\10\11\12\37758<\377\13\14\15\377\12\13\14\377\23\25\26"
	  "\377\14\15\14\377\14\16\17\377\21\24\25\377\17\20\21\377\12\14\14\376\32"
	  "\34\36\377\20\23\24\377\16\21\21\377\26\31\34\377\0\0\0\377\307\312\315\377"
	  "\360\363\370\377\360\363\367\377\361\363\370\377\360\363\370\377\361\363"
	  "\370\377\360\362\367\377\357\362\367\377\360\362\367\377\360\363\367\377"
	  "\202\360\363\370\377\203\360\362\367\377\202\357\361\367\377\1\357\361\366"
	  "\377\202\356\361\366\377\1\355\360\365\377\203\356\360\365\377\1\357\360"
	  "\366\377\203\355\360\365\377\3\353\356\363\377\354\357\365\377\355\357\365"
	  "\377\202\354\356\364\377\4\353\355\362\377\354\356\364\377\353\355\364\377"
	  "\353\355\363\377\202\352\355\363\377\3\354\356\364\377\353\355\363\377\352"
	  "\355\363\377\202\353\356\363\377\14\353\355\363\377\354\356\363\377\353\356"
	  "\364\377\353\355\362\377\352\355\363\377\353\355\363\377\352\354\362\377"
	  "\351\354\362\377\352\355\363\377\352\354\363\377\353\356\363\377\352\354"
	  "\361\377\202\351\354\362\377\7\352\355\363\377\213\214\220\377\2\3\3\377"
	  "\15\16\17\377\0\0\0\377\262\265\271\377\353\355\363\377\204\352\354\362\377"
	  "\13\351\354\361\377\347\353\361\377\351\353\362\377\352\355\363\377\351\353"
	  "\361\377\351\354\362\377\352\355\362\377\351\354\361\377\347\353\360\377"
	  "\352\354\362\377\351\354\362\377\202\352\355\363\377\13\353\355\363\377\354"
	  "\356\364\377\353\355\363\377\352\355\363\377\354\357\364\377\352\355\363"
	  "\377\353\356\364\377\213\214\220\377\3\3\3\377\4\5\5\377\13\14\14\377\202"
	  "\25\25\26\377\1\25\25\25\377\214\25\25\26\377\30\3\3\3\377\4\5\5\377\7\7"
	  "\7\377\16\17\20\377\15\20\20\377\16\17\22\377\10\10\10\377\10\11\11\377\14"
	  "\15\16\377\37!$\377\11\10\11\377%(+\377\34\37!\377\14\17\20\377\34\37\40"
	  "\376\11\13\13\377!'(\377\32\32\33\377\17\20\21\377\1\1\1\377\346\350\353"
	  "\377\361\363\370\377\360\362\366\377\360\362\367\377\203\360\363\370\377"
	  "\5\360\362\370\377\357\362\367\377\360\362\367\377\361\363\370\377\357\362"
	  "\367\377\202\357\361\366\377\12\357\361\364\377\356\361\366\377\357\361\367"
	  "\377\357\360\366\377\356\360\366\377\356\360\365\377\355\360\365\377\356"
	  "\360\366\377\356\360\365\377\354\357\364\377\202\355\357\365\377\3\355\360"
	  "\366\377\356\360\366\377\353\357\363\377\202\354\356\364\377\1\354\357\365"
	  "\377\202\354\356\364\377\15\353\355\363\377\353\356\364\377\353\356\363\377"
	  "\353\355\363\377\353\355\364\377\353\356\364\377\351\354\361\377\353\355"
	  "\363\377\353\356\363\377\353\355\363\377\353\355\362\377\355\357\364\377"
	  "\354\357\364\377\203\353\355\363\377\17\352\355\363\377\352\354\362\377\351"
	  "\354\362\377\352\355\363\377\353\355\363\377\352\354\362\377\352\355\363"
	  "\377\354\356\364\377\352\355\363\377\251\252\257\377\0\1\1\377\14\16\17\377"
	  "\0\0\0\377\262\264\271\377\352\355\362\377\202\351\354\362\377\7\350\353"
	  "\360\377\352\354\361\377\351\354\361\377\347\353\361\377\352\354\362\377"
	  "\352\354\361\377\351\354\362\377\202\352\354\362\377\2\352\355\363\377\351"
	  "\355\362\377\203\351\354\362\377\22\352\355\363\377\353\356\364\377\354\356"
	  "\363\377\354\357\364\377\353\356\364\377\356\360\365\377\355\357\364\377"
	  "\353\356\363\377\211\214\216\377\3\4\4\377\2\2\3\377\213\214\216\377\356"
	  "\361\366\377\357\363\367\377\360\362\370\377\361\363\370\377\360\363\367"
	  "\377\357\363\367\377\202\357\362\367\377\15\360\363\370\377\361\363\371\377"
	  "\362\364\370\377\362\364\371\377\360\363\370\377\362\364\370\377\363\365"
	  "\371\377*+,\377\4\4\4\377\14\15\16\377\10\10\11\377\16\20\21\377\11\11\12"
	  "\377\202\10\10\10\377\20\22\24\25\377\10\10\11\377\37#%\377\15\15\16\377"
	  "\23\25\27\377\14\15\16\377\32\35\36\376!%&\377\12\13\13\377\16\17\17\377"
	  "\14\15\16\377\13\13\14\377\362\364\370\377\361\363\370\377\360\362\366\377"
	  "\361\363\371\377\202\361\363\370\377\23\357\362\367\377\360\362\367\377\357"
	  "\362\367\377\360\362\370\377\360\362\367\377\357\362\366\377\357\361\366"
	  "\377\356\361\366\377\356\360\364\377\357\361\366\377\356\360\365\377\356"
	  "\360\364\377\356\361\366\377\357\360\366\377\355\360\365\377\357\360\365"
	  "\377\355\360\364\377\356\360\365\377\355\360\365\377\202\355\357\364\377"
	  "\15\355\360\365\377\355\357\365\377\353\356\363\377\353\355\363\377\354\356"
	  "\364\377\353\356\364\377\354\356\364\377\353\356\363\377\353\355\363\377"
	  "\352\355\363\377\353\355\363\377\353\356\364\377\352\355\363\377\202\353"
	  "\355\363\377\7\354\355\363\377\352\355\363\377\353\356\363\377\354\356\364"
	  "\377\353\356\364\377\352\354\362\377\353\355\362\377\202\353\355\363\377"
	  "\26\353\355\362\377\352\354\362\377\352\355\362\377\353\354\362\377\351\354"
	  "\362\377\352\355\363\377\353\355\362\377\352\354\362\377\277\300\306\377"
	  "\0\0\0\377\17\20\22\377\0\0\0\377\261\263\270\377\351\354\361\377\352\354"
	  "\362\377\351\353\362\377\347\352\357\377\352\355\362\377\351\353\361\377"
	  "\351\354\362\377\352\354\362\377\353\354\363\377\202\351\354\362\377\3\352"
	  "\355\363\377\353\356\363\377\351\356\362\377\203\351\354\362\377!\352\356"
	  "\363\377\353\356\363\377\354\356\364\377\354\357\364\377\354\357\365\377"
	  "\353\356\363\377\355\357\364\377\354\356\363\377\212\214\217\377\2\2\3\377"
	  "\3\3\4\377\212\213\215\377\353\356\363\377\352\356\363\377\355\357\365\377"
	  "\354\357\364\377\354\357\365\377\355\357\365\377\355\360\365\377\355\357"
	  "\365\377\355\360\365\377\355\360\366\377\356\361\366\377\355\360\365\377"
	  "\356\361\366\377\357\361\367\377\360\363\370\377**+\377\14\16\17\377\14\17"
	  "\20\377\6\7\7\377\11\11\12\377\12\13\14\377\202\10\10\11\377\20\12\13\13"
	  "\377\13\14\14\377\14\14\15\377\31\32\35\377\13\13\14\377\13\13\13\377\"&"
	  "(\376),/\377\15\16\16\377\15\17\16\377\12\12\12\377\30\30\31\377\364\366"
	  "\372\377\361\363\370\377\357\361\366\377\361\363\370\377\202\360\363\370"
	  "\377\2\357\362\367\377\360\362\370\377\202\360\362\367\377\202\357\362\367"
	  "\377\15\357\361\367\377\356\361\365\377\355\357\365\377\356\361\366\377\355"
	  "\360\366\377\357\361\366\377\357\360\366\377\357\361\366\377\355\360\365"
	  "\377\356\360\365\377\355\360\366\377\355\357\365\377\355\357\364\377\202"
	  "\354\357\364\377\10\355\360\366\377\355\360\365\377\352\355\363\377\353\356"
	  "\364\377\352\356\364\377\354\357\365\377\354\356\364\377\353\356\364\377"
	  "\202\353\355\363\377\21\353\356\363\377\352\355\363\377\352\354\362\377\352"
	  "\355\362\377\353\356\363\377\353\355\363\377\352\355\363\377\353\356\363"
	  "\377\354\356\363\377\353\355\361\377\352\354\361\377\352\355\363\377\353"
	  "\355\364\377\352\355\363\377\352\355\362\377\352\354\361\377\353\356\364"
	  "\377\202\352\354\362\377\32\352\355\363\377\352\354\362\377\352\355\362\377"
	  "\316\320\325\377\0\0\0\377\13\13\15\377\0\0\0\377\262\263\271\377\351\354"
	  "\362\377\352\354\361\377\351\353\361\377\350\353\361\377\352\353\361\377"
	  "\352\354\362\377\352\355\362\377\351\353\361\377\353\355\363\377\351\354"
	  "\362\377\353\356\363\377\352\355\363\377\352\355\362\377\351\355\362\377"
	  "\352\355\362\377\352\354\363\377\353\355\363\377\354\356\363\377\202\353"
	  "\356\363\3775\354\356\364\377\354\357\365\377\352\355\363\377\354\356\364"
	  "\377\353\356\363\377\213\214\217\377\3\4\4\377\2\3\3\377\211\213\216\377"
	  "\354\356\364\377\355\357\365\377\355\360\365\377\356\360\366\377\356\361"
	  "\367\377\355\360\366\377\355\360\365\377\356\360\366\377\355\360\365\377"
	  "\355\360\366\377\356\361\366\377\355\361\366\377\356\361\366\377\357\361"
	  "\366\377\361\364\370\377**+\377\22\25\26\377\25\31\32\377\7\7\11\377\11\13"
	  "\14\377\11\12\12\377\10\10\11\377\12\13\13\377%*.\377\10\10\10\377\13\14"
	  "\15\377\34!#\377\13\13\14\377\11\10\10\377\17\21\20\376\13\14\13\377\36\37"
	  "!\377\14\15\15\377\20\23\24\377\37\37\40\377\363\365\371\377\360\363\370"
	  "\377\360\362\367\377\357\362\367\377\361\364\371\377\357\362\370\377\357"
	  "\362\367\377\360\363\370\377\360\361\367\377\202\357\361\366\377\15\356\361"
	  "\366\377\357\361\367\377\356\360\366\377\357\361\365\377\356\361\365\377"
	  "\355\357\365\377\355\357\364\377\356\357\365\377\356\360\366\377\355\357"
	  "\365\377\355\360\365\377\354\357\365\377\354\356\364\377\202\354\357\364"
	  "\377\30\354\357\365\377\353\356\364\377\354\357\365\377\352\355\363\377\354"
	  "\357\365\377\353\356\364\377\354\356\364\377\353\356\363\377\354\356\364"
	  "\377\354\357\364\377\353\356\364\377\352\354\362\377\353\356\364\377\352"
	  "\355\363\377\351\354\361\377\352\355\363\377\352\354\362\377\352\355\363"
	  "\377\353\355\363\377\353\354\362\377\353\355\362\377\353\355\363\377\352"
	  "\355\363\377\351\354\362\377\202\352\355\362\377\2\352\354\362\377\352\355"
	  "\363\377\202\353\355\363\377\12\351\353\362\377\353\355\362\377\351\354\362"
	  "\377\323\325\333\377\0\0\0\377\14\14\16\377\0\0\0\377\263\265\272\377\351"
	  "\354\362\377\350\353\361\377\202\351\354\362\377\4\353\355\363\377\352\354"
	  "\361\377\351\354\362\377\353\355\363\377\202\352\354\362\377\20\352\354\361"
	  "\377\352\355\363\377\351\354\362\377\352\356\362\377\352\354\362\377\352"
	  "\355\362\377\351\354\362\377\353\356\363\377\353\356\364\377\352\355\362"
	  "\377\355\357\364\377\354\357\365\377\354\357\364\377\353\356\364\377\353"
	  "\355\363\377\213\214\217\377\202\2\2\2\377\1\211\213\216\377\202\354\357"
	  "\365\377\5\356\360\365\377\355\357\365\377\355\360\366\377\356\360\366\377"
	  "\355\360\365\377\202\356\361\366\377\2\355\360\366\377\356\360\366\377\202"
	  "\356\361\366\377*\355\360\366\377\362\364\371\377**,\377\12\14\15\377\14"
	  "\16\17\377\7\10\11\377\13\15\16\377\7\7\7\377\10\12\13\377\20\22\24\377\12"
	  "\14\15\377\14\14\14\377\13\14\14\377\17\22\22\377\20\22\24\377\11\11\11\377"
	  "\15\17\17\376\21\23\24\377\14\14\14\377\33\35\36\377\11\12\11\377\35\35\37"
	  "\377\363\365\371\377\361\364\370\377\360\362\367\377\360\363\370\377\360"
	  "\362\370\377\361\363\370\377\357\361\366\377\360\362\370\377\356\360\366"
	  "\377\357\361\366\377\356\361\366\377\357\361\366\377\360\362\367\377\356"
	  "\360\365\377\357\361\367\377\355\360\365\377\355\357\364\377\356\360\365"
	  "\377\355\357\363\377\354\356\364\377\202\355\360\365\377\5\354\357\364\377"
	  "\354\357\365\377\355\356\364\377\355\356\363\377\354\356\364\377\202\354"
	  "\357\365\377\25\353\356\364\377\354\357\365\377\353\356\364\377\354\356\364"
	  "\377\353\356\364\377\353\356\363\377\355\357\365\377\354\356\363\377\352"
	  "\354\362\377\353\355\364\377\352\355\364\377\351\354\361\377\352\355\362"
	  "\377\351\354\361\377\352\356\363\377\354\355\364\377\353\355\363\377\352"
	  "\355\363\377\353\356\363\377\353\355\362\377\352\354\362\377\202\352\355"
	  "\362\377\2\352\355\363\377\352\355\362\377\202\353\355\363\377\30\352\355"
	  "\361\377\351\354\362\377\352\355\363\377\323\324\332\377\0\0\0\377\12\13"
	  "\13\377\0\0\0\377\262\265\271\377\352\354\362\377\352\353\361\377\352\354"
	  "\362\377\351\353\360\377\353\354\362\377\353\355\362\377\352\354\362\377"
	  "\353\355\363\377\353\355\362\377\351\354\362\377\352\354\361\377\351\353"
	  "\361\377\351\355\362\377\352\356\362\377\353\355\362\377\353\355\363\377"
	  "\202\353\356\363\377\4\354\357\364\377\353\356\364\377\354\356\364\377\353"
	  "\356\364\377\202\354\356\364\377\12\352\355\363\377\213\215\217\377\2\2\2"
	  "\377\1\2\2\377\211\213\216\377\355\357\365\377\353\356\364\377\355\357\365"
	  "\377\355\360\365\377\355\357\365\377\202\355\360\365\377\"\356\361\367\377"
	  "\356\361\366\377\357\361\366\377\355\360\366\377\357\361\366\377\356\361"
	  "\367\377\356\360\366\377\361\364\370\377**+\377\6\10\10\377\11\11\13\377"
	  "\5\7\7\377\12\14\15\377\10\12\13\377\11\11\11\377\12\12\13\377+.1\377\13"
	  "\14\15\377\22\24\26\377\35\40#\377\10\11\12\377\12\13\14\377\13\15\15\376"
	  "\12\11\11\377\17\21\22\377\31\35\36\377\23\22\24\377\23\24\24\377\363\365"
	  "\371\377\360\362\367\377\361\363\370\377\360\362\366\377\361\363\370\377"
	  "\356\362\366\377\202\357\362\367\377\3\356\360\366\377\356\361\366\377\360"
	  "\362\367\377\202\357\361\367\377\1\357\361\366\377\202\356\360\366\377\5"
	  "\356\361\366\377\355\360\365\377\354\356\364\377\356\360\364\377\355\357"
	  "\364\377\203\355\360\365\377\4\355\357\365\377\354\357\364\377\354\356\365"
	  "\377\354\357\365\377\202\353\356\364\377\2\352\355\363\377\352\355\364\377"
	  "\202\354\356\364\377#\354\357\364\377\353\356\363\377\354\356\364\377\354"
	  "\355\363\377\353\356\364\377\354\356\364\377\352\354\362\377\353\355\362"
	  "\377\352\355\362\377\353\355\363\377\353\356\364\377\353\356\363\377\353"
	  "\355\362\377\353\355\363\377\352\354\362\377\352\355\362\377\352\355\363"
	  "\377\353\355\363\377\352\354\363\377\353\355\363\377\352\355\362\377\353"
	  "\355\362\377\353\356\363\377\353\355\363\377\352\355\362\377\311\313\320"
	  "\377\0\0\0\377\17\21\22\377\0\0\0\377\261\264\271\377\352\355\362\377\351"
	  "\353\361\377\351\353\362\377\351\354\362\377\352\354\362\377\202\352\355"
	  "\363\377\13\353\355\363\377\352\355\362\377\353\355\362\377\352\355\363\377"
	  "\351\354\362\377\351\355\362\377\352\356\363\377\351\354\362\377\353\356"
	  "\364\377\354\357\364\377\353\356\364\377\202\353\356\363\377\2\354\356\364"
	  "\377\352\354\361\377\202\354\356\364\377\2\355\357\364\377\213\215\217\377"
	  "\202\2\2\2\377\5\212\213\215\377\355\357\366\377\355\360\366\377\355\360"
	  "\365\377\355\360\366\377\202\355\357\365\377\3\355\360\365\377\356\360\366"
	  "\377\355\361\366\377\202\356\361\367\377\40\356\361\366\377\357\361\367\377"
	  "\356\361\366\377\361\363\370\377**+\377\4\5\5\377\7\10\10\377\6\7\10\377"
	  "\17\21\22\377\13\14\15\377\16\20\21\377\22\23\24\377\22\24\25\377)-0\377"
	  "\26\31\33\377\13\13\14\377\22\24\26\377\14\16\17\377\13\13\13\376\25\30\31"
	  "\377DGL\377\17\20\20\377\14\16\16\377\10\10\10\377\355\360\365\377\357\362"
	  "\367\377\360\362\367\377\360\362\370\377\361\363\370\377\360\363\370\377"
	  "\356\362\367\377\357\362\367\377\202\357\361\366\377\12\360\362\366\377\357"
	  "\362\367\377\360\361\367\377\356\361\365\377\356\360\365\377\355\357\365"
	  "\377\354\357\364\377\355\357\365\377\354\357\364\377\355\360\364\377\202"
	  "\354\357\364\377\1\354\357\365\377\203\355\357\365\377\15\355\360\365\377"
	  "\354\357\365\377\353\357\364\377\355\356\364\377\353\356\363\377\352\355"
	  "\364\377\354\357\364\377\354\356\363\377\355\357\365\377\354\357\365\377"
	  "\353\355\363\377\354\356\363\377\352\354\364\377\202\351\354\362\377\3\353"
	  "\355\363\377\351\354\361\377\352\355\363\377\203\353\355\363\377\2\354\356"
	  "\364\377\353\355\363\377\202\351\354\362\377\3\352\354\362\377\352\354\363"
	  "\377\352\355\363\377\203\353\355\362\377\21\353\355\364\377\352\354\362\377"
	  "\270\271\276\377\0\0\0\377\11\12\12\377\0\0\0\377\262\264\271\377\351\354"
	  "\361\377\351\353\361\377\352\354\362\377\351\354\362\377\353\355\362\377"
	  "\352\354\362\377\353\356\363\377\353\355\363\377\352\354\362\377\352\355"
	  "\363\377\202\353\355\363\377\6\353\356\363\377\352\355\363\377\353\356\363"
	  "\377\353\356\364\377\352\355\363\377\354\357\364\377\202\355\357\364\377"
	  "\6\353\356\364\377\355\357\364\377\354\356\364\377\352\355\362\377\354\357"
	  "\364\377\213\214\217\377\202\1\1\1\377\2\212\213\216\377\355\357\365\377"
	  "\202\355\360\365\377\6\354\357\365\377\355\360\366\377\356\360\366\377\354"
	  "\357\366\377\356\360\365\377\357\361\367\377\202\356\361\367\377\1\357\361"
	  "\367\377\202\357\362\367\377\30\361\364\370\377*+,\377\6\7\7\377\7\10\10"
	  "\377\6\7\7\377\35!$\377\11\13\14\377\23\26\30\377\11\12\12\377\12\12\12\377"
	  "\33\36!\377\13\14\15\377\15\17\20\377\11\11\12\377\11\11\11\377\34!#\376"
	  "\15\17\20\377\"%'\377\17\20\20\377\26\27\30\377\0\0\0\377\336\340\343\377"
	  "\360\362\367\377\361\363\370\377\202\360\362\367\377\2\360\363\370\377\357"
	  "\362\367\377\202\357\361\367\377\2\357\362\367\377\357\361\366\377\202\356"
	  "\360\365\377\2\356\361\366\377\356\360\366\377\202\355\357\365\377\20\354"
	  "\356\363\377\353\356\364\377\354\357\364\377\355\360\365\377\355\357\364"
	  "\377\354\356\364\377\355\360\365\377\355\357\365\377\355\360\365\377\354"
	  "\357\365\377\353\357\365\377\353\357\364\377\354\356\365\377\354\357\364"
	  "\377\353\356\364\377\352\355\364\377\203\353\356\364\377\17\352\355\363\377"
	  "\351\354\362\377\352\354\363\377\351\354\362\377\350\353\361\377\352\355"
	  "\363\377\352\354\362\377\353\355\362\377\352\355\363\377\353\355\363\377"
	  "\353\356\363\377\353\355\363\377\353\355\362\377\352\355\362\377\352\354"
	  "\363\377\202\352\355\363\377\2\352\354\362\377\353\355\362\377\202\353\355"
	  "\363\377\11\352\355\362\377\352\354\362\377\240\241\246\377\0\0\0\377\13"
	  "\14\15\377\0\0\0\377\262\263\270\377\352\355\362\377\352\354\362\377\202"
	  "\353\355\363\377\4\354\356\363\377\352\354\363\377\352\355\363\377\353\356"
	  "\363\377\202\353\355\363\377\5\353\356\363\377\352\354\362\377\354\356\363"
	  "\377\352\356\364\377\353\356\363\377\202\353\355\363\377\1\354\356\364\377"
	  "\202\353\356\364\377\1\354\357\364\377\202\355\360\365\377\3\353\356\363"
	  "\377\354\360\365\377\214\215\217\377\202\1\1\1\377\6\212\213\216\377\355"
	  "\360\365\377\355\357\365\377\354\357\365\377\357\361\366\377\355\360\366"
	  "\377\202\356\360\366\377\5\355\360\366\377\357\361\366\377\357\361\367\377"
	  "\357\361\366\377\360\362\367\377\202\357\362\367\377\3\362\365\371\377**"
	  "+\377\10\10\10\377\202\6\7\10\377\22\11\14\14\377\17\21\23\377\14\15\16\377"
	  "\15\17\20\377\14\15\16\377\15\16\17\377\15\17\20\377\17\21\22\377\10\11\12"
	  "\377\11\13\13\3777=A\376<=B\377\14\14\14\377\15\17\20\377\15\16\16\377\0"
	  "\0\0\377\272\275\300\377\360\362\367\377\202\360\363\370\377\4\357\361\367"
	  "\377\360\362\367\377\357\361\367\377\356\361\366\377\202\357\361\367\377"
	  "\202\360\362\367\377\23\355\360\365\377\357\361\367\377\355\360\365\377\355"
	  "\357\365\377\355\360\365\377\355\357\365\377\355\357\363\377\355\357\364"
	  "\377\354\357\365\377\354\357\364\377\355\357\364\377\355\356\364\377\354"
	  "\357\365\377\353\357\364\377\355\357\365\377\354\357\365\377\353\356\364"
	  "\377\354\356\364\377\353\356\364\377\202\352\355\363\377\14\353\355\363\377"
	  "\353\355\361\377\353\355\363\377\352\355\363\377\351\354\362\377\352\355"
	  "\363\377\351\354\362\377\351\355\363\377\352\355\362\377\352\354\362\377"
	  "\354\356\363\377\353\355\362\377\202\353\356\364\377\11\354\356\364\377\352"
	  "\354\362\377\352\355\363\377\352\354\363\377\352\355\362\377\352\354\362"
	  "\377\353\355\362\377\350\353\360\377\352\354\361\377\202\352\355\363\377"
	  "\11\351\354\361\377\177\200\203\377\2\2\2\377\13\14\15\377\0\0\0\377\261"
	  "\264\271\377\351\353\362\377\352\354\362\377\353\355\363\377\202\352\354"
	  "\361\377\3\353\355\361\377\353\355\362\377\352\354\361\377\202\353\356\363"
	  "\377\4\353\356\364\377\352\355\363\377\353\356\363\377\352\356\363\377\202"
	  "\353\356\363\377\2\353\355\363\377\354\357\364\377\202\353\356\363\377\20"
	  "\354\356\364\377\356\360\365\377\354\356\364\377\355\357\365\377\355\360"
	  "\365\377\213\214\217\377\2\1\2\377\2\2\2\377\210\212\215\377\356\360\365"
	  "\377\355\360\366\377\356\361\366\377\356\360\365\377\355\360\366\377\356"
	  "\361\366\377\355\360\366\377\202\356\361\366\377$\357\361\367\377\356\361"
	  "\366\377\357\362\367\377\360\362\370\377\357\361\367\377\362\365\371\377"
	  "**,\377\4\4\5\377\6\10\10\377\6\7\10\377\10\11\12\377\27\33\35\377\31\34"
	  "\36\377\15\17\20\377\10\11\11\377\11\11\11\377\7\7\10\377\21\23\25\377\16"
	  "\16\20\377\21\23\24\377\31\34\36\376\14\16\16\377\16\20\20\377\24\25\26\377"
	  "\31\34\35\377\1\1\1\377\221\223\226\377\360\363\370\377\360\362\367\377\357"
	  "\362\367\377\357\361\367\377\357\361\366\377\357\361\367\377\357\362\367"
	  "\377\355\361\366\377\357\362\367\377\202\357\361\367\377\4\357\361\366\377"
	  "\357\361\367\377\356\361\366\377\357\361\366\377\203\356\360\365\377\35\355"
	  "\357\364\377\355\357\365\377\353\355\363\377\352\355\363\377\354\356\364"
	  "\377\355\360\365\377\354\356\364\377\353\357\364\377\352\356\364\377\355"
	  "\357\365\377\354\357\364\377\352\355\363\377\353\356\365\377\353\356\364"
	  "\377\354\356\364\377\353\356\364\377\353\356\363\377\352\354\363\377\352"
	  "\355\363\377\353\356\364\377\352\355\362\377\351\353\361\377\352\355\362"
	  "\377\352\355\363\377\351\354\363\377\352\354\360\377\355\357\365\377\353"
	  "\356\363\377\354\356\364\377\202\353\355\363\377\202\352\355\363\377\1\351"
	  "\354\362\377\202\352\354\362\377\22\352\354\363\377\353\355\363\377\353\354"
	  "\362\377\351\354\362\377VWZ\377\3\4\4\377\14\14\15\377\0\0\0\377\262\264"
	  "\271\377\351\354\362\377\353\355\363\377\352\354\363\377\352\354\362\377"
	  "\352\355\362\377\353\355\363\377\353\356\363\377\352\354\362\377\353\355"
	  "\363\377\202\352\355\362\377\7\353\355\363\377\351\354\362\377\352\356\363"
	  "\377\353\355\363\377\353\356\363\377\355\357\364\377\354\357\364\377\202"
	  "\352\355\363\377\6\352\356\363\377\354\356\361\377\353\355\364\377\354\357"
	  "\364\377\356\361\365\377\214\216\220\377\202\2\2\2\377\15\211\212\216\377"
	  "\356\360\365\377\355\360\366\377\356\361\366\377\355\360\366\377\356\361"
	  "\366\377\356\361\367\377\356\360\366\377\357\361\367\377\357\361\366\377"
	  "\357\362\367\377\357\361\367\377\357\362\366\377\202\357\362\367\377\31\363"
	  "\365\371\377*+,\377\14\16\17\377\14\17\20\377\7\10\10\377\7\10\11\377\16"
	  "\17\21\377\15\17\20\377\14\16\20\377\17\20\21\377\14\14\15\377\7\11\11\377"
	  "\12\12\13\377\7\11\11\377269\377\21\23\24\376\22\25\27\377\12\14\14\377\17"
	  "\17\20\377\20\22\23\377\5\5\5\377_`a\377\357\362\367\377\360\362\370\377"
	  "\357\362\367\377\202\356\361\366\377\2\357\361\366\377\357\362\367\377\202"
	  "\357\361\367\377\21\357\362\367\377\356\361\366\377\357\361\366\377\356\361"
	  "\366\377\357\361\367\377\357\362\367\377\356\361\365\377\356\360\366\377"
	  "\355\357\365\377\356\360\366\377\354\357\364\377\354\356\364\377\353\357"
	  "\364\377\354\357\365\377\354\356\364\377\354\357\365\377\354\356\364\377"
	  "\202\354\357\365\377\4\354\356\364\377\352\355\363\377\354\357\364\377\354"
	  "\357\365\377\202\353\356\364\377\4\353\356\363\377\352\355\363\377\351\354"
	  "\362\377\353\355\364\377\204\352\355\363\377\7\350\353\361\377\352\355\363"
	  "\377\354\357\364\377\354\356\364\377\354\355\363\377\352\354\363\377\352"
	  "\354\362\377\202\351\354\362\377\1\352\354\362\377\202\351\354\362\377\14"
	  "\352\355\363\377\352\354\362\377\352\354\361\377\354\357\365\377#$%\377\5"
	  "\6\6\377\16\16\17\377\0\1\1\377\262\264\270\377\352\354\362\377\354\355\363"
	  "\377\352\354\362\377\202\353\355\363\377\11\351\354\362\377\352\355\363\377"
	  "\351\354\361\377\352\355\362\377\352\354\363\377\353\355\363\377\352\355"
	  "\362\377\352\356\362\377\353\357\363\377\202\353\356\363\377\3\355\357\365"
	  "\377\353\356\363\377\352\355\363\377\202\354\357\364\377\5\354\356\364\377"
	  "\352\356\363\377\355\357\365\377\356\360\365\377\214\215\220\377\202\2\2"
	  "\2\377\5\211\212\216\377\355\361\366\377\355\360\366\377\355\360\365\377"
	  "\355\361\366\377\202\355\360\366\377#\356\361\366\377\357\361\367\377\357"
	  "\362\367\377\357\361\366\377\357\361\367\377\357\362\367\377\360\362\367"
	  "\377\361\363\367\377\363\365\371\377*+,\377\7\10\11\377\11\12\12\377\15\20"
	  "\20\377\7\10\11\377\11\13\13\377\11\12\13\377\13\13\14\377\12\13\13\377\13"
	  "\14\15\377\14\15\15\377\10\11\11\377\20\23\24\377\27\31\34\377\22\24\26\376"
	  "\15\16\17\377\14\17\20\377\24\26\30\377\16\17\20\377\6\7\6\377\"#$\377\361"
	  "\363\370\377\357\362\367\377\360\361\367\377\356\361\366\377\357\361\367"
	  "\377\202\356\361\367\377\11\357\361\366\377\355\360\366\377\357\361\367\377"
	  "\356\361\366\377\357\362\370\377\356\361\367\377\356\360\365\377\356\360"
	  "\363\377\356\361\366\377\203\355\357\365\377\3\354\357\364\377\353\356\363"
	  "\377\354\356\364\377\202\355\357\365\377\1\353\356\364\377\203\354\357\365"
	  "\377\21\354\356\365\377\352\355\364\377\353\357\364\377\355\357\365\377\354"
	  "\356\364\377\352\355\363\377\353\354\362\377\354\356\364\377\352\355\363"
	  "\377\353\356\364\377\353\355\362\377\352\355\364\377\351\354\362\377\352"
	  "\355\362\377\351\354\362\377\353\356\363\377\354\356\363\377\202\353\356"
	  "\363\377\26\351\354\362\377\353\355\363\377\354\355\363\377\353\355\363\377"
	  "\352\354\362\377\351\354\362\377\352\355\362\377\353\355\363\377\352\355"
	  "\362\377\351\354\362\377\325\327\333\377\1\1\1\377\11\11\11\377\13\14\16"
	  "\377\0\0\0\377\263\265\272\377\352\354\362\377\352\354\361\377\351\354\362"
	  "\377\352\355\363\377\353\355\362\377\352\355\362\377\202\352\355\363\377"
	  "\4\353\356\363\377\353\355\363\377\353\356\363\377\354\356\364\377\202\352"
	  "\356\363\377\25\353\356\363\377\354\355\364\377\354\356\364\377\352\355\363"
	  "\377\353\355\364\377\354\357\363\377\354\357\365\377\353\356\364\377\355"
	  "\357\365\377\355\360\365\377\356\361\365\377\214\215\220\377\3\3\4\377\2"
	  "\3\3\377\211\213\215\377\355\360\366\377\356\361\366\377\356\360\366\377"
	  "\356\361\366\377\355\360\366\377\356\360\366\377\202\356\361\365\377\40\356"
	  "\362\367\377\357\362\367\377\360\361\367\377\357\362\367\377\357\361\367"
	  "\377\360\363\370\377\362\365\371\377*+,\377\10\11\11\377\10\12\12\377\12"
	  "\14\14\377\10\10\10\377\7\10\10\377\7\7\7\377\10\11\11\377\13\14\14\377\12"
	  "\14\15\377\26\30\31\377\12\12\13\377\15\15\17\377\14\14\15\377\14\15\14\376"
	  "\14\15\15\377\14\15\14\377\31\35\40\377\21\24\25\377\17\20\21\377\0\0\0\377"
	  "\317\321\326\377\360\362\367\377\356\361\366\377\356\360\366\377\202\357"
	  "\362\367\377\4\356\361\366\377\357\361\366\377\356\360\366\377\356\360\365"
	  "\377\202\357\361\367\377\32\357\361\366\377\356\360\366\377\356\361\366\377"
	  "\357\360\366\377\355\357\364\377\355\357\365\377\355\360\365\377\353\357"
	  "\364\377\354\356\364\377\354\357\365\377\355\360\365\377\355\357\365\377"
	  "\354\360\366\377\353\356\364\377\352\356\364\377\353\357\365\377\353\356"
	  "\364\377\354\357\364\377\355\357\365\377\355\360\365\377\355\357\365\377"
	  "\353\356\363\377\353\355\362\377\352\354\361\377\353\356\364\377\354\357"
	  "\365\377\202\354\357\364\377\202\353\356\363\377\4\352\355\362\377\353\356"
	  "\363\377\354\356\364\377\354\356\363\377\202\352\355\362\377\2\352\354\362"
	  "\377\353\355\363\377\202\352\355\362\377\33\351\355\362\377\352\354\362\377"
	  "\352\355\363\377\351\354\362\377\353\355\363\377\224\226\232\377\1\1\1\377"
	  "\24\26\30\377\20\17\20\377\0\0\0\377\263\265\272\377\352\355\362\377\352"
	  "\354\361\377\353\354\363\377\353\355\363\377\351\354\361\377\352\354\362"
	  "\377\352\355\363\377\353\355\362\377\353\355\363\377\353\356\363\377\352"
	  "\355\363\377\353\356\363\377\352\355\362\377\351\355\362\377\352\356\363"
	  "\377\353\356\363\377\202\353\355\363\377\15\353\356\363\377\354\356\364\377"
	  "\354\357\364\377\354\356\364\377\355\357\364\377\355\360\365\377\355\360"
	  "\364\377\214\215\220\377\2\3\3\377\2\2\3\377\211\213\215\377\355\360\365"
	  "\377\354\360\365\377\202\356\361\366\377\202\355\360\365\377\1\356\360\365"
	  "\377\202\355\360\366\377+\357\361\366\377\357\362\367\377\355\360\365\377"
	  "\356\361\366\377\357\361\366\377\360\363\370\377**+\377\6\7\7\377\10\13\13"
	  "\377\13\13\14\377\7\11\10\377\10\11\11\377\6\7\7\377\11\10\11\377\11\13\14"
	  "\377\30\33\35\377\40#%\377\12\13\14\377\10\10\11\377\16\21\23\377\13\15\14"
	  "\376\13\13\13\377\22\24\25\377\22\25\25\377\25\30\31\377\17\21\22\377\3\3"
	  "\3\377\204\205\207\377\357\362\367\377\356\361\366\377\356\361\367\377\357"
	  "\362\370\377\356\361\367\377\357\361\366\377\356\360\366\377\356\361\367"
	  "\377\357\362\367\377\355\360\365\377\357\361\366\377\356\360\366\377\357"
	  "\361\367\377\356\360\366\377\355\360\366\377\202\355\357\365\377\10\353\355"
	  "\364\377\354\357\365\377\355\357\365\377\355\360\366\377\355\360\365\377"
	  "\354\356\365\377\352\356\364\377\353\356\364\377\202\352\355\363\377\3\352"
	  "\355\364\377\355\357\365\377\354\357\365\377\202\355\357\365\377\17\353\356"
	  "\363\377\352\355\363\377\351\353\360\377\354\357\364\377\354\360\366\377"
	  "\354\357\365\377\353\356\364\377\354\356\365\377\354\357\365\377\354\357"
	  "\364\377\354\356\364\377\353\356\363\377\354\356\364\377\354\357\364\377"
	  "\352\354\361\377\203\352\355\363\377\2\352\355\362\377\351\354\361\377\203"
	  "\353\355\363\377\13\353\356\364\377IJK\377\3\3\3\377\21\23\24\377\17\20\20"
	  "\377\1\1\1\377\262\265\272\377\351\355\362\377\351\354\361\377\351\353\360"
	  "\377\352\354\362\377\202\353\355\363\377#\351\354\362\377\352\355\363\377"
	  "\353\355\363\377\352\354\362\377\353\354\362\377\352\354\362\377\351\354"
	  "\362\377\347\353\360\377\350\355\362\377\351\354\362\377\351\355\363\377"
	  "\353\356\363\377\351\354\362\377\354\356\363\377\354\356\364\377\354\357"
	  "\364\377\355\357\364\377\353\356\364\377\354\356\364\377\213\215\220\377"
	  "\3\3\4\377\6\6\10\377\211\212\215\377\354\356\364\377\355\357\365\377\353"
	  "\356\364\377\355\360\365\377\354\357\363\377\355\360\365\377\354\357\365"
	  "\377\354\356\364\377\356\360\365\377\355\360\365\377\356\361\366\377\355"
	  "\357\365\377\202\355\360\365\377\31\361\363\370\377)*+\377\6\7\7\377\11\12"
	  "\13\377\17\21\22\377\13\14\15\377\13\13\14\377\11\12\12\377\7\7\7\377\21"
	  "\23\24\377\17\21\22\377\17\20\22\377448\377@CI\377\16\17\20\377\16\17\17"
	  "\376\24\30\31\377\13\14\14\377\23\25\26\377\22\24\25\377\33\37!\377\36\36"
	  "!\377,,-\377\361\363\370\377\357\361\367\377\202\357\362\367\377\1\356\361"
	  "\367\377\203\357\361\367\377\15\357\361\366\377\355\361\366\377\357\361\367"
	  "\377\355\360\365\377\356\360\366\377\355\360\365\377\356\361\366\377\355"
	  "\357\365\377\354\356\364\377\352\355\363\377\355\360\366\377\356\360\365"
	  "\377\355\360\365\377\202\356\360\366\377\2\355\360\365\377\356\360\365\377"
	  "\202\356\360\366\377\12\354\356\364\377\355\357\364\377\355\360\365\377\355"
	  "\360\364\377\355\360\365\377\354\357\364\377\353\355\363\377\351\354\362"
	  "\377\354\357\364\377\354\356\365\377\203\353\356\364\377\3\352\355\363\377"
	  "\354\356\364\377\353\356\363\377\202\354\356\364\377\202\354\356\363\377"
	  "\24\353\356\364\377\354\356\364\377\352\355\363\377\353\354\362\377\352\354"
	  "\362\377\353\355\362\377\353\355\363\377\353\356\364\377\332\334\341\377"
	  "\6\6\6\377\11\11\11\377\"(+\377\13\13\13\377\0\0\0\377\261\264\271\377\352"
	  "\354\362\377\351\353\357\377\351\353\360\377\350\353\361\377\351\354\361"
	  "\377\203\352\355\362\377\6\353\355\363\377\352\354\362\377\353\355\363\377"
	  "\352\355\363\377\352\355\362\377\347\353\360\377\202\352\355\362\377\6\352"
	  "\354\362\377\353\354\362\377\352\355\363\377\353\355\363\377\353\356\363"
	  "\377\354\357\364\377\202\354\356\364\377\15\354\357\364\377\213\215\220\377"
	  "\3\3\4\377\2\3\4\377\211\213\215\377\354\356\363\377\354\357\365\377\353"
	  "\357\365\377\355\360\365\377\355\357\365\377\354\360\364\377\355\357\365"
	  "\377\354\357\364\377\202\355\360\365\377\1\356\361\366\377\202\354\357\365"
	  "\377\"\355\357\365\377\361\363\370\377**,\377\5\6\6\377\13\14\15\377\17\22"
	  "\23\377\14\15\17\377\6\7\10\377\11\12\13\377\11\11\11\377\12\11\12\377\12"
	  "\12\12\377\14\17\17\377\26\30\32\377\16\20\21\377\21\23\23\377\15\17\17\376"
	  "\15\17\16\377\14\16\16\377\16\20\20\377\13\15\16\377\25\26\27\377\11\11\12"
	  "\377\0\0\0\377\275\277\303\377\360\363\370\377\357\362\370\377\360\362\370"
	  "\377\357\361\367\377\357\362\367\377\360\361\370\377\357\361\367\377\356"
	  "\361\367\377\357\361\366\377\202\356\361\366\377\11\356\360\366\377\355\360"
	  "\366\377\356\360\366\377\355\360\365\377\354\356\364\377\354\357\364\377"
	  "\355\357\365\377\356\360\366\377\356\360\365\377\202\360\362\367\377\1\356"
	  "\361\365\377\202\355\357\365\377\7\355\357\364\377\354\357\365\377\355\357"
	  "\364\377\355\356\364\377\355\357\365\377\354\356\364\377\354\357\365\377"
	  "\202\354\357\364\377\202\354\357\365\377\17\353\356\364\377\354\356\364\377"
	  "\353\356\364\377\353\355\364\377\353\356\363\377\354\356\364\377\355\357"
	  "\364\377\354\357\364\377\353\356\364\377\354\356\364\377\352\354\364\377"
	  "\352\355\363\377\351\354\362\377\352\355\363\377\351\354\362\377\202\352"
	  "\355\363\377\16\353\356\364\377\202\203\207\377\1\2\2\377\24\26\27\377\20"
	  "\21\22\377\15\17\17\377\0\0\0\377\261\263\270\377\351\353\361\377\351\353"
	  "\360\377\352\354\362\377\352\354\361\377\352\354\362\377\353\355\362\377"
	  "\202\351\354\362\377\202\352\354\362\377\4\352\355\363\377\352\354\363\377"
	  "\352\354\362\377\352\356\363\377\202\353\356\363\377\4\353\355\363\377\352"
	  "\355\363\377\353\355\363\377\353\356\363\377\202\354\357\364\377\4\353\356"
	  "\363\377\354\357\365\377\354\357\364\377\213\214\217\377\202\1\2\2\377\7"
	  "\212\213\215\377\356\360\365\377\354\357\365\377\355\360\365\377\356\360"
	  "\365\377\354\356\364\377\356\361\366\377\202\354\357\365\377\"\355\360\365"
	  "\377\354\357\365\377\356\361\366\377\355\360\366\377\356\361\366\377\356"
	  "\360\366\377\362\364\371\377**+\377\7\7\10\377\13\14\14\377\15\17\17\377"
	  "\10\10\10\377\22\25\27\377\10\11\12\377\10\10\10\377\7\10\7\377\14\15\16"
	  "\377\20\22\24\377\17\21\21\377\20\22\24\37758=\377\26\32\33\376\36!\"\377"
	  ",03\377\17\20\21\377\15\15\16\377\27\31\32\377\13\13\13\377\5\5\5\377RRT"
	  "\377\361\363\370\377\357\361\367\377\357\361\370\377\357\362\367\377\202"
	  "\357\361\367\377\14\357\362\370\377\357\361\367\377\357\362\367\377\356\361"
	  "\367\377\356\360\366\377\357\361\366\377\355\357\365\377\355\360\365\377"
	  "\355\360\366\377\356\360\365\377\354\357\365\377\353\356\364\377\203\355"
	  "\357\365\377\202\356\361\366\377\4\354\357\365\377\355\360\366\377\354\356"
	  "\364\377\353\356\364\377\202\354\357\364\377\12\355\357\365\377\354\357\364"
	  "\377\355\360\365\377\355\357\365\377\355\360\365\377\354\357\364\377\354"
	  "\357\365\377\353\356\364\377\355\357\365\377\354\357\364\377\203\353\356"
	  "\364\377\10\354\356\363\377\354\356\364\377\353\355\363\377\352\355\363\377"
	  "\352\355\362\377\352\354\362\377\350\353\361\377\352\354\362\377\202\352"
	  "\354\363\377\16\352\355\363\377\350\353\361\377\35\35\36\377\20\21\23\377"
	  "\17\21\22\377\7\10\10\377\14\14\14\377\0\0\0\377\263\264\271\377\352\354"
	  "\361\377\352\355\363\377\354\357\364\377\355\357\364\377\354\357\364\377"
	  "\202\353\355\363\377\7\351\354\361\377\353\355\363\377\352\355\363\377\354"
	  "\356\364\377\353\356\364\377\353\356\363\377\353\357\363\377\202\354\357"
	  "\365\377\12\355\360\365\377\354\360\365\377\354\357\365\377\356\360\365\377"
	  "\355\357\364\377\355\360\366\377\354\357\365\377\355\360\366\377\356\361"
	  "\366\377\214\216\220\377\202\1\2\2\377\12\213\214\216\377\357\362\367\377"
	  "\360\363\370\377\361\363\371\377\362\364\371\377\360\363\370\377\361\364"
	  "\371\377\360\363\370\377\361\364\370\377\361\363\371\377\202\362\364\371"
	  "\377\202\362\365\371\377\35\362\365\372\377\366\370\373\377++,\377\17\21"
	  "\23\377\11\12\12\377\22\23\24\377\34\36\40\377\7\12\12\377\11\12\13\377\10"
	  "\10\11\377\12\13\14\377\13\15\16\377\12\12\12\377\13\13\14\377\14\15\16\377"
	  "\32\35!\377\25\30\31\376\16\22\23\377\23\24\25\377\21\24\25\377\15\17\17"
	  "\377\17\22\22\377\12\13\13\377\6\7\7\377\2\2\2\377\311\313\317\377\357\361"
	  "\366\377\357\361\367\377\356\361\367\377\202\357\362\367\377\1\356\361\367"
	  "\377\203\357\362\367\377\2\356\360\366\377\357\361\366\377\202\356\361\366"
	  "\377\11\355\360\365\377\356\360\366\377\355\360\366\377\355\357\365\377\355"
	  "\360\365\377\354\357\365\377\354\357\366\377\356\361\367\377\356\360\365"
	  "\377\202\355\357\365\377\10\355\360\365\377\354\356\363\377\355\357\363\377"
	  "\355\357\365\377\354\356\364\377\354\360\365\377\354\357\365\377\354\356"
	  "\364\377\203\354\357\365\377\2\352\356\363\377\354\356\365\377\202\353\356"
	  "\364\377\7\353\356\363\377\352\355\363\377\353\355\362\377\352\354\361\377"
	  "\352\355\363\377\351\354\362\377\352\355\363\377\202\351\354\362\377\26\352"
	  "\355\363\377\352\355\362\377\352\355\363\377\353\355\363\377\222\223\227"
	  "\377\2\2\2\377\21\24\24\377\14\16\16\377\13\15\16\377\13\13\14\377\0\0\0"
	  "\377\262\264\271\377\352\355\363\377\356\360\365\377\355\360\365\377\356"
	  "\360\365\377\356\360\366\377\353\356\363\377\352\355\363\377\353\356\363"
	  "\377\352\355\362\377\351\355\362\377\202\353\356\364\377\21\353\356\363\377"
	  "\352\356\364\377\354\356\364\377\355\360\366\377\355\360\365\377\355\360"
	  "\366\377\355\357\365\377\355\357\364\377\354\357\364\377\355\360\365\377"
	  "\354\357\365\377\356\361\366\377\357\361\366\377\215\215\220\377\3\4\4\377"
	  "\5\6\7\377\34\35\35\377\203113\377\207123\377\2""223\377123\377\202224\377"
	  "#234\377\11\11\11\377\12\12\13\377\25\31\34\377\14\16\17\377\6\7\7\377\12"
	  "\12\12\377\11\11\10\377\21\23\24\377\7\10\10\377\13\13\14\377\22\25\27\377"
	  "\21\22\24\377\31\33\36\377\11\12\12\377\27\30\32\376\14\16\16\377\16\20\21"
	  "\377\25\27\31\377\22\24\25\377\13\14\14\377\13\15\15\377\12\13\12\377\1\2"
	  "\3\377LMN\377\361\363\370\377\357\361\367\377\357\362\370\377\360\362\367"
	  "\377\361\363\370\377\357\362\367\377\360\362\370\377\360\362\367\377\357"
	  "\361\367\377\356\360\366\377\202\356\361\366\377\5\356\362\366\377\355\360"
	  "\365\377\356\360\366\377\355\360\366\377\355\357\366\377\202\355\360\365"
	  "\377\7\354\357\365\377\356\360\366\377\357\361\366\377\356\361\366\377\356"
	  "\360\365\377\355\360\365\377\355\360\366\377\202\355\360\365\377\14\354\357"
	  "\364\377\353\356\364\377\353\357\363\377\354\357\365\377\353\356\364\377"
	  "\352\355\364\377\354\356\364\377\353\356\364\377\354\356\364\377\353\356"
	  "\364\377\352\355\364\377\354\356\364\377\202\354\357\364\377\7\353\356\364"
	  "\377\353\355\363\377\352\355\362\377\352\355\363\377\354\356\364\377\353"
	  "\355\363\377\353\356\363\377\202\354\356\364\377\27\346\350\354\377\33\33"
	  "\34\377\25\30\30\377\12\12\12\377\16\20\21\377\34\36\40\377\15\15\15\377"
	  "\0\0\0\377\262\265\271\377\354\356\364\377\355\360\365\377\355\362\367\377"
	  "\357\361\366\377\356\360\366\377\354\356\364\377\352\355\362\377\353\356"
	  "\363\377\354\357\364\377\353\356\364\377\355\357\364\377\354\356\363\377"
	  "\351\355\362\377\354\360\365\377\202\355\360\365\3776\355\357\365\377\354"
	  "\357\365\377\355\357\365\377\356\361\366\377\357\362\367\377\356\361\366"
	  "\377\355\361\366\377\356\361\366\377\356\361\365\377\214\215\220\377\1\1"
	  "\1\377\13\15\14\377\5\13\10\377\6\6\6\377\7\7\7\377\10\10\11\377\12\13\14"
	  "\377\7\6\7\377\20\21\22\377\5\5\6\377\15\16\17\377\6\7\7\377\6\6\6\377\4"
	  "\4\4\377\7\11\12\377\5\5\5\377\4\5\5\377\4\5\6\377\6\7\7\377\12\13\14\377"
	  "\30\31\33\377\16\20\21\377\6\7\7\377\7\7\10\377\12\13\13\377\11\11\11\377"
	  "\11\12\12\377\12\12\13\377\30\34\36\377\17\22\23\377\6\7\6\377\32\34\35\377"
	  "\12\13\13\376\25\26\30\377\16\20\21\377\40#&\377\22\24\26\377>CH\377\16\16"
	  "\17\377\11\13\13\377\11\11\11\377\0\0\0\377\255\260\263\377\357\362\370\377"
	  "\202\357\362\367\377\4\360\362\367\377\357\362\367\377\357\362\370\377\360"
	  "\363\370\377\202\360\362\367\377\202\357\361\366\377\3\357\361\367\377\355"
	  "\360\365\377\356\361\367\377\202\355\360\366\377\7\356\360\365\377\356\361"
	  "\367\377\355\360\366\377\356\360\366\377\357\361\366\377\356\361\367\377"
	  "\357\361\366\377\202\355\360\365\377\12\355\360\366\377\356\360\367\377\356"
	  "\360\366\377\355\357\365\377\354\357\365\377\354\357\364\377\352\356\364"
	  "\377\353\357\364\377\353\356\364\377\352\356\364\377\202\353\356\364\377"
	  "\13\354\356\364\377\353\356\363\377\354\356\363\377\355\357\365\377\353\355"
	  "\363\377\352\355\363\377\353\356\364\377\353\355\362\377\354\356\364\377"
	  "\353\356\362\377\352\355\363\377\202\354\357\364\377\13vwy\377\1\1\1\377"
	  "\14\15\15\377\33\36\40\377\16\21\20\377\23\24\24\377\13\14\15\377\0\0\0\377"
	  "\264\266\273\377\353\356\363\377\354\357\364\377\202\355\357\365\377\5\354"
	  "\357\364\377\354\356\362\377\352\355\363\377\354\356\364\377\354\357\364"
	  "\377\202\354\357\365\377\10\355\360\366\377\355\357\365\377\354\360\365\377"
	  "\356\360\366\377\354\357\365\377\356\361\366\377\354\357\365\377\356\360"
	  "\366\377\202\357\362\366\377\26\357\362\367\377\356\362\367\377\357\361\367"
	  "\377\357\361\366\377\214\216\220\377\1\2\2\377\11\12\11\377\10\22\12\377"
	  "\23\24\25\377\15\17\17\377\17\25\22\377\20\22\23\377\26\30\31\377\14\13\14"
	  "\377\23\26\27\377\25\26\27\377\27\32\35\377\11\12\12\377\24\24\25\377\7\10"
	  "\10\377\17\17\20\377\11\12\12\377\202\14\15\16\377*\10\10\11\377\11\12\12"
	  "\377\7\7\10\377\7\11\12\377\6\7\7\377\13\15\16\377\15\17\17\377\7\10\10\377"
	  "$&(\377\22\24\25\377\11\13\13\377\27\31\33\377\31\33\36\377\37!#\376\16\17"
	  "\17\377\20\22\23\377\15\17\17\377\22\23\26\377\14\15\15\377\12\13\13\377"
	  "\11\10\10\377\14\15\15\377\2\3\3\377\37\40\40\377\345\350\354\377\356\361"
	  "\367\377\356\362\366\377\357\362\370\377\356\361\367\377\357\361\367\377"
	  "\356\361\367\377\357\361\367\377\357\362\367\377\357\361\367\377\357\361"
	  "\366\377\360\362\370\377\356\361\366\377\356\360\366\377\356\361\367\377"
	  "\356\361\366\377\357\361\367\377\356\360\366\377\202\355\360\366\377\1\355"
	  "\360\365\377\202\356\360\365\377\17\355\360\365\377\355\357\366\377\356\361"
	  "\366\377\357\361\366\377\356\360\366\377\356\360\365\377\355\360\365\377"
	  "\353\356\364\377\354\357\365\377\353\356\364\377\354\357\365\377\352\355"
	  "\363\377\353\356\364\377\354\356\364\377\353\355\363\377\202\353\356\363"
	  "\377\7\355\357\364\377\352\355\362\377\352\354\362\377\353\356\363\377\353"
	  "\355\363\377\353\356\363\377\354\356\364\377\202\353\356\364\377\33\304\306"
	  "\313\377\6\6\6\377\5\6\5\377\14\15\16\377\22\24\24\377\15\17\16\377\20\21"
	  "\22\377\25\27\30\377\0\0\0\377\263\265\272\377\352\355\363\377\355\356\363"
	  "\377\352\355\363\377\353\356\363\377\353\355\363\377\353\356\363\377\354"
	  "\357\364\377\354\356\364\377\355\360\364\377\355\360\365\377\354\357\364"
	  "\377\355\360\366\377\356\360\365\377\354\360\365\377\356\360\365\377\355"
	  "\360\365\377\356\361\366\377\203\355\360\366\377+\356\361\366\377\357\361"
	  "\367\377\356\360\366\377\355\360\366\377\355\361\365\377\214\216\221\377"
	  "\1\1\2\377\12\14\12\377\7\20\12\377\11\11\12\377\12\13\13\377\6\21\12\377"
	  "\16\17\20\377\14\14\14\377\16\17\17\377\14\15\16\377\15\17\17\377\20\20\21"
	  "\377\16\16\16\377\17\17\20\377\12\11\12\377\20\20\21\377\12\12\12\377\12"
	  "\11\12\377\10\11\11\377\11\11\12\377\7\7\7\377\13\16\17\377\10\11\12\377"
	  "\16\17\20\377\10\11\12\377\17\20\21\377\22\26\31\377\13\13\13\377\15\17\21"
	  "\377\15\16\17\377\16\20\22\377\30\32\34\377\32\36\37\376*02\377\13\13\13"
	  "\377\15\20\20\377\15\16\16\377\202\11\11\11\377\23\11\13\13\377\11\11\11"
	  "\377\10\11\10\377\1\1\1\377]^`\377\357\362\367\377\356\361\367\377\357\361"
	  "\367\377\356\361\366\377\357\361\366\377\357\362\367\377\357\361\367\377"
	  "\356\360\366\377\357\361\367\377\356\361\366\377\357\362\370\377\357\361"
	  "\367\377\356\362\367\377\356\361\366\377\202\357\362\367\377\12\357\361\366"
	  "\377\356\361\367\377\356\360\366\377\357\361\366\377\356\360\366\377\357"
	  "\361\366\377\355\357\365\377\354\357\366\377\356\362\367\377\356\360\366"
	  "\377\202\355\360\366\377$\353\356\365\377\355\360\365\377\353\356\364\377"
	  "\352\355\363\377\354\356\365\377\353\356\364\377\354\357\365\377\354\357"
	  "\364\377\353\356\364\377\354\357\365\377\353\356\364\377\353\356\363\377"
	  "\353\355\363\377\354\355\363\377\352\354\361\377\353\356\364\377\353\355"
	  "\363\377\354\356\363\377\353\355\363\377\345\350\356\377*+,\377\3\3\2\377"
	  "\7\10\10\377\12\12\12\377\14\14\15\377\20\17\16\377\15\17\20\377\22\24\25"
	  "\377\0\0\0\377\262\265\272\377\353\356\363\377\353\355\362\377\353\356\364"
	  "\377\353\356\363\377\353\356\364\377\353\356\363\377\202\355\357\365\377"
	  "\2\355\360\365\377\355\357\364\377\202\356\360\366\377\2\354\357\365\377"
	  "\355\361\366\377\202\356\361\366\377\7\357\361\366\377\355\361\366\377\356"
	  "\360\366\377\355\357\365\377\355\360\365\377\355\360\366\377\356\361\366"
	  "\377\202\355\360\365\377>\213\215\220\377\1\1\1\377\15\16\16\377\12\14\15"
	  "\377\10\11\11\377\12\13\12\377\12\25\16\377\13\14\14\377\14\15\16\377\14"
	  "\13\14\377\15\14\15\377\12\12\11\377\15\15\16\377\15\16\15\377\11\11\11\377"
	  "\20\20\21\377\10\11\10\377\21\23\24\377\10\11\11\377\11\11\10\377\7\10\10"
	  "\377\11\13\14\377\7\7\7\377\7\10\10\377\11\12\11\377\13\14\15\377\11\13\14"
	  "\377\31\32\35\377\11\11\11\377\21\22\24\377\21\23\25\377\13\13\14\377@CH"
	  "\377\17\23\22\376\20\22\21\377\13\14\14\377\11\11\10\377\10\10\7\377\11\13"
	  "\12\377\15\16\17\377\26\26\30\377\12\13\14\377\7\10\10\377\20\21\21\377\0"
	  "\0\0\377\226\230\232\377\355\361\366\377\357\360\366\377\356\360\365\377"
	  "\355\360\366\377\360\362\367\377\357\361\367\377\357\362\370\377\356\361"
	  "\366\377\357\362\367\377\360\362\370\377\356\361\366\377\356\360\366\377"
	  "\356\361\366\377\357\361\367\377\355\360\366\377\356\361\366\377\202\356"
	  "\361\367\377\13\356\360\366\377\356\361\366\377\355\360\366\377\356\360\366"
	  "\377\356\360\367\377\356\361\366\377\355\360\366\377\356\360\366\377\357"
	  "\361\367\377\356\361\366\377\354\357\365\377\202\353\356\364\377\2\353\357"
	  "\365\377\354\357\365\377\203\354\357\364\377\31\354\356\364\377\353\356\363"
	  "\377\354\356\364\377\353\355\363\377\354\356\364\377\352\354\361\377\354"
	  "\356\364\377\353\356\364\377\354\357\364\377\353\356\364\377]]_\377\1\1\0"
	  "\377\10\10\7\377\10\10\10\377\15\16\16\377\14\15\15\377\15\17\17\377\14\15"
	  "\15\377\15\17\17\377\0\0\0\377\263\266\273\377\353\356\363\377\353\355\362"
	  "\377\354\357\365\377\353\356\363\377\202\355\360\365\377\11\354\357\365\377"
	  "\353\355\364\377\355\357\365\377\355\357\364\377\355\360\366\377\356\360"
	  "\366\377\356\361\367\377\354\360\364\377\356\361\365\377\203\356\361\366"
	  "\377\2\357\361\367\377\355\360\366\377\203\356\361\366\377&\357\361\367\377"
	  "\356\361\366\377\214\216\220\377\1\1\1\377\11\13\13\377\10\11\11\377\11\12"
	  "\13\377\10\12\11\377\10\22\12\377\24\25\26\377\11\12\12\377\15\16\17\377"
	  "\13\13\13\377\14\15\15\377\32\32\34\377\15\17\17\377\22\23\24\377\16\16\16"
	  "\377\21\23\23\377\21\21\21\377\26\30\33\377\7\7\7\377\23\23\25\377\10\11"
	  "\11\377\16\16\16\377\11\12\11\377\25\30\31\377%)+\377\20\21\22\377\11\10"
	  "\11\377\12\13\13\377\13\14\15\377\21\22\24\377%(,\377\15\16\16\377\13\15"
	  "\15\376\10\11\12\377\12\15\15\377\202\13\13\13\377\12\22\24\25\377\14\15"
	  "\15\377\11\13\12\377\12\14\14\377\24\27\27\377\26\27\30\377\14\16\16\377"
	  "\6\6\7\377\270\272\275\377\357\361\367\377\202\357\362\367\377\21\360\362"
	  "\370\377\361\363\370\377\357\362\367\377\360\362\370\377\357\362\370\377"
	  "\357\361\367\377\357\362\367\377\357\361\366\377\356\361\367\377\357\361"
	  "\366\377\357\361\367\377\356\362\367\377\355\360\366\377\357\361\367\377"
	  "\356\361\367\377\356\360\366\377\355\361\366\377\202\355\360\365\377\12\356"
	  "\361\367\377\356\361\366\377\356\361\367\377\356\360\366\377\356\361\367"
	  "\377\354\357\364\377\355\360\365\377\354\357\364\377\354\357\365\377\354"
	  "\356\364\377\202\354\357\364\377\202\354\357\365\377\4\354\356\365\377\354"
	  "\356\364\377\354\357\364\377\355\357\365\377\202\353\356\363\377\6\353\356"
	  "\364\377\355\360\364\377\204\206\210\377\0\0\0\377\7\7\6\377\11\12\11\377"
	  "\202\14\15\15\377\15\25\27\30\377\10\10\10\377\27\33\35\377\26\30\32\377"
	  "\0\0\0\377\264\266\273\377\354\356\364\377\352\356\363\377\354\357\365\377"
	  "\354\360\365\377\355\357\365\377\355\360\365\377\355\360\366\377\202\354"
	  "\357\364\377\15\355\357\365\377\356\360\366\377\355\360\365\377\356\362\366"
	  "\377\355\361\366\377\357\361\367\377\357\361\366\377\356\360\366\377\355"
	  "\360\365\377\357\361\367\377\356\360\366\377\357\361\367\377\357\362\367"
	  "\377\202\357\361\367\3774\356\361\367\377\214\215\220\377\1\1\1\377\11\13"
	  "\12\377\11\13\14\377\11\13\13\377\10\10\7\377\5\20\10\377\12\13\13\377\17"
	  "\21\22\377\12\11\12\377\16\17\20\377\26\30\31\377\13\12\12\377\24\26\30\377"
	  "\22\22\23\377\21\23\24\377\34\36\40\377\40$&\377\14\16\15\377%&)\377\10\7"
	  "\7\377\10\10\10\377\14\15\15\377\15\15\15\377\23\25\27\377\14\15\15\377\13"
	  "\13\14\377\16\20\21\377\12\11\12\377\27\31\34\377\11\11\11\377\20\22\23\377"
	  "\25\30\31\377\23\24\24\376\11\12\12\377\15\16\17\377\30\32\33\377\16\21\23"
	  "\377\11\12\12\377\14\16\16\377\12\12\11\377\12\15\15\377\26\31\31\377\16"
	  "\17\20\377\7\10\7\377\3\4\3\377\20\20\20\377\307\311\314\377\360\363\370"
	  "\377\356\361\367\377\357\362\367\377\202\360\362\367\377\10\360\363\370\377"
	  "\360\362\367\377\357\362\367\377\360\362\370\377\357\361\367\377\356\361"
	  "\366\377\357\362\366\377\360\362\370\377\202\357\362\367\377\21\357\361\367"
	  "\377\356\361\366\377\355\360\365\377\356\361\366\377\356\360\366\377\355"
	  "\360\366\377\355\360\365\377\356\361\367\377\356\360\365\377\357\361\366"
	  "\377\356\361\366\377\354\357\365\377\355\360\366\377\355\357\364\377\354"
	  "\357\366\377\354\357\364\377\354\357\365\377\202\355\357\365\377\203\354"
	  "\357\364\377\27\355\357\364\377\356\360\365\377\354\357\364\377\353\356\364"
	  "\377\354\356\364\377\231\233\237\377\2\2\2\377\23\24\26\377\10\10\7\377\11"
	  "\12\11\377\12\12\12\377\33\35\36\377\14\15\15\377\12\13\13\377\15\16\20\377"
	  "\14\15\14\377\0\0\0\377\264\267\273\377\355\357\365\377\354\357\364\377\354"
	  "\357\365\377\354\360\365\377\354\357\365\377\202\355\360\365\377\16\355\360"
	  "\366\377\355\360\365\377\356\360\366\377\356\361\367\377\356\360\366\377"
	  "\355\361\366\377\356\362\366\377\357\362\367\377\357\362\370\377\356\360"
	  "\366\377\357\361\367\377\360\362\370\377\357\361\367\377\357\361\366\377"
	  "\202\357\362\367\377\20\357\361\367\377\357\362\367\377\215\217\221\377\1"
	  "\2\2\377\15\16\17\377\13\15\16\377\14\17\20\377\12\14\15\377\6\21\12\377"
	  "\12\12\11\377\13\14\15\377\17\17\20\377\13\15\16\377\11\11\11\377\12\12\12"
	  "\377\11\11\11\377\202\11\12\12\377%\26\27\30\377\24\24\26\377)-0\377\7\7"
	  "\6\377\6\6\6\377\7\7\7\377\11\11\12\377\13\16\17\377\24\26\27\377\34\37\40"
	  "\377\24\26\31\377\16\17\20\377\30\33\36\377\12\14\14\377\10\10\10\377\15"
	  "\17\21\377\30\32\35\377\30\33\34\376\12\13\12\377\12\15\15\377+01\377\20"
	  "\21\22\377\12\13\12\377\11\12\11\377\26\33\32\377\32\34\35\377!$'\377\15"
	  "\17\17\377\13\15\15\377\24\26\30\377\3\3\3\377\24\24\25\377\304\306\311\377"
	  "\356\361\367\377\357\361\367\377\360\363\370\377\360\363\371\377\203\360"
	  "\362\370\377\12\360\361\367\377\357\362\367\377\356\362\367\377\357\362\370"
	  "\377\357\361\367\377\357\362\367\377\360\362\370\377\356\361\367\377\356"
	  "\361\366\377\356\360\366\377\202\355\360\366\377\202\356\361\367\377!\357"
	  "\361\367\377\355\360\366\377\356\360\365\377\354\360\366\377\355\360\366"
	  "\377\356\361\366\377\355\360\365\377\354\357\366\377\354\357\365\377\355"
	  "\360\365\377\354\357\365\377\353\357\364\377\355\360\365\377\353\356\364"
	  "\377\355\360\366\377\356\360\365\377\354\356\364\377\353\356\364\377\354"
	  "\357\365\377\230\232\236\377\3\3\4\377\6\7\7\377\14\15\15\377\16\20\21\377"
	  "\13\13\13\377\17\20\20\377#%'\377\23\23\23\377\12\11\11\377\15\17\20\377"
	  "\10\11\10\377\0\0\0\377\264\266\273\377\202\355\357\365\377\4\354\357\365"
	  "\377\355\360\365\377\356\360\366\377\356\360\365\377\202\355\357\365\377"
	  "\2\354\357\365\377\356\360\366\377\203\356\361\366\377\3\356\362\366\377"
	  "\360\362\367\377\356\362\367\377\202\357\362\367\377\5\360\363\370\377\360"
	  "\362\370\377\356\361\365\377\360\363\370\377\357\362\370\377\202\357\362"
	  "\367\377\26\215\216\221\377\2\2\2\377\11\12\12\377\14\14\16\377\12\14\15"
	  "\377\12\13\12\377\17\31\24\377\35\40\40\377\12\12\13\377\14\14\16\377\16"
	  "\16\15\377\12\12\12\377\11\10\11\377\10\10\10\377\11\11\11\377\17\20\21\377"
	  "\26\30\31\377\14\13\14\377\7\7\7\377\14\15\15\377\7\7\7\377\12\12\13\377"
	  "\202\16\20\20\377\15*.0\377\37#%\377\31\33\36\377Z`e\377\"#&\377\7\10\10"
	  "\377\11\12\13\377\12\12\12\377\23\25\25\377\22\25\26\3766;@\377\10\12\11"
	  "\377\10\11\11\377\202\12\13\13\377\20\13\14\14\377\7\10\10\377\31\35\40\377"
	  "\27\30\30\377\10\11\10\377\17\21\22\377\16\17\17\377\14\14\15\377\5\6\5\377"
	  "\15\15\16\377\261\264\266\377\360\363\370\377\357\362\367\377\360\363\370"
	  "\377\360\362\370\377\360\363\370\377\202\360\362\370\377\1\356\361\366\377"
	  "\202\357\362\367\377\1\356\361\366\377\202\357\362\370\377\1\360\362\367"
	  "\377\202\357\361\366\377\24\356\360\366\377\357\361\367\377\357\362\367\377"
	  "\360\362\367\377\357\362\370\377\357\362\367\377\356\360\366\377\355\360"
	  "\366\377\356\360\366\377\355\360\366\377\354\357\364\377\354\357\365\377"
	  "\355\357\365\377\353\356\364\377\354\357\365\377\355\357\365\377\354\357"
	  "\365\377\353\356\364\377\355\357\365\377\354\357\364\377\202\355\357\365"
	  "\377\24\203\204\207\377\2\2\2\377\5\6\5\377\32\36\37\377\17\17\17\377\10"
	  "\10\7\377\12\14\14\377\14\15\15\377**,\377\7\10\10\377\10\11\10\377\13\13"
	  "\13\377\16\17\20\377\0\0\0\377\264\267\273\377\355\360\365\377\356\360\364"
	  "\377\356\360\365\377\356\357\365\377\356\360\366\377\202\355\360\365\377"
	  "\10\356\360\365\377\356\360\366\377\356\361\366\377\356\361\367\377\355\360"
	  "\365\377\356\362\370\377\356\362\366\377\356\361\367\377\202\357\361\367"
	  "\377\3\357\362\367\377\356\361\367\377\357\362\367\377\202\357\361\367\377"
	  "\203\357\362\367\3770\215\217\221\377\2\2\2\377\13\15\16\377\12\14\14\377"
	  "\11\10\10\377\11\12\12\377\25\36\33\377\12\13\13\377\30\32\34\377\13\14\14"
	  "\377\12\12\13\377\11\11\11\377\12\13\13\377\11\11\11\377\22\24\25\377\13"
	  "\13\13\377\10\12\12\377\7\10\10\377\7\7\7\377\12\12\12\377\16\17\20\377/"
	  "25\377\13\14\15\377\35\37\"\377\15\17\17\377\34\36!\377\40%'\377\26\27\27"
	  "\377\15\17\20\377\16\17\20\377\30\32\35\377\15\16\17\377\11\11\11\377\17"
	  "\22\22\376\15\21\21\377\35!\"\377\23\23\24\377\11\11\11\377\32\35\35\377"
	  ".16\377\17\20\20\377\26\27\30\377\13\16\16\377\35\37\37\377\11\11\11\377"
	  "\11\13\13\377\13\14\14\377\13\14\13\377\202\4\4\4\377\16\210\212\214\377"
	  "\360\362\367\377\356\362\367\377\360\361\367\377\360\363\370\377\357\363"
	  "\370\377\360\363\370\377\360\362\370\377\357\361\366\377\360\363\370\377"
	  "\357\362\367\377\356\360\365\377\360\362\370\377\357\361\367\377\203\356"
	  "\361\366\377\10\357\362\367\377\357\362\370\377\360\362\367\377\356\362\367"
	  "\377\357\362\367\377\356\361\367\377\360\362\367\377\355\361\366\377\202"
	  "\355\360\365\377\6\355\360\366\377\354\357\365\377\353\356\364\377\352\356"
	  "\363\377\354\357\365\377\355\360\366\377\202\355\360\365\377\27\355\360\364"
	  "\377\346\351\357\377[[]\377\0\0\0\377\6\7\6\377\31\33\35\377\15\17\17\377"
	  "\11\11\10\377\10\11\11\377\7\7\7\377\7\10\10\377\5\6\6\377\7\7\7\377\6\7"
	  "\6\377\21\23\24\377\13\15\16\377\0\0\0\377\265\267\273\377\355\360\364\377"
	  "\355\357\365\377\355\360\365\377\354\357\365\377\355\360\366\377\202\356"
	  "\361\366\377\1\356\357\364\377\202\356\361\366\377\11\357\361\366\377\357"
	  "\361\367\377\357\362\367\377\357\363\370\377\356\362\367\377\360\362\370"
	  "\377\357\362\367\377\356\362\367\377\357\362\367\377\202\356\361\366\377"
	  "\202\357\362\367\377k\357\362\370\377\357\362\367\377\215\217\220\377\2\3"
	  "\2\377\14\14\14\377\12\12\12\377\16\20\21\377\10\11\10\377\20\32\26\377\37"
	  "\40#\377\12\11\12\377\13\13\13\377\21\22\24\377\30\33\35\377\10\10\10\377"
	  "\11\12\12\377\12\12\12\377\11\12\13\377\12\12\13\377\6\7\7\377\10\10\10\377"
	  "\11\11\12\377\25\30\32\377\32\33\37\377\20\21\22\377\22\23\25\377\12\13\14"
	  "\377\15\20\22\377\21\23\24\377\14\15\16\377,.2\377\15\16\17\377\11\12\13"
	  "\377\10\11\11\377\12\14\15\377\24\27\30\376\22\26\25\377FJP\377036\377\15"
	  "\20\17\377\20\21\23\377\26\27\31\377\20\21\22\377\16\20\17\377\40\40\"\377"
	  "\32\34\35\377\13\13\13\377\10\11\11\377\12\12\12\377\17\20\20\377\11\11\11"
	  "\377\10\10\7\377\0\0\0\377KKM\377\334\337\343\377\357\362\367\377\361\363"
	  "\371\377\357\362\370\377\360\362\370\377\360\363\370\377\360\362\370\377"
	  "\360\363\366\377\361\363\370\377\357\362\370\377\360\363\370\377\357\362"
	  "\367\377\357\361\366\377\356\361\366\377\357\361\367\377\356\361\367\377"
	  "\357\361\367\377\360\363\370\377\357\363\370\377\357\361\367\377\360\362"
	  "\370\377\355\360\366\377\355\360\365\377\356\361\367\377\353\356\364\377"
	  "\354\357\366\377\354\357\364\377\353\356\364\377\354\357\364\377\354\357"
	  "\365\377\354\357\364\377\355\360\365\377\354\357\365\377\304\306\311\377"
	  "***\377\1\1\1\377\7\10\10\377\17\20\21\377\12\13\14\377\6\7\6\377\10\7\7"
	  "\377\12\14\14\377\10\12\11\377\13\14\15\377\11\12\12\377\7\7\7\377\36\37"
	  "!\377\14\15\16\377\22\23\23\377\0\0\0\377\264\267\274\377\354\357\364\377"
	  "\355\357\365\377\202\356\360\366\377\5\357\361\367\377\356\361\366\377\357"
	  "\361\367\377\357\362\370\377\360\362\367\377\202\356\361\366\377\11\355\360"
	  "\366\377\356\362\367\377\357\363\367\377\357\362\367\377\360\362\367\377"
	  "\360\363\370\377\356\362\367\377\356\361\367\377\360\363\367\377\202\357"
	  "\362\367\377*\356\361\367\377\357\362\367\377\360\363\370\377\216\217\221"
	  "\377\1\1\1\377\11\11\11\377\16\20\21\377\14\14\14\377\35\35\37\377\7\20\12"
	  "\377\12\13\13\377\13\12\12\377\16\17\20\377\16\16\17\377\10\11\11\377\16"
	  "\17\17\377\10\7\7\377\10\10\11\377\10\10\10\377\7\7\7\377\11\11\12\377\20"
	  "\23\24\377\12\13\14\377\14\15\16\377\7\10\10\377$'+\377\13\14\15\377\21\23"
	  "\24\377\15\20\17\377\16\17\20\377\25\30\32\377\27\32\32\377\20\23\23\377"
	  "\12\13\13\377\11\12\13\377\12\14\15\377\32\36\40\376\37!#\377*.0\377\14\15"
	  "\15\377\34\40\"\377\11\12\12\377\202\11\12\11\377\24\12\14\13\377\10\10\7"
	  "\377\7\7\6\377\10\12\11\377\13\15\15\377\12\13\12\377\11\12\11\377\13\14"
	  "\14\377\13\14\15\377\12\12\12\377\2\2\2\377\22\22\23\377\225\227\231\377"
	  "\360\362\367\377\360\363\370\377\361\364\371\377\361\363\370\377\360\363"
	  "\370\377\360\362\366\377\361\363\370\377\202\360\363\370\377\3\360\362\370"
	  "\377\357\361\367\377\356\361\366\377\205\357\362\370\377'\357\362\367\377"
	  "\360\362\367\377\357\362\370\377\356\361\367\377\356\360\366\377\355\360"
	  "\365\377\355\360\367\377\355\360\365\377\354\357\365\377\353\357\364\377"
	  "\354\357\365\377\354\357\364\377\345\347\354\377qqt\377\5\5\5\377\3\4\3\377"
	  "\12\12\12\377\14\16\16\377\20\23\23\377\10\10\10\377\7\10\7\377\14\16\17"
	  "\377\15\16\16\377\12\13\13\377\13\14\14\377\11\10\10\377\5\6\6\377\31\33"
	  "\35\377\10\11\11\377\20\22\23\377\0\0\0\377\264\267\274\377\353\356\363\377"
	  "\356\360\366\377\357\361\367\377\356\361\366\377\357\361\366\377\360\362"
	  "\367\377\357\362\370\377\203\357\362\367\377\202\357\361\367\377\5\357\362"
	  "\367\377\357\363\367\377\360\362\367\377\356\361\366\377\360\363\370\377"
	  "\202\357\362\370\377\4\360\363\370\377\360\363\367\377\360\363\371\377\357"
	  "\362\367\377\202\361\363\370\377@\217\220\221\377\1\1\1\377\24\26\27\377"
	  "\31\32\34\377\12\14\14\377\13\13\13\377\6\20\12\377\11\11\11\377\15\17\20"
	  "\377\22\24\24\377\14\16\16\377\10\10\10\377\7\7\7\377\15\20\21\377\20\23"
	  "\25\377\10\10\10\377\15\16\20\377\13\13\13\377#%(\377\23\25\26\377\7\10\11"
	  "\377\26\27\31\377\21\23\25\377\27\30\32\377\16\17\20\377\20\23\24\377\30"
	  "\32\35\377\20\22\23\377\34\36\40\377\22\24\25\377\11\12\12\377\12\14\15\377"
	  "\7\10\10\377\27\32\33\376\20\22\23\377\15\17\17\377,14\377\11\13\12\377\27"
	  "\31\32\377!#%\377\12\13\13\377\6\7\6\377\11\12\11\377\10\10\10\377\17\17"
	  "\17\377\31\32\33\377\15\16\15\377\17\23\24\377$%)\377\10\10\10\377\24\27"
	  "\30\377\11\13\13\377\4\4\3\377\0\0\0\377001\377\254\256\261\377\362\363\370"
	  "\377\361\363\370\377\360\362\370\377\360\363\367\377\360\362\367\377\357"
	  "\362\367\377\360\363\371\377\361\362\370\377\203\357\361\367\377\3\360\362"
	  "\370\377\356\361\370\377\356\361\367\377\202\357\362\370\377\5\360\362\367"
	  "\377\360\363\370\377\356\361\367\377\356\361\366\377\355\361\366\377\202"
	  "\356\360\367\377\202\355\360\365\377\27\351\353\360\377\215\216\220\377\30"
	  "\30\31\377\1\1\1\377\7\6\7\377\12\11\12\377\15\15\15\377\31\32\35\377\27"
	  "\25\26\377\7\7\7\377\16\17\20\377\17\21\22\377\10\10\10\377\16\16\17\377"
	  "\14\15\16\377\14\16\16\377\10\7\7\377\10\11\11\377\16\17\21\377\23\26\27"
	  "\377\0\0\0\377\266\270\275\377\356\361\365\377\202\356\361\366\377\1\357"
	  "\362\367\377\202\360\362\367\377S\357\362\367\377\357\361\366\377\357\361"
	  "\367\377\361\363\370\377\360\362\370\377\360\362\367\377\357\362\370\377"
	  "\357\363\370\377\360\363\370\377\356\362\370\377\360\362\367\377\360\363"
	  "\371\377\360\362\370\377\360\364\371\377\361\364\371\377\360\363\370\377"
	  "\360\362\370\377\361\364\371\377\360\363\370\377\216\217\221\377\5\6\6\377"
	  "%(*\377\25\26\27\377\24\25\26\377\11\11\10\377\7\20\12\377\12\14\14\377\15"
	  "\15\16\377\16\17\17\377\11\12\12\377\16\17\20\377\10\11\12\377\15\15\16\377"
	  "\12\12\12\377\10\10\11\377\11\12\13\377\34\37!\377\23\25\26\377\14\16\16"
	  "\377\40\"$\377\15\16\17\377!$&\377\15\15\15\377),/\377\12\12\12\377\10\12"
	  "\13\377\36\"%\377\7\11\10\377\12\13\14\377\21\22\23\377\11\11\12\377\12\13"
	  "\14\377\12\16\15\376\14\17\17\377\33\37\"\377\36\40!\377178\377'(,\377\23"
	  "\26\27\377\10\11\12\377\10\12\11\377\20\23\23\3779?D\377\14\13\14\377\7\10"
	  "\7\377\10\12\11\377\13\14\15\377\13\14\13\377\11\12\12\377\7\10\7\377\7\7"
	  "\7\377\11\12\12\377\7\11\11\377\3\4\4\377\0\0\0\377../\377\227\230\233\377"
	  "\351\353\360\377\360\363\367\377\360\362\370\377\357\362\367\377\360\363"
	  "\370\377\361\363\371\377\202\357\361\367\377\5\357\362\367\377\360\363\370"
	  "\377\360\363\371\377\360\363\370\377\357\362\370\377\202\360\362\370\377"
	  "#\361\363\370\377\357\362\367\377\357\362\370\377\356\361\366\377\356\361"
	  "\367\377\357\362\367\377\330\333\340\377~\177\202\377\30\31\31\377\0\0\0"
	  "\377\12\14\14\377\14\15\15\377\25\27\27\377\23\25\26\377\11\10\10\377\10"
	  "\11\11\377\11\12\11\377\11\11\11\377\13\14\15\377\11\13\13\377\12\12\11\377"
	  "-/3\377\11\11\11\377\7\7\7\377\13\15\15\377\12\13\12\377\12\14\14\377\25"
	  "\27\27\377\0\0\0\377\265\267\274\377\356\361\366\377\360\362\366\377\356"
	  "\360\366\377\357\361\367\377\360\363\370\377\202\357\361\367\377\2\356\361"
	  "\366\377\357\362\367\377\202\360\363\367\377\2\361\364\371\377\357\362\370"
	  "\377\202\360\363\370\377\1\357\362\370\377\202\361\363\370\377G\360\363\371"
	  "\377\362\364\371\377\361\364\371\377\361\363\371\377\361\364\371\377\361"
	  "\363\370\377\360\363\370\377\216\217\221\377\3\3\3\377\11\12\12\37746:\377"
	  "\10\10\11\377\11\12\13\377\5\16\11\377\26\30\31\377\12\12\12\377\16\17\17"
	  "\377\33\36\37\377\12\12\13\377\23\25\26\377\10\7\7\377\11\11\11\377/58\377"
	  "\17\17\21\377\10\11\11\377\25\27\31\377)+.\37746:\377\26\30\32\377\13\14"
	  "\15\377\14\16\16\377\24\30\31\377\11\13\14\377\34\37\"\377\12\12\11\377\7"
	  "\10\10\377\16\20\21\377\12\12\13\377\11\12\12\377\11\12\13\377\14\15\14\376"
	  "%,.\377-.0\377\11\12\13\377\40$'\377CIO\377\12\13\13\377\11\12\11\377\14"
	  "\14\14\377\37\"$\377\15\20\17\377\10\11\10\377\10\11\7\377\36\40\"\377\7"
	  "\11\11\377\10\11\10\377\7\7\6\377\5\6\6\377\6\6\6\377\11\12\13\377\6\7\7"
	  "\377\4\6\5\377\5\6\6\377\3\3\3\377\0\0\0\377\14\14\14\377VVX\377\242\243"
	  "\246\377\337\342\346\377\362\366\372\377\361\363\371\377\202\360\362\370"
	  "\377\37\357\362\367\377\360\363\371\377\362\364\372\377\362\364\371\377\360"
	  "\363\371\377\360\363\370\377\357\362\367\377\361\363\371\377\357\362\370"
	  "\377\360\363\370\377\322\324\331\377\220\221\224\377BCE\377\4\4\4\377\0\0"
	  "\1\377\6\6\6\377\21\22\25\377\7\7\7\377\20\22\22\377\32\32\33\377\12\12\12"
	  "\377\10\11\10\377\20\22\23\377\23\24\25\377\17\21\22\377\7\10\7\377\6\6\5"
	  "\377\11\12\11\377\16\16\17\377\10\12\11\377\7\11\11\377\202\10\11\10\377"
	  "\6\12\12\11\377\12\14\13\377\0\0\0\377\265\267\274\377\357\361\367\377\356"
	  "\361\366\377\202\357\362\367\377\6\360\363\370\377\360\362\367\377\357\362"
	  "\370\377\357\361\367\377\357\362\367\377\360\363\367\377\202\360\362\367"
	  "\377\26\360\363\370\377\360\364\371\377\361\363\371\377\360\363\371\377\361"
	  "\363\370\377\361\364\371\377\360\363\370\377\361\364\371\377\360\363\371"
	  "\377\362\364\371\377\361\364\371\377\362\364\371\377\362\364\372\377\217"
	  "\220\221\377\3\4\4\377\15\16\17\377\6\6\6\377\31\33\35\377\17\21\21\377\6"
	  "\17\12\377\7\10\10\377\13\13\14\377\202\20\22\22\377A\11\12\12\377\7\7\7"
	  "\377\12\12\13\377\23\25\27\377\34\37!\377(+/\377\7\10\10\377\24\25\30\377"
	  "\35\37!\377\34\36!\377%')\377\20\20\22\377\10\11\11\377\40#&\377\24\26\31"
	  "\377\12\12\12\377\20\21\22\377\10\11\11\377\25\26\27\377\10\11\11\377\15"
	  "\17\20\377\17\21\22\377\22\25\25\376\12\14\13\377\36\"$\377EGK\377\35\"#"
	  "\377\13\14\14\377\15\17\21\377\33\37\"\377\24\26\26\377\23\25\25\377\14\15"
	  "\14\377\7\10\10\377\12\14\14\377\7\7\6\377\10\11\11\377\13\15\15\377\14\16"
	  "\16\377\13\14\15\377\10\11\11\377\11\12\12\377\36\40\"\377349\377\7\7\7\377"
	  "\14\17\17\377\11\11\11\377\7\10\10\377\3\3\4\377\1\2\1\377\2\2\3\377()*\377"
	  "[\\]\377\201\202\205\377\241\243\245\377\266\270\274\377\307\311\315\377"
	  "\316\320\324\377\315\317\322\377\304\306\312\377\261\263\267\377\232\234"
	  "\236\377y{}\377PQR\377\34\34\35\377\202\0\0\0\377(\2\2\3\377\5\6\10\377\16"
	  "\20\21\377\12\14\15\377\7\12\11\377\20\23\25\377\10\10\10\377\10\10\7\377"
	  "\13\13\13\377\23\24\25\377\10\10\10\377\17\22\22\377\20\20\21\377\7\10\7"
	  "\377\31\32\33\377\7\7\7\377\13\14\15\377\12\14\13\377\10\11\10\377\33\36"
	  "\40\377\10\10\10\377\11\12\11\377\11\12\13\377\0\0\0\377\266\270\274\377"
	  "\360\362\370\377\357\363\370\377\356\361\366\377\357\362\367\377\360\363"
	  "\370\377\360\362\367\377\357\363\370\377\357\362\370\377\360\363\370\377"
	  "\361\363\370\377\361\363\371\377\360\362\370\377\360\363\371\377\361\364"
	  "\371\377\361\364\372\377\202\361\364\371\3776\360\363\371\377\356\361\367"
	  "\377\360\363\370\377\361\363\371\377\361\365\371\377\361\363\371\377\361"
	  "\363\370\377\361\364\371\377\216\217\221\377\1\1\1\377\7\10\7\377\20\20\21"
	  "\377\7\10\10\377\32\34\36\377\7\17\13\377\7\10\10\377\20\21\23\377\12\12"
	  "\13\377\11\12\12\377\12\13\14\377\10\10\10\377\31\33\34\377),/\377\22\23"
	  "\25\377\16\20\21\377\13\16\20\377\7\10\10\377\14\15\17\377\13\14\15\377\25"
	  "\27\30\377\22\24\26\377\15\15\17\377\10\11\11\377\22\24\26\377\16\21\23\377"
	  "\26\31\34\377\6\7\6\377\13\15\15\377\11\14\14\377\11\12\13\377\12\15\15\377"
	  "\36!\"\376\12\14\15\377\16\21\21\377037\377\26\30\32\377\14\16\16\377\20"
	  "\23\24\377ot{\377\"$&\377\35!#\377\11\13\13\377\13\15\15\377\14\16\15\377"
	  "\202\10\11\10\377\21'+-\377\15\16\16\377\7\10\6\377\17\21\22\377\16\20\21"
	  "\377\6\7\6\377\6\7\7\377\30\32\33\377\5\6\5\377\7\7\7\377\12\14\13\377\6"
	  "\6\6\377\21\22\23\377\7\7\7\377\5\7\6\377\2\2\2\377\1\1\1\377\207\0\0\0\377"
	  "\27\2\2\2\377\1\1\1\377\3\4\4\377\5\6\5\377\11\13\13\377\11\11\10\377\11"
	  "\12\11\377\35\40$\377\26\30\33\377\6\7\7\377\7\7\7\377\6\7\6\377\11\11\10"
	  "\377\7\7\6\377\7\10\7\377\12\13\14\377\10\11\10\377\7\7\7\377\7\7\6\377\36"
	  "\40#\377\10\10\7\377\12\12\12\377\12\13\13\377\202\10\12\12\377\7\10\11\10"
	  "\377\16\20\20\377\10\10\7\377\11\10\7\377\0\0\0\377_ad\377~\177\202\377\202"
	  "}~\201\377\203~\177\202\377\1}\177\202\377\202~\177\202\377\203~\200\203"
	  "\377\1}\177\202\377\203~\200\203\377\6\177\200\203\377~\200\203\377}\200"
	  "\203\377}\177\202\377~\177\203\377\177\201\203\377\202~\200\203\377k~\201"
	  "\204\377JJL\377\2\3\2\377\40\"$\377\10\11\11\377\6\7\7\377\17\20\21\377\4"
	  "\14\10\377\20\21\21\377\7\7\7\377\11\12\12\377\25\30\32\377\11\11\11\377"
	  "\14\16\16\377\12\14\15\377\26\30\31\377\37!$\377\17\20\21\377\11\12\12\377"
	  "\12\13\14\377\11\11\12\377\24\27\31\377\17\21\22\377\20\23\24\377\14\15\16"
	  "\377\10\11\11\377\11\11\11\37759=\377\40\"$\377\7\10\10\377\13\15\14\377"
	  "\23\25\27\377\12\14\15\377\6\6\7\377\36!\"\376HOT\377&+-\377\16\16\16\377"
	  "\21\25\27\377\30\34\37\377\14\16\16\377.46\377035\377\"%(\3775:>\377\14\15"
	  "\15\377\11\13\13\377\7\7\7\377\21\22\22\377\11\13\13\377\26\32\32\377\12"
	  "\13\14\377\12\12\11\377\6\7\6\377\7\10\10\377\5\7\6\377\6\7\7\377\7\10\10"
	  "\377\11\12\12\377\12\13\13\377\36!$\377\24\27\30\377!&(\377\7\11\11\377\7"
	  "\10\10\377\6\7\7\377\5\6\6\377\6\7\6\377\6\10\10\377\10\10\10\377\6\6\6\377"
	  "\12\11\11\377\12\13\12\377\13\13\12\377\30\32\34\377%)-\377\11\11\11\377"
	  "\12\13\13\377\10\11\11\377\12\12\12\377\11\11\13\377\7\7\10\377\12\12\12"
	  "\377\24\26\27\377\15\15\15\377\10\11\11\377\35\37\40\377\10\11\10\377\15"
	  "\16\17\377\10\11\10\377\15\16\16\377\20\22\22\377\10\10\7\377\40\"$\377\12"
	  "\13\13\377\13\14\15\377\7\6\7\377\14\15\16\377\17\20\21\377\31\34\35\377"
	  "\6\6\7\377'(,\377\4\4\4\377\1\1\1\377\2\1\1\377\1\1\1\377\2\1\1\377\203\1"
	  "\1\1\377\1\1\1\2\377\202\2\2\2\377\177\4\5\6\377\1\2\2\377\4\4\4\377\1\2"
	  "\2\377\2\2\2\377\3\2\2\377\3\3\4\377\2\2\2\377\11\12\13\377\2\3\3\377\3\4"
	  "\5\377\2\3\4\377\3\3\3\377\1\2\1\377\1\1\1\377\2\2\2\377\3\3\3\377\5\6\6"
	  "\377\13\14\15\377\7\10\11\377\32\34\36\377\7\7\7\377\5\14\7\377\5\6\6\377"
	  "\11\12\12\377\10\10\10\377\11\11\11\377\21\25\27\377\17\21\22\377\37!$\377"
	  "\12\14\14\377\40$&\377\11\12\13\377\7\7\6\377\31\33\34\377+-0\377\12\13\13"
	  "\377\32\35\37\377\15\16\17\377\14\16\17\377\20\22\23\377\15\17\20\377\13"
	  "\14\14\377\15\16\17\377\7\10\7\377\31\34\36\377\22\23\25\377\12\13\13\377"
	  "\6\7\7\377\16\20\21\376/68\377ZZ`\377\15\17\17\377\14\15\15\377\23\30\32"
	  "\377\30\32\35\377\36!$\377\40#%\377ov~\377\33\35\37\377\16\21\20\377\12\14"
	  "\14\377\21\22\23\377\23\24\26\377\22\25\26\377\11\12\12\377\15\17\20\377"
	  "\15\16\16\377\6\6\6\377\16\20\21\377\7\10\10\377\6\7\6\377\7\6\6\377\6\6"
	  "\6\377\7\10\10\377\10\11\11\377\10\7\10\377\7\7\7\377\20\22\24\377\14\16"
	  "\17\377\7\10\10\377\10\12\11\377\10\10\10\377\7\10\7\377\10\10\10\377\7\7"
	  "\7\377\13\14\14\377\16\17\20\377\12\14\13\377\35!#\377\15\17\16\377\30\31"
	  "\33\377\10\12\11\377\20\22\23\377\12\12\12\377\7\10\12\377\12\12\13\377\21"
	  "\22\24\377\12\13\13\377\14\17\17\377\10\11\10\377\17\20\20\377\30\33\34\377"
	  "\7\10\7\377\12\14\13\377$)+\377\14\14\14\377\20\21\22\377\13\13\13\377\11"
	  "\13\12\377\10\10\7\377\17\20\21\377\11\10\11\377\15\16\17\377\26\26\27\377"
	  "\11\12\12\377\23\25\26\377\10\10\10\377\6\6\6\377\7\7\6\377\6\6\6\377\15"
	  "\15\15\377\25\26\30\377\10\7\10\377\11\12\12\377\6\7\6\377\11\12\12\377["
	  "\16\16\17\377\15\16\16\377\30\31\32\377\12\12\11\377\11\12\13\377\11\12\12"
	  "\377\15\15\16\377\12\13\14\377\14\15\15\377\16\21\22\377\17\21\22\377\14"
	  "\16\17\377\11\12\13\377\7\7\7\377\10\11\11\377\11\12\12\377\12\13\13\377"
	  "\16\17\21\377\7\7\10\377\5\6\7\377\10\10\10\377\20\21\22\377.13\377\5\13"
	  "\7\377\11\12\11\377\10\10\10\377\14\15\15\377\11\11\11\37768<\377\13\13\14"
	  "\377\26\27\31\377\"&(\377\7\10\10\377\11\11\11\377\20\20\20\377\34\36\40"
	  "\377#&)\377$'*\377\16\20\20\377\12\14\14\377\10\11\11\377)-0\377\20\21\23"
	  "\377\7\10\10\377\26\27\30\377\16\17\20\377\33\34\40\377\11\13\14\377\13\14"
	  "\15\377\7\10\7\377$((\376\33\35\37\377\14\20\20\377\21\24\25\377\33\36!\377"
	  "\13\16\15\377037\377+02\377\30\33\35\377#'*\377%+.\377\24\24\25\377\14\16"
	  "\17\377\26\27\31\377\15\15\15\377\7\10\10\377#&(\377\10\12\11\377\6\10\7"
	  "\377\17\17\20\377\7\10\7\377\22\24\25\377\10\10\10\377\7\7\7\377\13\14\13"
	  "\377\14\16\16\377\22\24\25\377\17\21\23\377\10\11\11\377\11\11\10\377\11"
	  "\11\11\377\35\37!\377\15\17\15\377\6\6\6\377\5\6\5\377\6\7\6\377\11\12\12"
	  "\377\11\11\11\377%')\377\21\23\24\377\22\23\23\377\202\7\7\7\377/\13\14\14"
	  "\377\7\10\7\377\26\32\34\37769>\377\11\12\13\377\16\16\16\377&),\377\16\17"
	  "\17\377\13\14\13\377\12\13\13\377\12\12\12\377\27\32\34\377\24\25\27\377"
	  "\7\7\7\377\23\25\27\377\33\35\40\377\10\10\7\377\7\7\6\377\23\26\27\377\14"
	  "\15\16\377\40!$\377\7\7\7\377\6\7\6\377\21\23\25\377\6\6\6\377\24\26\30\377"
	  "\13\13\13\377\16\20\20\377\16\17\17\377\10\10\10\377\12\14\15\377\12\12\13"
	  "\377\11\13\13\377\14\15\16\377\13\14\14\377\20\21\22\377\11\12\12\377\11"
	  "\11\11\377\13\14\14\377\15\17\17\377\12\13\14\377\12\12\12\377\10\12\12\377"
	  "!$'\377\11\12\12\377\17\22\23\377\16\17\20\377\203\10\11\11\377D\7\7\10\377"
	  "\7\10\11\377\7\10\7\377\7\10\10\377\11\12\12\377\10\11\13\377\23\25\27\377"
	  "\13\14\15\377\7\15\12\377\11\11\11\377\12\12\13\377-03\377;>C\377\17\20\21"
	  "\377\16\21\21\377\20\22\24\377\13\14\15\377\7\10\11\377\10\10\10\377\10\12"
	  "\12\377\24\26\27\377\26\30\32\377\14\16\17\377\25\26\30\377\10\11\12\377"
	  "\15\20\21\377\11\11\11\377\13\14\14\377-15\377\11\12\13\377\13\14\14\377"
	  "!$'\377\10\11\11\377\14\15\16\377\11\13\13\377\33\35\36\376\13\16\16\377"
	  "\13\15\14\377\25\30\32\377\24\30\33\377\37\"#\377\15\17\17\377Y]d\377\32"
	  "\33\35\377\20\22\24\377\17\22\24\377\22\27\30\377\25\31\33\377\16\21\21\377"
	  "\10\11\10\377\12\13\13\377\13\16\17\377\15\15\16\377\14\15\14\377\7\10\10"
	  "\377\35\37\40\377\15\16\16\377\7\7\7\377\17\21\21\377\10\11\11\377!$&\377"
	  "\27\31\33\377\11\11\11\377\7\11\11\377\11\12\12\377\16\20\21\377\22\26\26"
	  "\377\33\34\36\377\202\7\10\7\377\36\7\7\7\377\22\23\25\377\12\13\13\377\16"
	  "\17\20\377\15\17\17\377\11\11\10\377\10\11\10\377\13\15\15\377\10\11\10\377"
	  "&)+\377\15\16\15\377\7\10\11\377\21\24\26\377\36!\"\377\14\16\16\377\17\20"
	  "\20\377\12\13\13\377\7\7\7\377\20\21\22\377\21\23\24\377\10\7\6\377\11\12"
	  "\11\377\12\13\13\377\15\20\21\377\10\12\11\377\11\12\13\377\13\16\15\377"
	  "\23\24\26\377\15\16\16\377\7\7\7\377\202\6\6\6\377\14\12\13\14\377\10\12"
	  "\11\377\11\13\14\377\35!$\377\21\22\24\377\15\15\15\377\6\7\7\377\12\14\13"
	  "\377\21\23\23\377\17\20\20\377\10\11\11\377\10\10\7\377\202\7\7\6\377\36"
	  "\11\11\11\377\7\10\10\377\10\11\12\377\32\32\35\377\11\12\11\377\13\13\13"
	  "\377\24\25\26\377\12\13\13\377\7\10\7\377\11\12\12\377\7\11\10\377\11\12"
	  "\13\377\12\13\14\377\10\12\13\377\11\12\13\377\22\24\26\377\16\17\20\377"
	  "'*.\377\16\21\23\377\11\12\13\377\20\27\25\377\11\11\12\377\11\11\11\377"
	  "\15\17\20\377\20\23\25\377\13\13\13\377\7\7\10\377\12\13\14\377\7\7\7\377"
	  "\13\15\16\377\202\14\15\15\377\177\20\22\23\377\10\12\12\377\14\15\16\377"
	  "#%'\377\15\15\15\377\20\23\24\377\11\11\11\377\36\40\"\377;?D\377\31\34\34"
	  "\377\12\14\14\377\13\15\16\377\20\22\23\377\22\25\27\377\7\7\7\377\23\24"
	  "\25\376\15\17\20\377\23\27\30\377\16\20\20\377\36\40$\377(,0\377\35\37!\377"
	  "\12\14\14\377!%(\377\10\12\11\377\12\14\14\377047\377\33\37\"\377\14\16\17"
	  "\377\22\21\22\377\10\12\12\377\6\10\7\37749=\377\6\7\5\377\20\23\24\377\40"
	  "\"$\377\11\11\12\377\21\23\24\377\16\17\17\377\34\40#\377\17\21\22\377\12"
	  "\13\14\377\23\26\27\377\12\14\14\377\7\10\7\377\11\12\13\377\23\25\25\377"
	  "\20\23\24\377\10\12\12\377\11\11\10\377\25\27\27\377\12\13\13\377\15\20\21"
	  "\377278\377\7\7\6\377\11\11\11\377\7\10\10\377\17\20\21\377\22\25\25\377"
	  "\32\34\37\377\14\16\17\377\17\20\22\377\30\34\36\377\31\32\34\377\15\17\17"
	  "\377\36\37\"\377\11\10\10\377\13\13\13\377#%'\377\13\14\15\377-.1\377-03"
	  "\377\31\31\33\377\10\10\10\377368\377\20\21\22\377\22\23\22\377\23\24\25"
	  "\377\16\17\21\377\6\6\6\377\10\12\12\377\6\6\6\377\10\10\7\377\6\7\10\377"
	  "\10\12\12\377\7\11\10\377\12\13\13\377\7\6\6\377\6\7\7\377\15\16\17\377\34"
	  "\35\37\377\6\6\6\377\7\10\7\377\16\17\20\377\17\20\20\377\21\22\23\377\7"
	  "\6\6\377\6\6\6\377\10\10\10\377\11\13\12\377\12\14\13\377\11\11\11\377\13"
	  "\15\15\377\12\12\12\377\10\10\7\377\10\11\10\377\20\20\21\377\14\14\14\377"
	  "\7\10\11\377\27\30\31\377(),\377\21\23\24\377\30\32\33\377\37\"#\377\20\20"
	  "\22\377\12\14\14\377\13\22\20\377\31\33\35\377\7\7\7\377\17\20\21\377\7\7"
	  "\7\377\11\14\15\377\10\11\11\377\7\10\10\377\30\31\33\377\11\13\14\377\15"
	  "\16\17\377\177\10\11\11\377\10\11\12\377\13\14\14\377\10\11\10\377\13\15"
	  "\16\377\26\31\33\377\11\11\12\377\13\15\16\377\33\35!\377139\377\40#&\377"
	  "\7\7\10\377\24\30\32\377\14\15\16\377\10\12\12\377\14\14\15\377\17\21\22"
	  "\376\36#%\377\15\16\17\377,14\377\16\20\22\377\31\35\35\377\40\"%\377\14"
	  "\16\17\377\20\21\22\377\15\20\20\377\40\"&\377\14\16\16\377\27\34\36\377"
	  "&+-\377\37!%\377\12\13\13\377\13\16\17\377\15\17\17\377(+.\377\21\22\23\377"
	  "\32\33\35\377\21\23\24\377\16\20\20\377\36!\"\377%%(\377\12\13\14\377\30"
	  "\34\35\377\13\15\14\377\40%'\377#%&\377\27\32\33\377\32\33\36\377\11\12\12"
	  "\377\10\10\10\377\35\40#\377\13\15\16\377\34\40!\377\14\17\20\377\23\24\25"
	  "\377\27\31\33\377\13\13\13\377\14\17\16\377\12\13\13\377\24\31\32\377KOR"
	  "\377'+-\377\22\25\27\377\7\11\11\377\13\14\15\377\"')\377\14\15\16\377\7"
	  "\7\7\377\25\31\32\377\12\11\11\377+/1\377!#&\377&)+\377\13\14\14\377\15\17"
	  "\17\377\11\13\13\377\21\22\22\377\24\26\27\377\15\16\17\377\7\7\7\377\24"
	  "\25\26\377(+.\377\15\16\17\377\11\12\12\377\6\6\6\377\6\7\10\377\12\14\14"
	  "\377\14\16\16\377\12\11\12\377\7\7\7\377%)*\377\20\21\22\377\25\26\27\377"
	  "\6\5\5\377\12\13\13\377\25\26\31\377\7\7\6\377\10\10\7\377\7\7\6\377\11\11"
	  "\12\377\11\11\11\377\14\14\14\377\13\13\13\377\7\7\7\377ahl\377\11\11\11"
	  "\377\11\11\12\377\14\15\15\377\10\12\13\377\15\16\16\377\14\16\16\377\26"
	  "\30\32\377&).\377'+/\377\15\15\16\377\15\16\17\377\16\20\20\377\17\26\25"
	  "\377!#&\377\11\11\12\377\7\10\10\377\11\11\12\377\10\11\11\377\11\13\14\377"
	  "\13\13\14\377\15\16\17\377!$&\377`\14\15\15\377\40#%\377\23\25\27\377\12"
	  "\12\13\377#')\377\21\23\25\377\10\10\11\377\26\32\33\377%(,\377\37\"$\377"
	  "\30\32\35\377\12\13\14\377\14\17\17\377\12\13\14\377\13\14\15\377\21\24\24"
	  "\377\31\35\37\377\16\21\21\376\31\34\36\377*.1\377\32\32\33\377/47\377\13"
	  "\15\15\377\20\21\22\377+/2\377\7\11\11\377(03\377DGL\377\13\15\16\377\30"
	  "\33\35\37716;\377\35\37!\377/47\377\11\12\12\377\11\13\13\377\14\16\16\377"
	  "QV\\\377\25\27\30\377\25\30\33\377EJO\377&')\377\33\36\37\377\37!#\377\17"
	  "\22\22\377\"'*\377\31\33\35\377\31\32\33\377(+.\377\21\22\23\377\20\22\22"
	  "\377\31\33\35\377'+.\377\40$&\377\16\20\21\377\11\11\11\377\22\24\25\377"
	  "\33\37!\377\13\14\14\377\12\14\14\377\15\17\20\377\14\16\16\377+03\377;="
	  "A\377\37#&\377\15\16\20\377\11\13\13\377\17\20\21\377+02\377\26\27\31\377"
	  "\10\10\10\377#')\377\16\20\22\377$')\3777;>\377%'(\377\37\"$\377\13\14\13"
	  "\377\11\11\11\377\17\23\23\377\11\12\12\377\10\10\10\377\23\25\27\377\"%"
	  "(\377\33\34\37\377\13\13\14\377\22\23\24\377*,0\377\6\7\7\377\11\12\12\377"
	  "\21\21\22\377\13\14\15\377\16\17\17\377\20\21\22\377\12\11\11\377\27\30\32"
	  "\377\11\11\11\377\202\11\11\10\377\30\7\7\6\377\13\14\14\377\15\17\17\377"
	  "\13\13\12\377\7\10\10\377\24\25\26\377.05\377\5\6\5\377\17\20\21\377\20\22"
	  "\22\377\15\15\16\377\20\22\23\377(),\377\21\23\24\377\17\22\23\377\26\30"
	  "\31\377\17\21\23\377\34\40\"\377\26\27\31\377\23\25\26\377-25\377\17\21\22"
	  "\377\23\24\26\377\11\13\13\377\202\10\11\11\377!\22\25\25\377\30\34\36\377"
	  "\14\16\20\377\11\12\14\377\24\26\30\377\17\20\21\377\20\21\22\377\23\26\27"
	  "\377\34\36\40\377\14\16\16\377\22\25\26\377,/2\377\21\23\25\377\13\15\16"
	  "\377\36\40$\377\20\22\24\377\12\13\14\377\21\24\27\377\12\12\13\377\"%(\377"
	  "\6\7\7\377\20\24\24\376\12\15\16\377PT[\377\40\"%\377\13\15\15\377-15\377"
	  "\11\12\12\377\17\21\21\377/47\377\12\14\14\377\23\27\31\377059\377\202\23"
	  "\26\27\377\177V[b\377\27\30\32\377\16\16\17\377\13\12\12\377\15\17\17\377"
	  "\23\27\27\377ADI\377\24\30\32\377(,.\377HKP\377\21\21\22\377\6\7\7\377\27"
	  "\33\36\377\16\21\22\377,03\377#&(\377%()\377\25\27\30\377'),\377\12\14\14"
	  "\377\37\"#\377\21\25\27\377158\377\10\11\11\377\7\10\7\377$()\377\21\22\23"
	  "\377\23\27\31\377\17\20\20\377\12\13\13\377\40\"%\377CGL\377\26\30\33\377"
	  "\17\20\22\377#$'\377\12\12\12\377\24\25\25\377\11\13\12\377\13\15\15\377"
	  "\24\26\30\377\35\36\40\377\11\12\12\377\13\16\15\377=AF\377\7\10\6\377\15"
	  "\16\16\377\11\11\11\377\10\11\10\377?BG\377&&)\377\12\12\12\377\13\15\15"
	  "\377\12\13\13\377\25\27\31\377\24\27\31\377\23\24\25\377\15\17\17\377\31"
	  "\35\37\377\36!#\377!$(\377\11\12\13\377\13\14\14\377\14\16\17\377\14\15\15"
	  "\377\11\11\11\377\7\7\6\377\10\6\6\377\10\12\13\377\11\10\10\377\37\"$\377"
	  "\14\14\14\377\10\11\10\377\35!#\377\13\13\14\377\12\12\12\377\14\15\16\377"
	  "\34\37\40\377\17\22\22\377\13\14\15\377\23\24\26\3775;?\377\35\37!\377\15"
	  "\17\17\37715:\377&*-\377\27\32\35\377\24\27\30\377\17\27\24\377-26\377\6"
	  "\6\6\377\13\15\17\377\10\11\12\377\7\7\6\377\10\13\14\377?@E\377\24\27\30"
	  "\377\10\11\11\377\13\15\15\377\31\32\34\377NQV\377\23\25\26\377\11\11\11"
	  "\377\24\26\31\377)-0\377!%'\377\22\24\26\377!$&\377\27\30\31\377,14\377\17"
	  "\21\21\377\25\27\30\377\20\24\26\377\7\10\11\377#&(\37728;\376'+/\377\13"
	  "\14\14\377\34\37!\377\35\40\"\377\15\16\16\377\20\21\22\377\17\21\22\377"
	  "-13\377\21\23\24\377\17\22\23\377'),\37716:\377\177\35!$\377\25\27\27\377"
	  ")-1\377\15\17\17\377#&)\377\12\13\12\377\37$&\37727<\377$%'\377\23\25\27"
	  "\377\33\36\40\377'+/\377\10\11\11\377\11\13\12\377\"$'\377+04\377#$&\377"
	  ")-0\377,36\377PW]\377\17\17\17\377\17\22\22\377KPU\37778:\377\13\16\15\377"
	  "\20\23\23\377\21\24\23\377\40$'\377\23\25\26\377\11\13\13\377\10\10\7\377"
	  "\13\13\13\377\26\27\31\377\30\33\36\377\17\20\21\377\15\20\20\377247\377"
	  "\10\10\10\377\34\35\36\377\15\16\15\377\12\14\14\377\21\24\26\377\14\15\15"
	  "\377\37!#\377\7\7\6\377\22\24\25\377\35\37!\377\12\13\13\377\12\12\12\377"
	  "\10\11\11\377!%)\377\35\"%\377\10\11\11\377\12\14\14\377.15\377\33\36!\377"
	  "\15\16\16\377#%(\377!%'\377\14\17\20\377\5\6\6\3778;?\377(*.\377\12\13\13"
	  "\377\17\20\21\377\11\12\13\377\10\10\10\377\11\12\11\377\13\14\14\377\10"
	  "\10\10\377\10\10\7\377\25\27\30\377\40!$\377\7\7\7\377\16\17\20\377\26\31"
	  "\34\377\21\25\26\377\27\31\32\377\10\10\10\377\25\27\32\377!$(\377\36\"%"
	  "\377@BF\377\25\27\32\377-/2\377$&*\377\13\14\15\377\33\37!\377\17\27\25\377"
	  "\21\23\24\377\10\11\11\377\6\10\10\377\36\40\"\377\16\20\21\377\10\10\11"
	  "\377\13\14\14\377\35!$\377\36\36!\377\7\7\10\377@CG\377(+.\377\11\13\13\377"
	  "\24\26\30\377\35!$\377\26\31\33\377\22\25\26\377NQW\377\6\7\10\377\31\32"
	  "\33\377DGM\377\33\35\36\377\16\21\21\377\10\11\10\377\23\27\30\377\13\14"
	  "\15\377\40\"$\376\22\23\23\377\21\23\22\377\30\31\34\377\20\22\24\377\12"
	  "\14\15\377\22\25\26\377ACI\377\12\13\13\377(,/\377\31\33\35\377\13\14\14"
	  "\377vafm\377,-0\377\14\15\16\377&),\377Z]c\377\35\40\"\377237\377\25\31\33"
	  "\377#&(\377\24\26\30\377\11\13\13\377\26\31\34\377\"$%\377\35\37!\377\16"
	  "\21\22\377\25\27\31\377!#%\377\21\23\24\37738<\377NSZ\377/24\377\12\13\12"
	  "\377>@E\377\31\32\32\377-14\377369\377\40!$\377\16\17\20\377\10\10\10\377"
	  "59<\377\"%'\377\7\11\11\377\10\10\10\377\7\10\7\377\12\14\16\377\30\33\35"
	  "\377\34!\"\377\12\13\13\377\22\22\23\377\12\11\10\377\17\21\21\377\12\14"
	  "\14\377\12\13\13\377\10\10\11\377\7\10\10\377\16\17\20\377\17\21\21\377\13"
	  "\14\15\377\40\"$\377,-0\377\16\16\17\377\25\30\32\377X\\a\377\24\24\25\377"
	  "\6\6\6\377\12\13\13\377\10\11\11\377\22\24\26\377\26\31\32\377\13\14\14\377"
	  "\10\10\11\377\17\20\22\377$(+\377\22\24\25\377\11\11\12\377\22\23\26\377"
	  "\11\11\10\377\11\11\11\377\11\10\11\377\17\21\23\377\7\10\10\377\13\14\15"
	  "\377\13\13\13\377\21\23\24\377\13\14\13\377\16\15\14\377\33\35\37\377\21"
	  "\23\24\377\12\12\12\377\16\17\17\377\30\33\36\377)-0\377\22\24\25\377\34"
	  "\40#\377\23\26\30\377\33\37\40\377\40#%\377\16\16\17\377,04\377\24\35\34"
	  "\377\22\24\26\377\7\6\6\377\40$(\377\11\13\13\377146\377\6\7\7\377\11\12"
	  "\12\377\14\15\16\377%&)\3778;@\377\11\12\12\377\12\12\13\377[_e\377\27\33"
	  "\36\377\40#$\377\14\16\16\37715:\377\26\30\31\377TW]\37746;\377\27\31\33"
	  "\377\25\30\32\377\7\10\10\377\34\37#\377\17\22\23\377/25\377\13\14\14\376"
	  "\14\16\17\377\202\24\27\30\377\177\10\11\7\377.37\37789<\377\17\22\22\377"
	  "\30\33\36\377\11\11\11\377).0\377\37#&\377\10\11\11\377#')\377\13\15\15\377"
	  "\37$&\377,/3\377GLP\377\31\35\37\377\27\32\33\377\34!#\377\31\32\34\377\32"
	  "\35\40\377\14\15\16\377\21\24\24\377\26\26\30\3777;A\377\34\36\37\377\16"
	  "\22\23\377\23\25\27\3774;?\377\31\34\36\377\16\20\20\377\31\36\37\377\11"
	  "\12\11\377\24\25\26\377\10\11\10\377,03\377058\377\14\16\16\377\11\11\10"
	  "\377\35\37!\377),.\377\7\10\10\377\10\11\11\377\7\10\10\377\23\26\27\377"
	  "\16\20\22\377+-1\377,.1\377\13\14\14\377\12\12\13\377\24\24\26\377\23\24"
	  "\25\377\5\6\6\377\17\20\21\377\25\30\32\377\20\21\23\377\34\36!\377),0\377"
	  "\22\25\27\377\11\13\12\377\26\27\30\377\16\17\20\377\11\13\14\377\27\33\35"
	  "\377\14\15\15\377\7\7\7\377\12\13\13\377\20\21\22\377\11\11\11\377\33\34"
	  "\36\377\12\12\12\377BGL\377fip\377\10\12\11\377\35\37!\377\11\13\14\377\37"
	  "!%\377\13\14\14\377\26\26\27\377\7\7\10\377\12\13\13\377\12\14\14\377\14"
	  "\14\13\377\11\11\10\377\35\37\40\377\30\33\34\377\10\11\12\377\14\15\15\377"
	  "\32\34\36\377\12\13\14\377;>C\377\32\34\36\377GKO\377+-1\377\22\25\26\377"
	  "w}\203\377\14\14\16\377\12\13\14\377\17\22\24\377UY_\377\16\17\20\377\12"
	  "\12\13\377\17\21\21\377&+,\377\6\7\7\3775:>\377\20\20\22\377\6\7\7\377#%"
	  "(\377\36\37\"\377\10\11\11\377\11\13\13\377_cj\37758=\377\15\17\20\377\37"
	  "\"%\377\15\16\17\377,/3\377\40\"&\377\17\21\22\377\24\26\30\377\"%'\377\16"
	  "\17\21\377\15\20\21\377\24\26\30\377\13\15\16\377\26\31\32\376\11\11\10\377"
	  "\17\23\24\3772$%'\377\21\25\25\377\"$&\377\21\22\23\377\24\30\31\377\20\22"
	  "\23\377\20\23\24\377\20\22\25\3779:>\377\14\15\15\377\15\15\15\377@DI\377"
	  ",04\377\22\24\25\377).1\377-/3\377>AF\377\13\14\14\377\26\33\34\377\16\21"
	  "\23\377\34\40\"\377\14\16\17\377\32\35\37\377\27\27\30\377\32\35\36\3774"
	  "8<\377\20\23\23\377\21\23\25\377$'*\37747;\377\10\11\10\377\14\17\20\377"
	  ")-0\377$%'\377\11\13\12\377\27\31\33\37727:\377\13\14\14\377\11\12\11\377"
	  "\21\22\22\377$)+\377\21\23\24\377\7\10\10\377\10\11\12\377\17\21\23\377("
	  ",.\377\32\34\36\377\40!$\377\27\31\33\377\6\6\7\377\202\10\11\11\377\177"
	  "\7\10\10\377\24\24\26\377\15\16\17\377\24\24\25\377\31\32\34\377\24\26\30"
	  "\377\32\33\36\377\10\11\12\377\13\14\14\377\11\12\13\377\7\7\7\377\10\7\7"
	  "\3778<A\377\10\10\7\377\17\21\22\377\17\17\20\377\7\10\10\37737;\377\17\20"
	  "\21\377\16\20\21\377\"%)\377\23\25\26\377\25\27\30\377\32\34\36\377\23\24"
	  "\26\377\6\6\6\377\7\7\6\377\7\10\7\377\30\32\34\377\10\11\11\377\15\17\17"
	  "\377\10\10\7\377/46\377\11\11\11\377\14\13\14\377(-0\377\36!#\377\12\12\11"
	  "\377PSX\377*-1\377\"')\377\26\31\34\377\20\22\23\377`fm\377\12\13\13\377"
	  "\26\31\34\377\12\20\15\377.36\377\11\12\12\377\11\11\11\377\7\10\10\377+"
	  "/2\377\26\25\27\377\20\22\24\377\13\14\15\377\15\16\17\377\16\17\21\377\31"
	  "\33\34\377\31\33\36\377\16\16\17\377\37!$\377pw~\377\15\15\16\377\27\30\32"
	  "\377'+.\377\12\14\15\377\36\40\"\377'(,\377\11\13\14\377\12\15\15\377\37"
	  "#&\377\10\11\12\377-13\377\25\30\32\376\16\20\21\377\7\11\10\377\26\30\33"
	  "\37758<\377\17\22\22\377\17\20\20\377\22\27\31\377\27\31\32\377049\377\21"
	  "\24\24\377\15\16\16\377\30\33\35\377\35\40\"\377\33\37\37\3778=B\377\15\20"
	  "\20\377\25\32\32\37757;\377\34\36!\377.27\377\12\14\14\377\"&)\377\32\36"
	  "\40\377\23\24\27\377\13\13\13\377\"&)\377?DH\377*.1\377\17\22\22\377\26\31"
	  "\34\377\27\34\35\377\17\17\20\377\13\16\16\37728=\377GJO\377\30\32\34\377"
	  "\13\14\14\377\25\30\32\377*+.\377\14\17\20\377\16\16\17\377\10\11\10\377"
	  "\36!!\377/6:\377\32\34\35\377\12\13\15\377\11\11\11\377\23\25\27\377\32\35"
	  "\36\377\32\35\37\377\22\23\23\377\11\12\12\377\7\10\7\377M\10\12\13\377\33"
	  "\35\37\377\31\33\35\377\27\31\33\377\15\16\16\377\15\16\17\377\27\31\34\377"
	  "\10\10\10\377\27\33\35\377\11\11\12\377\6\7\6\377\10\11\11\377\23\24\26\377"
	  "\25\27\30\377\20\23\23\377\13\13\14\377\14\17\17\377\"$'\377\7\10\10\377"
	  "\27\31\34\377\20\22\23\377\15\20\21\37725:\377\34\36\40\377\22\23\24\377"
	  "\11\11\12\377\13\15\15\377\17\17\21\377\7\7\10\377\7\7\7\377\17\20\21\377"
	  "\13\16\17\377\12\13\13\377\12\11\10\377!#'\377\40$&\377\12\13\13\377\13\14"
	  "\14\377\25\31\34\377\13\14\13\37735:\377*-1\377-15\377GLP\377\25\27\30\377"
	  "48=\377\21\22\23\377\35#$\377\12\13\13\377\26\30\32\377\20\22\23\377\26\30"
	  "\32\377\10\12\12\377\23\24\25\377%'*\377\34!$\377\12\12\11\377\16\17\20\377"
	  "\35!#\377OQX\377\31\34\36\377*+-\377%*,\377\33\37\37\377-13\377\10\10\11"
	  "\377\24\27\32\377\27\30\32\377\36\37\"\377:?B\377\20\21\23\377\15\20\21\377"
	  "\11\13\14\377\22\24\25\377\22\25\25\376\31\32\34\377\40$&\377\202\14\16\17"
	  "\377\177\23\30\32\377\14\16\16\377\25\31\31\377JLR\377\11\12\12\377#$'\377"
	  "\11\11\11\377!$&\37736;\377\13\15\14\377\16\22\23\377Z]d\377\15\17\20\377"
	  "\14\17\17\377;AF\377)-0\377\36!$\377\17\22\23\377\36!$\377\32\34\36\377\17"
	  "\22\23\377\36\37\"\377%),\377\17\21\22\377\11\12\12\377\35!#\377\13\15\15"
	  "\377\12\12\12\377\27\34\36\377LQV\377035\377\15\16\16\377.26\377\35\37!\377"
	  "\17\22\22\377\22\26\27\377\20\21\23\377\11\12\10\377\11\13\13\37758:\377"
	  "&*,\377\24\26\31\377\12\11\11\377\11\11\10\377\37!#\377\13\14\14\377\14\16"
	  "\17\377\34\37\"\377\16\17\20\377\15\16\16\377\22\23\23\377/26\377\36\40!"
	  "\377\24\25\26\377\23\25\26\377\10\7\7\377\12\13\13\377\7\7\6\377\7\7\7\377"
	  "\12\14\14\377\32\34\37\377\14\15\16\377\36\37\"\377\7\10\10\377-16\377\17"
	  "\20\22\377\15\16\17\377\12\12\14\377\12\13\14\37736:\377\21\23\24\377\25"
	  "\27\30\377@DI\377\14\14\15\377\11\11\12\377\25\30\31\377\15\15\16\377\6\7"
	  "\10\377\12\13\13\377\11\11\11\377MNT\377\7\10\7\377\14\14\14\377\17\21\22"
	  "\377;?B\377\12\13\14\377\10\11\11\377\25\30\32\377\36\"%\377\12\13\13\377"
	  "\30\32\34\377\26\31\34\3778=?\377(+/\377\20\21\21\377Y\\c\377\36##\377\12"
	  "\13\13\377\33\34\35\377kow\377\17\21\22\377\7\7\7\377=?C\377\25\26\31\377"
	  "\13\14\15\377\36\"$\377\17\17\20\37779<\377\22\25\27\377ORW\377\11\13\13"
	  "\377\26\30\32\377-03\377\40\"$\377\27\31\32\377\31\32\36\377\20\22\23\377"
	  "$&*\377\35!\"\377&*.\377\14\15\16\377\15\17\20\37748<\377\12\13\14\376\31"
	  "\35\37\377Y_e\377\30\31\32\377C\12\13\12\377\17\21\21\377\31\35\36\377\24"
	  "\30\30\377\14\16\16\377\17\21\23\377\7\7\7\377BFK\377\14\16\16\377\23\26"
	  "\27\377\20\22\23\3775;>\377\23\24\25\377\36#&\377\27\31\34\377<BF\377'+/"
	  "\377\25\31\33\377\"$'\377\25\26\30\37749=\377\34\36\40\377\37$&\377\11\12"
	  "\13\377\25\30\31\377$(,\377\20\21\21\377\13\15\15\377\"&)\377\20\22\22\377"
	  ",.1\377\17\20\20\377\26\31\33\377\14\17\20\377\23\30\32\377\24\26\25\377"
	  "\32\34\36\377\31\32\34\377\14\21\21\377\11\12\11\377\15\16\16\377\34\36\36"
	  "\377-15\377\17\21\23\377\11\13\12\377\6\6\6\377\26\31\33\377\22\24\24\377"
	  "\11\12\11\377\37!#\377\10\11\11\377\15\16\16\377\15\17\20\377#&)\377\35\36"
	  "!\377\27\27\30\377\13\15\15\377\10\11\11\377\7\7\7\377\10\11\11\377\40&("
	  "\377\27\34\36\377\10\11\12\377\17\17\20\377&*,\377\26\31\34\377\16\20\20"
	  "\377\202\11\12\12\377.\36\40\"\377\11\11\12\377\14\17\17\377+.2\377\20\20"
	  "\22\377\23\27\31\377').\377\11\11\11\377\12\13\14\377\12\12\12\377\31\34"
	  "\36\377\25\26\30\377\10\7\6\377\17\20\22\377\20\23\25\377\12\13\13\377\21"
	  "\22\23\377\24\26\31\377\10\11\11\377\11\12\13\377-15\37747<\377\11\11\11"
	  "\377\26\31\32\377!$&\377\35\37!\377\34\36\"\377025\377\25\35\33\377\37#%"
	  "\377\10\11\10\377\26\27\30\377\27\31\34\377\11\13\14\377\10\10\11\377\12"
	  "\13\14\377\14\20\21\377'),\377*-1\377\6\7\7\377\22\23\24\377\20\23\25\377"
	  "$'+\377KMS\377\11\12\12\377047\377\202\12\14\15\377r\30\34\36\377\10\11\11"
	  "\3778;@\377%)+\377\14\16\20\377\11\13\14\377lpu\377<?D\376\14\16\17\377-"
	  "03\377\22\26\30\377\13\14\14\377\13\15\15\377>AF\377\33\36\40\377\11\13\13"
	  "\377\12\14\13\377KQV\377\25\27\31\377\25\26\30\377\15\17\20\377\"%)\377\17"
	  "\22\23\377\30\33\35\377\25\27\31\377\25\31\33\377\30\33\35\377%*,\377\36"
	  "\40#\377\35!\"\377:>B\377\36\"#\377!#&\377\10\11\11\377+14\377.03\377\22"
	  "\23\24\377\12\14\15\377\35\"$\377\35\37\"\377\27\31\34\377\17\20\22\377+"
	  "/3\377137\377\30\31\34\377\22\23\23\377\40$%\377\17\20\21\377\21\25\26\377"
	  "69=\377\30\34\35\377\11\12\12\377\11\11\10\377RY\\\377\36\37!\377\10\11\11"
	  "\377\11\12\12\377\10\11\10\377\14\15\16\377\17\22\22\377\17\20\22\377\34"
	  "\40!\377\13\15\16\377\11\12\12\377\16\20\21\377\22\25\26\377\31\33\35\377"
	  "\"$(\377\10\11\11\377\15\15\15\377\"%(\377\23\26\27\377\14\17\17\377\10\10"
	  "\11\377\24\27\27\377\21\24\25\377')+\377\13\14\15\377\12\12\12\377\37#&\377"
	  "\24\25\26\377\30\32\34\377\30\31\32\377\16\17\17\377\20\21\23\377#%'\377"
	  "\26\27\30\377\12\12\12\377\16\17\20\377\32\34\36\377*.1\377\13\13\13\377"
	  "\15\16\17\377\10\11\11\377%(*\377\33\34\37\377\11\13\12\377\14\15\15\377"
	  "\31\33\34\37746:\377\10\11\11\377)-0\377\25\26\30\377\10\11\11\377\24\25"
	  "\26\377\22\24\26\377*-1\377\23\25\26\377mqy\377)+.\377\10\10\7\377\7\7\10"
	  "\377afk\377147\377\202\10\10\10\377D9<@\377\37\"$\377\14\14\15\377\21\22"
	  "\24\377\7\10\10\377\26\30\33\377;=B\377\"$'\377\25\27\30\377\30\32\34\377"
	  "5:?\377\27\32\35\377\15\16\20\377,26\377\31\33\36\377&),\377\13\15\17\377"
	  "\27\33\35\377\24\25\26\377\36!\"\376\23\26\27\377\16\20\21\377\37\"$\377"
	  "-35\377'&(\377\14\15\15\377\20\22\24\377\12\12\12\377\17\22\23\3778?B\377"
	  "98=\377\22\26\27\377X[a\377\22\24\25\377\25\31\32\377\14\16\17\377OU\\\377"
	  "\21\22\23\377\40$'\377\"#&\377128\377?EL\377QV]\377\35\36!\377\13\14\15\377"
	  "X\\c\377.13\377\25\26\27\377\10\11\11\377:@E\377\21\22\24\377\27\31\34\377"
	  "\27\31\33\377\34\37#\377\37$'\377\17\20\21\377\33\40#\377\22\26\27\377\12"
	  "\14\14\377\27\32\34\377\33\34\36\377\33\36\37\377\35!#\377\17\20\21\377\11"
	  "\12\13\377\13\14\16\377\12\13\15\377?DI\377\202\10\11\11\377\177\17\20\20"
	  "\377\15\20\20\377(+/\377\7\10\10\377\14\16\16\377\23\26\27\377\12\13\12\377"
	  "\23\26\27\377+04\377\7\7\7\377\24\27\30\377036\377\14\16\17\377\14\17\17"
	  "\377\13\13\13\377\16\17\20\377\25\30\33\377\12\13\14\377\14\15\15\377\13"
	  "\14\15\377$'*\377\11\7\10\377\36!$\377),/\377\14\14\14\377\6\6\7\377$'*\377"
	  "\10\10\10\377\7\10\10\377(-1\377\33\37\40\377\11\11\12\377\14\16\15\377\24"
	  "\26\30\377\12\13\13\377\7\10\7\377\17\21\22\377\36!%\377\23\25\26\377\7\10"
	  "\10\377\15\17\21\377\33\37\40\377\22\24\24\377\10\11\10\377\20\22\24\377"
	  "\17\20\22\377\13\14\14\377\21\22\23\377\24\25\25\377\255\261\273\3779?A\377"
	  "\23\24\24\377\20\21\22\3778<A\377\17\20\21\377\25\25\27\377\20\23\24\377"
	  "\32\33\36\377\10\10\10\377\10\11\11\377\12\13\13\377/25\377*-0\377\10\11"
	  "\11\377\15\16\17\377049\377)-1\377\20\21\22\377\16\20\21\377),1\377<@F\377"
	  "\21\24\26\37749<\377&*.\377\16\20\21\377\10\11\12\37737:\377\16\20\20\376"
	  "\12\13\13\377%(+\377\17\22\23\377bel\377RW]\377\10\11\10\377\11\12\11\377"
	  "@EL\377\40$%\377\27\31\33\3777;?\377\35\40#\377\20\23\24\377\32\34\36\377"
	  "%),\377/37\377\15\17\17\377\34\40#\377\33\36\37\377,.2\377),0\377afn\377"
	  "*,/\377\33\37\40\377\37\37!\377),0\377\27\32\34\377\20\21\22\377GKP\377\22"
	  "\26\27\377$(*\377\12\13\13\377\31\34\36\377CIO\377\23\25\26\377\21\22\23"
	  "\377\31\34\36\377\"%)\377\32\34\36\377\11\13\13\377bfm\377\21\23\23\377\17"
	  "\22\22\377eiq\377\26\30\32\377\7\10\10\377\12\13\14\377!$'\377\33\36\40\377"
	  "\177\10\7\10\377\10\10\10\377\21\22\24\377\13\14\14\377\15\16\16\377\12\14"
	  "\15\377\13\16\16\377\33\37!\377')+\377\14\16\16\377+.0\3779<A\377569\377"
	  "\24\30\31\377\31\31\31\377\30\32\34\377\12\13\14\377\17\21\22\377\12\13\13"
	  "\377\10\12\13\377\24\30\32\377\11\11\11\377059\377\21\23\23\377\16\20\21"
	  "\377\22\25\27\377\"$'\377\10\10\10\377\12\14\14\377\32\34\36\377\30\32\34"
	  "\377-/3\377\20\20\21\377\10\11\11\377\11\13\14\377\37!#\377\10\10\11\377"
	  "\10\11\11\377\23\25\26\377\26\31\32\377%*-\377\10\11\11\377\22\24\27\377"
	  "\33\36\40\377\16\20\22\377\12\13\13\37769;\377&&*\377\11\11\11\377\15\16"
	  "\17\377ABF\377\12\24\17\377\12\14\14\377/37\377)+/\377\23\25\26\377\7\10"
	  "\10\377-15\377\32\34\37\377\10\10\11\377\11\12\13\377\35\40#\377\32\34\37"
	  "\377\10\12\12\377\12\12\12\377\15\16\20\377\30\32\34\377(*-\37737;\377\14"
	  "\15\16\377ILR\377)+-\377\37\"&\377\34\36!\37726<\377\7\7\10\377\26\31\33"
	  "\377\40$&\377\37$&\376\"%(\377/68\37789=\377&+-\377,-/\377\12\13\13\377\20"
	  "\21\21\377\35\"%\377@BG\377\"&)\37737<\377\31\34\35\377\36\40\"\377\13\16"
	  "\15\377DHM\377;=B\377\31\32\35\377\21\23\23\377GLQ\37725:\377$(,\377\22\25"
	  "\27\377#(*\377MRY\377\35\37!\377\10\10\7\377).1\377^ag\377\15\21\20\377+"
	  "/2\377\17\20\20\377\20\22\23\377\13\14\15\377\25\31\32\377\24\25\26\377\24"
	  "\27\30\377\22\24\25\377\40$&\377\22\24\25\37736;\377\13\15\14\377\37!#\377"
	  "%(+\377'*-\377\24\25\25\377\32\34\36\377\10\10\11\377\12\12\12\377\4\12\14"
	  "\14\377\26\27\31\377\12\13\12\377\7\7\7\377\202\11\12\12\377\177\13\14\15"
	  "\377\10\12\12\377058\377\15\15\15\377\10\11\10\377DJP\377^`e\377\16\20\21"
	  "\377\21\23\23\377(*-\377\14\15\16\377\21\22\24\377\10\12\13\377\11\13\13"
	  "\377\36!$\377\12\13\14\377\36\40$\377\22\23\24\377\30\34\35\377\14\15\15"
	  "\377\30\33\36\377\10\10\10\377\17\20\21\377(+/\377\37#&\377\12\15\15\377"
	  "\12\12\12\377\17\22\22\377\20\22\23\377\13\14\15\377\16\20\20\377\15\21\22"
	  "\377\11\13\13\377\11\11\11\377158\377\7\10\10\377\7\12\12\377\13\15\16\377"
	  "'*,\377\34\36\37\377\7\11\11\377\30\31\33\377\16\17\17\377#%'\377\23\24\26"
	  "\377\10\10\10\377<@C\377JNU\377\22\24\24\377\40#&\377\27\32\34\377\10\10"
	  "\10\377\12\14\14\377\27\31\33\377\"$'\377\24\26\30\377\20\23\25\377\25\27"
	  "\32\377\12\12\13\377038\377\30\33\34\377\27\30\32\377\14\15\16\377\32\36"
	  "\37\377LOV\377\13\16\16\377GJN\377>BF\377ILQ\377\14\15\16\377\12\14\15\377"
	  "\14\15\17\377%)+\377\22\26\27\376\23\26\26\377\33\37\40\377BGL\377\30\27"
	  "\30\377\13\13\13\377%)-\377LPV\377\10\12\11\377'*,\377\200\207\217\377\35"
	  "\37\40\377\20\22\24\377036\377(+-\377\32\37\40\377\26\31\32\377369\377\26"
	  "\31\32\377%*-\377<AG\377\32\34\37\377\17\22\21\377MRY\377'*,\377\16\20\20"
	  "\37737:\377\33\35\36\37716;\377\40\"$\377\13\16\17\377(-0\377!$&\377\16\20"
	  "\20\377\11\12\11\377Y^d\377!\"$\377\11\13\14\377\14\16\17\377:@D\377\15\17"
	  "\17\3778;@\37747:\377)*.\377\27\30\32\377\25\30\31\377\35\37\"\377\11\11"
	  "\12\377\10\10\10\377\14\15\15\37726<\377\12\14\15\377\6\6\6\377\6\6\7\377"
	  "5\10\11\12\377\26\33\33\377\34\40#\377\16\17\20\377\34\36\37\3779=A\377\33"
	  "\37!\377\37!$\377\14\16\17\377\17\21\22\377#&(\377\12\12\12\377\11\12\12"
	  "\377\17\21\23\377\14\17\17\377\12\13\12\377\35\40#\377\32\34\36\377\21\24"
	  "\25\377\17\21\22\377\25\27\31\377\7\7\7\377\22\23\24\377\35\37\"\377#&)\377"
	  "\14\15\16\377\23\25\26\377\15\15\15\377\20\21\23\377$'(\377$&)\377\16\21"
	  "\22\377\7\10\10\377SV]\377\24\26\27\377\6\6\6\377\24\26\27\377\12\13\14\377"
	  "\7\11\12\377\12\13\13\377*-/\377(*,\377\13\13\14\377&(+\377&),\377\32\35"
	  "\37\377$&(\377\10\21\14\377\34\37!\377458\377\15\15\16\377\17\21\21\377\14"
	  "\17\17\377\202\12\13\14\377\177\36\40$\3775:>\377\13\13\14\377\10\11\12\377"
	  "\20\23\24\377\37\"%\377\31\34\37\377\20\22\24\377\17\20\21\3776:>\377\26"
	  "\30\33\377LOT\377\24\27\30\377\20\22\24\377(,0\377\31\35\37\377\10\12\12"
	  "\377\12\15\16\377\40$&\377\26\31\33\376\34\37\"\377\34!#\377,.1\377\16\17"
	  "\17\377\23\25\26\377\23\26\27\377+-1\377,03\377\31\32\34\377\31\36\37\377"
	  "69=\377\31\36\37\377=@C\377258\377\21\23\24\377\30\33\34\377%)+\377>BG\377"
	  "\31\35\37\377\34\37!\377\40#&\3776:>\377!\"%\377\16\17\20\377,/3\377BEJ\377"
	  "-14\377\20\21\22\377\17\23\24\377\26\31\33\377\33\34\40\377\33\35\37\377"
	  "\11\13\13\377GJN\377\15\16\16\377\20\22\21\377\30\34\36\377259\377\13\13"
	  "\12\3774:=\377:<@\377BEI\377\13\13\14\377258\377\20\21\22\377\14\16\17\377"
	  "\13\14\16\377\7\10\10\377\16\21\21\377\14\15\14\377\23\25\26\377\10\10\10"
	  "\377\6\6\6\377\6\7\7\377-/3\377\13\14\14\377\14\16\16\377&),\377247\377\33"
	  "\36\40\377\10\11\11\377\13\15\16\377+03\377\31\33\35\377\12\13\13\377\7\7"
	  "\10\377\23\25\27\377\22\23\24\377\22\24\25\377\12\13\15\377\12\13\13\377"
	  "\24\27\31\377+/1\377\10\11\10\377\36!\"\377\13\15\15\377%(+\377*,.\377\11"
	  "\11\11\377$%(\377/25\377\17\20\21\377\23\24\25\377<?D\377\17\21\23\377\12"
	  "\15\15\377;=B\377*-/\377\24\27\30\377\11\12\12\377\22\24\27\377\7\10\10\377"
	  "#%'\377\32\36\40\377\15\16\16\377.13\377\25\26\30\377258\377\40\"$\377_c"
	  "i\377\40(&\377\11\11\10\377.03\377\14\20\22\377\27\32\35\377\12\13\14\377"
	  "!#&\377\177\20\22\24\377\14\15\15\377AEJ\377\17\20\22\377\12\14\15\377\35"
	  "\40!\377\37!$\377&'*\3777:>\377\33\35\40\377\31\33\34\377\33\35\37\377.1"
	  "5\377\40#'\377\21\23\24\377\14\16\17\377\16\20\21\377OSX\377\13\14\15\377"
	  "\34\37\"\37738<\37625:\377\20\22\22\377\21\23\23\377\31\32\33\377NSY\377"
	  "\15\15\16\377\30\35\36\377\203\211\223\377236\377\20\22\23\377#')\377=CH"
	  "\3778:=\377\13\14\14\377,15\377\33\36\40\377&*-\37718<\377SUZ\377\14\15\15"
	  "\37759>\377\36!$\377\15\20\21\377\26\31\32\377\"')\377).2\377/36\377\20\23"
	  "\24\377\13\17\17\377GLR\377\14\16\17\377\11\11\11\377>DH\377(-0\377\27\30"
	  "\32\377\11\11\11\377ms{\377\13\14\13\377\37\40#\377\23\25\26\377:?C\377\12"
	  "\14\12\377,03\377\30\31\34\377\15\20\17\377\13\15\16\377\15\16\17\3777<@"
	  "\377\10\10\10\377\13\14\15\377\12\14\14\377\12\13\13\377\13\15\16\377\7\7"
	  "\7\377\7\7\6\377\15\15\15\377<@D\377\33\35\37\377\12\13\12\377\36\40\"\377"
	  ":>B\377\20\22\24\377$*-\377\17\20\20\377\10\11\11\377\36!$\377\24\26\27\377"
	  "\26\26\30\377\24\26\30\377\23\24\25\377\10\12\13\377\34\37\"\377\14\15\16"
	  "\377\31\33\35\377\15\17\17\377!%'\377\10\10\7\377\11\12\12\377FIN\377\36"
	  "\40\"\377\15\16\16\377-13\377\22\24\27\377\30\32\34\377\31\34\35\377-/4\377"
	  "\11\11\12\377\20\23\23\377-03\377\20\20\21\377%')\377\21\21\22\377\13\13"
	  "\13\377\30\31\32\377\13\14\16\377\23\26\27\377%(+\377#&(\377y~\206\377\23"
	  "\23\23\377@FI\377\30\31\32\377\10\11\11\3776;>\377(,/\377\6\10\10\377\177"
	  "36;\377\27\30\33\377,14\377\21\23\25\377\11\11\11\377DGM\377\16\17\22\377"
	  "\17\21\22\377/25\377358\377.14\3778<@\377#&)\377\15\16\17\3777;?\377\14\15"
	  "\16\377\37\40#\377$'*\377\23\25\27\377\10\12\13\377\35\40\"\377,03\376NS"
	  "Y\377\20\22\23\377\22\23\24\377\30\34\36\377\20\21\23\377\32\37\40\377\20"
	  "\21\22\377\30\34\34\377\34\40\"\377\21\21\22\37759=\377$&)\377\17\22\22\377"
	  "&)-\377\15\20\21\377BDK\377\21\25\26\377\30\31\33\377!%&\377U[`\377\24\25"
	  "\26\377\13\16\17\377(+.\377\22\24\26\377\16\22\22\37759=\377\36\"%\377\32"
	  "\36!\377!\"%\377\20\22\23\377\37\"#\377'*-\377\21\23\25\377\27\31\32\377"
	  "(-0\377\32\33\34\377\11\10\10\377x~\205\377*-0\377\22\24\26\377\12\13\13"
	  "\377NQV\377\31\34\37\377\34\36!\377\11\11\12\377\31\34\36\377\23\25\30\377"
	  "\31\33\35\377&')\377\15\17\17\377\10\10\10\377\21\23\23\377*-2\377\12\14"
	  "\15\377\6\6\6\377\11\13\12\37746:\377\15\17\17\377\12\12\12\377*/2\377SW"
	  "]\377\25\27\30\377\12\14\14\377\16\21\21\377\27\32\34\377\31\34\36\3779:"
	  "?\377\20\22\23\377\11\11\10\377\24\27\30\377/16\377\6\6\6\3777<?\377\32\35"
	  "\37\377\15\17\17\377\11\11\12\377\11\14\14\377\21\23\24\377359\377\30\31"
	  "\32\377\35\37\40\377,02\377*-1\377\35\40!\377'*-\377#%)\377\17\21\22\377"
	  "\14\16\16\377Z^f\377\35\36\40\377\10\11\11\377BCH\377\11\11\10\377\12\14"
	  "\15\377\14\16\16\37759=\377\20\21\22\3775:?\377\31\33\35\377.35\377\16\26"
	  "\22\377\12\13\13\3777;>\377\21\23\24\377\30\32\34\377\177\26\30\33\377\27"
	  "\31\33\377MOU\377\32\33\36\377\15\17\17\377\25\30\32\377IMS\377\25\27\30"
	  "\3778;?\377.04\377+.2\377),.\377BFK\377(*,\377%*-\377\11\13\13\377\36\"%"
	  "\377047\377\"%'\377\14\15\16\377\10\12\12\37747;\377\30\31\32\376\24\27\30"
	  "\377\35\37!\377\27\32\34\377\27\31\33\377\33\37!\3775:>\377\36!%\377\11\13"
	  "\12\377'-/\377mrz\377\17\17\17\377\14\16\17\377$')\377\16\20\21\377KOW\377"
	  "\21\25\26\377DFK\377\12\14\13\377\25\31\34\377<AE\377%')\377\25\27\30\377"
	  "\13\14\14\377-26\377015\377\24\26\30\377#'+\377\"&)\377%),\377\12\14\14\377"
	  "BEK\377%'*\377\13\13\14\377\33\40\"\377.15\377\12\13\13\377\33\36\37\377"
	  "\31\34\34\377\25\30\31\377\14\17\17\377MPV\377\11\12\12\377*/2\377\12\13"
	  "\13\377\12\15\15\377\32\35\37\377\13\15\17\377$(+\377\33\37!\377\20\21\21"
	  "\377\10\11\11\377\12\14\14\377\27\31\32\377\20\23\24\377'+.\377\7\10\7\377"
	  "\11\12\12\377\13\15\15\377\32\35\37\377\30\34\37\377\34\37\"\377\31\34\36"
	  "\377\13\14\14\377\31\34\37\377\20\22\23\377(+/\377\"%(\377\11\12\12\377\35"
	  "\37\"\377\21\22\23\377\11\12\13\377\17\20\22\377\12\13\14\377-04\377\10\12"
	  "\12\377\7\10\10\377\36\"$\377'),\377\7\7\7\377GKQ\377'*-\377.13\377\35\37"
	  "!\377\34\40\"\377\34\35\40\377\23\26\30\377&(+\377\32\35\37\377\23\25\26"
	  "\377+/1\3779<A\377\10\10\10\377<@E\377\21\23\24\377\25\27\31\377\20\21\22"
	  "\377>AG\377\13\14\15\377\36!$\377'*-\377)22\377\14\15\15\377\32\34\36\377"
	  "\24\27\30\377\177'*-\377\14\17\17\377\210\216\231\377\13\13\14\377\13\14"
	  "\14\3778<@\377/48\377\24\26\30\377PRW\377>CI\377%'+\377\26\31\33\37736=\377"
	  "\23\26\30\377\33\36\40\377\20\21\22\377-15\377\12\14\15\377%),\377\17\22"
	  "\24\377\27\32\33\377\12\13\13\377#&)\377\33\36\37\376\35\40\"\377\24\30\30"
	  "\37738<\377\24\27\30\377*-1\377#%)\377\16\20\20\377$')\377\33\36\40\377\37"
	  "\"%\377),0\377\15\15\17\377\36#$\377:<@\377\"'*\377#'+\377\14\16\16\377N"
	  "QY\377\20\22\24\377\17\21\22\377:=B\377\14\16\16\377\32\35\37\377\24\26\30"
	  "\377\36\"%\377\22\25\27\377\23\27\30\377:?B\377\32\33\35\377SX^\377\27\30"
	  "\31\377\11\12\12\377+-1\377>CG\377\22\23\23\377\11\15\16\377157\377\10\11"
	  "\10\377\26\30\31\3777;>\377\23\25\27\377(,.\377\17\20\20\3779=B\377\21\24"
	  "\25\377\34\36\40\377\14\16\17\377&(-\377\15\15\16\377\12\14\14\377\17\20"
	  "\21\377\11\12\12\377\12\14\14\377048\377?CH\377\12\12\11\377\7\7\7\377\16"
	  "\17\20\377#&(\377\23\30\31\377\21\23\25\377\10\12\13\377/25\377\16\17\20"
	  "\377)*.\377\32\35\40\377\15\16\17\377\31\33\35\377\12\13\13\377\14\14\15"
	  "\377\12\13\13\377\35\37#\377\15\17\20\377\17\20\22\377\15\17\20\377\21\22"
	  "\24\377#'+\377\10\11\11\377\33\35\37\377\22\24\25\377'*-\37756;\3775:>\377"
	  "\11\13\13\377\17\21\22\377(,/\3779;@\377\21\23\23\377\40!#\377\30\32\34\377"
	  "\30\33\34\377127\377\14\15\16\377.15\377\15\16\16\377=AD\377\30\31\33\377"
	  "\12\13\14\377\40#&\377569\377V[`\377\16\17\20\377\12\12\13\377dTY^\377*+"
	  ".\377\30\32\34\377&),\377\12\13\15\377\31\33\35\377FJO\377\32\34\36\377M"
	  "PV\377.14\377Z`f\377\40\"$\377ADH\377\34\36\40\377:?C\377\13\13\13\377\23"
	  "\25\27\377\32\36!\377$'*\377\12\13\14\377--1\377SY_\377\6\10\10\377\27\31"
	  "\32\377\15\17\16\376\21\22\23\377$')\377#(*\377CFK\377\22\26\31\377\40#&"
	  "\377\30\31\32\377DMQ\377[]a\377\15\17\17\377\25\31\32\377\23\27\30\377\26"
	  "\26\30\377\25\31\33\377!%(\377\13\16\17\3777=A\377\34\40#\377&),\377\15\17"
	  "\17\377\17\21\21\377)-0\37759<\377\24\25\26\377\12\13\14\377$(+\377EHM\377"
	  "\21\22\24\377<CI\377WZ`\377#&'\377\10\10\10\377$',\377\20\21\21\377\\`f\377"
	  "\35\40!\377\11\12\13\377\36!#\377\24\24\26\377&*,\37749=\377\21\22\22\377"
	  "036\377\"&)\377\33\40!\377\26\32\35\377&&'\377\11\12\12\377\12\13\13\377"
	  "\33\36\40\377\17\22\22\377\15\15\15\377\11\13\14\377\40\"%\377\17\21\23\377"
	  "\26\30\32\377\12\13\13\377\11\11\10\377\14\15\15\377\40$&\377\31\33\34\377"
	  "\17\20\20\377\26\32\32\377dio\377\15\16\16\377\7\10\10\377\24\27\31\377\25"
	  "\26\30\377\16\17\21\377\14\15\16\377\24\27\31\377\10\11\11\377\7\11\11\377"
	  "\15\17\20\377\13\14\14\377\202\20\21\22\377\177\12\13\14\377\32\35\37\377"
	  "268\377\26\27\31\377\224\232\243\377\35\36!\377\15\20\20\377\12\13\14\377"
	  "kow\377!$(\377\22\23\24\377\15\17\20\377\26\26\27\377036\377/26\377\23\25"
	  "\27\377\13\13\14\377>BF\377)*.\377\24\26\27\377\31\32\34\377\23\25\26\377"
	  "37;\377\32#\"\377\10\11\10\377(,/\377\23\24\25\377_em\377\12\14\15\377\10"
	  "\12\12\377\16\20\21\377/15\377=AF\377\27\30\32\377\16\15\17\377qv\177\377"
	  "\26\25\26\377GLQ\377\40#&\377\31\34\37\377\33\35\40\377\16\20\22\377\17\21"
	  "\22\3779>C\377\30\31\33\377&*,\377\22\24\26\377\26\31\34\377\16\20\21\377"
	  "\11\12\13\377\21\22\23\376\34\35\40\377\34!$\377:>B\377\16\20\20\377adi\377"
	  "\34!#\377>@D\377\33\37\40\377.56\377SSW\377\23\26\27\377158\377/15\377\14"
	  "\16\16\377\11\13\13\377\40!%\377\30\32\35\377\25\27\31\377\35\37\"\377\23"
	  "\23\24\377\22\23\25\377%),\377>CG\377\16\17\20\377\13\13\13\3776;@\377#&"
	  "*\377DHK\377\32\34\36\377AFL\377)-.\377.15\377\12\12\12\377x~\206\377\36"
	  "\37!\377\24\27\31\377'+-\377\30\32\33\377\22\23\23\377\27\30\32\377\27\31"
	  "\33\377\32\35\35\377\20\23\24\377#'*\377\24\26\31\377\37#&\377\13\14\16\377"
	  "\7\11\11\377#(+\377\20\22\22\377\17\21\21\377!%'\377#%'\377\13\14\15\377"
	  "\11\11\11\377\17\20\22\377,03\377\10\10\7\377\11\11\11\377\16\20\21\377\34"
	  "\"#\37727:\377\16\17\20\37738;\377##&\377\13\14\15\377\33\34\35\377\35\37"
	  "\"\377\32\35\37\377qx\177\377\12\13\13\377\11\12\13\377\12\13\12\377BHL\377"
	  "\21\24\26\377\7\7\6\377\177*.1\377\27\32\34\377\15\20\20\377\35\40$\377\32"
	  "\36!\377\24\25\26\377047\377\17\21\22\377\20\22\24\377\33\34\35\377\37!#"
	  "\377!#$\377\17\22\23\377\20\21\22\377DGL\377\17\20\20\377\25\30\33\377\26"
	  "\26\30\377\40\"$\377(+-\377&*.\377\17\20\21\377\20\22\24\377\22\24\25\377"
	  "\33!\40\377\10\11\12\377<@B\377=AG\377\14\16\16\377\16\21\22\377\13\14\15"
	  "\377\17\21\22\37746;\3775:=\377\25\25\27\377,/2\377\34\35\40\377}\203\213"
	  "\377&()\377!#&\377\31\32\34\377%),\377-12\37715;\377\13\14\15\377\31\34\37"
	  "\377,04\377?DH\377\31\33\36\377\14\15\16\377GKP\37759>\376\17\20\22\377("
	  "+.\377\15\20\20\37736:\377%),\377\234\240\254\377+.0\377\17\22\22\377259"
	  "\377147\377\40$'\377\12\13\13\377\40#&\377\23\25\26\377\10\11\11\377\20\23"
	  "\24\377\35\40\"\377\23\25\27\377\33\37\"\377\36\"$\377ILQ\377\25\27\31\377"
	  "\17\22\22\377CIM\377+.1\377\21\23\24\377\21\24\26\377+14\377\33\37\40\377"
	  "49>\377EGL\377\25\26\26\377(,/\377\15\16\16\377!#&\377$'*\377%(+\377.25\377"
	  "\16\17\17\377\10\11\11\377\33\34\37\377\24\30\31\377\26\31\33\377\22\26\30"
	  "\377\23\24\25\377\22\24\26\377\16\20\21\377)-1\377\25\26\30\377\40$&\377"
	  "!#%\377\24\25\26\37725:\377\7\7\7\377\40\"$\377\10\11\11\377*.1\377*,/\377"
	  "\7\7\7\377\10\12\12\377*.2\377\31\36\40\377\"&)\377\30\32\34\377\25\30\32"
	  "\377\11\13\13\37727:\377\23\24\25\377\37#&\377\34\36\40\377\15\20\20\377"
	  "\6\7\7\377:<A\377\17\20\20\377\10\11\11\377\177$'+\377\16\21\22\377\10\12"
	  "\12\377\20\23\25\377\34\37#\37736;\377'*,\377\10\10\11\377pu}\377\17\21\23"
	  "\377\11\12\11\377\37\40\"\377$%(\377,/2\377&),\377\11\12\12\377\23\24\23"
	  "\377\17\20\20\37758=\377\13\14\15\377\13\15\15\377,04\377\30\33\35\377\15"
	  "\16\17\377\23\25\26\377\16\27\24\377\13\14\14\37758;\377>CG\377\31\34\36"
	  "\377\12\13\14\377\25\27\32\377.26\377\33\34\37\377\15\17\17\377\20\21\22"
	  "\377.25\377&*-\377149\377\"&)\377\12\13\14\377'+/\377DIN\377\30\32\34\377"
	  "\32\34\36\37735:\377\13\15\15\377.16\377\33\35\40\377QTY\377148\377\23\26"
	  "\27\377PV\\\3768:?\377\14\17\17\377\36!$\377\20\24\25\377\27\34\35\377KN"
	  "S\377\40$'\377;>B\377\21\24\24\377'-0\377\25\30\32\377\24\25\30\377\32\37"
	  "\37\377EJN\377\34\37!\377\12\13\13\377\23\27\31\377\25\32\33\377\35\37#\377"
	  "/27\377#&*\377\27\31\33\377<>B\377<AF\377,/2\377\22\26\27\377\21\25\26\377"
	  "\21\27\30\377\\dl\377<<@\377\13\15\15\377jmu\377\14\16\17\377\35\40\"\377"
	  "\40!$\377\33\34\36\377:?D\377%(+\377\12\13\14\377\14\16\16\377\11\12\13\377"
	  "\13\15\15\377\24\31\34\377\31\35\37\377\24\26\27\377\14\15\17\377$)-\377"
	  "$'+\377\27\27\32\377\40#&\377DHM\377&(+\377\12\11\12\377FJO\377\14\15\16"
	  "\377\"%'\377\35\40!\377)+-\377\16\17\20\377\10\13\14\377\10\11\12\377\37"
	  "\"%\377\7\7\10\377\40\"$\377\31\34\36\377\15\17\20\377\22\25\26\377).0\377"
	  "\27\31\33\377\21\23\24\377\36!#\377269\377\12\13\14\377\15\16\17\377\177"
	  "\26\30\31\377\30\33\36\377\40$&\377\34\36\40\377\12\14\16\377\15\17\17\377"
	  "\33\37\"\377LQW\377*,.\377\"%'\377\20\21\22\377\17\21\22\377\16\17\20\377"
	  "\17\20\22\377psy\377\24\25\27\377\30\32\33\377\22\23\24\377IMR\377\11\11"
	  "\11\377LOV\377\16\20\21\377\16\17\20\377\21\22\24\377\21\24\26\377\15\16"
	  "\17\377\20\30\27\377\13\16\17\377:>A\37749<\377\25\26\31\377*.2\377>@F\377"
	  "\24\24\26\37759=\377GLQ\377\15\16\17\377!$(\377mrz\377\35\37\40\377\22\24"
	  "\25\377\22\26\30\377\26\27\30\37736:\377\17\22\24\377\40#&\377!$'\377LPU"
	  "\377\27\31\33\377`ci\377lqy\377\32\34\36\377?CH\37747<\376*04\377,.2\377"
	  "\14\16\15\377\36#'\377&)+\377\15\17\17\377TY_\37718;\377jnu\377\32\34\36"
	  "\377\20\24\25\37748<\377$'*\377HLP\377\25\30\32\377\32\34\40\377+01\3773"
	  "8;\377\"&)\377\11\12\12\377\24\27\31\377*/2\377`ek\377\23\25\27\377\36#&"
	  "\377wy\201\377\14\14\14\377BGL\377\37\40\"\377'+.\377\15\20\21\377\26\30"
	  "\33\3774:>\377SX^\377\30\33\35\377\14\15\15\377\"#(\377\30\31\33\377\20\22"
	  "\23\377\13\15\14\377\22\24\26\377\11\11\11\377\11\13\13\37726:\377\21\24"
	  "\26\377!#(\377\14\14\15\377\26\32\35\377QW]\377\30\32\35\377\37!#\377\22"
	  "\24\25\377-15\377\23\27\31\377!\"$\377\"$%\377,/2\377\11\13\12\377Y_g\377"
	  "\13\15\16\377\31\33\36\377\16\17\17\377\37#'\377ADI\377\13\13\13\377\12\14"
	  "\15\3776;@\377!$'\377\16\22\23\377\34\37!\377\23\24\25\377;=A\377\11\12\12"
	  "\377Y\16\17\20\377-15\377\23\25\27\3777:=\377cem\377\15\17\20\377\10\11\11"
	  "\377\30\32\34\377*/3\377*.2\377\12\12\13\377\13\13\13\377\15\17\20\377&)"
	  ",\377\17\20\20\377\30\30\32\377\21\23\24\377\32\35\37\377\\^e\377\14\15\15"
	  "\377\34\36!\377\21\21\23\377\31\33\35\377\27\32\34\377\20\21\22\377#&)\377"
	  "\37\"%\377\12\22\16\377\17\21\22\377\261\266\277\377/24\377\27\31\33\377"
	  "FHM\377\17\21\22\377138\377JLQ\377(+-\377\26\30\31\377(+/\377:=A\377\33\36"
	  "\40\377\22\24\25\377\33\34\34\377RW]\377\35\37#\377\31\32\34\377=?D\3776"
	  ":?\377\26\33\35\377\33\37\"\377\40\"$\377?CH\377?DJ\377'*-\377*04\3769>C"
	  "\377\22\24\24\377\23\27\30\377\"%'\377\16\20\22\377\34\36!\377\20\22\22\377"
	  "\210\220\230\377>@D\377\13\14\15\377\24\30\32\377,/2\377=BG\377\12\15\14"
	  "\377\31\35\37\377CHM\377\40!$\377#')\377\33\36\40\377\13\15\16\377\37%&\377"
	  "*-1\377\22\27\27\377\35\40\"\377\21\24\24\377\30\33\35\377$&)\377\16\21\22"
	  "\377\31\32\35\377%(*\377048\377\26\31\33\377LRW\377HKQ\377\202\22\23\24\377"
	  "[\12\12\11\377\12\11\10\377\16\17\20\37737;\377\25\30\31\377\12\12\12\377"
	  "\10\11\11\377\30\32\34\377\15\17\17\377#&*\377\10\11\12\377\37\"$\377JMR"
	  "\377:=A\377\12\12\12\377\32\35\36\377\200\207\216\377\"#&\377\21\22\23\377"
	  "\11\12\12\377\23\25\26\377\32\35\37\377*-0\37737;\377\24\26\30\377\"'*\377"
	  "\20\22\23\377\36!\"\377!$'\377\13\17\20\377\16\20\22\377\11\12\13\377+03"
	  "\377259\377\21\21\22\377\13\14\15\377\27\32\33\377\32\34\37\377\15\16\16"
	  "\377\35!#\377\13\15\16\377)+/\377\26\30\33\377\23\26\27\377<AE\377)-0\377"
	  "\13\13\13\377\17\20\21\377\10\11\11\377\17\22\23\377+.1\377\12\13\14\377"
	  "\10\11\11\377).0\377CGK\377\15\15\15\377;?C\377\17\17\17\377\15\16\16\377"
	  "&*,\377\21\23\25\377\23\24\26\377\25\27\31\377*.1\377$,+\377\22\24\26\377"
	  "&)+\377dip\377!$&\377\13\14\14\377+.1\377\"$(\377258\377#%'\377\24\26\30"
	  "\37737;\377\11\11\11\377\26\30\32\377&),\377\20\21\22\37748;\377\17\23\24"
	  "\377\15\15\15\377[af\377!$&\377\37!\"\377*.1\377\26\31\32\377\35\36\40\377"
	  "\36!#\377\16\17\17\377",
};

static const struct {
  unsigned int 	 width;
  unsigned int 	 height;
  unsigned int 	 bytes_per_pixel; /* 3:RGB, 4:RGBA */
  unsigned char	 rle_pixel_data[64070 + 1];
}  ofIconDebug = {
  128, 128, 4,
  "\31\20\21\20\376\30\34\34\3769=@\376KOS\376\15\17\17\376\30\33\35\376\14"
  "\15\15\376\13\15\15\376\16\17\17\376\16\21\21\37618<\376.03\376\37\"#\376"
  "\22\24\24\37636:\376\32\33\34\376\21\22\21\376*-0\376\34\35\36\376\15\15"
  "\15\376`dj\376135\376\24\25\25\376#%'\376\31\32\33\376\202\31\33\35\3765"
  "\24\27\27\376\23\25\25\376\37\"$\376#%'\376\10\12\11\376\21\23\24\376\35"
  "\40\"\376\12\13\13\376\21\23\24\376\20\22\23\376\25\27\30\376\27\31\33\376"
  "#&(\376\21\22\23\376\33\35\36\376\24\25\27\376\17\21\22\376\20\22\22\376"
  "\23\26\26\376)-0\376.02\376\36\"#\376,03\376\17\21\21\376\14\16\16\376\13"
  "\15\15\376\34\40!\376\17\21\22\376\20\22\23\376\22\24\26\376\23\25\27\376"
  "\17\21\22\376\37#$\376,.0\376\23\25\26\376,02\37636:\376/35\376\24\24\25"
  "\376\26\30\32\376\25\27\30\376!#%\376\24\25\25\376\30\33\34\376\40#%\376"
  "\21\23\23\376\27\32\33\376\36\40\"\376\31\34\36\376\34\37!\376\15\16\17\376"
  "\13\14\15\376\14\15\16\376\202\23\25\26\376\177+.1\376>@D\376'*-\376\"&("
  "\376\13\13\14\376\31\34\37\376,/3\376\32\34\36\376\33\36\40\376\"&(\376!"
  "$&\376\13\14\14\376\22\24\26\376?CH\376ru}\376\24\25\26\376\36!$\376\34\37"
  "!\376\12\15\13\376\22\31\30\376\16\17\20\376\17\20\21\376\17\21\22\376\37"
  "!$\376\21\22\23\376;>B\376249\376\31\33\35\376-/3\376\30\31\34\376\10\11"
  "\11\376\40$&\376'*-\376EFL\376\12\12\13\376\20\21\22\3768;?\376\35\40#\376"
  ":?C\376'*-\376\15\16\17\376\22\23\24\376\30\33\35\376\32\35\37\376\40$&\376"
  "%(+\376,04\376\35\35\37\377#'(\377\32\34\35\377\33\36\40\377&(*\377\24\30"
  "\30\377\16\17\17\377\13\14\14\377125\377%(+\377\32\34\35\377bgl\377\12\14"
  "\13\377\37%'\377\16\16\15\377\16\17\17\377\34\40!\377\21\21\22\377\24\27"
  "\30\377\"&'\377%&'\3776<?\377/12\377\15\16\15\377\36!\"\377&),\377\16\17"
  "\17\377\17\21\21\377\35\37\"\377\16\21\22\377\27\31\33\377\21\22\22\377\23"
  "\26\30\377\22\24\26\377\15\16\17\377\33\37!\377BEH\377\10\12\12\377\12\13"
  "\13\377\26\30\32\37727:\377\23\25\25\377\13\14\14\377\15\16\16\377\"%(\377"
  "-24\377\230\233\240\377\13\14\13\377\35!#\377\12\13\14\377\16\17\17\377\15"
  "\17\17\377&+.\377\27\31\32\377\17\20\20\377\16\20\21\377\13\15\15\377(+."
  "\377-14\377\15\14\14\377\23\25\26\3778=A\377$(*\377EHL\377\36\36\37\377\21"
  "\24\25\377\25\31\31\377\15\17\17\377\31\34\35\377\34\37!\377*-1\377\20\21"
  "\21\377\16\20\20\377\32\36\37\377347\377=CH\377\14\14\15\377\13\14\13\377"
  "\15\15\16\377\26\30\33\377\177\16\17\20\377&'*\377W\\a\377.04\377\36\37\""
  "\377\14\15\15\377\32\35!\377\12\13\13\377\40#$\377$(*\377\27\31\33\377\35"
  "\37\"\377\14\15\15\377\24\27\31\377'+0\377\36\40\"\377\15\16\17\377+.2\377"
  "\26\31\33\377137\377\6\15\10\377\26\27\30\377\21\23\25\377\14\15\16\377\12"
  "\13\14\377?BE\377\24\26\30\377\16\17\20\377GMS\377\11\12\11\377\34\36!\377"
  "\27\30\32\377\34\35\40\3779>B\377\13\14\15\377\13\16\17\377\10\11\11\377"
  "8=@\377\21\24\25\377#')\377\"&)\377(*-\377\27\31\32\377!#&\377\13\14\14\377"
  ")-0\377359\377\31\33\34\376\30\33\35\377\20\23\23\377),.\377\40$%\377\36"
  "\40!\377\20\22\23\377\16\20\21\377\14\17\17\377$'*\377\34\35\36\377\35\36"
  "\37\377\26\31\32\377\24\27\27\377\17\17\15\377.45\377\24\24\24\377\21\20"
  "\17\3775:=\377\33\36\40\377\16\17\17\377\22\23\23\377-25\377#%'\377\40!\""
  "\377\15\15\15\377\27\32\35\377\27\32\32\377\24\26\27\377\10\11\10\377\"%"
  "&\377359\377\22\24\24\377\15\16\15\377\16\20\21\377\21\23\24\377$)-\377>"
  "AF\377\7\11\11\377\11\12\12\377\24\27\30\377tz\201\377\14\16\16\377\17\22"
  "\22\377\14\15\15\377NTX\377\32\36!\377MPU\377\16\17\17\377\13\13\13\377\15"
  "\20\21\377\13\14\15\377\36!$\377!\"$\377!$&\377\25\26\27\377\12\14\14\377"
  "\30\31\32\3778;@\377\22\24\26\377\20\22\22\377\17\20\21\377FKO\377RVZ\377"
  "*/1\377&(+\377\21\22\23\377\14\16\17\377\27\31\31\377\32\34\35\377\30\31"
  "\32\377\31\34\35\377+.2\377\31\32\33\377\27\27\27\377\30\33\35\377\33\35"
  "\40\377\20\21\21\377\12\12\13\377\15\15\15\377Q\13\14\14\377\36\"$\37726"
  "9\377\30\32\33\3776:?\377\30\30\32\377\"&(\377\17\21\23\377\30\33\35\377"
  "\12\13\13\377)-/\377\23\23\25\377\15\16\17\377NSV\3779<?\377\37\"%\377\20"
  "\21\23\377\23\27\31\377\21\24\26\377!$&\377\17\20\22\377\13\24\21\377\11"
  "\14\15\377\30\34\36\377\12\12\13\377\31\34\36\377!$'\377DHK\377%'*\377\30"
  "\32\34\377\22\22\24\377\11\11\11\377<?C\377BGL\377\11\11\11\377\13\16\16"
  "\377\17\21\22\377\14\17\20\377\15\16\17\377\22\26\27\377\34\40\"\377\34\36"
  "\40\377JMS\377048\377\33\34\36\377\24\24\26\377\22\24\25\377DJO\377\30\32"
  "\33\376\21\23\22\377\40$&\377\31\34\36\377\17\17\17\3778>C\377\16\17\20\377"
  "\24\25\26\3778=A\377\16\20\17\377\20\22\23\377\32\35\37\377\40\"$\377\23"
  "\22\21\377KQT\377225\377\20\20\17\377\30\31\32\377BGL\377\27\27\30\377\32"
  "\36\36\377/25\377\20\22\21\377KPT\377\23\25\26\377\22\23\24\377\17\22\22"
  "\377GLQ\377\20\21\22\377\16\17\20\377\14\20\20\377\22\24\26\377\30\34\35"
  "\377\202\20\23\24\377\177/27\377\12\14\14\377\16\20\21\377\10\11\10\377\20"
  "\22\23\377\12\14\14\377+03\377\37!#\377\14\16\17\377\17\23\23\377\40#%\377"
  "\16\22\24\377\30\33\36\377\21\22\23\377\24\30\32\377\23\24\25\377\32\35\37"
  "\377\21\22\23\377*.2\377\16\20\21\377\23\26\30\377\13\14\15\377\31\32\34"
  "\377\16\17\20\377\35\37\"\377*.0\3778<?\377\21\21\22\377]ch\377036\377\15"
  "\17\17\377\14\14\13\3775:<\377>@D\377\17\21\22\377\20\22\22\377\"%(\3779"
  "=A\377%')\377$'*\377\14\15\15\377\16\16\16\377\33\35\37\377\"%'\377\12\13"
  "\13\377'+.\377(+-\377\27\32\32\37758<\377\35\37\40\377vy\201\377\17\20\21"
  "\377:?C\377\10\12\12\377\17\21\22\377\14\14\15\377\40$'\377+/1\377\36\40"
  "#\377/04\377\23\25\26\377?EI\377\16\17\21\377\25\30\31\377\40!$\377\25\26"
  "\30\377\33#!\37728=\377\11\12\12\377\13\14\15\377\25\31\33\377(*-\37757<"
  "\377238\377\10\10\11\377\23\24\26\377RW]\377\20\21\22\377\31\32\34\377\15"
  "\17\21\377\13\13\13\377&)-\377\37!#\377\22\22\23\377\33\34\37\377\"%'\377"
  "147\377;=A\377&(+\377HMR\377\21\22\22\377\20\21\23\377\20\22\23\377\36#&"
  "\376\26\26\27\37759<\377\25\31\31\377\17\21\21\377\13\16\14\377\35\37\40"
  "\377_di\377\21\24\24\3775;<\377\21\24\23\377\16\17\16\377\21\22\23\377\26"
  "\30\31\377JNR\377\33\36\36\377\37\37\37\377,/2\377\23\25\23\377\27\32\33"
  "\377\37\"%\377\25\26\26\377\16\21\20\377\20\21\20\377!$&\377\17\21\21\377"
  "\27\32\34\377\12\13\12\377\32\36\36\377\26\30\32\377\37#$\377\16\20\17\377"
  "\15\17\20\377*-0\377\177\31\34\36\377\14\16\16\377\10\11\11\377\26\30\32"
  "\377\11\13\12\377&*-\377\12\13\14\377\11\12\12\377\14\17\16\3776;?\377\15"
  "\20\20\377\12\14\14\377\11\12\14\377\30\34\36\377\15\17\17\377/48\377ru}"
  "\377\20\22\22\377\12\13\13\377\15\16\17\377\35\40#\377'+.\377\32\34\37\377"
  "\11\12\11\377\26\32\33\377\23\25\26\377dio\377+,/\377!$%\377\32\36\37\377"
  "\35\37!\377\16\17\17\377\25\30\31\377\15\17\17\377EHM\377\31\33\34\377\17"
  "\17\20\377#&)\377248\377',-\377\36\40\"\377\14\15\14\377\23\24\24\377\33"
  "\35\36\377\17\20\21\3778<?\377\15\16\16\377\21\24\26\377\20\21\22\377\11"
  "\11\12\377DFK\377\30\31\33\377#(*\377\13\15\14\377\27\30\32\377\12\11\11"
  "\37737;\377(*,\377SW^\377\30\31\33\377\16\17\20\377knw\377\30\32\33\377\37"
  "\40$\377\12\14\14\377\30\33\36\377&)*\377\14\23\21\377\26\31\32\377\32\35"
  "\36\377\17\21\22\377\27\32\32\377\24\27\30\377\24\25\27\377\22\23\24\377"
  "\33\35\36\377\16\20\22\377#'+\377\20\22\22\377\12\13\13\377\31\33\35\377"
  "+/1\377\25\26\30\377\36!\"\377+.2\377\31\35\37\377\15\16\16\377=?E\377/3"
  "5\377#%(\37727:\377\20\22\24\377\27\31\33\377\17\21\22\377\27\33\34\376#"
  "$&\377\27\31\31\377\23\26\27\377\16\17\17\377\17\21\22\377'+0\377\40#%\377"
  "\32\35\36\377&*,\377\21\23\23\377\17\21\20\377\27\32\32\377#$&\377\20\23"
  "\22\377`ek\3777;=\377\17\17\16\377\37#%\377\31\32\33\377\15\16\15\377,.1"
  "\377\26\31\32\377&'*\377\24\27\30\377346\377\20\23\23\377\17\23\23\377\30"
  "\34\35\377\24\26\26\377\30\33\34\377\12\14\15\377\13\15\15\377).47\377\17"
  "\23\24\377\12\13\13\377\22\24\26\377\22\25\26\377\11\13\13\377\24\27\31\377"
  "\21\22\22\377\11\13\13\377\13\15\15\377,15\377\24\27\30\377\10\11\10\377"
  "\11\12\14\377\31\33\37\377\"&'\377HLR\377-04\377')+\377\11\12\12\377\40!"
  "%\377\27\33\35\377\33\34\36\377\34\37!\377\33\35\37\377\26\31\32\377\37!"
  "#\377\16\20\20\377fip\377\24\26\26\377\20\23\25\377\16\17\17\377\31\32\34"
  "\377\36\37!\377\25\27\30\377\17\17\17\377148\377,.1\377\40#$\377-14\377\36"
  "\40\"\377\202\20\21\22\377L\17\20\20\377\20\20\20\377025\377,/3\377\33\35"
  "\37\377\17\17\20\377\13\15\16\377\12\13\12\377\"%&\377=@D\377\17\21\23\377"
  "\34\37!\377\12\12\12\377\40#&\377\16\20\20\377ORX\377\23\24\25\377\27\31"
  "\33\377\35\40\"\377\36!#\377258\377\10\11\11\377\12\13\14\377\22\23\24\377"
  ".27\377\21\30\25\377\14\17\20\377`cj\377$&*\377\33\35\37\377\11\12\12\377"
  "\12\13\13\377\25\26\30\377JOR\377\34\36\"\377\12\13\14\377\11\14\14\377\40"
  "#&\377\13\15\16\377#&*\37747:\377\12\13\14\377%(-\377\24\27\32\377\13\16"
  "\17\377\13\14\14\377@DI\377\36\40\"\377+02\377\24\25\30\377&(+\377\15\17"
  "\20\377\21\23\23\376\15\17\17\377\31\35\37\377\13\15\14\377\37\"#\377&+-"
  "\377\25\24\25\377\32\34\36\377+.0\377\24\25\24\377\21\22\21\377\20\22\22"
  "\377\34\36\40\377\17\20\17\377035\3776=@\377..0\377\37$$\37799<\377\14\16"
  "\15\377\35\34\34\377\13\14\13\377!')\377%(*\377\202\11\12\12\377cKQV\377"
  "JKN\377\31\32\34\377\31\34\35\377\11\12\12\377\12\13\13\377.47\377\14\15"
  "\15\377\15\20\20\377\26\32\33\377\15\20\21\377!$%\377\10\11\11\377\16\22"
  "\21\377\11\13\13\377Y^b\377\14\15\15\377\13\15\15\377\14\17\20\377\10\12"
  "\12\377\14\15\17\3777:@\377.24\377\37#&\377<?C\377\16\20\21\377\26\27\31"
  "\377\35\40!\377\40\"$\377\15\17\20\377\21\21\22\377\32\35\37\377KLQ\377\32"
  "\34\35\377\24\27\30\377\16\17\20\377\14\16\16\377\15\16\17\377\32\34\35\377"
  "\35\37\40\377\31\33\35\377\32\34\36\377\27\31\33\377#&(\377:>C\377\21\22"
  "\23\377\27\31\31\377\17\17\16\377\17\21\23\377\20\23\25\377\27\32\34\377"
  "!#&\377\15\16\16\377\31\33\35\377\37#%\377\16\17\20\377\14\15\16\377\24\26"
  "\27\377\13\14\14\377\25\27\30\377\14\15\15\377\17\20\20\377148\377\34\35"
  "\37\377VY]\377\11\12\12\377%()\377569\377..2\377\25\27\31\377\14\15\16\377"
  "\13\15\16\377DFJ\377\24\26\31\377\15\16\16\377\22\33\31\377')-\377/35\377"
  "\\`g\377\16\17\17\377\12\14\14\377\22\24\25\377\34\36\"\377\20\21\21\377"
  "\40#%\377\22\24\26\377\25\30\32\377\30\33\35\377\21\23\24\377'*,\377\36\40"
  "\"\377\33\36\40\377\13\15\16\377058\377\14\16\17\377\36\"$\377\12\13\15\377"
  "\30\32\35\377%)-\377\202\16\20\21\377\177\17\21\22\377\25\32\33\376\26\27"
  "\27\377\16\20\21\377\30\34\35\377>AE\377\21\22\23\377\20\20\21\377\20\22"
  "\21\377\13\15\15\377\16\20\20\377\31\31\32\377\30\32\33\377\20\22\22\377"
  "\36\40!\377\32\35\36\377014\377\24\26\26\377\31\35\36\377GJO\377\26\26\25"
  "\377\15\15\14\377$(*\377\15\16\15\377147\377\13\15\14\377\14\16\16\377?B"
  "E\377%')\377\17\22\23\377\13\14\14\377\30\35\35\377\37\"$\377\32\37!\377"
  "\13\15\15\377\27\31\32\377\22\25\26\377\21\24\25\377\16\20\20\377\10\10\11"
  "\377\10\11\11\377\35!#\377FJL\377\25\27\30\377\14\15\15\377\10\11\11\377"
  "\14\17\20\377,/4\377\26\31\34\377'*-\377NRX\377\15\16\17\377&*,\377\23\25"
  "\26\377#$(\377\21\23\24\377\17\21\21\377\11\13\12\377\36\40\"\377036\377"
  "\30\31\33\377)-/\377\10\11\11\377\14\14\15\377\40$&\377\27\31\34\377\26\30"
  "\27\377\26\27\30\377\33\36\40\377=BE\377\23\25\27\377\30\32\34\377\21\23"
  "\24\377\17\20\21\377\32\32\33\377\23\26\27\377\36\40!\377INQ\377\35\40!\377"
  "\40\"%\377\20\22\22\377\14\15\15\377\25\26\30\377-03\377\12\13\13\377\20"
  "\21\22\377\13\14\14\377\20\21\21\377RV[\377\37\"%\377\16\20\21\377\17\20"
  "\21\377-/3\377#%'\377\37\"#\377\26\27\30\377\13\15\17\377\15\16\20\377\14"
  "\17\21\377\14\15\16\377\27\30\32\377\22\25\26\377\27\37\35\377\201\206\216"
  "\377/26\377\20\21\22\377\34\36!\377\10\12\12\377\25\27\31\377\16\17\21\377"
  "\27\31\32\377\17\20\22\377JPS\377\12\13\13\377\20\22\23\377\31\33\35\377"
  "\37\40#\377\27\31\33\377+.1\377=AF\377\30\31\33\377\"&)\377\23\25\27\377"
  "27;\377\20\22\23\377\24\26\27\377\15\16\17\377\177\16\20\21\377\21\24\26"
  "\377\17\22\23\376\32\34\36\377\23\26\26\377ail\377358\377*13\377\\]c\377"
  "\15\15\15\377\13\15\14\377'*+\377\34\36\37\377\25\26\26\377?DG\377347\377"
  "\17\20\20\377\32\35\36\3776:=\377\32\34\35\377-02\377\23\26\26\377\34\35"
  "\36\377\12\12\11\377\20\22\23\377\13\14\15\377\32\36\37\377>AE\377\21\23"
  "\24\377GKO\377\23\26\27\377\17\20\21\377\22\25\27\377\32\34\35\377\12\14"
  "\13\377%(*\377\12\15\15\377\13\15\14\377\23\30\31\377\26\31\33\377\14\15"
  "\15\377%+.\377\20\21\22\377\23\26\27\377),.\377\16\20\20\377\11\12\13\377"
  "\13\15\16\377DIN\377\26\31\35\377\20\21\22\377,13\377EHM\377\16\20\20\377"
  "\"%'\377\27\32\33\377\24\26\27\377\14\16\17\377BIM\377\16\16\17\377025\377"
  "9<?\377\15\16\16\377\25\27\32\377\12\12\12\377%(,\377\16\20\20\377\14\15"
  "\15\377\21\22\23\377?CG\377+.1\377LMQ\377\14\13\13\377\20\21\21\377*-/\377"
  "\27\27\30\377!%'\377,.2\377;<@\377(+-\377\25\27\30\377\25\30\31\377\12\12"
  "\12\377\17\20\20\377#'*\377\23\26\27\377\20\21\21\377\13\13\13\377\15\16"
  "\17\377PTZ\377\13\15\15\377\11\13\13\377358\377@CF\377\25\27\27\377\16\16"
  "\20\377\14\15\16\377\12\14\14\377\14\16\17\377\40!$\377.02\377\25\27\32\377"
  "'+0\377\30\37\36\377,/2\377\23\25\30\377\10\11\12\377\32\35\40\377_dk\377"
  "\10\11\11\377\33\36!\377\14\15\15\377\40#&\377\14\14\15\377\17\21\23\377"
  "\34\36\40\377+-2\377\35\40\"\377\37!#\377\14\17\17\377Y_e\3777;@\377\13\13"
  "\14\377\40#&\377\20\23\24\377\17\21\21\377\24\26\30\377\177\17\20\20\377"
  "&(,\377\30\31\33\377\15\17\17\376\20\23\24\377?EI\377\17\20\20\3777?A\377"
  "437\377\14\16\14\377\13\16\15\377\13\14\13\377\27\31\30\377%(*\377),.\377"
  "&+-\377\17\21\20\377\21\24\26\377\25\30\30\377\31\33\32\377\16\15\14\377"
  "\31\35\36\3779;?\377\20\23\23\377\10\12\12\377\11\12\11\377,.1\377\20\21"
  "\22\377\11\13\13\377\20\24\25\377\11\12\10\377\24\30\31\377#&)\377\25\30"
  "\32\377\14\15\15\377,-1\377\14\16\16\377\20\23\24\377\16\20\20\377\10\12"
  "\12\3778=A\377')+\377\13\15\15\377\12\15\15\377\14\16\15\377\32\34\36\377"
  "\33\40#\377\13\15\15\377\10\11\11\377%'*\377&',\377\26\32\31\377148\377\35"
  "!#\377\32\36\37\377\20\23\23\377>BF\377\27\33\33\377!#&\377\12\15\15\377"
  "\22\24\26\377)+,\377\30\32\33\377\31\32\34\377\14\14\15\377\13\14\13\377"
  "\13\12\12\377\30\33\34\377\33\35\37\377\34\36\40\377<@D\377<=A\377\13\14"
  "\15\377\17\20\20\377\23\23\23\377<>B\377\27\30\32\377\40!\"\377\37\40\"\377"
  "@CH\377\37#$\377\23\27\30\377\24\25\26\377\34\37!\377\17\20\20\377\25\27"
  "\31\377\26\27\30\377\17\20\20\377\15\20\21\377\15\16\17\377\23\24\26\377"
  "\15\17\20\377\22\25\25\377+/2\377\25\30\31\377\25\31\33\377\11\11\11\377"
  "\12\14\14\377!$'\377\13\14\15\377\12\13\14\377).3\377\16\20\22\377HIP\377"
  "\31\37\35\377\14\14\15\377\27\32\33\377GJQ\377\15\16\17\377\30\34\33\377"
  "48<\377\21\23\25\377\25\30\32\377\13\15\15\377\15\16\17\377\23\25\27\377"
  ":?A\377\40$(\377\16\20\22\377\15\16\17\377#'*\377\20\22\23\377',/\377\33"
  "\40\"\377\17\17\17\377\23\24\25\377\13\14\15\377\17758=\377\14\16\20\377"
  "\22\23\24\377\22\23\25\377\27\35\36\376\25\27\27\377\15\20\20\377<AD\377"
  "DEI\377\21\25\25\377\14\16\16\377!$&\377\13\14\13\377\23\25\27\377\36\40"
  "!\377269\377\16\20\20\377\36#\"\377\15\17\17\377CFL\377\35\40!\377\17\21"
  "\21\377STZ\377\11\13\13\377\21\23\25\377\12\14\13\377\20\21\21\377\13\14"
  "\15\377\11\13\12\377\27\30\32\377\35\"!\377--/\377\21\24\24\377\31\33\35"
  "\377\21\24\24\377\35\36!\377\21\23\23\377(,0\377\11\14\13\377\13\16\17\377"
  "\11\13\13\377'.1\377\24\26\27\377\17\17\17\377\33\35\37\377\15\20\20\377"
  "\30\32\34\377\40%(\377148\377\17\17\17\377\13\15\17\377\17\21\23\377\177"
  "\202\213\377\15\16\17\377BFM\377\23\25\26\377\27\32\33\3777>@\377egp\377"
  "\13\16\16\377\17\20\20\377\21\22\24\377\27\31\32\377\10\10\10\377\27\30\32"
  "\377#$'\377\17\20\21\377\14\16\16\377\12\14\13\377<?D\377\34\37\40\377),"
  "/\377\17\21\20\377\20\21\21\377\36\40\"\377\33\32\34\377\16\16\16\377\37"
  "\40!\377<>A\377\11\13\12\377?CF\377.26\377\21\22\23\377\30\33\35\377\17\20"
  "\20\377\26\30\32\377\14\15\15\377\13\13\14\377&),\377\25\27\30\377\11\12"
  "\11\377\12\13\13\377\35\37!\377\15\17\20\377\13\15\15\377\33\35\37\377\7"
  "\10\10\377\14\16\20\377\23\24\27\377\12\12\13\377\23\25\26\377\27\30\33\377"
  "\14\16\20\3778<A\377\32\35\40\377\14\24\20\377!#$\377\21\22\24\377\17\20"
  "\21\377\13\16\17\377\22\26\27\377\17\23\24\377.03\377\11\11\13\377\25\26"
  "\31\377$%'\377\34\35\37\377)+.\377\37!$\377\15\20\21\377\30\32\34\377\13"
  "\14\14\377\40\"%\377-03\377\12\16\20\377\16\17\20\377\15\15\16\377\177\12"
  "\14\14\377\13\14\15\377\21\21\23\377\20\23\24\377\21\23\25\377\20\22\23\376"
  "\20\23\23\377\27\33\34\377\36!$\377\24\27\27\377\14\15\15\377!%&\377\15\16"
  "\15\377\14\15\15\377\23\25\25\377.13\377\15\16\15\3776;=\377$&(\377\14\17"
  "\15\377\27\32\32\37767:\377\11\12\12\377\13\15\16\377\17\22\22\377\14\16"
  "\16\377\21\23\24\377\23\24\26\377\36\"$\377\13\16\16\377\13\14\14\377\40"
  "#&\3778=B\377\15\20\20\377\7\10\7\377\27\33\35\377\30\33\34\37738<\377\14"
  "\15\15\377\15\16\17\377\12\14\15\3778>B\377\11\13\13\377\24\27\30\377\22"
  "\24\26\377\17\20\21\377\20\21\22\377-.2\377\16\20\21\377\24\27\31\377\20"
  "\22\22\377\13\15\16\377\20\21\23\377$')\377]`c\377\13\13\14\377\35\37\"\377"
  "349\377\37#'\377\22\24\26\377\31\32\34\377\25\26\27\377\7\10\7\377\12\12"
  "\11\377\17\20\21\377\22\25\27\377\17\21\21\377\15\16\16\377\26\30\32\377"
  "\13\16\16\377\10\12\12\377\27\32\35\377\31\33\33\377\17\20\21\3779;?\377"
  "#%&\377\13\15\15\377\24\25\27\377\40!#\377FJO\377146\377'*-\377\22\22\23"
  "\377\33\36!\377\20\21\23\377+,/\377\17\20\20\377\27\32\33\377\21\24\25\377"
  "\25\26\31\377\13\14\14\377\11\12\11\377\12\12\12\377\14\15\15\377\21\22\23"
  "\37726:\377\13\14\14\377\24\27\31\377\36!\"\377\20\21\22\377\21\23\24\377"
  "*-1\377\11\11\11\377+/2\377\20\22\24\377\37\"$\377\10\16\11\377),0\377\16"
  "\17\20\377\13\14\15\377#'(\377#&(\377\22\22\23\377\23\25\27\377\25\27\31"
  "\377\20\23\25\377\33\35\40\377\21\23\24\377\21\24\26\377$&)\377*.2\377\13"
  "\15\16\377\30\32\33\377DIL\377\20\22\23\377\15\16\20\377$(+\377\177\27\32"
  "\34\377\11\14\14\377\14\16\17\377\13\14\14\377X]b\377\22\26\30\377\16\21"
  "\21\376\16\20\20\377\24\26\27\377\22\25\25\377\24\25\25\377\22\26\26\377"
  "**-\377#)*\377\16\17\15\377168\377\20\20\17\377\24\26\26\377\35\37!\377\34"
  "\37\40\377\15\16\16\377\34!\"\377148\377\10\11\11\377\13\14\14\377\7\10\10"
  "\377\10\11\11\377\7\10\10\377(-/\377VZ_\377\7\10\10\377\36!\"\377\33\40!"
  "\377\24\27\30\377\14\16\17\377\12\13\13\377\14\17\17\377aek\377%,.\377\17"
  "\22\23\377\14\15\15\377\26\27\31\377\11\13\13\377MRW\377\21\22\24\377\10"
  "\11\10\377)-.\377\14\20\20\377!%(\377\11\13\12\377\15\20\21\377\23\25\26"
  "\377eim\377\10\11\13\377%(*\377\35\40#\377?BG\377\16\17\20\377\31\32\34\377"
  "\13\14\14\377\16\20\21\377\31\31\35\377*03\377\13\13\14\377\14\15\15\377"
  "\35\40\"\377\13\14\14\377\12\13\13\377\10\10\10\3776:<\37726;\377\14\14\14"
  "\377\10\10\10\377\14\14\14\377\33\35\37\377\22\23\24\377\20\22\22\377\17"
  "\20\20\377/47\377\17\17\20\377EIL\377X[`\377\15\16\16\377\32\33\35\377\13"
  "\13\13\377HMP\377\14\15\16\377\13\14\14\377+/3\377\22\24\26\377\13\14\14"
  "\377\13\13\13\377\13\14\14\377\11\13\13\377\12\12\12\377\13\15\16\377\14"
  "\15\16\377\16\21\21\377\16\20\21\377\13\15\16\377$%(\377\15\16\20\377\10"
  "\12\13\377\11\12\12\377\"%'\377\22\24\26\377\25\30\31\377\24\33\32\377\12"
  "\14\14\377\13\14\14\377\22\24\26\377\15\17\17\3777:?\377')-\377',/\377\25"
  "\27\32\377\17\21\22\377\21\23\24\377!$'\37726:\377\17\21\23\377\16\20\22"
  "\377\20\22\23\377&),\377\27\31\33\377\34\36\40\377\24\27\30\377\177\34\34"
  "\37\377\36#%\377\14\14\15\377\14\16\17\377\24\26\27\377\12\13\13\377/46\377"
  "\25\30\31\376\34\37!\377\13\16\16\377\14\16\15\377\37$%\377@BG\377%*,\377"
  "\13\15\14\377\17\21\22\377\12\13\13\377\37\"$\377\20\21\21\377\16\20\16\377"
  "\37!$\377\23\25\25\377HNS\377\20\22\22\377\7\11\11\377\31\33\35\377\7\7\6"
  "\377\10\10\10\377\14\16\17\377\21\23\23\377\24\26\27\377\20\24\24\377\15"
  "\16\17\377\40#%\377\13\14\14\377\13\15\15\377\7\13\12\377\16\22\23\377\13"
  "\14\14\377\27\32\32\377\26\31\34\377\16\20\20\377\10\11\10\377\24\30\31\377"
  "%'*\377\16\21\20\377\15\20\20\377\20\23\24\377\27\33\34\377((*\377\17\20"
  "\21\377\10\11\12\377\21\23\24\377\35\40\"\377/24\377\15\20\21\377.15\377"
  "*,-\377\10\10\7\377\11\11\11\37736;\377=?C\377\17\17\20\377\15\20\20\377"
  "\21\23\24\377\17\20\21\377\10\7\7\377\11\11\10\377\30\31\32\377#'*\377\20"
  "\22\23\3779:>\377\11\12\12\377\12\12\12\377\23\25\26\377\"$(\377\35\40!\377"
  "\16\16\16\377).0\377\36\40\"\3779;?\377\32\33\35\377\27\30\31\377\20\21\22"
  "\377\15\16\17\377\20\22\24\377\16\16\15\377\30\30\33\377\24\27\31\377\22"
  "\25\25\377+-0\377\16\20\21\377\17\20\20\377\11\12\12\377\27\31\32\377\12"
  "\11\11\377\16\16\17\377\10\10\10\377+/2\377!#%\377\31\33\35\377\34\37!\377"
  "\10\12\12\377\27\33\35\377\10\10\10\377\30\31\33\377&')\377\22\24\26\377"
  "\7\15\10\377\16\16\17\377\30\31\34\377\13\14\15\377\15\15\14\377!%&\377@"
  "DJ\377\20\23\25\377\21\22\23\377$(,\377\14\14\15\377\37\40#\377hmt\377\14"
  "\16\17\377\32\35\36\3779;?\377\16\17\17\377\33\37\40\377\36!$\377\177\13"
  "\15\16\377\13\14\14\377!\"%\377:>B\377\16\21\23\377\14\15\16\377*/4\377\16"
  "\21\21\377\17\21\22\376\15\17\20\377\13\15\15\3778=@\377:<@\377\20\23\23"
  "\377+/2\377\24\25\26\377\14\14\14\377#()\377\33\35\36\377\13\14\13\377$'"
  ")\377\16\20\17\377\37!#\377\14\15\14\377)-1\377\7\10\10\377\16\20\21\377"
  "\21\22\22\377\11\14\14\377\13\14\14\377\7\10\10\377\14\15\15\377\21\25\27"
  "\377#&)\377\10\12\12\377\13\14\14\377\17\20\21\377\14\17\17\377\37#&\377"
  "\12\13\12\377\26\31\33\377\30\34\36\377\21\23\25\377\15\16\17\377\15\17\20"
  "\377\30\32\34\377\21\24\25\377\30\32\32\377EHN\377\10\13\13\37769>\377\15"
  "\17\20\377\16\20\21\377\7\10\10\377&*.\377\16\17\20\377\15\17\17\377\22\25"
  "\25\377\21\22\24\377\12\12\13\377\11\12\11\377\23\25\27\377\27\31\32\377"
  "\7\7\10\377\13\14\15\377\26\32\33\377\11\13\12\377\10\10\7\377-03\377RU["
  "\377\21\22\24\377)(,\377\13\13\12\377\11\11\11\377\35!\"\377\14\14\15\377"
  "\25\25\27\377\30\31\32\377\31\34\35\377\20\23\22\377ORX\377*+.\377\36\37"
  "!\377\14\13\14\377\20\20\21\377\22\23\24\377\10\10\10\377!#$\377\26\31\32"
  "\377\23\26\26\377\33\34\37\377\13\12\13\377\25\26\30\377\16\20\21\377\14"
  "\15\14\377\20\22\23\377\6\7\7\377\10\10\10\377\32\34\36\377\14\16\16\377"
  "\23\26\27\377).1\377\11\12\13\377\20\22\23\377!\"%\377\31\32\34\377\34\36"
  "\40\377*-/\377\15\17\20\377\7\16\11\377\24\27\30\377\25\27\30\377\12\13\14"
  "\377\12\13\13\377&(+\377\21\23\25\377?BD\377\24\26\31\377\24\26\27\3779?"
  "D\377\20\23\25\377\15\17\20\377\24\27\31\377\16\20\21\377\36\37\40\377)+"
  ".\377,/2\377L\22\24\26\377\10\11\11\377&*-\377\24\30\32\377\26\30\30\377"
  "JNS\377\24\26\30\377\16\20\21\377\31\34\36\377\23\25\26\376\40#%\377\31!"
  "\"\377\27\30\32\377\25\32\32\377((+\377,24\377\30\32\32\377\15\17\17\377"
  "\14\16\17\377\26\31\31\377\17\20\21\377\16\21\20\377\"$%\377\10\11\10\377"
  "\24\30\32\377\14\15\15\377\13\14\15\377\14\17\17\377\16\22\23\377\34\34\36"
  "\377\6\6\6\377\11\12\13\377\16\21\23\377\20\23\24\377\11\14\14\377\10\10"
  "\10\377\17\21\21\377\14\16\17\377\11\13\13\377\12\15\15\377\27\32\34\377"
  "\12\15\15\377\31\35\36\377KLR\377\12\14\14\377\13\15\17\377(,.\377\17\20"
  "\21\377\35!#\377\31\36\36\377\14\16\16\377\21\24\25\377#%(\377\12\13\13\377"
  "\15\16\17\377\11\12\12\377\21\24\25\377(),\377\30\32\33\377\7\7\10\377\11"
  "\11\12\377\24\26\30\377\10\10\10\377\10\11\11\377\25\30\31\377\22\25\27\377"
  "\22\24\24\377\14\15\16\377\33\36\37\377\12\13\12\377\25\27\30\377\10\11\10"
  "\377\22\23\25\377\14\15\15\377\34\35\37\377\21\23\25\377\202\15\16\16\377"
  "\177\27\33\33\377#&(\3778:>\377\20\22\22\377\17\17\20\377\12\12\12\377\15"
  "\17\16\377\13\14\13\377\14\15\14\377\35\37\"\377\16\20\21\377\"#&\377\27"
  "\31\33\3778:?\377\15\17\17\377\24\25\26\377'(,\377\14\16\16\377\10\10\10"
  "\377\11\11\12\377\15\14\14\377\26\26\31\377\36!\"\377\12\14\15\377\25\30"
  "\32\377048\377\7\10\7\377\14\15\15\377\11\12\13\377+-2\377\13\14\15\377\26"
  "\30\32\377\34\40\40\377\15\15\16\377\17\20\21\377\21\25\25\377\17\20\21\377"
  "\13\16\16\377\22\23\24\377\40#$\377\32\34\36\377,/3\377\30\33\35\377,.2\377"
  "\11\12\12\377\31\34\35\3778;>\377\20\22\22\377137\377\13\15\16\377\25\26"
  "\30\377\16\20\22\377\10\12\11\377\20\23\25\377\32\35\37\377;@D\377\20\23"
  "\25\377\17\22\23\377\12\12\12\377\17\21\21\376\20\24\25\377&*,\377#(+\377"
  "\37\40\"\377\40$&\377\22\24\24\377\16\21\21\377\15\17\17\377\20\22\22\377"
  "7:=\377\13\13\14\377\25\27\27\377\11\12\11\377\13\14\14\377\11\11\10\377"
  "\32\34\36\377\10\11\10\377`ek\377\31\32\34\377\12\12\13\377\11\12\12\377"
  "\6\10\10\377+.0\377\10\10\7\377\6\7\7\377\36\"$\377*/1\377\23\25\25\377\10"
  "\12\11\377\25\30\32\377\23\24\24\377\30\33\33\377\11\13\13\377\12\13\12\377"
  "\15\17\20\377\17\22\23\377.15\377\22\26\27\377\17\20\21\377:>B\377\20\22"
  "\22\377:<?\377\10\11\11\377\10\11\12\377\11\12\11\377\17\21\23\377\13\13"
  "\15\377\14\15\15\377\10\11\10\377\11\12\12\377\7\10\7\377\21\23\23\377\6"
  "\6\6\377\21\25\26\377\22\24\26\377\21\21\22\377\7\7\7\377\31\34\34\377\20"
  "\22\23\377\10\11\11\377\10\10\10\377\11\11\11\377\13\15\15\377<>B\377\10"
  "\10\11\377\13\15\16\377\14\14\14\377\6\32\34\35\377\10\12\11\377\15\15\15"
  "\377\20\22\22\377\25\25\27\377\24\26\27\377\202\16\17\20\377\177\32\33\35"
  "\377\16\17\16\377\14\17\17\377VZ`\377\12\13\11\377\17\21\22\377\36\"%\377"
  "$&)\377\15\16\16\377\20\20\20\377\22\23\25\377\16\17\20\377\10\7\7\377\11"
  "\11\11\377\31\32\33\377\30\31\33\377\10\10\11\377%(*\3779;@\377\21\24\26"
  "\377\10\10\11\377\12\12\12\377\10\11\12\377\15\15\16\377\24\27\30\377\30"
  "\35\35\377*,0\377\21\22\22\377\15\17\17\377\14\16\16\377\22\26\30\377\21"
  "\21\23\377\12\13\14\377\37\"%\377!\"&\377\"')\377\12\13\13\377*-0\377\12"
  "\12\13\377/14\377:=A\377\11\12\12\377=>C\377!%'\377\14\15\16\377\32\35\37"
  "\377\33\35\37\377\40%'\377/36\377\14\15\15\377\17\20\21\377!#%\377\16\20"
  "\20\376\23\25\27\377\15\21\21\377&,/\3777<?\377\36!#\377\30\32\33\377\20"
  "\23\24\377\30\34\34\377\14\15\15\377\13\14\14\377\13\15\15\377\10\11\10\377"
  "\21\22\22\377\12\13\14\377\21\23\24\377\10\10\10\377\24\27\31\37706:\377"
  "\31\32\34\377\25\30\31\377\11\12\12\377\6\7\7\377\6\6\6\377\10\11\11\377"
  "\14\16\16\377\25\27\30\377).1\377\13\14\14\377\33\40!\377\27\30\31\377\11"
  "\11\12\377\16\20\21\377\20\23\23\377\22\24\25\377\40#$\37738<\377@CF\377"
  "\12\13\13\377\24\25\26\377\12\13\12\377\11\12\12\377\10\12\12\377\15\20\21"
  "\377\7\10\10\377\10\11\12\377\20\21\23\377\6\7\7\377\6\6\6\377\11\12\12\377"
  "\23\25\26\377\16\17\20\377\6\6\6\377.04\377\24\30\31\377\10\11\11\377\12"
  "\12\12\377\20\22\23\377\23\25\26\377\17\21\21\377\16\17\17\377\11\11\10\377"
  "\11\10\10\377024\377\37\37!\377\13\14\15\377\13\14\14\377\11\11\11\377\14"
  "\16\17\377\37#%\377\23\24\25\377\14\13\12\377\21\22\23\377\20\20\21\377\17"
  "\22\23\377\26\32\34\35\377\10\10\10\377]ch\377\31\31\33\377\27\31\34\377"
  "\25\26\27\377\10\10\10\377\27\30\31\377;>B\377\15\15\16\377\21\22\22\377"
  "\17\21\22\377\7\10\10\377\10\7\10\377\6\6\6\377\17\21\22\377\10\11\12\377"
  "\11\13\13\377\22\24\26\377\15\17\20\377\12\14\15\377158\377\202\7\7\7\377"
  "\177\20\22\22\377\14\16\16\377\20\26\24\377-04\377\21\23\24\377\15\16\17"
  "\377\40\"$\377+/2\377\24\27\31\377\14\16\17\377\13\13\14\377\24\25\25\377"
  "$&)\377\16\16\16\377\26\31\32\377048\377\27\31\32\377\23\24\25\377!$'\377"
  "\40!$\377\30\31\33\377\15\17\20\377+,/\377\36#%\377\15\16\17\377\20\23\23"
  "\377\12\12\13\377\14\15\16\377\21\23\25\377\21\24\25\376\22\26\27\377\22"
  "\25\26\3777:>\377<@D\377.13\377\16\17\20\377\20\24\24\377\22\24\24\377\11"
  "\12\11\377\14\16\17\377\7\10\7\377\15\20\20\377\12\13\13\377\10\10\10\377"
  "\16\21\21\377*.2\377\21\22\23\377\36\36\37\377\15\17\17\377%),\377\21\22"
  "\22\377\5\6\6\377\7\7\7\377\12\13\13\377\36\40!\377\12\14\14\377\13\16\15"
  "\377)-1\377\6\7\6\377\22\27\30\377(*,\377\13\15\15\377258\377#%(\377\10\11"
  "\10\377\7\11\10\377\11\13\13\377\15\16\16\377\14\15\16\377\24\26\27\377\11"
  "\12\11\377\"')\377\13\15\15\377\11\13\13\377\6\7\6\377\7\7\10\377\7\11\11"
  "\377\11\11\11\377\24\25\27\377\24\26\30\377\10\12\11\377JPU\377\27\27\30"
  "\377\25\25\25\377\7\10\10\377\37#%\377\20\22\22\377\13\14\14\377\10\10\7"
  "\377\40#%\377\17\21\22\377\17\20\20\377\10\10\7\377\12\12\11\377\17\17\21"
  "\377HLR\377\33\35\36\377\12\13\13\377\14\15\15\377\16\16\16\377\15\17\17"
  "\377\17\21\21\377\25\27\31\377269\377;=A\377\14\16\17\37778;\377\"$&\377"
  "\17\17\20\377\13\13\13\377\12\12\11\377\21\22\23\377\11\13\12\377\20\20\21"
  "\377\11\11\10\377\20\20\21\377\10\11\10\377\13\14\15\377\11\13\13\377\6\7"
  "\7\377\12\13\13\377\30\32\34\377\11\12\12\377\15\16\20\377\25\27\31\377\7"
  "\10\10\377\14\15\16\377?\11\11\12\377\10\10\11\377\30\33\35\377\11\17\14"
  "\377\16\20\20\377\16\16\17\377\24\25\27\377\13\12\13\37759=\377\20\22\24"
  "\377\20\21\22\377\20\22\23\377\11\11\11\377\22\23\24\377!%(\377$'*\377\24"
  "\25\26\377\25\27\30\377\23\25\26\377EHL\377\15\15\16\377\15\16\20\377'+/"
  "\377\13\14\15\377##'\377\12\12\12\377\6\7\7\377\12\13\13\377147\377\23\25"
  "\27\377!&)\376\15\20\17\377\20\22\22\377!%'\377\33\35\36\377CJM\377\35\37"
  "!\377\25\30\30\377\12\12\11\377\10\11\10\377\13\15\16\377\13\14\15\377\14"
  "\15\15\377\20\22\23\377\15\16\17\377\31\34\35\377/25\377\36\37!\377\10\12"
  "\12\377\10\12\11\377\6\7\6\377\6\6\6\377\6\7\7\377\17\22\23\377\16\17\20"
  "\377\13\15\14\377\14\15\15\377\7\10\7\377\6\7\6\377.36\377\17\20\21\377\40"
  "%&\377146\377\202\11\12\12\3779\6\7\6\377\7\10\10\377\36\40\"\377\23\23\23"
  "\377\25\30\30\377\13\16\15\377\10\12\11\377\22\23\21\377\10\11\10\377\7\7"
  "\6\377\10\11\10\377\11\12\13\377\14\15\16\377\22\25\26\3777:<\377\7\7\6\377"
  "\10\10\7\377\30\34\36\377\12\12\12\377\6\6\7\377\11\14\14\377\16\20\21\377"
  "\7\10\10\377\10\11\10\377\22\24\26\377\6\6\6\377\33\36\37\377\23\30\30\377"
  "\12\12\12\377\16\16\16\377\31\33\35\377\20\21\21\377\11\12\11\377\7\7\7\377"
  "\6\6\6\377\7\10\10\377\37\"$\377\13\13\12\377\24\26\27\377DFH\37746:\377"
  "\33\33\34\377\22\24\25\377\20\20\20\377\16\16\15\377\26\30\30\377\21\22\23"
  "\377\25\27\30\377\12\13\13\377\13\14\14\377\14\15\15\377\"%'\377\26\26\26"
  "\377\25\30\33\377\12\13\13\377\12\14\15\377\10\10\10\377\202\11\11\11\377"
  "5\10\11\11\377\7\7\6\377\14\16\17\377\12\12\12\377\11\11\12\377\12\13\14"
  "\377\15\20\21\377\11\20\15\377\25\26\27\377!#%\377')+\377\34\37\"\377\36"
  "!!\377MTY\377\37!$\377\13\12\12\377\16\20\21\377\11\11\11\377247\37776:\377"
  "\22\23\24\377\40!$\377\17\20\21\377\10\10\10\377ADJ\377\22\24\25\377\10\10"
  "\11\377\12\12\12\377\10\11\10\377\11\12\12\377\33\35\40\377\23\25\25\377"
  "\37\"#\377SX]\377\36\40#\376\14\17\20\377\13\15\15\377\14\16\16\377\20\23"
  "\23\377EHK\377\14\16\16\377\12\13\12\377\12\14\13\377\17\20\21\377\14\17"
  "\17\377+-1\377\13\14\14\377\13\15\16\377ILS\377\31\33\34\377\13\15\15\377"
  "\6\10\10\377\10\12\12\377\202\7\10\10\377L\12\14\14\377\17\23\23\377\17\22"
  "\23\377\15\16\17\377\5\6\6\377\6\6\6\377\10\12\12\377\22\25\26\377&)+\377"
  "\12\14\14\377\16\17\17\377\20\23\23\377\7\7\7\377\13\15\14\377\21\23\23\377"
  "\11\12\12\377\13\15\16\377\22\23\24\377\23\26\26\377\13\14\14\377\6\7\6\377"
  "\34\37\"\377\22\24\24\377\6\6\5\377\7\7\7\377\6\7\7\377\16\20\21\377\12\13"
  "\13\377\7\10\7\377')-\377\11\13\13\377\7\7\7\377\11\12\12\377\31\33\35\377"
  "\12\13\13\377\10\10\11\377\16\17\17\377\7\10\10\377\10\10\10\377:<A\377\14"
  "\15\15\377\33\35\36\377\7\10\10\377\10\10\10\377\11\12\13\377\12\14\13\377"
  "\10\11\10\377\10\12\12\377\10\10\10\377\12\11\11\377\12\13\13\377\11\13\12"
  "\377\30\31\32\377\13\14\14\377'+,\377\24\25\26\377\40\40\"\377\13\13\13\377"
  "\22\22\23\377)+,\377\17\20\20\377\12\13\13\377\14\14\15\377\15\15\15\377"
  "\21\21\23\377\21\23\25\377\32\34\35\377\16\20\20\377\11\12\12\377\33\34\36"
  "\377\17\17\20\377\12\13\13\377\20\22\23\377\6\7\6\377\16\17\17\377\12\12"
  "\13\377\202\10\11\11\377\177\16\20\21\377\10\11\12\377\17\26\25\377\11\12"
  "\12\377-13\377\26\31\31\377\16\20\21\377\14\17\17\377\16\17\21\377\11\11"
  "\11\377\10\10\11\377\11\10\10\377\15\15\16\377\6\7\7\377\15\16\17\377\13"
  "\13\13\377\11\11\11\377\32\34\35\377\33\34\36\377\37\"$\377\11\11\11\377"
  "\11\12\12\377\17\21\22\377\16\17\20\377\24\30\32\377\13\15\16\377\20\21\22"
  "\377\32\33\36\377#&'\377\13\15\15\376\21\24\25\377\13\15\14\377\16\17\17"
  "\377\25\30\31\377\21\22\23\377\10\10\11\377\21\24\25\377\12\13\13\377\21"
  "\22\23\377\26\31\31\377\15\16\16\377\"%'\377\16\21\21\377EKO\377\35\35\37"
  "\377\6\6\5\377\7\10\10\377\11\13\13\377\16\20\20\377\10\11\10\377\16\23\24"
  "\377\23\26\27\377\11\12\11\377\6\6\6\377\5\6\6\377\6\6\6\377-25\377NPS\377"
  "\10\11\11\377\15\17\17\377\21\25\26\377\17\20\20\377\33\36\37\377\15\16\16"
  "\377()+\377\12\14\14\377\26\31\32\377\12\12\12\377\6\7\6\377\13\14\15\377"
  "\11\13\13\377\21\23\23\377\10\11\12\377\6\6\6\377\13\15\16\377\16\21\23\377"
  "%'*\377\6\6\6\377\11\13\13\377\6\7\7\377\7\7\6\377\10\10\10\377\12\14\13"
  "\377\33\36!\377\16\20\21\377\6\7\6\377\7\10\10\377\12\14\13\377\33\35\36"
  "\377\13\14\14\377\11\12\13\377\7\10\7\377\14\16\16\377\16\17\20\377\15\16"
  "\15\377156\377\10\11\11\377\7\10\10\377\17\20\20\377\10\11\10\377\27\31\32"
  "\377\16\20\20\377\17\21\21\377\35\37!\377\34\37!\377\12\13\13\377\14\14\14"
  "\377?CG\377\16\17\17\377\36!$\377\14\15\15\377\22\23\24\377\20\21\24\377"
  "\14\15\15\377\12\13\13\377#'(\377\12\12\13\377\11\12\13\377\13\16\16\377"
  "\23\25\26\377\15\16\17\377\10\11\11\377\11\11\12\377\10\10\10\377\11\12\11"
  "\377\30\31\34\377\13\14\15\377O\17\21\22\377\14\16\17\377%(*\377\11\20\14"
  "\377\11\11\11\377\23\25\25\37747:\377\10\10\11\377\12\13\13\377\7\10\10\377"
  "\34\36\37\377\15\17\20\377\14\15\16\377\10\10\11\377\10\11\10\377\10\7\10"
  "\377\11\13\13\377\12\12\13\377\12\13\12\377\13\15\16\377\7\10\10\377\26\31"
  "\31\377\30\33\34\377\11\12\12\377\27\32\34\377#')\377\15\20\21\377\10\11"
  "\11\377\20\21\22\377\11\12\13\377\24\27\27\376\12\14\14\377*03\377\14\16"
  "\16\377\11\12\10\377\11\13\12\377\11\12\11\377\13\15\15\377\32\35\36\377"
  "56:\377\10\11\10\377\13\14\14\377.47\377(*,\377\10\11\11\377\10\13\12\377"
  "\13\14\15\377\10\11\11\377\14\16\17\377\12\12\11\377\14\17\17\377!#%\377"
  "\10\11\12\377\7\10\10\377\14\16\16\377\7\7\7\377\22\26\26\377\12\13\14\377"
  "\6\10\7\377\11\13\13\377\17\22\22\377\25\25\27\377\36\"%\377\15\17\16\377"
  "CGK\377\11\13\12\377\15\16\17\377\12\14\15\377\22\25\25\377\11\13\13\377"
  "\12\13\13\377\7\7\7\377\11\12\11\377\10\11\11\377\5\6\5\377\10\11\11\377"
  "\11\13\15\377\10\10\11\377\22\25\26\377\202\16\20\20\377b\10\11\10\377\16"
  "\20\21\377\12\13\13\377\7\7\7\377\20\22\24\377\36!\"\377\10\10\7\377\11\11"
  "\11\377\11\13\13\377\11\12\12\377\22\25\26\377\10\10\10\377\10\11\11\377"
  "\12\13\13\377\7\7\7\377\10\10\10\377\16\20\21\377\15\16\17\377\11\11\10\377"
  ".12\377\14\14\15\377\20\21\22\377\13\13\14\377\17\20\20\377\11\11\11\377"
  "\13\12\11\377\22\24\24\377347\377(+-\377\24\24\25\377\14\15\15\377\13\13"
  "\13\377;=@\377\30\27\31\377\7\7\10\377',/\3778=A\377\30\31\31\377#%'\377"
  "\34\36!\377\14\15\15\377\7\7\7\377\6\6\6\377\12\12\12\377\30\31\33\37758"
  ";\377(,.\377\12\14\15\377\15\16\21\377\25\26\30\377\5\13\7\377\14\15\15\377"
  "\14\15\16\377\15\17\20\377/25\377\10\11\10\377\13\13\14\377\12\12\13\377"
  "\13\13\13\377\31\33\34\377\12\13\13\377\11\11\11\377\10\10\10\377\11\11\10"
  "\377#$(\377\30\34\36\377\12\12\12\377\14\16\17\377\11\12\13\377\10\11\11"
  "\377#&(\377\20\21\22\377\15\15\16\377!%&\377\34\36\40\377\12\12\12\377\36"
  "#$\377\15\16\15\376\13\14\14\377\16\20\20\377\15\16\17\377\16\16\16\377\14"
  "\15\14\377\12\12\11\377\7\10\7\377V[`\377\21\21\21\377\17\22\22\377\26\27"
  "\30\377\16\21\21\377\30\32\33\377\16\17\20\377\6\10\7\377\30\33\35\377\31"
  "\32\33\377\7\10\7\377\7\6\6\377\11\14\14\377\202\10\11\11\377z\22\26\27\377"
  "\13\13\13\377\15\16\16\377\7\11\11\377\14\15\15\377\11\12\12\377\13\14\14"
  "\377\12\12\12\377\15\20\20\377\16\21\21\377\17\21\23\377\11\13\12\377QUZ"
  "\377\27\31\33\377\36\"$\377\12\12\12\377\10\11\11\377\11\13\12\377\10\12"
  "\11\377\17\20\20\377\6\6\6\377\10\11\11\377\15\16\17\377\7\10\11\377\20\23"
  "\26\37716<\377\7\7\6\377\10\7\7\377,03\377\26\26\27\377\14\15\16\377\10\11"
  "\10\377\11\12\11\377\20\23\23\377\22\23\24\377\6\6\6\377\11\13\13\377\26"
  "\30\30\377\25\27\30\3777:@\377'')\377\11\10\7\377\17\21\22\377\7\10\7\377"
  "\11\12\11\377\14\15\15\377\10\10\7\377\6\10\10\377\20\22\22\377\7\10\10\377"
  "\15\20\21\377\12\12\12\377\17\16\16\377\14\14\13\377\32\34\36\377\17\20\20"
  "\377\14\15\15\377&')\377\15\15\16\377\30\32\33\377\33\35\36\377\35\36!\377"
  "\14\14\15\377\14\15\15\377\23\25\26\377\12\12\12\377\7\10\7\377\14\14\15"
  "\377\13\15\16\377\7\10\7\377\10\7\7\377\13\14\13\3777;?\377(*.\377\14\16"
  "\16\377\13\15\15\377\21\22\23\377\20\21\21\377',.\377\34\37#\377\13\14\15"
  "\377\10\10\10\377\10\11\11\377&)+\377\22\22\24\377\10\10\10\377\14\15\16"
  "\377\11\12\12\377\37!\"\377\13\14\14\377\15\16\17\377\32\35\36\377\17\20"
  "\20\377&')\377\17\20\22\377\11\11\11\377\13\14\14\377\16\20\20\377\10\12"
  "\11\377.14\377\16\20\21\377\16\17\21\377\31\34\36\377<@C\377\12\12\12\377"
  "59<\376\14\14\15\377\12\14\13\377\12\13\12\377\15\15\16\377\11\12\11\377"
  "\24\30\27\377\17\20\20\377\14\15\15\377%)+\377\13\15\14\377\17\21\22\377"
  "\12\12\12\377\15\17\17\377\31\35\37\377\27\32\34\377\14\16\15\377\202\6\7"
  "\6\377\6\15\16\17\377\12\13\13\377\12\15\15\377\26\31\33\377\10\12\11\377"
  "\17\22\22\377\202\7\10\10\377\37\11\13\12\377\14\16\16\377\13\15\16\377\17"
  "\20\21\377\30\31\32\377\11\11\11\377\27\31\32\377\12\15\15\377168\377+-0"
  "\377\21\21\22\377259\377\14\14\14\377\5\6\6\377\6\7\7\377\6\10\10\377\7\11"
  "\11\377\11\12\11\377\6\7\7\377\13\14\16\377\25\31\34\377\14\16\16\377\23"
  "\25\25\377\26\27\27\377()+\377\10\10\11\377\7\7\7\377\16\20\20\377\11\12"
  "\11\377\13\15\16\377\14\15\15\377\202\7\7\7\377m\20\22\23\377\34\37!\377"
  "\30\34\36\377\16\17\20\377\11\13\12\377\6\7\6\377\11\12\11\377\11\11\11\377"
  "\20\22\22\377147\377\16\16\17\377\11\11\11\377#$'\377\13\12\11\377\14\14"
  "\14\377\13\13\14\377\21\21\23\377\27\30\31\377%')\377\21\20\21\37736:\377"
  "\15\15\15\377\31\33\34\377\14\16\16\377\11\12\12\377\11\11\12\377\10\11\11"
  "\377\10\10\10\377\12\14\15\377\30\33\35\377\6\7\7\377\7\7\6\377\10\10\10"
  "\377\7\7\7\377\10\10\10\377\12\13\14\377\11\11\11\377\32\33\36\377\27\32"
  "\34\377\11\11\12\377\14\16\16\377\36%$\377\24\26\30\377\10\10\10\377\13\14"
  "\15\377\13\15\16\377\16\21\22\377\21\22\23\377\15\15\15\377\10\10\10\377"
  "\25\27\31\377ORW\377!\"&\377\10\12\13\377\12\15\16\377\17\21\22\377\16\16"
  "\17\377\13\14\14\377\22\24\25\377\10\11\12\377\24\26\26\377\15\17\17\377"
  "HLQ\377$&)\377\12\14\14\377\14\15\15\377\17\21\22\377\11\13\13\377\21\24"
  "\24\376\14\15\14\377\13\16\15\377\32\33\35\377\14\14\13\377\40$%\377\26\31"
  "\32\377\35\35\36\377\11\13\12\377\14\15\15\377#&(\377\40\40!\377\12\14\14"
  "\377\14\15\15\377\"&)\377.14\377\6\7\6\377\7\7\7\377\17\21\22\377\6\7\7\377"
  "\30\32\34\377\12\13\12\377\12\12\13\377\12\13\14\377\7\10\7\377\12\15\14"
  "\377\15\17\17\377\10\10\7\377\13\15\15\377\12\12\12\377\10\10\10\377\11\12"
  "\12\377\16\21\20\377\16\17\17\377\23\30\31\377\26\31\31\377\16\16\16\377"
  "\16\21\20\377\35\36!\377\30\32\33\377\10\10\7\377\202\12\13\14\377\10\11"
  "\13\13\377\15\17\16\377\7\10\11\377\31\36\37\377\12\14\14\377\13\15\15\377"
  "\12\14\14\377\10\12\12\377\202\10\11\11\377S\11\14\14\377\13\15\15\377\23"
  "\25\27\377\10\10\10\377\24\25\27\377**.\377\20\22\22\377\14\16\16\377\33"
  "\36\40\377\33\34\35\377\12\13\12\377\11\12\11\377\10\10\10\377\11\11\10\377"
  "\22\22\24\377\17\21\22\377\24\26\26\377=@D\377\16\20\20\377\10\10\7\377&"
  ")+\377()+\377\"\"&\377\11\11\11\377\20\21\22\377\10\11\11\377\26\26\27\377"
  "\11\10\7\377\14\14\13\377\13\13\13\377\12\12\12\377\10\10\10\377\10\7\7\377"
  "\11\12\12\377\11\11\11\377\24\25\26\377\25\26\27\377\6\6\6\377\6\7\7\377"
  "\14\15\15\37745;\377\14\15\16\377\6\7\7\377\12\14\15\377\10\11\10\377\17"
  "\21\20\377128\377\11\13\14\377\21\30\27\377\21\24\25\377\12\14\15\377\12"
  "\13\13\377\13\14\15\377\7\10\7\377\40#%\377\27\31\33\377)-/\377\16\20\21"
  "\377),0\377&)-\377\34\35!\377\13\13\14\377\11\11\12\377\10\11\11\377\22\24"
  "\24\377\24\27\31\377\13\15\15\377\15\17\17\377\34\36\40\377\34\37!\377(,"
  "0\377\13\15\15\377\7\7\7\377\12\11\12\377\40\"&\377\24\27\30\376\12\13\13"
  "\377\13\16\16\377\10\11\11\377\15\20\20\377GKQ\377\37\40!\377\11\11\10\377"
  "\202\15\17\17\377\177\11\12\11\377\14\15\15\377\10\11\11\377\32\34\36\377"
  "\10\12\12\377\7\10\7\377\10\12\12\377\13\15\15\377\10\12\11\377\13\14\14"
  "\377\7\7\7\377\23\24\25\377\16\21\21\377\12\14\15\377\26\31\32\377\13\15"
  "\15\377\20\22\23\377\33\34\35\377\7\7\7\377\10\10\10\377\10\10\7\377\10\10"
  "\10\377'*-\377\14\15\15\377\31\34\35\377\17\22\21\377\23\24\25\377\35!$\377"
  "\11\11\10\377\7\10\10\377\21\24\25\377\37\"%\377\20\22\22\377\12\13\13\377"
  "\26\30\31\377\15\17\20\377\22\23\25\377\7\11\11\377\10\12\11\377\10\11\11"
  "\377\13\14\15\377\40#%\377\7\10\7\377\35!#\377\21\23\24\377\10\7\7\377\10"
  "\11\10\377\17\21\21\377/23\377\30\31\33\377\20\22\21\377\12\12\12\377\17"
  "\22\23\377\21\23\22\377\7\7\7\377\12\13\14\377\27\31\31\377\27\33\33\377"
  "\10\12\12\377\36\40#\37759=\377\14\13\14\377\27\32\32\377\14\14\15\377\20"
  "\20\21\377\12\13\12\377*-.\377\11\11\10\377\14\13\12\377\13\12\11\37759:"
  "\377\15\15\15\377\15\16\20\377\13\13\13\377\22\25\26\377\17\21\22\377\11"
  "\12\12\377\21\23\24\377\12\13\14\377\7\7\6\377\11\12\13\377\15\15\16\377"
  "\16\17\21\377\15\17\20\377\16\16\20\377\15\16\16\377\20\22\23\377\13\14\16"
  "\377\27\31\34\377\16\21\22\377369\377\5\13\7\377\12\14\13\377\22\24\25\377"
  "\20\22\23\377\11\12\13\377\15\17\20\377\20\22\24\377\16\17\21\377359\377"
  "!%'\377\12\13\14\377\15\16\20\377\17\21\21\377\12\12\13\377\15\15\16\377"
  "\30\33\34\377\40$&\377\13\13\14\377(-1\377\36!$\377\14\15\16\377\21\24\25"
  "\377\22\22\23\377\12\14\15\377\11\12\12\377\7\10\7\377\10\11\11\377\37\""
  "$\376,/1\377\12\14\14\377\16\17\17\377\15\17\17\377\23\23\24\377\12\13\13"
  "\377\14\15\15\377\10\11\11\377\27\11\12\11\377\20\23\24\377\20\20\21\377"
  "\32\34\36\377\10\10\10\377\7\11\11\377\6\7\6\377\12\15\15\377\13\14\14\377"
  "\12\14\15\377\6\7\7\377\31\33\33\377\12\14\14\377\7\10\10\377\20\21\22\377"
  "\14\15\14\377\25\31\32\377\17\23\23\377\6\7\6\377\12\13\13\377\7\10\7\377"
  "\7\7\7\377\11\11\10\377\202\12\13\13\377\177\22\23\24\377\23\24\25\377\34"
  "\36\37\377\7\10\7\377\10\12\11\377\30\33\35\377\12\14\14\377&*-\377\12\13"
  "\13\377\6\7\6\377\31\34\36\377\14\15\16\377\7\10\10\377\10\11\11\377\25\26"
  "\30\377\24\27\30\377+-1\377\16\17\20\377\36\"$\377\14\15\16\377\12\13\13"
  "\377\13\14\15\377\12\13\14\377\20\22\23\377\32\34\35\377:>B\377\11\11\11"
  "\377\10\11\10\377\23\26\30\377\14\15\15\377\10\11\11\377)./\377?CH\377\11"
  "\13\13\377$(*\377\11\11\11\377\10\10\11\377\30\32\33\377\20\21\22\377\13"
  "\15\15\377\11\10\7\377\26\30\31\377\23\26\26\377\16\17\17\377\30\32\34\377"
  "\22\24\25\377\14\14\14\377\24\26\30\377\13\14\13\377\15\15\16\377\12\12\12"
  "\377\17\21\21\377\16\17\21\377\16\16\16\377\10\10\10\377\10\7\7\377\13\13"
  "\13\377\22\24\25\377\11\12\12\377\11\13\13\377\22\23\25\377\37!%\377\6\6"
  "\6\377\12\14\15\377\6\10\10\377\7\10\10\377\7\7\7\377\13\21\16\377\40#%\377"
  "\20\17\20\377\23\25\30\377\17\17\17\377\13\15\15\377\12\12\13\377\13\14\15"
  "\377\13\13\14\377\27\31\32\377\27\33\35\377\21\23\26\377\15\15\16\377\15"
  "\20\21\377/27\377\31\35\40\377\34\40!\377AEH\377\13\14\15\377\21\22\24\377"
  "\23\25\26\377\12\14\14\377\16\17\20\377\6\7\6\377\22\24\25\377\7\7\7\377"
  "\13\13\13\377*-/\376\13\12\12\377\20\23\24\377\17\21\22\377\10\10\10\377"
  "\11\11\7\377\30\33\35\377\17\22\23\377\16\20\17\377\16\20\20\377\20\21\22"
  "\377$%(\377\10\11\12\377\7\7\10\377\7\10\7\377\25\32\32\377\11\13\12\377"
  "\23\24\25\377\12\12\12\377\11\12\12\377\12\13\13\377\11\12\12\377\13\13\14"
  "\377\13\15\15\377\21\24\25\377\32\34\36\377\11\12\13\377\12\13\13\377\13"
  "\14\14\377\11\11\12\377\10\11\10\377\11\12\11\377\11\13\13\377k\7\10\6\377"
  "$%(\377\17\21\22\377\11\12\11\377\12\14\15\377\21\22\23\377\33\35\36\377"
  "\16\17\20\377\7\10\10\377\10\13\12\377\14\17\20\377\6\6\6\377\14\15\15\377"
  "\10\12\12\377\10\7\10\377\12\13\13\377\21\23\23\377\20\21\21\377\10\11\11"
  "\377\10\12\12\377\26\32\33\377\23\26\26\377\37#&\377\22\24\25\377\14\16\15"
  "\377\16\21\21\377\12\12\11\377\13\15\16\377\"%'\377\21\22\22\377\13\13\12"
  "\377\31\33\35\377\10\11\11\377\7\10\10\377\20\21\23\377\7\10\7\377)//\377"
  "\13\14\13\377\14\16\16\377\13\15\15\377\7\10\7\377\10\10\10\377\11\12\11"
  "\377\11\11\10\377\17\20\20\377\22\24\25\377\21\22\23\377\13\14\14\377\15"
  "\16\16\377\12\14\15\377\11\12\11\377\12\12\11\377\40\"$\377\23\24\26\377"
  "\12\12\12\377\10\11\11\377\21\23\24\377\21\21\23\377\15\16\17\377\15\15\16"
  "\377\10\11\12\377\11\13\14\377\15\15\15\377\12\13\14\377\7\7\10\377\11\11"
  "\12\377\10\10\10\377\13\15\16\377\17\27\24\377\17\21\22\377\36\40#\377\20"
  "\21\22\377\27\32\34\377\10\11\11\377\14\15\15\377\27\30\33\377\24\27\32\377"
  "\21\22\22\377(*/\377\11\12\12\377\13\14\14\377\16\21\23\377\35\40#\377\22"
  "\24\26\377\31\33\34\377!$%\377#&(\377\14\16\17\377\22\23\25\377\35\40\"\377"
  "\37\"#\377\20\22\23\377\14\15\16\377\25\27\30\377\24\30\31\377\20\22\21\376"
  "\16\21\17\37789=\377\21\22\22\377\31\32\33\377\12\13\13\377\13\15\14\377"
  "\20\22\22\377\27\30\31\377\7\10\10\377\14\16\16\377\10\10\7\377\202\7\10"
  "\7\377'\7\10\10\377\26\32\32\377LNS\377\11\12\11\377\25\31\33\377\37\37\""
  "\377\12\14\13\377\11\13\12\377\12\14\14\377\10\10\10\377\11\13\12\377\11"
  "\12\11\377\10\11\10\377\12\13\13\377\7\10\10\377\11\12\12\377\13\15\15\377"
  "\12\13\13\377\7\7\7\377\10\11\10\377\11\13\13\377\12\13\13\377\17\21\21\377"
  "\32\35\40\377\34\36\40\377\11\12\12\377\23\25\26\377\10\12\12\377\13\14\14"
  "\377\10\12\11\377\24\27\27\377\11\12\12\377\10\11\12\377\20\22\24\377\15"
  "\17\20\377\15\15\16\377\7\10\10\377\13\14\14\377\14\14\14\377\202\7\10\10"
  "\377\7\7\10\7\377\14\14\15\377\11\12\12\377\7\7\6\377\10\10\7\377\10\11\10"
  "\377\14\15\15\377\202\7\7\7\3773\10\12\12\377\15\16\16\377\14\15\16\377\13"
  "\14\14\377!#&\377\15\17\17\377\20\23\23\377\10\11\10\377\10\11\11\377\11"
  "\12\11\377\33\36\40\377\35\36\40\377\34\36\37\377\24\26\30\377\35\40#\377"
  "\34\37!\377\22\25\26\377\13\13\13\377\14\16\16\377\25\27\30\377),/\377\10"
  "\11\11\377\11\10\10\377\22\22\23\377\30\33\35\377\15\16\17\377\26\30\32\377"
  "\10\10\11\377\15\16\16\377\12\13\13\377\10\11\11\377\37\"%\377\13\14\15\377"
  "\14\15\15\377\11\12\12\377\17\22\23\377\15\16\20\377\15\24\21\377\15\17\17"
  "\377)/2\377\24\26\30\377\13\14\15\377!#&\377\11\12\12\377\30\31\33\377\36"
  "\37\"\377\13\14\14\377\20\21\22\377$'*\377\10\11\11\377\16\17\20\377\202"
  "\11\12\12\377\3\14\14\15\377\16\17\17\377\10\12\13\377\202\12\13\13\377>"
  "FIN\377%'+\377\7\7\10\377-/3\377*+/\377\32\36\37\377\32\35\36\3765:=\377"
  "\35\40\"\377\14\16\15\377-/2\377\13\15\15\377\10\10\10\377\13\14\13\377\11"
  "\12\11\377\12\12\11\377\6\6\5\377\12\13\14\377\10\11\10\377\7\11\11\377\12"
  "\14\14\377\20\22\22\377\16\21\21\377\33\37\40\377\13\13\12\377\13\15\15\377"
  "\10\12\11\377\23\26\27\377\21\22\24\377\7\7\7\377\12\14\14\377\11\13\11\377"
  "\10\11\10\377\10\11\12\377\13\14\15\377\10\11\11\377\6\7\6\377\7\7\6\377"
  "\12\13\13\377\10\11\11\377\11\11\11\377\12\12\11\377\34\40\"\377\36\40#\377"
  "\11\12\11\377\15\16\17\377\13\15\15\377\10\11\11\377\11\12\12\377\11\13\14"
  "\377\27\31\33\377\10\11\11\377\16\21\22\377049\377\32\33\34\377\10\10\10"
  "\377\37#%\377\31\33\35\377\15\17\17\377\27\32\33\377\32\33\34\377\14\16\17"
  "\377\202\11\11\11\377`\12\13\12\377\22\22\24\377\7\7\10\377\10\10\10\377"
  "\11\12\12\377\17\20\21\377\10\10\10\377\13\13\13\377\12\11\11\377\14\16\16"
  "\377\24\25\25\377\7\7\6\377\21\22\23\377\7\10\10\377\6\7\7\377\7\10\10\377"
  "\6\7\7\377\11\13\12\377\11\13\13\377\10\11\10\377\11\11\12\377\10\11\11\377"
  "\12\14\14\377\13\15\16\377\7\7\6\377\15\17\21\377\10\11\11\377\7\7\6\377"
  "\10\7\7\377\22\24\25\377\21\23\24\377\16\20\21\377\10\10\10\377\11\11\12"
  "\377\12\14\15\377\32\33\36\377\"%)\377\11\13\14\377\12\14\14\377\31\34\36"
  "\377\7\11\11\377\36\"#\377\13\15\15\377\5\15\10\377\33\35\37\377\31\33\36"
  "\377\31\34\36\377\13\14\16\377\36!$\377\12\13\13\377\16\16\17\377\13\14\15"
  "\377\24\25\26\377\32\34\35\377BGL\377\11\12\12\377\14\14\15\377\15\16\17"
  "\377%&)\377\13\15\16\377\34\36!\377\12\13\13\377\23\25\27\377'(+\377\7\11"
  "\11\377+.2\377\14\15\16\377148\377\31\35\37\377;>B\377\15\16\16\376\16\21"
  "\21\377\13\16\16\377\30\33\35\377\7\11\10\377\25\25\27\377\26\31\33\377\12"
  "\12\12\377\7\7\6\377\10\12\11\377\20\21\22\377\10\10\10\377\12\14\14\377"
  "\13\13\14\377-14\377\13\14\14\377\23\26\26\377$&(\377\13\16\16\377\7\10\10"
  "\377\13\14\14\377\17\17\21\377\30\33\35\377\16\21\21\377\10\10\7\377\11\13"
  "\12\377\202\12\13\13\377'\10\10\7\377\11\10\10\377\10\10\7\377\7\7\7\377"
  "\22\25\26\377\13\12\12\377\6\6\6\377\27\32\34\377\34\36\40\377\13\14\15\377"
  "\12\13\13\377\10\11\10\377\13\13\13\377\11\13\13\377\11\13\12\377\15\17\21"
  "\377\11\12\11\377\17\21\21\377\16\21\23\377\11\13\14\377\12\13\14\377\17"
  "\21\21\377\14\16\17\377\13\14\13\377\14\15\15\377\11\13\12\377\22\25\25\377"
  "\23\25\27\377\22\23\23\377\11\12\12\377\6\6\6\377\7\7\7\377\6\7\7\377\6\6"
  "\6\377\5\7\6\377\6\10\7\377\6\6\6\377\5\6\5\377\7\11\10\377\202\5\5\5\377"
  "\177\5\6\6\377\5\5\5\377\6\7\7\377\6\6\5\377\11\10\10\377\7\10\7\377\11\12"
  "\12\377\10\11\11\377\7\11\10\377\10\10\10\377\14\15\15\377\10\11\10\377\11"
  "\12\12\377\14\14\16\377\10\10\7\377\11\12\12\377\11\11\11\377\17\20\20\377"
  "+03\377+.2\377\24\25\25\377\20\21\21\377\17\17\20\377\12\12\12\377\30\32"
  "\34\377\20\21\22\377\11\10\10\377\16\20\20\377\14\17\20\377\10\12\11\377"
  "\17\21\22\377\11\11\11\377\10\17\14\377\13\15\15\377\25\26\27\377\30\32\34"
  "\377\31\32\35\377\10\11\12\377\13\14\16\377\11\11\11\377\10\10\10\377\23"
  "\25\27\377\21\24\26\377\7\7\10\377\12\15\15\377\40!$\377\11\12\13\377\16"
  "\20\20\377\12\14\14\377\6\7\7\377\12\14\15\377\11\14\15\377\10\11\11\377"
  "\23\24\25\377\17\20\21\377(,1\377\26\30\31\377.25\377\22\22\24\377\34\40"
  "!\376\23\25\27\377\17\21\22\377\13\15\15\377279\377\21\25\26\377'*,\377\12"
  "\13\13\377\14\15\15\377\12\14\14\377\7\11\10\377\21\21\21\377\7\10\7\377"
  "\14\16\17\377\11\10\10\377\40#'\377\30\31\33\377\7\7\7\377\10\11\11\377\7"
  "\10\10\377\10\11\10\377\20\24\25\377\14\15\15\377\13\15\15\377\11\12\12\377"
  "\10\11\10\377\15\20\20\377\33\34\37\377\11\11\10\377\13\14\14\377\15\16\17"
  "\377$(*\377\22\24\24\377\13\14\14\377\10\12\11\377\15\16\16\377\12\13\12"
  "\377\7\10\7\377\7\10\10\377\11\12\12\377\12\12\13\377\13\14\13\377\30\31"
  "\34\377\10\11\11\377\16\17\20\377\27\35\36\377\22\24\27\377\21\22\25\377"
  "'),\377\30\33\34\377\12\13\13\377\24\26\27\377\25\30\30\377\12\14\13\377"
  "\16\17\20\377\10\11\10\377\10\10\10\377\6\10\7\377\6\6\6\377\10\12\12\377"
  "\24\27\27\377+-0\377\7\11\11\377\6\7\7\377\14\16\16\377\11\12\11\377\5\6"
  "\5\377\7\10\10\377\177\15\20\21\377\10\10\10\377\15\16\20\377\12\13\13\377"
  "\21\22\23\377\6\7\7\377\27\31\32\377\10\10\11\377\10\10\10\377\7\7\7\377"
  "\5\6\6\377\6\6\6\377\11\13\14\377\13\13\13\377\33\36\37\377\7\6\7\377\12"
  "\12\12\377\10\11\11\377\15\16\16\377\20\21\22\377\16\16\20\377\14\17\20\377"
  "\10\12\12\377\6\7\7\377\7\10\10\377\10\11\11\377\5\6\6\377\16\21\21\377\11"
  "\12\13\377\37\"#\377\20\22\23\377\17\20\21\377!$'\377\5\16\11\377\14\16\17"
  "\377\22\24\25\377\34\36!\377+.1\377\23\25\27\377\14\16\20\377\10\11\12\377"
  "\16\21\22\377\12\13\13\377\7\10\10\377\12\13\13\377\14\15\16\377\21\21\23"
  "\377\14\15\16\377\13\14\14\377\11\12\12\377$+,\377\11\11\12\377\11\12\13"
  "\377\15\17\20\377,03\377137\377\25\27\27\377%'+\377\24\26\30\377\21\24\26"
  "\377+/1\376\16\20\20\377\23\26\26\377\20\23\23\377\33\37\40\377#$'\377\10"
  "\11\10\377\14\16\16\377\31\33\36\377\21\22\23\377\20\21\21\377\14\16\15\377"
  "\14\15\16\377\10\10\10\377\13\13\13\377\7\10\7\377\7\10\10\377\16\20\20\377"
  "\7\11\11\377\16\17\20\377\33\35\40\377\24\26\30\377\14\16\15\377\10\11\10"
  "\377\11\13\12\377\11\12\12\377\30\31\32\377\11\12\12\377\11\11\10\377\15"
  "\17\20\377\11\12\12\377\23\27\25\377\16\20\21\377\11\13\14\377\22\25\26\377"
  "\12\13\12\377\14\14\14\377\13\15\14\377\14\15\15\377\10\11\10\377\21\23\25"
  "\377\16\21\21\377\14\13\13\377\33\35\37\377\40\"#\377\11\12\12\377\31\35"
  "\37\377\12\12\13\377\7\11\10\377\10\11\11\377\10\10\10\377\10\11\10\377\14"
  "\16\16\377\12\14\14\377\13\15\15\377\12\13\13\377\7\10\7\377\10\11\11\377"
  "\7\7\7\377\16\20\21\377\7\7\6\377\6\7\7\377\6\7\6\377\7\7\7\377\12\14\13"
  "\377\10\10\10\377\6\7\7\377D\7\10\10\377\15\20\20\377\17\21\22\377\11\12"
  "\13\377\31\32\33\377\15\20\21\377\11\13\13\377\7\10\10\377\11\12\12\377\12"
  "\14\13\377\12\13\13\377\11\13\14\377\10\7\7\377\11\11\12\377\13\13\13\377"
  "\7\10\7\377\7\10\10\377\7\7\7\377\7\10\10\377\10\10\10\377\14\14\14\377\14"
  "\16\16\377\6\7\7\377\10\10\10\377\11\11\12\377\7\10\7\377\7\7\7\377\7\10"
  "\10\377\7\6\7\377\6\7\10\377\20\21\21\377\15\16\16\377\15\17\20\377\6\10"
  "\10\377\10\20\14\377\12\13\14\377\14\15\16\377\13\14\14\377\12\12\12\377"
  "\13\16\16\377\16\17\20\377\15\16\17\377\10\11\11\377\12\11\12\377\7\7\7\377"
  "\24\24\25\377\13\13\14\377\11\12\12\377\16\17\21\377\10\12\13\377\16\16\17"
  "\377\7\10\11\377\12\13\14\377\10\10\10\377\13\14\15\377\23\25\27\377\"#'"
  "\377\24\30\31\377\25\26\30\377\14\15\16\377\13\16\16\377\26\32\32\376\40"
  "#%\377\13\15\14\377\20\23\23\377\36!#\377\11\13\13\377\12\13\13\377\202\12"
  "\14\13\377\7\12\12\12\377\14\14\14\377\15\15\16\377\25\27\27\377\33\37\40"
  "\377\12\14\13\377\10\11\11\377\202\14\15\15\3776\13\13\14\377\15\16\16\377"
  "\14\17\20\377\11\12\12\377\7\10\7\377\11\11\10\377\10\11\10\377\10\11\11"
  "\377\11\14\14\377\10\12\11\377\15\17\17\377\27\32\32\377\21\23\24\377\21"
  "\23\23\377\11\13\13\377\16\17\20\377\6\6\6\377\5\5\5\377\4\4\4\377\6\7\6"
  "\377\5\5\5\377\23\24\25\377\22\24\25\377\17\20\21\377\25\27\31\377\23\25"
  "\27\377\22\25\26\377\25\31\32\377\36\40#\377\23\26\31\377\21\22\24\377\11"
  "\13\13\377$%)\377\15\16\16\377\16\20\21\377\14\15\15\377\10\12\12\377\7\11"
  "\11\377\7\10\7\377\17\22\23\377\10\11\11\377\14\14\15\377\11\13\12\377\7"
  "\7\7\377\33\36\40\377%'*\377\6\6\5\377\12\13\13\377\12\13\14\377\21\22\24"
  "\377\7\11\11\377\1\1\1\377\3\2\2\377\2\2\2\377\202\3\3\3\377\5\2\3\2\377"
  "\2\2\2\377\6\6\7\377\4\4\4\377\2\3\2\377\202\2\2\2\377\202\3\3\3\377\1\4"
  "\4\4\377\202\2\2\2\377\1\1\2\2\377\202\2\2\2\377\7\2\2\3\377\2\2\2\377\2"
  "\3\3\377\1\2\2\377\1\1\2\377\2\2\2\377\3\4\4\377\202\13\14\15\377F\6\7\10"
  "\377\4\5\4\377\3\4\3\377\3\11\6\377\10\12\12\377\23\24\26\377\10\11\11\377"
  "\16\20\21\377\7\10\10\377\11\13\14\377\6\6\6\377\4\4\4\377\4\5\5\377\3\4"
  "\5\377\5\5\5\377\7\7\10\377\5\5\5\377\6\6\6\377\34\34\37\377\6\7\7\377\7"
  "\7\10\377\11\12\12\377\5\6\6\377\11\13\13\377\14\17\20\377\17\21\21\377\16"
  "\16\16\377%'*\377\21\24\26\377\11\13\14\37727:\376013\377\10\12\11\377\14"
  "\15\15\377\10\11\10\377\23\23\24\377\13\16\16\377+/2\377\14\16\15\377\13"
  "\14\14\377\21\22\23\377\15\16\16\377-14\377\13\15\15\377\11\12\12\377\6\6"
  "\5\377\5\6\6\377\7\7\7\377\10\12\11\377\10\11\10\377\11\13\13\377\10\10\11"
  "\377\16\20\21\377\13\15\15\377\14\17\17\377\13\16\16\377\13\15\14\377\30"
  "\34\36\377\12\12\13\377\10\12\12\377\2\2\3\377\0\0\0\377\3\3\3\377\20\20"
  "\21\377\40\40!\377'')\377%&'\377\35\36\37\377\15\15\15\377\1\1\1\377\202"
  "\0\0\0\377\6\14\16\16\377\6\6\6\377\35!#\377\25\30\33\377\26\31\34\377\22"
  "\23\26\377\202\11\12\12\377\35\12\12\12\377\16\17\17\377\13\14\13\377\25"
  "\27\30\377\10\12\12\377\11\12\12\377\13\16\15\377\13\15\15\377\15\16\16\377"
  "\14\14\14\377\10\10\7\377\13\15\15\377\12\14\14\377\10\7\7\377\6\7\6\377"
  "\7\10\10\377\27\32\34\377\21\22\22\377\0\0\0\377LMN\377deg\377ddg\377eeg"
  "\377cdg\377deg\377deh\377ceg\377cdg\377ceg\377\202deh\377\22ddf\377deh\377"
  "dfh\377deg\377dfh\377efi\377efh\377dfh\377eeh\377efi\377efh\377efi\377eg"
  "i\377fgi\377;<=\377\5\6\6\377\5\6\7\377\26\27\27\377\204'()\377\1(()\377"
  "\205'()\377\1(()\377\204'()\377\1(()\377\202'()\377\2''(\377(()\377\202'"
  "()\377)()*\377\4\4\4\377\16\17\20\377\17\20\21\377\27\32\33\377\13\14\14"
  "\377\16\16\17\377\20\21\20\376\15\16\16\377%'*\377\10\13\13\377\13\15\15"
  "\377\20\23\24\37758=\377\12\14\13\377\16\16\17\377\27\31\31\377\11\11\10"
  "\377\40%&\377\22\24\24\377\12\12\11\377\13\15\14\377\36!\"\377\13\16\16\377"
  "\31\34\35\377\11\12\12\377\12\13\13\377\12\12\12\377\13\14\14\377\13\15\15"
  "\377\14\16\15\377\7\7\6\377\5\5\4\377\0\0\0\377\6\7\7\377=>?\377xxz\377\247"
  "\250\253\377\317\321\324\377\347\352\357\377\362\365\371\377\202\363\365"
  "\371\377\21\361\364\370\377\357\362\367\377\357\361\366\377\342\344\347\377"
  "\303\305\311\377\231\233\236\377hik\377,-/\377\2\2\2\377\6\7\7\377\4\4\4"
  "\377\10\11\12\377\11\12\13\377\7\12\11\377\10\11\11\377\10\10\7\377\7\10"
  "\10\377\202\6\7\7\377\20\5\6\5\377\10\10\10\377\13\13\12\377\13\13\13\377"
  "\7\7\7\377*.0\377\16\20\20\377\7\11\12\377\12\13\14\377\6\7\7\377\12\15\16"
  "\377\12\14\14\377\35\37!\377\0\0\0\377\261\263\270\377\352\354\361\377\202"
  "\351\353\360\377\5\350\353\361\377\350\353\360\377\350\352\360\377\351\354"
  "\362\377\350\352\360\377\203\351\353\361\377\1\351\352\360\377\202\351\354"
  "\361\377\6\352\355\362\377\353\355\363\377\353\355\362\377\353\356\363\377"
  "\353\355\363\377\352\355\362\377\202\354\356\363\377\10\354\356\364\377\355"
  "\357\364\377\355\357\363\377\213\214\217\377\1\1\1\377\1\1\2\377\212\213"
  "\216\377\357\361\366\377\202\357\362\367\377\15\360\363\367\377\357\362\367"
  "\377\360\363\370\377\357\361\366\377\356\361\366\377\360\363\370\377\361"
  "\363\367\377\357\362\367\377\357\362\366\377\360\362\366\377\357\361\366"
  "\377\357\361\367\377\361\362\367\377\202\357\362\367\377/\356\362\367\377"
  "\361\364\370\377\361\363\370\377\361\364\370\377\177\200\202\377\0\0\0\377"
  "\14\13\14\377\13\13\15\377\14\15\16\377\20\23\25\377\37#&\377\21\23\23\376"
  "\16\20\20\377\25\30\31\37759=\377\22\25\25\377\27\32\34\377\34\35\37\377"
  "\12\13\13\377\16\20\17\377\14\16\15\377!#%\377\24\26\27\377\10\11\10\377"
  "\13\15\15\377\17\20\20\377\15\17\17\377./1\377\10\11\11\377\14\14\13\377"
  "\13\14\14\377\20\21\21\377\16\20\21\377\11\12\11\377\1\1\1\377\5\6\6\377"
  "OOQ\377\244\245\250\377\351\352\355\377\364\366\372\377\362\365\371\377\362"
  "\364\371\377\361\364\371\377\361\363\370\377\360\362\370\377\360\362\367"
  "\377\357\361\366\377\202\356\361\366\3776\355\360\365\377\355\357\363\377"
  "\355\357\364\377\355\360\365\377\355\357\365\377\356\361\366\377\327\331"
  "\337\377\214\216\221\377889\377\1\1\1\377\2\2\1\377\11\11\11\377\10\10\7"
  "\377\7\7\7\377\6\7\6\377\7\7\7\377\11\12\13\377\21\22\23\377\14\15\15\377"
  "\7\11\11\377\10\10\7\377!#&\377\31\33\34\377\11\12\12\377\22\24\24\377\6"
  "\7\7\377\10\10\7\377\10\12\12\377&),\377\7\7\7\377\0\0\0\377\262\264\271"
  "\377\351\352\357\377\352\354\361\377\351\353\361\377\350\352\360\377\350"
  "\353\360\377\350\353\361\377\347\353\360\377\351\353\360\377\351\354\362"
  "\377\351\354\361\377\351\353\360\377\350\352\357\377\350\354\362\377\352"
  "\356\362\377\352\354\362\377\352\353\360\377\353\354\362\377\353\355\363"
  "\377\352\355\363\377\351\354\362\377\354\357\363\377\353\356\363\377\202"
  "\353\355\363\377\2\355\357\364\377\213\214\217\377\202\1\1\1\377\1\211\212"
  "\215\377\202\354\357\364\377\12\356\360\365\377\354\357\364\377\355\357\364"
  "\377\355\357\365\377\354\357\364\377\354\356\364\377\354\356\363\377\356"
  "\360\366\377\355\357\365\377\354\357\364\377\202\355\360\365\377\204\356"
  "\360\365\377$\355\360\366\377\356\360\365\377\357\362\367\377{{~\377\0\0"
  "\0\377\11\12\13\377\14\15\16\377\12\12\13\377\23\25\26\377\33\34\36\377\11"
  "\12\12\377\11\13\12\376\11\11\12\377\27\32\33\377\23\26\27\377@EG\377\14"
  "\15\16\377\13\14\13\377\21\23\23\377\14\14\14\377\25\30\32\377\20\20\20\377"
  "\15\14\12\377\11\12\11\377\14\14\14\377\12\12\11\377\12\13\13\377\12\13\12"
  "\377\12\12\12\377\16\20\20\377\13\14\13\377\7\10\7\377\1\1\1\377\22\22\23"
  "\377}}\177\377\337\341\344\377\202\364\366\372\377\4\363\365\371\377\363"
  "\364\371\377\361\364\371\377\361\363\370\377\202\360\363\370\377\1\357\362"
  "\367\377\202\360\362\367\377\3\356\361\366\377\360\362\367\377\356\360\365"
  "\377\202\355\357\364\377<\354\357\365\377\356\357\365\377\355\357\365\377"
  "\354\357\365\377\354\357\364\377\356\360\365\377\306\310\313\377_`b\377\6"
  "\6\6\377\1\1\1\377\5\5\5\377\7\10\10\377\10\11\11\377\6\7\7\377\33\36\40"
  "\377\10\12\11\377\14\14\13\377\12\13\13\377\11\12\11\377\10\11\11\377\23"
  "\25\25\377\5\6\6\377\10\10\10\377\26\30\31\377\30\32\34\377\7\10\10\377\10"
  "\10\11\377\0\0\0\377\261\264\270\377\351\353\360\377\351\353\361\377\350"
  "\353\361\377\350\353\360\377\351\354\361\377\351\353\361\377\350\353\361"
  "\377\352\354\363\377\351\354\361\377\350\352\357\377\351\353\361\377\351"
  "\354\362\377\350\354\361\377\352\355\362\377\352\353\357\377\352\355\362"
  "\377\351\353\360\377\352\354\362\377\353\355\363\377\353\356\363\377\353"
  "\355\363\377\351\354\362\377\351\354\361\377\352\355\363\377\352\355\362"
  "\377\212\213\216\377\1\1\2\377\1\1\1\377\212\213\216\377\355\360\364\377"
  "\354\357\364\377\202\355\357\365\377\6\355\357\364\377\355\357\365\377\354"
  "\356\364\377\354\357\364\377\355\360\365\377\357\361\366\377\202\356\360"
  "\365\377\13\355\360\365\377\354\357\364\377\355\360\365\377\356\360\365\377"
  "\355\360\365\377\356\360\366\377\355\360\366\377\357\361\367\377xy|\377\0"
  "\0\0\377\10\10\11\377\202\10\11\11\377\35\12\14\16\377\14\15\16\377\13\14"
  "\15\377\12\13\13\377\13\14\13\376\13\14\14\377\15\17\17\377\25\30\31\377"
  "\22\24\23\377\12\14\14\377\22\24\24\377\12\14\13\377\32\36\40\377\34\35\36"
  "\377\13\14\13\377\12\13\13\377\22\24\25\377\13\13\13\377\15\15\14\377\22"
  "\22\22\377\16\17\17\377,/1\377\31\33\33\377\2\2\2\377\12\12\12\377{|~\377"
  "\351\352\356\377\364\365\372\377\362\365\371\377\202\363\365\371\377\202"
  "\362\364\371\377\203\361\363\370\377\11\360\363\370\377\357\362\367\377\357"
  "\361\366\377\356\361\365\377\360\362\366\377\357\361\366\377\355\360\364"
  "\377\355\357\365\377\356\357\364\377\202\354\357\365\377\2\354\360\365\377"
  "\354\357\365\377\202\354\357\364\377\30\353\356\363\377\354\356\363\377\321"
  "\323\330\377XY\\\377\1\1\1\377\3\3\4\377\12\13\14\377\25\31\32\377\10\12"
  "\12\377\11\13\13\377\16\17\17\377\12\13\13\377\7\10\10\377\23\24\24\377\7"
  "\10\7\377\6\7\6\377\12\12\12\377\23\24\25\377\10\11\10\377\25\27\31\377\20"
  "\20\21\377\0\0\0\377\261\263\267\377\352\354\361\377\202\350\353\361\377"
  "\3\351\354\362\377\350\352\360\377\350\353\361\377\202\352\354\362\377\202"
  "\351\353\361\377\4\353\355\362\377\352\354\362\377\347\353\360\377\350\354"
  "\361\377\202\352\354\362\377\4\354\355\363\377\352\355\362\377\351\354\362"
  "\377\352\355\362\377\202\352\354\362\377\4\352\354\363\377\353\356\364\377"
  "\353\355\363\377\212\214\217\377\202\1\1\1\377\1\211\212\215\377\202\354"
  "\356\364\377\12\355\360\365\377\354\356\363\377\354\357\364\377\354\357\365"
  "\377\354\357\364\377\355\357\364\377\355\360\365\377\355\357\364\377\356"
  "\360\365\377\355\360\365\377\202\356\360\365\377\203\355\360\365\377\"\356"
  "\360\366\377\357\362\370\377uvy\377\0\0\0\377\10\11\11\377\12\13\13\377\12"
  "\13\14\377\10\13\14\377\17\23\25\377\14\14\15\377\13\12\12\377\23\25\26\377"
  "\16\17\17\376\20\21\21\377\20\21\22\377\15\15\14\377\12\13\13\377\25\27\27"
  "\377\12\15\15\377\13\15\16\377\35\37\40\377\12\12\12\377\23\26\26\377\31"
  "\32\34\377\11\11\11\377\13\14\14\377\14\14\14\377\14\15\15\377\17\21\21\377"
  "\30\30\31\377\0\0\0\377KLM\377\332\333\337\377\364\366\373\377\202\363\365"
  "\372\377\13\363\365\371\377\362\363\367\377\362\364\370\377\361\364\371\377"
  "\362\364\371\377\360\363\370\377\362\364\371\377\361\363\370\377\361\362"
  "\367\377\356\361\366\377\355\361\365\377\202\357\362\367\377(\355\360\365"
  "\377\356\360\366\377\357\360\365\377\356\360\365\377\355\360\365\377\355"
  "\357\365\377\354\357\364\377\355\357\365\377\355\357\364\377\352\356\363"
  "\377\353\356\363\377\354\357\363\377\355\357\364\377\353\356\362\377\271"
  "\273\277\377)*+\377\0\1\1\377\26\27\32\377\12\14\14\377\24\25\26\377\11\11"
  "\11\377\13\14\14\377(*-\377\13\13\12\377\10\10\10\377\26\31\32\377\34\34"
  "\36\377\12\13\13\377\14\16\17\377\35\40\"\377\31\33\35\377\0\0\0\377\262"
  "\263\270\377\352\354\361\377\352\354\362\377\350\353\361\377\352\354\362"
  "\377\351\353\361\377\347\352\360\377\350\353\361\377\202\351\353\362\377"
  "\5\351\354\362\377\350\354\361\377\352\354\362\377\350\353\360\377\351\354"
  "\361\377\203\352\354\362\377\11\353\355\363\377\352\354\362\377\353\354\362"
  "\377\354\356\363\377\353\356\364\377\353\355\363\377\353\356\363\377\353"
  "\355\363\377\213\214\217\377\202\1\2\2\377\10\211\212\215\377\355\357\365"
  "\377\353\356\364\377\356\360\365\377\353\356\363\377\354\357\364\377\355"
  "\357\365\377\354\357\364\377\202\355\360\365\377\202\355\357\365\377\2\355"
  "\360\364\377\355\360\366\377\202\356\360\365\3773\356\360\366\377\356\361"
  "\366\377\357\361\367\377stw\377\0\0\0\377\10\12\11\377\12\12\12\377\14\15"
  "\15\377\15\16\20\377\21\23\24\377\15\17\20\377\14\15\15\377\16\16\20\377"
  "\13\14\14\377&+.\376\30\31\33\377\35\37!\377\12\12\12\377\12\13\12\377\12"
  "\15\15\377,/4\377\26\30\32\377\14\15\15\377\26\30\30\37778;\377\11\11\11"
  "\377\13\16\16\377\12\13\13\377\12\14\13\377\16\17\17\377\4\5\5\377\13\13"
  "\13\377\232\232\234\377\365\367\373\377\363\364\372\377\363\365\372\377\363"
  "\366\372\377\363\365\371\377\363\364\371\377\362\363\370\377\361\363\370"
  "\377\361\364\370\377\361\364\371\377\361\362\370\377\361\363\370\377\360"
  "\363\367\377\357\362\367\377\356\361\366\377\357\361\365\377\357\361\367"
  "\377\356\361\365\377\203\356\360\365\377/\356\361\365\377\356\360\365\377"
  "\355\360\365\377\354\357\365\377\354\356\364\377\355\357\364\377\353\356"
  "\364\377\355\357\364\377\354\356\363\377\355\357\364\377\353\356\363\377"
  "\353\356\364\377\345\347\355\377klo\377\1\1\1\377\10\12\12\377\15\16\16\377"
  "\11\12\11\377\37#%\377\20\20\20\377\10\11\10\377\12\12\12\377\14\15\15\377"
  "\10\11\12\377\15\17\17\377\26\30\32\377\36\40\"\377\12\12\13\377\0\0\0\377"
  "\261\263\270\377\352\354\361\377\351\353\361\377\351\353\362\377\351\354"
  "\361\377\351\353\360\377\350\352\360\377\350\353\360\377\350\352\361\377"
  "\351\353\360\377\351\353\361\377\350\352\361\377\347\352\360\377\351\354"
  "\361\377\352\355\362\377\352\354\362\377\350\353\361\377\350\352\360\377"
  "\202\352\355\362\377\3\351\355\363\377\352\355\363\377\354\356\364\377\202"
  "\353\355\363\377\7\353\356\363\377\213\214\217\377\1\1\1\377\2\3\3\377\212"
  "\213\216\377\355\360\365\377\355\357\365\377\202\354\357\364\377$\355\357"
  "\364\377\355\360\365\377\354\357\365\377\355\357\365\377\355\360\365\377"
  "\355\357\365\377\356\360\365\377\356\360\366\377\355\357\365\377\356\360"
  "\365\377\355\360\365\377\356\361\366\377\357\361\367\377qqu\377\0\0\0\377"
  "\23\25\27\377\16\17\21\377\27\33\35\377\17\22\24\377\23\26\30\377\12\13\13"
  "\377\16\14\14\377\12\12\12\377\15\17\17\377\12\12\13\377:AD\376HKN\377\10"
  "\10\7\377\13\14\13\377\12\13\14\377\26\27\31\377\22\23\25\377\13\14\13\377"
  "\35!\"\377)+-\377\15\16\17\377\202\14\15\15\377\7\20\22\23\377\16\17\17\377"
  "\4\3\3\377###\377\315\316\321\377\364\366\372\377\362\364\371\377\202\364"
  "\366\372\377\5\363\365\372\377\362\364\371\377\363\364\371\377\362\364\371"
  "\377\362\363\367\377\202\361\363\370\377\1\362\363\370\377\202\360\362\367"
  "\377\1\360\363\367\377\202\355\360\365\3777\356\360\366\377\355\357\363\377"
  "\355\360\365\377\355\357\364\377\356\360\365\377\355\357\364\377\356\357"
  "\365\377\355\357\364\377\353\355\363\377\354\357\364\377\354\356\364\377"
  "\355\357\364\377\354\356\363\377\354\356\362\377\354\356\363\377\353\356"
  "\363\377\354\356\363\377\354\355\363\377\354\356\364\377\244\246\252\377"
  "\13\14\14\377\3\3\2\377\20\21\22\377\20\20\20\377\13\14\15\377\10\12\12\377"
  "\16\17\20\377\15\16\17\377\16\17\20\377INR\377\15\15\16\377\11\12\12\377"
  "\12\12\12\377\0\0\0\377\262\264\271\377\352\355\362\377\351\353\361\377\350"
  "\352\360\377\350\353\361\377\351\353\361\377\350\352\360\377\350\354\361"
  "\377\347\352\360\377\347\352\357\377\350\353\360\377\351\354\362\377\350"
  "\352\360\377\350\353\360\377\351\355\362\377\352\354\362\377\347\351\357"
  "\377\351\353\362\377\351\355\363\377\352\354\362\377\351\354\362\377\202"
  "\353\356\363\377\4\354\356\363\377\354\356\364\377\353\356\363\377\213\215"
  "\220\377\202\1\1\1\377\7\211\213\215\377\354\357\364\377\355\356\364\377"
  "\355\357\365\377\354\356\364\377\354\357\364\377\354\356\363\377\203\355"
  "\360\364\377+\356\360\365\377\355\357\364\377\355\357\365\377\354\357\365"
  "\377\356\361\365\377\356\360\365\377\357\362\367\377nor\377\1\2\2\377\11"
  "\13\14\377\14\16\16\377\12\13\13\377\13\14\16\377\16\17\20\377\13\14\14\377"
  "\12\11\11\377\13\13\12\377\12\12\12\377\14\14\14\377\25\27\30\377\23\24\25"
  "\376\14\14\15\377\11\11\11\377\11\12\12\377\23\24\26\377\31\34\35\377\21"
  "\22\22\377\14\15\15\377\32\34\35\377\14\16\15\377\13\14\14\377\12\14\14\377"
  "\14\17\17\377\17\17\17\377\1\1\2\37799:\377\343\345\350\377\364\366\372\377"
  "\364\366\373\377\363\365\372\377\364\366\373\377\364\365\372\377\363\365"
  "\372\377\202\363\365\371\377\32\362\364\370\377\362\363\371\377\361\362\367"
  "\377\360\362\367\377\357\361\366\377\360\362\367\377\357\361\366\377\357"
  "\362\367\377\357\361\366\377\355\360\365\377\356\360\366\377\355\360\365"
  "\377\355\357\365\377\355\360\365\377\356\360\366\377\355\357\364\377\354"
  "\356\363\377\355\357\365\377\353\356\364\377\352\355\363\377\354\356\364"
  "\377\353\355\363\377\353\355\362\377\354\356\363\377\355\357\364\377\354"
  "\356\364\377\202\354\356\363\377\35\354\356\364\377\354\356\363\377\301\303"
  "\307\377\30\30\31\377\2\2\2\377\11\11\11\377\10\10\10\377\15\17\17\377\15"
  "\17\20\377\14\15\15\37736:\377\12\13\12\377\12\12\12\377\12\11\11\377\10"
  "\11\11\377\0\0\0\377\262\265\271\377\350\353\361\377\350\353\360\377\351"
  "\353\361\377\347\352\360\377\350\353\361\377\351\353\361\377\350\353\360"
  "\377\351\353\361\377\351\353\360\377\347\351\357\377\352\354\361\377\351"
  "\354\362\377\202\350\354\361\377\14\351\353\360\377\351\354\362\377\352\354"
  "\361\377\351\355\363\377\351\354\362\377\353\356\363\377\352\355\363\377"
  "\351\355\362\377\353\355\362\377\353\356\363\377\353\355\363\377\213\214"
  "\217\377\202\1\2\2\377\4\212\213\216\377\356\360\365\377\354\356\365\377"
  "\355\357\365\377\203\355\357\364\377\23\355\357\365\377\355\360\365\377\355"
  "\360\364\377\355\360\365\377\355\357\365\377\356\360\365\377\355\360\365"
  "\377\356\360\365\377\356\360\366\377lmp\377\0\0\0\377\24\25\30\377\12\13"
  "\13\377\20\22\24\377\13\15\15\377\11\12\12\377\15\16\16\377\13\13\13\377"
  "\13\12\12\377\202\11\11\11\377\30\13\13\13\37725:\377\16\16\16\376\13\13"
  "\13\377!#$\377\21\24\25\377\16\17\17\377\16\16\16\377\12\14\13\3775:=\377"
  "\25\30\31\377\15\20\17\377\15\16\17\377\15\17\17\377\15\16\16\377\1\2\2\377"
  "?@A\377\353\355\361\377\365\367\373\377\364\366\372\377\365\366\373\377\365"
  "\366\372\377\364\366\372\377\362\365\371\377\204\362\364\371\377\202\361"
  "\362\370\377\202\357\361\366\377\7\361\362\367\377\357\362\366\377\356\360"
  "\366\377\355\360\365\377\356\361\366\377\356\360\365\377\353\355\363\377"
  "\202\353\356\363\377\2\355\360\365\377\355\357\364\377\202\354\357\364\377"
  "\4\353\356\363\377\353\355\363\377\354\356\364\377\353\357\364\377\202\353"
  "\355\363\377\5\354\356\363\377\353\356\363\377\353\355\363\377\354\355\363"
  "\377\354\356\363\377\202\352\354\362\377\16\315\316\324\377\34\34\35\377"
  "\2\2\2\377\12\13\14\377\7\7\7\377\10\7\7\377\22\23\25\377\12\13\12\377\10"
  "\10\10\377\11\11\11\377\10\10\11\377\10\11\11\377\0\0\0\377\262\264\270\377"
  "\202\351\353\361\377G\350\352\360\377\350\353\357\377\351\354\362\377\350"
  "\352\360\377\351\354\362\377\352\354\362\377\351\353\361\377\351\354\361"
  "\377\351\353\361\377\351\354\361\377\350\353\361\377\351\354\361\377\351"
  "\353\361\377\351\354\362\377\350\353\361\377\352\355\362\377\352\354\362"
  "\377\351\354\362\377\352\354\363\377\352\355\362\377\352\355\361\377\354"
  "\356\363\377\354\357\364\377\212\214\217\377\1\2\2\377\2\2\3\377\212\213"
  "\216\377\354\357\364\377\353\356\363\377\354\357\364\377\355\360\365\377"
  "\354\357\363\377\354\357\364\377\354\357\365\377\354\357\363\377\355\360"
  "\365\377\356\360\364\377\356\360\365\377\356\360\364\377\356\360\365\377"
  "\357\362\367\377ikm\377\0\0\0\377\12\14\16\377\14\15\16\377\17\20\21\377"
  "\13\14\15\377\15\16\17\377\14\17\20\377\13\13\13\377\10\11\11\377\25\26\26"
  "\377\10\10\10\377\17\17\20\377\12\14\15\377\16\20\20\377\40#%\376\33\37!"
  "\377\37#%\377\33\35!\377\14\14\14\377\11\12\12\377\12\13\14\37758<\377\31"
  "\31\32\377158\377\15\17\17\377\33\34\36\377\3\3\3\37789:\377\353\355\357"
  "\377\202\364\366\373\377\6\364\365\372\377\364\366\373\377\365\366\373\377"
  "\364\365\372\377\363\365\372\377\361\364\371\377\202\361\363\370\377\5\360"
  "\362\367\377\357\362\367\377\360\363\370\377\360\362\370\377\357\362\367"
  "\377\202\360\362\367\377\5\357\361\367\377\356\361\366\377\356\360\366\377"
  "\355\357\365\377\352\355\363\377\202\353\356\364\377\202\355\357\364\377"
  "\3\354\356\364\377\355\357\364\377\353\356\363\377\202\353\356\364\377\30"
  "\353\356\363\377\353\355\363\377\354\356\363\377\352\356\363\377\354\356"
  "\364\377\353\356\363\377\353\354\362\377\353\355\363\377\352\355\362\377"
  "\352\354\362\377\351\354\361\377\312\314\321\377\25\25\26\377\3\3\3\377\7"
  "\10\7\377\25\27\30\377\15\17\17\377\10\11\11\377\14\14\14\377\7\7\7\377\10"
  "\11\12\377\11\12\12\377\0\0\0\377\262\264\270\377\202\351\353\361\377\20"
  "\351\354\361\377\351\353\361\377\351\354\362\377\351\354\361\377\351\355"
  "\362\377\351\354\362\377\350\352\361\377\351\354\361\377\351\353\361\377"
  "\350\352\360\377\351\354\361\377\351\355\361\377\350\353\360\377\351\354"
  "\362\377\352\354\363\377\351\355\362\377\202\353\355\363\377\22\353\356\363"
  "\377\353\356\362\377\352\355\363\377\354\356\364\377\353\356\363\377\213"
  "\214\217\377\1\1\1\377\2\1\2\377\212\213\216\377\355\360\365\377\352\355"
  "\363\377\353\356\364\377\355\357\365\377\354\357\365\377\354\357\364\377"
  "\354\360\365\377\355\357\364\377\355\360\364\377\202\356\360\365\377!\355"
  "\357\364\377\357\361\366\377hik\377\0\0\0\377\6\7\7\377\17\21\21\377#%'\377"
  "\13\15\16\377\17\17\20\377\13\14\14\377\22\23\25\377\13\15\16\377\17\17\21"
  "\377\11\12\12\377\14\14\15\377\12\12\12\377\12\13\14\377\12\12\13\37769="
  "\376=BE\377\34\35\37\377\16\20\20\377\21\23\24\3777;?\377\11\13\12\377\12"
  "\12\12\377\27\31\33\377\21\22\23\377\33\40#\377\7\7\10\377\"##\377\343\344"
  "\350\377\364\366\372\377\202\363\365\372\377\2\363\366\372\377\364\366\372"
  "\377\202\363\365\372\377\2\362\364\371\377\361\364\371\377\202\361\363\370"
  "\377\2\360\362\367\377\356\361\366\377\202\360\362\367\377\203\357\361\366"
  "\377\202\357\362\367\377\1\357\361\366\377\202\353\356\364\377\12\355\357"
  "\365\377\354\356\364\377\355\357\365\377\355\357\364\377\352\355\363\377"
  "\353\355\364\377\352\355\362\377\354\356\364\377\353\355\363\377\352\355"
  "\363\377\202\353\356\363\377\6\353\355\362\377\352\355\362\377\353\355\363"
  "\377\352\354\362\377\354\356\364\377\352\355\362\377\203\352\354\362\377"
  "\22\272\275\301\377\10\10\10\377\6\7\10\377\11\13\13\377\14\15\15\377#$'"
  "\377\7\7\10\377\7\11\11\377\10\11\11\377\13\13\14\377\0\0\0\377\262\264\270"
  "\377\350\353\361\377\350\353\360\377\350\353\361\377\347\352\357\377\351"
  "\354\361\377\352\355\362\377\202\351\353\361\377\12\351\354\362\377\350\353"
  "\361\377\351\354\361\377\350\353\361\377\350\354\361\377\351\354\362\377"
  "\351\353\361\377\351\354\362\377\352\355\362\377\353\355\362\377\202\353"
  "\355\363\377\1\353\356\363\377\202\353\355\363\377\3\354\356\364\377\354"
  "\357\364\377\213\214\217\377\202\1\1\1\377,\212\213\216\377\356\360\366\377"
  "\354\356\364\377\354\357\364\377\355\357\364\377\354\357\364\377\355\357"
  "\365\377\354\356\363\377\354\357\363\377\355\360\364\377\356\361\366\377"
  "\357\361\366\377\356\360\365\377egi\377\0\0\0\377\7\10\7\377\17\17\20\377"
  "'),\377\15\14\15\377\14\15\15\377$&(\377\32\33\35\377\14\15\16\377\14\16"
  "\17\377\11\13\13\377')+\377\15\17\20\377\14\15\17\377\14\14\15\377\15\16"
  "\15\377\21\23\23\376\26\30\31\377\16\20\20\377\17\20\20\377!$&\377\36\37"
  "\"\377!%'\377\23\25\25\377\11\12\11\377\20\21\21\377\14\16\17\377\12\12\12"
  "\377\313\315\320\377\362\365\372\377\203\363\365\372\377\1\362\365\371\377"
  "\202\363\365\372\377\1\362\364\370\377\202\362\364\371\377\203\360\362\367"
  "\377\12\356\361\366\377\357\361\366\377\360\361\366\377\357\361\366\377\355"
  "\360\366\377\360\362\366\377\356\361\366\377\360\362\366\377\357\361\367"
  "\377\354\357\365\377\202\354\357\364\377'\356\360\364\377\355\360\364\377"
  "\354\356\364\377\353\356\364\377\354\357\364\377\351\355\362\377\352\355"
  "\363\377\353\355\363\377\352\355\362\377\354\356\364\377\352\355\362\377"
  "\353\355\362\377\353\355\363\377\353\356\364\377\354\356\364\377\352\354"
  "\362\377\353\356\363\377\353\354\362\377\352\354\363\377\352\355\362\377"
  "\352\355\363\377\226\230\234\377\0\0\0\377\7\6\6\377\13\13\13\377\7\7\7\377"
  "\14\15\16\377\11\12\12\377\15\20\20\377\13\12\13\377\0\0\0\377\263\264\271"
  "\377\350\353\361\377\352\353\361\377\350\352\360\377\351\353\361\377\350"
  "\352\360\377\351\354\361\377\352\354\362\377\202\351\353\361\377\6\351\354"
  "\362\377\351\353\362\377\350\353\361\377\352\355\362\377\351\355\362\377"
  "\351\354\362\377\202\351\354\361\377\14\352\355\362\377\353\356\364\377\352"
  "\355\361\377\352\355\363\377\354\356\364\377\354\357\364\377\355\357\365"
  "\377\354\356\363\377\214\215\217\377\2\2\2\377\2\2\3\377\210\212\215\377"
  "\202\354\357\364\377\2\355\357\365\377\354\357\365\377\202\355\357\365\377"
  "\20\356\360\366\377\355\360\365\377\356\360\365\377\355\360\365\377\356\360"
  "\366\377bce\377\0\0\0\377\6\7\10\377\17\20\22\377\31\33\36\377\15\15\16\377"
  "\27\27\30\377\25\26\30\377\22\24\25\377\13\14\14\377\12\12\12\377\202\14"
  "\15\16\377\35\11\12\11\377\14\15\15\377\12\13\13\377\20\22\24\377\25\27\27"
  "\377\17\21\21\376\15\16\15\377\22\25\25\37749>\377\23\21\22\377\17\21\22"
  "\377\35#$\377BCH\377\13\15\14\377\16\16\16\377\0\0\0\377\226\230\232\377"
  "\364\366\373\377\363\366\373\377\363\365\371\377\363\365\372\377\363\365"
  "\371\377\362\364\371\377\362\363\371\377\363\365\372\377\362\365\371\377"
  "\361\363\370\377\361\363\367\377\357\362\367\377\202\360\362\367\377\1\356"
  "\361\367\377\202\357\361\366\377\21\360\362\367\377\356\360\366\377\356\361"
  "\366\377\357\361\366\377\357\362\367\377\355\357\365\377\357\360\366\377"
  "\355\360\365\377\354\356\364\377\354\357\365\377\356\360\365\377\356\356"
  "\364\377\354\356\363\377\354\356\364\377\351\354\362\377\353\356\364\377"
  "\354\356\363\377\202\352\355\363\377\5\353\355\363\377\353\356\363\377\354"
  "\356\364\377\353\356\363\377\353\355\363\377\202\353\355\362\377Y\352\354"
  "\362\377\351\353\361\377\351\354\362\377\352\354\362\377\353\355\363\377"
  "XY[\377\1\1\1\377\10\10\10\377\10\11\11\377\10\11\10\377\13\12\12\377\14"
  "\14\14\377\13\14\15\377\0\0\0\377\262\264\271\377\351\353\361\377\352\354"
  "\360\377\351\354\362\377\350\353\360\377\351\354\361\377\351\353\361\377"
  "\353\355\362\377\352\354\363\377\351\353\361\377\352\354\362\377\347\352"
  "\360\377\351\354\361\377\347\352\360\377\351\355\361\377\351\353\361\377"
  "\350\353\361\377\352\354\362\377\352\356\363\377\352\355\363\377\351\354"
  "\361\377\353\356\364\377\354\356\363\377\353\355\363\377\353\355\364\377"
  "\354\356\364\377\213\215\220\377\2\2\2\377\2\2\3\377\211\212\216\377\356"
  "\360\365\377\354\360\365\377\354\357\364\377\353\356\364\377\354\356\363"
  "\377\354\357\365\377\356\360\365\377\355\360\365\377\356\360\365\377\355"
  "\360\364\377_`c\377\0\0\0\377\14\14\15\377\17\17\20\377\20\20\21\377\12\12"
  "\12\377\14\13\14\377\32\35\37\377\14\15\16\377\12\13\13\377\10\11\11\377"
  "9<@\377\13\14\15\377\10\11\12\377\12\12\14\377\10\11\10\377\17\20\20\377"
  "\23\26\30\377\13\15\15\377\16\17\17\376\16\16\15\377\14\15\15\377\34\37\40"
  "\377+.1\377\21\22\22\377\33\35\37\377\15\16\15\377\32\37\40\377\6\7\7\377"
  "GHI\377\364\366\372\377\363\366\372\377\363\365\372\377\363\364\371\377\362"
  "\365\371\377\202\361\364\371\377\202\362\364\371\377\24\362\363\370\377\361"
  "\364\370\377\361\363\370\377\361\363\367\377\360\362\367\377\361\363\370"
  "\377\357\362\367\377\356\361\367\377\356\360\366\377\360\362\367\377\356"
  "\360\366\377\356\361\366\377\356\362\366\377\357\362\367\377\355\360\366"
  "\377\355\357\365\377\356\361\365\377\356\360\366\377\356\361\366\377\355"
  "\357\365\377\202\355\357\364\377\10\354\357\364\377\351\354\363\377\352\355"
  "\363\377\353\356\364\377\352\355\362\377\352\354\362\377\352\355\363\377"
  "\353\355\362\377\202\352\355\362\377\5\353\355\363\377\353\354\362\377\352"
  "\354\362\377\352\355\363\377\351\354\362\377\203\350\353\361\377\20\337\341"
  "\346\377\31\32\33\377\10\10\11\377\10\10\10\377\11\10\10\377\7\7\7\377\16"
  "\21\23\377\16\20\21\377\0\0\0\377\262\264\271\377\352\354\361\377\350\353"
  "\360\377\352\354\362\377\347\352\357\377\351\354\361\377\352\355\362\377"
  "\202\352\354\362\377\1\351\353\361\377\202\350\353\361\377\5\351\354\361"
  "\377\350\354\362\377\351\355\361\377\351\353\361\377\352\355\363\377\202"
  "\352\355\362\377#\351\354\362\377\352\355\363\377\353\355\362\377\354\356"
  "\364\377\354\357\364\377\355\356\364\377\354\357\364\377\213\215\220\377"
  "\2\2\2\377\3\3\3\377\212\213\215\377\355\360\365\377\355\357\364\377\354"
  "\357\364\377\353\356\363\377\354\357\365\377\355\357\365\377\355\357\364"
  "\377\355\360\365\377\354\357\364\377\\^_\377\2\2\3\377\15\16\16\377\14\16"
  "\17\377\26\30\32\377\13\13\13\377\16\16\16\377\22\23\24\377\15\16\16\377"
  "\11\11\11\377\13\13\14\377\14\15\15\377\25\31\32\377\25\27\31\377\7\7\7\377"
  "\202\11\12\12\377\23\12\13\13\377\13\14\16\377\16\17\20\377\17\21\21\376"
  "\15\17\17\377\23\26\26\377\15\17\20\377\15\16\16\37759<\377\14\14\15\377"
  "\13\15\14\377\30\33\34\377\11\11\11\377\327\331\334\377\363\365\371\377\363"
  "\366\372\377\364\366\373\377\362\364\370\377\362\365\371\377\202\362\364"
  "\371\377\34\362\364\370\377\360\364\371\377\362\364\371\377\360\362\370\377"
  "\361\363\370\377\360\363\370\377\361\363\366\377\361\363\370\377\360\362"
  "\370\377\357\362\366\377\357\361\367\377\357\361\366\377\356\360\365\377"
  "\356\361\366\377\357\361\366\377\356\361\366\377\355\360\366\377\355\357"
  "\365\377\355\360\366\377\354\356\363\377\356\360\365\377\355\357\364\377"
  "\353\357\364\377\354\357\365\377\353\355\364\377\353\356\364\377\353\355"
  "\364\377\352\355\363\377\202\352\355\362\377\202\353\355\363\377\4\352\355"
  "\363\377\352\355\362\377\353\355\363\377\352\355\363\377\202\352\354\362"
  "\377\1\351\354\362\377\203\352\354\362\377\26\352\355\362\377\241\243\246"
  "\377\0\0\0\377\11\10\11\377\12\12\13\377\7\7\10\377\27\32\35\377\14\15\16"
  "\377\0\0\0\377\262\264\271\377\352\354\362\377\351\354\361\377\352\353\362"
  "\377\351\354\362\377\353\355\362\377\352\355\363\377\352\355\362\377\352"
  "\354\362\377\350\353\361\377\351\354\362\377\351\353\361\377\351\354\362"
  "\377\202\351\355\362\377\5\351\353\361\377\351\354\361\377\351\354\362\377"
  "\352\355\363\377\351\354\362\377\202\353\355\363\377\2\353\356\364\377\354"
  "\356\364\377\202\354\357\364\377\1\214\215\220\377\202\2\2\2\377\5\211\213"
  "\216\377\354\356\363\377\354\357\365\377\355\360\364\377\353\356\363\377"
  "\202\355\357\364\377'\355\360\365\377\354\357\363\377Z[\\\377\0\0\1\377\21"
  "\23\24\377\13\15\16\377\11\12\12\377\13\13\14\377\12\13\13\377\17\17\20\377"
  "\13\13\14\377\14\15\14\377\13\13\13\377\27\31\34\377\11\12\12\377\26\31\34"
  "\377\15\15\15\377\15\17\20\377\17\17\17\377\35\40#\377\10\11\11\377\10\10"
  "\11\377),/\377\14\17\16\376\21\23\22\377045\377\11\13\13\377\16\17\17\377"
  "\12\12\12\377\12\14\14\377\21\24\24\377\2\2\3\377wxy\377\363\366\372\377"
  "\363\365\370\377\363\365\371\377\364\365\372\377\363\365\371\377\363\365"
  "\372\377\202\362\364\371\377\34\361\363\370\377\362\364\371\377\361\363\371"
  "\377\361\363\370\377\360\363\370\377\362\363\370\377\357\361\366\377\360"
  "\362\367\377\357\362\367\377\357\361\367\377\360\362\367\377\357\362\367"
  "\377\357\360\366\377\355\360\365\377\356\360\365\377\355\361\366\377\356"
  "\360\366\377\356\357\366\377\356\360\366\377\354\357\365\377\355\360\365"
  "\377\354\356\363\377\354\357\364\377\355\360\364\377\353\355\362\377\353"
  "\355\363\377\352\355\364\377\352\355\363\377\202\352\355\362\377\33\352\354"
  "\362\377\352\355\363\377\352\355\362\377\353\355\363\377\352\354\362\377"
  "\352\355\363\377\352\354\362\377\353\355\363\377\352\354\363\377\350\353"
  "\361\377\352\354\362\377\351\354\362\377\351\354\361\377\353\355\363\377"
  ";;=\377\2\3\3\377\12\13\13\377\10\12\12\377\11\12\12\377\11\12\13\377\0\0"
  "\0\377\262\265\272\377\353\355\363\377\351\353\361\377\350\352\361\377\352"
  "\354\362\377\353\355\362\377\202\351\354\362\377\2\352\355\362\377\352\354"
  "\362\377\202\352\354\361\377P\351\353\361\377\352\355\362\377\351\355\362"
  "\377\352\355\362\377\351\353\361\377\352\354\362\377\350\354\361\377\353"
  "\355\362\377\353\355\363\377\353\356\363\377\355\360\365\377\354\356\364"
  "\377\354\357\364\377\355\357\364\377\214\215\217\377\1\1\2\377\1\2\2\377"
  "\211\213\215\377\355\357\365\377\354\356\363\377\353\356\363\377\353\355"
  "\364\377\354\356\363\377\356\360\366\377\353\356\363\377WXZ\377\0\0\0\377"
  "\7\11\11\377\15\20\20\377\12\14\14\377\7\7\7\377\14\15\15\377\11\11\10\377"
  "\14\14\15\377\20\21\22\377\16\16\17\377\22\25\26\377\27\31\34\377\13\16\17"
  "\377\11\12\12\377\11\11\11\377\12\13\15\377\23\25\26\377\14\15\16\377\22"
  "\25\26\377\11\11\11\377\10\11\11\377\23\26\26\376\23\23\23\377\13\15\15\377"
  "\15\16\16\377\14\14\14\377\13\13\14\377EKO\377\12\12\13\377\17\20\20\377"
  "\346\350\354\377\362\364\371\377\363\365\371\377\363\365\372\377\364\366"
  "\372\377\363\365\372\377\361\363\370\377\362\364\371\377\362\365\371\377"
  "\362\364\371\377\362\365\372\377\362\363\371\377\361\363\370\377\361\364"
  "\371\377\361\362\367\377\361\363\370\377\360\363\370\377\360\362\370\377"
  "\360\362\367\377\357\362\367\377\356\361\366\377\356\361\365\377\356\357"
  "\365\377\356\361\366\377\202\356\361\365\377\2\355\357\365\377\355\360\365"
  "\377\202\354\357\364\377\202\354\356\364\377\12\354\357\365\377\354\356\364"
  "\377\353\356\363\377\351\355\363\377\354\356\364\377\352\355\363\377\352"
  "\354\362\377\351\354\362\377\351\353\361\377\351\354\363\377\202\352\355"
  "\362\377\32\353\355\363\377\353\354\362\377\352\355\362\377\352\354\362\377"
  "\351\354\362\377\350\353\360\377\351\354\362\377\352\354\362\377\353\355"
  "\362\377\266\267\274\377\0\0\0\377\11\12\12\377\10\10\10\377\11\12\12\377"
  "\7\10\11\377\0\0\0\377\263\265\271\377\352\355\362\377\351\353\361\377\351"
  "\354\362\377\352\355\362\377\353\354\362\377\351\354\362\377\352\355\362"
  "\377\352\354\362\377\352\355\362\377\202\352\354\362\377\3\351\354\362\377"
  "\351\355\362\377\350\354\361\377\202\352\354\362\377\3\352\355\363\377\351"
  "\355\362\377\353\356\363\377\202\352\354\362\377\202\355\357\364\377\202"
  "\353\356\363\377\6\213\214\217\377\1\2\2\377\2\2\3\377\211\212\216\377\354"
  "\357\364\377\354\356\365\377\202\354\356\363\377%\354\357\364\377\353\355"
  "\362\377UVW\377\0\1\1\377\4\6\6\377\12\13\12\377\15\15\15\377\12\12\13\377"
  "\11\11\12\377\16\16\17\377\11\13\13\377\11\12\12\377\15\16\17\377\21\22\24"
  "\377\25\27\30\377\20\21\23\377\13\12\12\377\11\12\13\377\10\10\11\377\7\10"
  "\10\377\27\30\32\377\34\35!\377\26\30\31\377\12\13\14\377\10\10\10\377\34"
  "\37\40\376\15\17\16\377\14\16\17\377\13\14\15\377\17\17\20\377\21\22\23\377"
  "\16\17\17\377\1\2\1\377vvx\377\363\366\372\377\362\365\371\377\363\365\371"
  "\377\203\363\365\372\377\1\362\364\371\377\202\363\365\371\377\10\362\363"
  "\371\377\363\365\372\377\362\363\370\377\362\364\371\377\360\363\370\377"
  "\360\362\370\377\361\363\370\377\360\363\367\377\202\360\362\367\377\15\357"
  "\361\367\377\356\361\366\377\356\360\366\377\356\361\365\377\356\360\364"
  "\377\356\361\365\377\353\356\363\377\355\357\365\377\354\356\364\377\353"
  "\356\363\377\354\357\364\377\353\356\363\377\353\355\363\377\202\354\356"
  "\364\377\36\353\355\362\377\352\355\363\377\354\356\364\377\352\355\363\377"
  "\352\354\363\377\350\353\360\377\351\354\361\377\352\355\363\377\352\354"
  "\362\377\351\354\361\377\352\354\363\377\353\355\363\377\352\355\363\377"
  "\353\355\363\377\352\355\362\377\351\353\361\377\351\354\361\377\353\355"
  "\363\377\352\355\362\377\353\355\363\3779:;\377\5\5\6\377\10\12\11\377#'"
  "*\377\7\7\10\377\0\0\0\377\263\265\271\377\354\356\364\377\352\354\362\377"
  "\353\355\362\377\202\352\354\362\377\1\352\354\363\377\202\353\355\363\377"
  "\1\353\355\362\377\202\352\354\362\377\10\351\354\362\377\351\355\362\377"
  "\350\355\362\377\352\355\362\377\351\354\361\377\353\355\362\377\351\354"
  "\362\377\352\355\362\377\202\353\355\363\3770\355\357\364\377\355\357\365"
  "\377\355\360\365\377\354\356\363\377\213\214\220\377\2\2\2\377\1\2\2\377"
  "\211\213\216\377\355\357\365\377\353\357\364\377\353\357\363\377\354\357"
  "\364\377\353\355\362\377RSU\377\0\0\0\377\7\7\10\377\11\12\12\377\22\24\25"
  "\377\15\15\16\377\11\12\12\377\27\32\34\377\15\15\16\377\10\10\11\377\26"
  "\27\31\377!$'\377\20\21\22\377\15\16\17\377\11\11\11\377\10\12\11\377\15"
  "\17\20\377\13\14\14\377\11\10\11\377\23\25\27\377\15\16\16\377\13\13\13\377"
  "\16\17\20\377\14\15\15\377(-/\376(+.\377\12\15\14\377\12\13\13\377\22\24"
  "\25\377\23\25\26\377\12\12\12\377\4\4\4\377\333\335\340\377\362\365\371\377"
  "\362\364\371\377\202\363\365\372\377\3\362\364\371\377\363\365\372\377\362"
  "\365\371\377\202\363\365\372\377\2\362\364\371\377\361\363\371\377\202\361"
  "\363\370\377\5\360\363\370\377\361\362\370\377\360\362\367\377\357\362\367"
  "\377\360\362\367\377\202\356\361\366\377\26\356\360\365\377\357\361\366\377"
  "\356\360\365\377\356\361\365\377\355\360\365\377\355\357\365\377\353\356"
  "\364\377\354\356\364\377\353\356\363\377\354\356\363\377\354\356\364\377"
  "\352\355\363\377\354\357\364\377\353\355\363\377\351\355\363\377\351\354"
  "\362\377\352\354\362\377\352\355\362\377\352\354\362\377\353\356\363\377"
  "\351\355\363\377\352\355\363\377\202\352\354\362\377\27\353\355\363\377\352"
  "\354\362\377\353\355\363\377\352\355\362\377\351\354\362\377\352\355\362"
  "\377\351\354\362\377\353\355\362\377\353\355\363\377\352\354\362\377\242"
  "\243\247\377\0\0\0\377\12\12\13\377\10\11\11\377\10\12\12\377\0\0\0\377\262"
  "\265\272\377\352\354\361\377\354\356\363\377\351\354\362\377\352\355\363"
  "\377\352\354\362\377\353\356\363\377\203\353\355\363\377\202\352\355\363"
  "\377?\352\354\362\377\352\355\363\377\351\355\362\377\353\355\362\377\352"
  "\355\363\377\353\356\363\377\352\355\363\377\352\354\362\377\354\357\364"
  "\377\353\356\364\377\355\357\365\377\355\360\365\377\355\357\365\377\355"
  "\360\364\377\214\215\220\377\1\1\1\377\1\2\1\377\211\213\216\377\354\356"
  "\364\377\354\357\364\377\354\356\364\377\352\354\361\377PQS\377\1\1\1\377"
  "\11\12\11\377\10\7\10\377\20\21\22\377\22\23\25\377\20\21\22\377\16\16\17"
  "\377\13\13\13\377\11\11\11\377\14\16\17\377\14\16\16\377\40!$\377\11\12\12"
  "\377\11\11\11\377\7\7\10\377\35\40\"\377\7\11\11\377\37!$\377\7\10\11\377"
  "\11\12\13\377\17\22\21\377\33\35\37\377\23\24\25\377.27\377\"%'\376\24\27"
  "\27\377\13\15\14\377\13\15\15\377\15\16\16\377\15\16\15\377\5\7\6\377JJK"
  "\377\364\366\372\377\361\364\370\377\362\364\371\377\361\364\370\377\362"
  "\364\371\377\361\364\371\377\363\365\371\377\361\364\370\377\202\362\364"
  "\371\377\11\362\364\370\377\361\363\370\377\362\364\371\377\361\363\370\377"
  "\360\362\370\377\360\362\367\377\360\363\367\377\356\361\366\377\360\362"
  "\367\377\202\356\361\366\377\7\356\360\366\377\357\361\366\377\354\357\364"
  "\377\356\361\366\377\354\357\365\377\355\357\365\377\353\355\363\377\202"
  "\353\356\364\377\16\354\356\365\377\354\356\364\377\353\356\363\377\353\356"
  "\364\377\354\356\364\377\352\355\362\377\350\353\362\377\352\355\363\377"
  "\351\354\362\377\352\355\362\377\353\356\364\377\355\357\365\377\353\355"
  "\363\377\352\355\362\377\203\352\354\362\377\4\352\355\362\377\350\353\361"
  "\377\350\354\362\377\351\353\361\377\202\351\354\362\377\22\352\355\363\377"
  "\353\356\363\377\350\353\360\377\24\24\25\377\11\12\13\377\6\10\10\377\12"
  "\13\15\377\0\0\0\377\263\265\272\377\352\354\361\377\353\355\362\377\352"
  "\354\363\377\352\354\362\377\351\354\361\377\352\354\362\377\352\356\363"
  "\377\352\354\362\377\352\355\363\377\202\353\355\363\377\3\352\354\362\377"
  "\351\354\362\377\351\355\362\377\202\352\355\362\377\12\353\355\363\377\353"
  "\356\364\377\353\356\363\377\353\355\363\377\354\357\364\377\355\357\364"
  "\377\355\357\365\377\355\360\365\377\354\357\364\377\214\215\217\377\202"
  "\1\2\2\377\7\211\213\216\377\354\357\365\377\353\356\364\377\352\354\361"
  "\377NPP\377\1\1\1\377\12\13\14\377\202\14\15\15\377\37\13\17\20\377\15\16"
  "\20\377\26\30\32\377\16\17\17\377\10\10\10\377\13\14\15\377\25\26\30\377"
  "\15\16\17\377\12\12\13\377\12\13\13\377\7\7\10\377\17\20\20\377\11\12\12"
  "\377\16\20\21\377\15\17\20\377\16\16\17\377\23\25\30\377\20\22\22\377\31"
  "\33\35\377+.2\377\7\7\7\377\13\14\13\376\12\13\13\377\11\13\12\377\34\40"
  "!\377\22\22\24\377\21\24\24\377\1\1\1\377\237\241\243\377\361\364\371\377"
  "\361\363\370\377\203\360\363\370\377\4\361\364\371\377\362\364\370\377\361"
  "\363\370\377\361\363\371\377\202\361\363\370\377\26\361\364\371\377\361\363"
  "\370\377\360\362\370\377\360\362\367\377\357\361\366\377\360\362\367\377"
  "\357\361\367\377\360\362\367\377\357\361\367\377\356\360\366\377\356\361"
  "\366\377\357\361\366\377\354\357\365\377\354\356\364\377\354\357\365\377"
  "\354\357\364\377\352\355\363\377\354\356\364\377\354\357\364\377\354\356"
  "\364\377\353\356\363\377\354\356\364\377\202\353\355\363\377\37\353\356\363"
  "\377\351\354\362\377\353\355\363\377\352\355\363\377\353\355\363\377\354"
  "\357\364\377\353\356\363\377\354\356\364\377\354\356\363\377\351\354\361"
  "\377\352\355\363\377\352\354\362\377\353\355\362\377\351\354\362\377\350"
  "\353\361\377\351\354\362\377\352\355\361\377\353\355\362\377\352\355\362"
  "\377\353\355\362\377\352\354\362\377bcf\377\2\2\2\377\12\14\14\377\12\13"
  "\13\377\0\0\0\377\262\265\271\377\350\354\360\377\353\355\362\377\353\354"
  "\363\377\352\355\363\377\202\352\354\361\377\1\354\356\363\377\202\353\355"
  "\363\377E\352\355\363\377\353\355\363\377\352\355\362\377\351\354\362\377"
  "\351\355\362\377\352\354\362\377\351\353\362\377\353\356\364\377\351\354"
  "\362\377\353\355\363\377\353\355\362\377\353\355\363\377\354\357\364\377"
  "\353\356\364\377\354\356\364\377\354\357\363\377\214\215\220\377\2\2\2\377"
  "\3\3\4\377\212\213\216\377\354\357\364\377\347\352\357\377LMO\377\0\0\1\377"
  "\17\21\22\377\17\17\20\377\13\15\15\377\11\13\13\377\14\15\16\377\20\22\24"
  "\377\14\14\15\377\22\21\23\377\25\27\30\377\11\11\11\377\10\11\11\377\13"
  "\14\14\377\10\12\12\377\22\22\24\377\13\15\16\377\11\12\12\377\22\25\26\377"
  "\12\13\13\377\11\12\13\377\16\17\20\377\13\14\15\377\12\13\14\37769=\377"
  "\10\10\10\377\36!#\377\16\20\20\376\10\10\10\377\25\27\27\377\21\24\24\377"
  "\20\23\23\377\33\40!\377\5\5\5\377\345\346\352\377\362\364\371\377\361\363"
  "\371\377\361\363\370\377\361\364\370\377\360\363\370\377\361\363\370\377"
  "\362\363\370\377\360\363\367\377\362\363\371\377\361\364\370\377\362\363"
  "\370\377\360\363\370\377\202\361\363\370\377\3\360\362\370\377\360\362\367"
  "\377\356\361\366\377\202\357\362\367\377\15\357\361\366\377\356\360\366\377"
  "\357\361\367\377\355\360\365\377\355\357\365\377\353\357\364\377\355\357"
  "\364\377\355\360\364\377\354\356\364\377\354\357\364\377\354\356\364\377"
  "\354\357\365\377\354\357\364\377\203\353\356\363\377\15\353\355\363\377\352"
  "\355\363\377\352\355\362\377\353\355\362\377\354\356\364\377\355\357\365"
  "\377\354\356\364\377\353\356\364\377\354\357\364\377\353\355\363\377\352"
  "\355\363\377\351\354\362\377\353\355\362\377\202\350\352\360\377\22\351\353"
  "\360\377\351\355\362\377\353\355\363\377\353\355\362\377\352\355\363\377"
  "\354\356\363\377\253\254\261\377\0\0\0\377\10\11\12\377\12\12\14\377\0\0"
  "\0\377\263\265\271\377\352\354\361\377\351\354\361\377\352\354\362\377\351"
  "\354\362\377\353\355\363\377\352\354\361\377\202\353\355\363\377\1\354\356"
  "\363\377\202\352\354\362\377\3\352\355\362\377\351\354\361\377\351\355\362"
  "\377\202\351\354\362\377\7\353\356\363\377\352\355\362\377\353\355\363\377"
  "\354\356\364\377\353\356\364\377\355\357\364\377\354\356\363\377\202\354"
  "\357\364\377:\214\215\217\377\1\1\2\377\2\3\3\377\211\213\215\377\347\353"
  "\360\377IJL\377\1\1\1\377\6\7\7\377\22\26\30\377\15\21\21\377\7\11\11\377"
  "\11\12\13\377\14\15\16\377\36!$\377\13\16\17\377\13\14\16\377\16\20\21\377"
  "\7\7\7\377\6\6\6\377\10\11\12\377\12\13\14\377\12\13\13\377\12\13\14\377"
  "\12\12\13\377\11\11\12\377\10\11\10\377\30\31\32\377\11\12\12\377#%(\377"
  "\24\26\27\377\13\13\13\37748;\377\32\33\35\377\27\31\32\376\22\24\24\377"
  "\16\23\22\377\21\23\24\377\34\36\40\377\17\20\21\377778\377\364\365\371\377"
  "\363\364\370\377\362\364\371\377\361\364\370\377\361\364\371\377\360\363"
  "\370\377\360\362\370\377\360\362\367\377\360\362\370\377\361\363\371\377"
  "\362\364\371\377\362\363\371\377\361\363\370\377\361\363\367\377\360\362"
  "\367\377\361\362\367\377\360\361\367\377\360\362\365\377\202\357\361\366"
  "\377\7\356\360\364\377\356\360\365\377\354\357\365\377\355\360\365\377\356"
  "\360\365\377\355\360\365\377\353\357\364\377\203\355\357\365\377\11\354\356"
  "\364\377\353\355\364\377\354\357\364\377\353\356\363\377\354\356\364\377"
  "\352\355\362\377\353\355\363\377\353\356\364\377\353\355\363\377\202\352"
  "\355\363\377\33\353\355\363\377\354\357\364\377\354\357\365\377\354\357\364"
  "\377\353\355\362\377\353\355\363\377\352\355\363\377\352\354\362\377\351"
  "\353\362\377\351\353\361\377\346\352\360\377\351\354\362\377\353\355\362"
  "\377\352\355\362\377\352\355\363\377\353\354\361\377\343\346\353\377\7\7"
  "\7\377\5\6\5\377!#&\377\0\0\0\377\262\265\271\377\352\354\361\377\351\353"
  "\360\377\352\354\362\377\352\355\363\377\353\354\362\377\202\352\354\362"
  "\377\20\354\356\363\377\352\355\362\377\353\355\362\377\352\354\362\377\351"
  "\354\362\377\347\353\360\377\350\355\362\377\352\354\363\377\351\355\362"
  "\377\353\355\363\377\351\354\362\377\354\356\364\377\354\356\363\377\355"
  "\357\365\377\355\357\364\377\353\356\364\377\202\354\357\364\377-\213\215"
  "\220\377\1\2\2\377\3\3\3\377\204\205\210\377HIK\377\6\7\7\377\26!\33\377"
  "\25\30\30\377\21\24\26\377\23\25\27\377\22\23\24\377\12\13\13\377\10\10\11"
  "\377\13\15\16\377\11\12\13\377\13\14\15\377\10\11\11\377\6\7\7\377\5\6\6"
  "\377\13\15\16\377\7\7\10\377\10\11\12\377\7\10\10\377\14\14\15\377\10\10"
  "\11\377\24\25\27\377\17\17\21\377\25\27\31\377\27\31\33\377\11\11\12\377"
  "\15\20\21\377\32\35\37\377\40\"$\377\32\35\36\376\30\33\35\377\17\22\22\377"
  "\23\23\24\377\23\25\26\377\6\7\7\377prt\377\362\364\371\377\363\365\372\377"
  "\362\364\371\377\361\364\371\377\360\363\370\377\202\360\362\367\377\202"
  "\357\362\367\377\16\361\363\370\377\362\364\370\377\363\364\371\377\362\364"
  "\371\377\361\362\370\377\361\363\367\377\360\363\367\377\357\362\366\377"
  "\356\361\366\377\360\362\367\377\357\361\366\377\356\360\365\377\355\360"
  "\366\377\356\360\366\377\202\356\360\365\377+\354\357\365\377\354\356\363"
  "\377\355\360\364\377\354\356\364\377\355\360\365\377\353\356\365\377\354"
  "\355\363\377\352\355\363\377\353\356\363\377\353\355\362\377\353\355\363"
  "\377\351\354\362\377\352\354\363\377\352\355\363\377\351\354\361\377\351"
  "\353\362\377\352\354\362\377\352\355\363\377\353\355\363\377\352\354\362"
  "\377\353\356\363\377\353\355\363\377\352\355\362\377\352\354\362\377\351"
  "\353\361\377\352\354\362\377\351\353\361\377\347\352\361\377\351\353\361"
  "\377\352\354\362\377\351\354\362\377\352\354\362\377\353\357\364\377456\377"
  "\4\4\5\377\16\17\17\377\0\0\0\377\263\265\271\377\351\352\357\377\351\353"
  "\360\377\351\353\361\377\351\354\361\377\352\355\363\377\202\352\355\362"
  "\377\14\353\355\363\377\352\355\362\377\353\356\363\377\352\355\363\377\352"
  "\355\362\377\350\354\360\377\350\354\361\377\351\354\362\377\352\354\362"
  "\377\353\355\363\377\352\355\363\377\352\355\362\377\202\354\356\364\377"
  "\2\354\356\363\377\354\356\364\377\202\354\357\364\377\15\212\214\217\377"
  "\1\2\2\377\3\3\3\377\16\16\17\377\1\1\1\377\30\32\33\377\15\34\25\377\13"
  "\16\16\377\25\27\32\377+-2\377\10\11\11\377\10\12\13\377\11\14\15\377\202"
  "\11\11\11\377\32\11\12\13\377\5\5\5\377\4\5\5\377%(+\377\5\6\6\377\7\7\10"
  "\377\14\15\16\377\15\16\17\377\10\11\11\377\"#&\377\12\13\13\377\22\23\25"
  "\377\15\17\21\377\11\12\12\377\27\31\34\377\26\30\32\377\12\13\13\377\31"
  "\34\35\377\12\14\14\376\15\17\20\377\33\37\40\377\30\32\34\377\26\31\32\377"
  "\2\3\3\377\241\242\244\377\361\363\370\377\202\362\364\371\377\2\361\364"
  "\370\377\361\363\370\377\202\357\362\366\377\6\356\361\367\377\360\362\367"
  "\377\361\363\370\377\361\363\367\377\361\363\370\377\361\363\371\377\202"
  "\361\363\370\377\6\357\362\367\377\357\361\366\377\357\361\367\377\357\361"
  "\366\377\356\361\366\377\356\360\365\377\202\356\360\366\377\16\355\357\364"
  "\377\355\357\365\377\355\360\365\377\355\357\364\377\354\357\365\377\355"
  "\357\365\377\355\360\365\377\354\356\364\377\353\356\364\377\353\356\363"
  "\377\354\356\363\377\353\356\364\377\354\356\364\377\353\356\363\377\202"
  "\353\355\363\377\1\352\355\363\377\202\353\355\363\377\36\354\356\364\377"
  "\353\356\363\377\353\355\363\377\355\357\364\377\354\356\363\377\352\354"
  "\362\377\352\355\362\377\353\355\363\377\352\355\363\377\352\354\363\377"
  "\351\355\362\377\352\355\362\377\351\354\362\377\352\354\362\377\351\354"
  "\362\377\352\354\363\377deh\377\4\5\5\377\24\26\31\377\0\0\0\377\262\264"
  "\270\377\350\353\360\377\351\354\361\377\351\353\361\377\351\354\362\377"
  "\353\355\363\377\352\354\362\377\351\354\362\377\352\354\362\377\351\354"
  "\362\377\202\352\354\362\377?\352\354\361\377\353\355\362\377\350\354\360"
  "\377\351\354\361\377\350\353\361\377\351\354\362\377\353\355\363\377\354"
  "\356\364\377\353\355\363\377\353\356\364\377\352\355\363\377\354\356\364"
  "\377\354\356\363\377\353\355\363\377\213\214\217\377\2\3\3\377\11\12\14\377"
  "\2\2\2\377\6\7\10\377\17\21\22\377\5\17\13\377\7\11\12\377\15\16\17\377\7"
  "\7\7\377\10\11\11\377\6\7\10\377\7\10\10\377\10\10\11\377\4\5\5\377\5\5\4"
  "\377\2\3\3\377\7\7\10\377\10\11\11\377\4\4\4\377\6\7\6\377EDJ\377\13\13\13"
  "\377\21\22\24\377\10\11\12\37758<\377\13\14\15\377\12\13\14\377\23\25\26"
  "\377\14\15\14\377\14\16\17\377\21\24\25\377\17\20\21\377\12\14\14\376\32"
  "\34\36\377\20\23\24\377\16\21\21\377\26\31\34\377\0\0\0\377\307\312\315\377"
  "\360\363\370\377\360\363\367\377\361\363\370\377\360\363\370\377\361\363"
  "\370\377\360\362\367\377\357\362\367\377\360\362\367\377\360\363\367\377"
  "\202\360\363\370\377\203\360\362\367\377\202\357\361\367\377\1\357\361\366"
  "\377\202\356\361\366\377\1\355\360\365\377\203\356\360\365\377\1\357\360"
  "\366\377\203\355\360\365\377\3\353\356\363\377\354\357\365\377\355\357\365"
  "\377\202\354\356\364\377\4\353\355\362\377\354\356\364\377\353\355\364\377"
  "\353\355\363\377\202\352\355\363\377\3\354\356\364\377\353\355\363\377\352"
  "\355\363\377\202\353\356\363\377\14\353\355\363\377\354\356\363\377\353\356"
  "\364\377\353\355\362\377\352\355\363\377\353\355\363\377\352\354\362\377"
  "\351\354\362\377\352\355\363\377\352\354\363\377\353\356\363\377\352\354"
  "\361\377\202\351\354\362\377\7\352\355\363\377\213\214\220\377\2\3\3\377"
  "\15\16\17\377\0\0\0\377\262\265\271\377\353\355\363\377\204\352\354\362\377"
  "\13\351\354\361\377\347\353\361\377\351\353\362\377\352\355\363\377\351\353"
  "\361\377\351\354\362\377\352\355\362\377\351\354\361\377\347\353\360\377"
  "\352\354\362\377\351\354\362\377\202\352\355\363\377\13\353\355\363\377\354"
  "\356\364\377\353\355\363\377\352\355\363\377\354\357\364\377\352\355\363"
  "\377\353\356\364\377\213\214\220\377\3\3\3\377\4\5\5\377\13\14\14\377\202"
  "\25\25\26\377\1\25\25\25\377\214\25\25\26\377\30\3\3\3\377\4\5\5\377\7\7"
  "\7\377\16\17\20\377\15\20\20\377\16\17\22\377\10\10\10\377\10\11\11\377\14"
  "\15\16\377\37!$\377\11\10\11\377%(+\377\34\37!\377\14\17\20\377\34\37\40"
  "\376\11\13\13\377!'(\377\32\32\33\377\17\20\21\377\1\1\1\377\346\350\353"
  "\377\361\363\370\377\360\362\366\377\360\362\367\377\203\360\363\370\377"
  "\5\360\362\370\377\357\362\367\377\360\362\367\377\361\363\370\377\357\362"
  "\367\377\202\357\361\366\377\12\357\361\364\377\356\361\366\377\357\361\367"
  "\377\357\360\366\377\356\360\366\377\356\360\365\377\355\360\365\377\356"
  "\360\366\377\356\360\365\377\354\357\364\377\202\355\357\365\377\3\355\360"
  "\366\377\356\360\366\377\353\357\363\377\202\354\356\364\377\1\354\357\365"
  "\377\202\354\356\364\377\15\353\355\363\377\353\356\364\377\353\356\363\377"
  "\353\355\363\377\353\355\364\377\353\356\364\377\351\354\361\377\353\355"
  "\363\377\353\356\363\377\353\355\363\377\353\355\362\377\355\357\364\377"
  "\354\357\364\377\203\353\355\363\377\17\352\355\363\377\352\354\362\377\351"
  "\354\362\377\352\355\363\377\353\355\363\377\352\354\362\377\352\355\363"
  "\377\354\356\364\377\352\355\363\377\251\252\257\377\0\1\1\377\14\16\17\377"
  "\0\0\0\377\262\264\271\377\352\355\362\377\202\351\354\362\377\7\350\353"
  "\360\377\352\354\361\377\351\354\361\377\347\353\361\377\352\354\362\377"
  "\352\354\361\377\351\354\362\377\202\352\354\362\377\2\352\355\363\377\351"
  "\355\362\377\203\351\354\362\377\22\352\355\363\377\353\356\364\377\354\356"
  "\363\377\354\357\364\377\353\356\364\377\356\360\365\377\355\357\364\377"
  "\353\356\363\377\211\214\216\377\3\4\4\377\2\2\3\377\213\214\216\377\356"
  "\361\366\377\357\363\367\377\360\362\370\377\361\363\370\377\360\363\367"
  "\377\357\363\367\377\202\357\362\367\377\15\360\363\370\377\361\363\371\377"
  "\362\364\370\377\362\364\371\377\360\363\370\377\362\364\370\377\363\365"
  "\371\377*+,\377\4\4\4\377\14\15\16\377\10\10\11\377\16\20\21\377\11\11\12"
  "\377\202\10\10\10\377\20\22\24\25\377\10\10\11\377\37#%\377\15\15\16\377"
  "\23\25\27\377\14\15\16\377\32\35\36\376!%&\377\12\13\13\377\16\17\17\377"
  "\14\15\16\377\13\13\14\377\362\364\370\377\361\363\370\377\360\362\366\377"
  "\361\363\371\377\202\361\363\370\377\23\357\362\367\377\360\362\367\377\357"
  "\362\367\377\360\362\370\377\360\362\367\377\357\362\366\377\357\361\366"
  "\377\356\361\366\377\356\360\364\377\357\361\366\377\356\360\365\377\356"
  "\360\364\377\356\361\366\377\357\360\366\377\355\360\365\377\357\360\365"
  "\377\355\360\364\377\356\360\365\377\355\360\365\377\202\355\357\364\377"
  "\15\355\360\365\377\355\357\365\377\353\356\363\377\353\355\363\377\354\356"
  "\364\377\353\356\364\377\354\356\364\377\353\356\363\377\353\355\363\377"
  "\352\355\363\377\353\355\363\377\353\356\364\377\352\355\363\377\202\353"
  "\355\363\377\7\354\355\363\377\352\355\363\377\353\356\363\377\354\356\364"
  "\377\353\356\364\377\352\354\362\377\353\355\362\377\202\353\355\363\377"
  "\26\353\355\362\377\352\354\362\377\352\355\362\377\353\354\362\377\351\354"
  "\362\377\352\355\363\377\353\355\362\377\352\354\362\377\277\300\306\377"
  "\0\0\0\377\17\20\22\377\0\0\0\377\261\263\270\377\351\354\361\377\352\354"
  "\362\377\351\353\362\377\347\352\357\377\352\355\362\377\351\353\361\377"
  "\351\354\362\377\352\354\362\377\353\354\363\377\202\351\354\362\377\3\352"
  "\355\363\377\353\356\363\377\351\356\362\377\203\351\354\362\377!\352\356"
  "\363\377\353\356\363\377\354\356\364\377\354\357\364\377\354\357\365\377"
  "\353\356\363\377\355\357\364\377\354\356\363\377\212\214\217\377\2\2\3\377"
  "\3\3\4\377\212\213\215\377\353\356\363\377\352\356\363\377\355\357\365\377"
  "\354\357\364\377\354\357\365\377\355\357\365\377\355\360\365\377\355\357"
  "\365\377\355\360\365\377\355\360\366\377\356\361\366\377\355\360\365\377"
  "\356\361\366\377\357\361\367\377\360\363\370\377**+\377\14\16\17\377\14\17"
  "\20\377\6\7\7\377\11\11\12\377\12\13\14\377\202\10\10\11\377\20\12\13\13"
  "\377\13\14\14\377\14\14\15\377\31\32\35\377\13\13\14\377\13\13\13\377\"&"
  "(\376),/\377\15\16\16\377\15\17\16\377\12\12\12\377\30\30\31\377\364\366"
  "\372\377\361\363\370\377\357\361\366\377\361\363\370\377\202\360\363\370"
  "\377\2\357\362\367\377\360\362\370\377\202\360\362\367\377\202\357\362\367"
  "\377\15\357\361\367\377\356\361\365\377\355\357\365\377\356\361\366\377\355"
  "\360\366\377\357\361\366\377\357\360\366\377\357\361\366\377\355\360\365"
  "\377\356\360\365\377\355\360\366\377\355\357\365\377\355\357\364\377\202"
  "\354\357\364\377\10\355\360\366\377\355\360\365\377\352\355\363\377\353\356"
  "\364\377\352\356\364\377\354\357\365\377\354\356\364\377\353\356\364\377"
  "\202\353\355\363\377\21\353\356\363\377\352\355\363\377\352\354\362\377\352"
  "\355\362\377\353\356\363\377\353\355\363\377\352\355\363\377\353\356\363"
  "\377\354\356\363\377\353\355\361\377\352\354\361\377\352\355\363\377\353"
  "\355\364\377\352\355\363\377\352\355\362\377\352\354\361\377\353\356\364"
  "\377\202\352\354\362\377\32\352\355\363\377\352\354\362\377\352\355\362\377"
  "\316\320\325\377\0\0\0\377\13\13\15\377\0\0\0\377\262\263\271\377\351\354"
  "\362\377\352\354\361\377\351\353\361\377\350\353\361\377\352\353\361\377"
  "\352\354\362\377\352\355\362\377\351\353\361\377\353\355\363\377\351\354"
  "\362\377\353\356\363\377\352\355\363\377\352\355\362\377\351\355\362\377"
  "\352\355\362\377\352\354\363\377\353\355\363\377\354\356\363\377\202\353"
  "\356\363\3775\354\356\364\377\354\357\365\377\352\355\363\377\354\356\364"
  "\377\353\356\363\377\213\214\217\377\3\4\4\377\2\3\3\377\211\213\216\377"
  "\354\356\364\377\355\357\365\377\355\360\365\377\356\360\366\377\356\361"
  "\367\377\355\360\366\377\355\360\365\377\356\360\366\377\355\360\365\377"
  "\355\360\366\377\356\361\366\377\355\361\366\377\356\361\366\377\357\361"
  "\366\377\361\364\370\377**+\377\22\25\26\377\25\31\32\377\7\7\11\377\11\13"
  "\14\377\11\12\12\377\10\10\11\377\12\13\13\377%*.\377\10\10\10\377\13\14"
  "\15\377\34!#\377\13\13\14\377\11\10\10\377\17\21\20\376\13\14\13\377\36\37"
  "!\377\14\15\15\377\20\23\24\377\37\37\40\377\363\365\371\377\360\363\370"
  "\377\360\362\367\377\357\362\367\377\361\364\371\377\357\362\370\377\357"
  "\362\367\377\360\363\370\377\360\361\367\377\202\357\361\366\377\15\356\361"
  "\366\377\357\361\367\377\356\360\366\377\357\361\365\377\356\361\365\377"
  "\355\357\365\377\355\357\364\377\356\357\365\377\356\360\366\377\355\357"
  "\365\377\355\360\365\377\354\357\365\377\354\356\364\377\202\354\357\364"
  "\377\30\354\357\365\377\353\356\364\377\354\357\365\377\352\355\363\377\354"
  "\357\365\377\353\356\364\377\354\356\364\377\353\356\363\377\354\356\364"
  "\377\354\357\364\377\353\356\364\377\352\354\362\377\353\356\364\377\352"
  "\355\363\377\351\354\361\377\352\355\363\377\352\354\362\377\352\355\363"
  "\377\353\355\363\377\353\354\362\377\353\355\362\377\353\355\363\377\352"
  "\355\363\377\351\354\362\377\202\352\355\362\377\2\352\354\362\377\352\355"
  "\363\377\202\353\355\363\377\12\351\353\362\377\353\355\362\377\351\354\362"
  "\377\323\325\333\377\0\0\0\377\14\14\16\377\0\0\0\377\263\265\272\377\351"
  "\354\362\377\350\353\361\377\202\351\354\362\377\4\353\355\363\377\352\354"
  "\361\377\351\354\362\377\353\355\363\377\202\352\354\362\377\20\352\354\361"
  "\377\352\355\363\377\351\354\362\377\352\356\362\377\352\354\362\377\352"
  "\355\362\377\351\354\362\377\353\356\363\377\353\356\364\377\352\355\362"
  "\377\355\357\364\377\354\357\365\377\354\357\364\377\353\356\364\377\353"
  "\355\363\377\213\214\217\377\202\2\2\2\377\1\211\213\216\377\202\354\357"
  "\365\377\5\356\360\365\377\355\357\365\377\355\360\366\377\356\360\366\377"
  "\355\360\365\377\202\356\361\366\377\2\355\360\366\377\356\360\366\377\202"
  "\356\361\366\377*\355\360\366\377\362\364\371\377**,\377\12\14\15\377\14"
  "\16\17\377\7\10\11\377\13\15\16\377\7\7\7\377\10\12\13\377\20\22\24\377\12"
  "\14\15\377\14\14\14\377\13\14\14\377\17\22\22\377\20\22\24\377\11\11\11\377"
  "\15\17\17\376\21\23\24\377\14\14\14\377\33\35\36\377\11\12\11\377\35\35\37"
  "\377\363\365\371\377\361\364\370\377\360\362\367\377\360\363\370\377\360"
  "\362\370\377\361\363\370\377\357\361\366\377\360\362\370\377\356\360\366"
  "\377\357\361\366\377\356\361\366\377\357\361\366\377\360\362\367\377\356"
  "\360\365\377\357\361\367\377\355\360\365\377\355\357\364\377\356\360\365"
  "\377\355\357\363\377\354\356\364\377\202\355\360\365\377\5\354\357\364\377"
  "\354\357\365\377\355\356\364\377\355\356\363\377\354\356\364\377\202\354"
  "\357\365\377\25\353\356\364\377\354\357\365\377\353\356\364\377\354\356\364"
  "\377\353\356\364\377\353\356\363\377\355\357\365\377\354\356\363\377\352"
  "\354\362\377\353\355\364\377\352\355\364\377\351\354\361\377\352\355\362"
  "\377\351\354\361\377\352\356\363\377\354\355\364\377\353\355\363\377\352"
  "\355\363\377\353\356\363\377\353\355\362\377\352\354\362\377\202\352\355"
  "\362\377\2\352\355\363\377\352\355\362\377\202\353\355\363\377\30\352\355"
  "\361\377\351\354\362\377\352\355\363\377\323\324\332\377\0\0\0\377\12\13"
  "\13\377\0\0\0\377\262\265\271\377\352\354\362\377\352\353\361\377\352\354"
  "\362\377\351\353\360\377\353\354\362\377\353\355\362\377\352\354\362\377"
  "\353\355\363\377\353\355\362\377\351\354\362\377\352\354\361\377\351\353"
  "\361\377\351\355\362\377\352\356\362\377\353\355\362\377\353\355\363\377"
  "\202\353\356\363\377\4\354\357\364\377\353\356\364\377\354\356\364\377\353"
  "\356\364\377\202\354\356\364\377\12\352\355\363\377\213\215\217\377\2\2\2"
  "\377\1\2\2\377\211\213\216\377\355\357\365\377\353\356\364\377\355\357\365"
  "\377\355\360\365\377\355\357\365\377\202\355\360\365\377\"\356\361\367\377"
  "\356\361\366\377\357\361\366\377\355\360\366\377\357\361\366\377\356\361"
  "\367\377\356\360\366\377\361\364\370\377**+\377\6\10\10\377\11\11\13\377"
  "\5\7\7\377\12\14\15\377\10\12\13\377\11\11\11\377\12\12\13\377+.1\377\13"
  "\14\15\377\22\24\26\377\35\40#\377\10\11\12\377\12\13\14\377\13\15\15\376"
  "\12\11\11\377\17\21\22\377\31\35\36\377\23\22\24\377\23\24\24\377\363\365"
  "\371\377\360\362\367\377\361\363\370\377\360\362\366\377\361\363\370\377"
  "\356\362\366\377\202\357\362\367\377\3\356\360\366\377\356\361\366\377\360"
  "\362\367\377\202\357\361\367\377\1\357\361\366\377\202\356\360\366\377\5"
  "\356\361\366\377\355\360\365\377\354\356\364\377\356\360\364\377\355\357"
  "\364\377\203\355\360\365\377\4\355\357\365\377\354\357\364\377\354\356\365"
  "\377\354\357\365\377\202\353\356\364\377\2\352\355\363\377\352\355\364\377"
  "\202\354\356\364\377#\354\357\364\377\353\356\363\377\354\356\364\377\354"
  "\355\363\377\353\356\364\377\354\356\364\377\352\354\362\377\353\355\362"
  "\377\352\355\362\377\353\355\363\377\353\356\364\377\353\356\363\377\353"
  "\355\362\377\353\355\363\377\352\354\362\377\352\355\362\377\352\355\363"
  "\377\353\355\363\377\352\354\363\377\353\355\363\377\352\355\362\377\353"
  "\355\362\377\353\356\363\377\353\355\363\377\352\355\362\377\311\313\320"
  "\377\0\0\0\377\17\21\22\377\0\0\0\377\261\264\271\377\352\355\362\377\351"
  "\353\361\377\351\353\362\377\351\354\362\377\352\354\362\377\202\352\355"
  "\363\377\13\353\355\363\377\352\355\362\377\353\355\362\377\352\355\363\377"
  "\351\354\362\377\351\355\362\377\352\356\363\377\351\354\362\377\353\356"
  "\364\377\354\357\364\377\353\356\364\377\202\353\356\363\377\2\354\356\364"
  "\377\352\354\361\377\202\354\356\364\377\2\355\357\364\377\213\215\217\377"
  "\202\2\2\2\377\5\212\213\215\377\355\357\366\377\355\360\366\377\355\360"
  "\365\377\355\360\366\377\202\355\357\365\377\3\355\360\365\377\356\360\366"
  "\377\355\361\366\377\202\356\361\367\377\40\356\361\366\377\357\361\367\377"
  "\356\361\366\377\361\363\370\377**+\377\4\5\5\377\7\10\10\377\6\7\10\377"
  "\17\21\22\377\13\14\15\377\16\20\21\377\22\23\24\377\22\24\25\377)-0\377"
  "\26\31\33\377\13\13\14\377\22\24\26\377\14\16\17\377\13\13\13\376\25\30\31"
  "\377DGL\377\17\20\20\377\14\16\16\377\10\10\10\377\355\360\365\377\357\362"
  "\367\377\360\362\367\377\360\362\370\377\361\363\370\377\360\363\370\377"
  "\356\362\367\377\357\362\367\377\202\357\361\366\377\12\360\362\366\377\357"
  "\362\367\377\360\361\367\377\356\361\365\377\356\360\365\377\355\357\365"
  "\377\354\357\364\377\355\357\365\377\354\357\364\377\355\360\364\377\202"
  "\354\357\364\377\1\354\357\365\377\203\355\357\365\377\15\355\360\365\377"
  "\354\357\365\377\353\357\364\377\355\356\364\377\353\356\363\377\352\355"
  "\364\377\354\357\364\377\354\356\363\377\355\357\365\377\354\357\365\377"
  "\353\355\363\377\354\356\363\377\352\354\364\377\202\351\354\362\377\3\353"
  "\355\363\377\351\354\361\377\352\355\363\377\203\353\355\363\377\2\354\356"
  "\364\377\353\355\363\377\202\351\354\362\377\3\352\354\362\377\352\354\363"
  "\377\352\355\363\377\203\353\355\362\377\21\353\355\364\377\352\354\362\377"
  "\270\271\276\377\0\0\0\377\11\12\12\377\0\0\0\377\262\264\271\377\351\354"
  "\361\377\351\353\361\377\352\354\362\377\351\354\362\377\353\355\362\377"
  "\352\354\362\377\353\356\363\377\353\355\363\377\352\354\362\377\352\355"
  "\363\377\202\353\355\363\377\6\353\356\363\377\352\355\363\377\353\356\363"
  "\377\353\356\364\377\352\355\363\377\354\357\364\377\202\355\357\364\377"
  "\6\353\356\364\377\355\357\364\377\354\356\364\377\352\355\362\377\354\357"
  "\364\377\213\214\217\377\202\1\1\1\377\2\212\213\216\377\355\357\365\377"
  "\202\355\360\365\377\6\354\357\365\377\355\360\366\377\356\360\366\377\354"
  "\357\366\377\356\360\365\377\357\361\367\377\202\356\361\367\377\1\357\361"
  "\367\377\202\357\362\367\377\30\361\364\370\377*+,\377\6\7\7\377\7\10\10"
  "\377\6\7\7\377\35!$\377\11\13\14\377\23\26\30\377\11\12\12\377\12\12\12\377"
  "\33\36!\377\13\14\15\377\15\17\20\377\11\11\12\377\11\11\11\377\34!#\376"
  "\15\17\20\377\"%'\377\17\20\20\377\26\27\30\377\0\0\0\377\336\340\343\377"
  "\360\362\367\377\361\363\370\377\202\360\362\367\377\2\360\363\370\377\357"
  "\362\367\377\202\357\361\367\377\2\357\362\367\377\357\361\366\377\202\356"
  "\360\365\377\2\356\361\366\377\356\360\366\377\202\355\357\365\377\20\354"
  "\356\363\377\353\356\364\377\354\357\364\377\355\360\365\377\355\357\364"
  "\377\354\356\364\377\355\360\365\377\355\357\365\377\355\360\365\377\354"
  "\357\365\377\353\357\365\377\353\357\364\377\354\356\365\377\354\357\364"
  "\377\353\356\364\377\352\355\364\377\203\353\356\364\377\17\352\355\363\377"
  "\351\354\362\377\352\354\363\377\351\354\362\377\350\353\361\377\352\355"
  "\363\377\352\354\362\377\353\355\362\377\352\355\363\377\353\355\363\377"
  "\353\356\363\377\353\355\363\377\353\355\362\377\352\355\362\377\352\354"
  "\363\377\202\352\355\363\377\2\352\354\362\377\353\355\362\377\202\353\355"
  "\363\377\11\352\355\362\377\352\354\362\377\240\241\246\377\0\0\0\377\13"
  "\14\15\377\0\0\0\377\262\263\270\377\352\355\362\377\352\354\362\377\202"
  "\353\355\363\377\4\354\356\363\377\352\354\363\377\352\355\363\377\353\356"
  "\363\377\202\353\355\363\377\5\353\356\363\377\352\354\362\377\354\356\363"
  "\377\352\356\364\377\353\356\363\377\202\353\355\363\377\1\354\356\364\377"
  "\202\353\356\364\377\1\354\357\364\377\202\355\360\365\377\3\353\356\363"
  "\377\354\360\365\377\214\215\217\377\202\1\1\1\377\6\212\213\216\377\355"
  "\360\365\377\355\357\365\377\354\357\365\377\357\361\366\377\355\360\366"
  "\377\202\356\360\366\377\5\355\360\366\377\357\361\366\377\357\361\367\377"
  "\357\361\366\377\360\362\367\377\202\357\362\367\377\3\362\365\371\377**"
  "+\377\10\10\10\377\202\6\7\10\377\22\11\14\14\377\17\21\23\377\14\15\16\377"
  "\15\17\20\377\14\15\16\377\15\16\17\377\15\17\20\377\17\21\22\377\10\11\12"
  "\377\11\13\13\3777=A\376<=B\377\14\14\14\377\15\17\20\377\15\16\16\377\0"
  "\0\0\377\272\275\300\377\360\362\367\377\202\360\363\370\377\4\357\361\367"
  "\377\360\362\367\377\357\361\367\377\356\361\366\377\202\357\361\367\377"
  "\202\360\362\367\377\23\355\360\365\377\357\361\367\377\355\360\365\377\355"
  "\357\365\377\355\360\365\377\355\357\365\377\355\357\363\377\355\357\364"
  "\377\354\357\365\377\354\357\364\377\355\357\364\377\355\356\364\377\354"
  "\357\365\377\353\357\364\377\355\357\365\377\354\357\365\377\353\356\364"
  "\377\354\356\364\377\353\356\364\377\202\352\355\363\377\14\353\355\363\377"
  "\353\355\361\377\353\355\363\377\352\355\363\377\351\354\362\377\352\355"
  "\363\377\351\354\362\377\351\355\363\377\352\355\362\377\352\354\362\377"
  "\354\356\363\377\353\355\362\377\202\353\356\364\377\11\354\356\364\377\352"
  "\354\362\377\352\355\363\377\352\354\363\377\352\355\362\377\352\354\362"
  "\377\353\355\362\377\350\353\360\377\352\354\361\377\202\352\355\363\377"
  "\11\351\354\361\377\177\200\203\377\2\2\2\377\13\14\15\377\0\0\0\377\261"
  "\264\271\377\351\353\362\377\352\354\362\377\353\355\363\377\202\352\354"
  "\361\377\3\353\355\361\377\353\355\362\377\352\354\361\377\202\353\356\363"
  "\377\4\353\356\364\377\352\355\363\377\353\356\363\377\352\356\363\377\202"
  "\353\356\363\377\2\353\355\363\377\354\357\364\377\202\353\356\363\377\20"
  "\354\356\364\377\356\360\365\377\354\356\364\377\355\357\365\377\355\360"
  "\365\377\213\214\217\377\2\1\2\377\2\2\2\377\210\212\215\377\356\360\365"
  "\377\355\360\366\377\356\361\366\377\356\360\365\377\355\360\366\377\356"
  "\361\366\377\355\360\366\377\202\356\361\366\377$\357\361\367\377\356\361"
  "\366\377\357\362\367\377\360\362\370\377\357\361\367\377\362\365\371\377"
  "**,\377\4\4\5\377\6\10\10\377\6\7\10\377\10\11\12\377\27\33\35\377\31\34"
  "\36\377\15\17\20\377\10\11\11\377\11\11\11\377\7\7\10\377\21\23\25\377\16"
  "\16\20\377\21\23\24\377\31\34\36\376\14\16\16\377\16\20\20\377\24\25\26\377"
  "\31\34\35\377\1\1\1\377\221\223\226\377\360\363\370\377\360\362\367\377\357"
  "\362\367\377\357\361\367\377\357\361\366\377\357\361\367\377\357\362\367"
  "\377\355\361\366\377\357\362\367\377\202\357\361\367\377\4\357\361\366\377"
  "\357\361\367\377\356\361\366\377\357\361\366\377\203\356\360\365\377\35\355"
  "\357\364\377\355\357\365\377\353\355\363\377\352\355\363\377\354\356\364"
  "\377\355\360\365\377\354\356\364\377\353\357\364\377\352\356\364\377\355"
  "\357\365\377\354\357\364\377\352\355\363\377\353\356\365\377\353\356\364"
  "\377\354\356\364\377\353\356\364\377\353\356\363\377\352\354\363\377\352"
  "\355\363\377\353\356\364\377\352\355\362\377\351\353\361\377\352\355\362"
  "\377\352\355\363\377\351\354\363\377\352\354\360\377\355\357\365\377\353"
  "\356\363\377\354\356\364\377\202\353\355\363\377\202\352\355\363\377\1\351"
  "\354\362\377\202\352\354\362\377\22\352\354\363\377\353\355\363\377\353\354"
  "\362\377\351\354\362\377VWZ\377\3\4\4\377\14\14\15\377\0\0\0\377\262\264"
  "\271\377\351\354\362\377\353\355\363\377\352\354\363\377\352\354\362\377"
  "\352\355\362\377\353\355\363\377\353\356\363\377\352\354\362\377\353\355"
  "\363\377\202\352\355\362\377\7\353\355\363\377\351\354\362\377\352\356\363"
  "\377\353\355\363\377\353\356\363\377\355\357\364\377\354\357\364\377\202"
  "\352\355\363\377\6\352\356\363\377\354\356\361\377\353\355\364\377\354\357"
  "\364\377\356\361\365\377\214\216\220\377\202\2\2\2\377\15\211\212\216\377"
  "\356\360\365\377\355\360\366\377\356\361\366\377\355\360\366\377\356\361"
  "\366\377\356\361\367\377\356\360\366\377\357\361\367\377\357\361\366\377"
  "\357\362\367\377\357\361\367\377\357\362\366\377\202\357\362\367\377\31\363"
  "\365\371\377*+,\377\14\16\17\377\14\17\20\377\7\10\10\377\7\10\11\377\16"
  "\17\21\377\15\17\20\377\14\16\20\377\17\20\21\377\14\14\15\377\7\11\11\377"
  "\12\12\13\377\7\10\11\37779=\377\21\23\24\376\22\25\27\377\12\14\14\377\17"
  "\17\20\377\20\22\23\377\5\5\5\377_`a\377\357\362\367\377\360\362\370\377"
  "\357\362\367\377\202\356\361\366\377\2\357\361\366\377\357\362\367\377\202"
  "\357\361\367\377\21\357\362\367\377\356\361\366\377\357\361\366\377\356\361"
  "\366\377\357\361\367\377\357\362\367\377\356\361\365\377\356\360\366\377"
  "\355\357\365\377\356\360\366\377\354\357\364\377\354\356\364\377\353\357"
  "\364\377\354\357\365\377\354\356\364\377\354\357\365\377\354\356\364\377"
  "\202\354\357\365\377\4\354\356\364\377\352\355\363\377\354\357\364\377\354"
  "\357\365\377\202\353\356\364\377\4\353\356\363\377\352\355\363\377\351\354"
  "\362\377\353\355\364\377\204\352\355\363\377\7\350\353\361\377\352\355\363"
  "\377\354\357\364\377\354\356\364\377\354\355\363\377\352\354\363\377\352"
  "\354\362\377\202\351\354\362\377\1\352\354\362\377\202\351\354\362\377\14"
  "\352\355\363\377\352\354\362\377\352\354\361\377\354\357\365\377#$%\377\5"
  "\6\6\377\16\16\17\377\0\1\1\377\262\264\270\377\352\354\362\377\354\355\363"
  "\377\352\354\362\377\202\353\355\363\377\11\351\354\362\377\352\355\363\377"
  "\351\354\361\377\352\355\362\377\352\354\363\377\353\355\363\377\352\355"
  "\362\377\352\356\362\377\353\357\363\377\202\353\356\363\377\3\355\357\365"
  "\377\353\356\363\377\352\355\363\377\202\354\357\364\377\5\354\356\364\377"
  "\352\356\363\377\355\357\365\377\356\360\365\377\214\215\220\377\202\2\2"
  "\2\377\5\211\212\216\377\355\361\366\377\355\360\366\377\355\360\365\377"
  "\355\361\366\377\202\355\360\366\377#\356\361\366\377\357\361\367\377\357"
  "\362\367\377\357\361\366\377\357\361\367\377\357\362\367\377\360\362\367"
  "\377\361\363\367\377\363\365\371\377*+,\377\7\10\11\377\11\12\12\377\15\20"
  "\20\377\7\10\11\377\11\13\13\377\11\12\13\377\13\13\14\377\12\13\13\377\12"
  "\14\14\377\32\25\27\377W/?\377\243Jk\377\344`\222\377\22\24\26\376\15\16"
  "\17\377\14\17\20\377\24\26\30\377\16\17\20\377\6\7\6\377\"#$\377\361\363"
  "\370\377\357\362\367\377\360\361\367\377\356\361\366\377\357\361\367\377"
  "\202\356\361\367\377\11\357\361\366\377\355\360\366\377\357\361\367\377\356"
  "\361\366\377\357\362\370\377\356\361\367\377\356\360\365\377\356\360\363"
  "\377\356\361\366\377\203\355\357\365\377\3\354\357\364\377\353\356\363\377"
  "\354\356\364\377\202\355\357\365\377\1\353\356\364\377\203\354\357\365\377"
  "\21\354\356\365\377\352\355\364\377\353\357\364\377\355\357\365\377\354\356"
  "\364\377\352\355\363\377\353\354\362\377\354\356\364\377\352\355\363\377"
  "\353\356\364\377\353\355\362\377\352\355\364\377\351\354\362\377\352\355"
  "\362\377\351\354\362\377\353\356\363\377\354\356\363\377\202\353\356\363"
  "\377\26\351\354\362\377\353\355\363\377\354\355\363\377\353\355\363\377\352"
  "\354\362\377\351\354\362\377\352\355\362\377\353\355\363\377\352\355\362"
  "\377\351\354\362\377\325\327\333\377\1\1\1\377\11\11\11\377\13\14\16\377"
  "\0\0\0\377\263\265\272\377\352\354\362\377\352\354\361\377\351\354\362\377"
  "\352\355\363\377\353\355\362\377\352\355\362\377\202\352\355\363\377\4\353"
  "\356\363\377\353\355\363\377\353\356\363\377\354\356\364\377\202\352\356"
  "\363\377\25\353\356\363\377\354\355\364\377\354\356\364\377\352\355\363\377"
  "\353\355\364\377\354\357\363\377\354\357\365\377\353\356\364\377\355\357"
  "\365\377\355\360\365\377\356\361\365\377\214\215\220\377\3\3\4\377\2\3\3"
  "\377\211\213\215\377\355\360\366\377\356\361\366\377\356\360\366\377\356"
  "\361\366\377\355\360\366\377\356\360\366\377\202\356\361\365\377\23\356\362"
  "\367\377\357\362\367\377\360\361\367\377\357\362\367\377\357\361\367\377"
  "\360\363\370\377\362\365\371\377*+,\377\10\11\11\377\10\12\12\377\12\14\14"
  "\377\10\10\10\377\7\10\10\377\7\6\6\377#\30\35\377k8K\377\265Tx\377\353["
  "\222\377\354\\\225\377\202\354\\\223\377\13\14\15\14\376\14\15\15\377\14"
  "\15\14\377\31\35\40\377\21\24\25\377\17\20\21\377\0\0\0\377\317\321\326\377"
  "\360\362\367\377\356\361\366\377\356\360\366\377\202\357\362\367\377\4\356"
  "\361\366\377\357\361\366\377\356\360\366\377\356\360\365\377\202\357\361"
  "\367\377\32\357\361\366\377\356\360\366\377\356\361\366\377\357\360\366\377"
  "\355\357\364\377\355\357\365\377\355\360\365\377\353\357\364\377\354\356"
  "\364\377\354\357\365\377\355\360\365\377\355\357\365\377\354\360\366\377"
  "\353\356\364\377\352\356\364\377\353\357\365\377\353\356\364\377\354\357"
  "\364\377\355\357\365\377\355\360\365\377\355\357\365\377\353\356\363\377"
  "\353\355\362\377\352\354\361\377\353\356\364\377\354\357\365\377\202\354"
  "\357\364\377\202\353\356\363\377\4\352\355\362\377\353\356\363\377\354\356"
  "\364\377\354\356\363\377\202\352\355\362\377\2\352\354\362\377\353\355\363"
  "\377\202\352\355\362\377\33\351\355\362\377\352\354\362\377\352\355\363\377"
  "\351\354\362\377\353\355\363\377\224\226\232\377\1\1\1\377\24\26\30\377\20"
  "\17\20\377\0\0\0\377\263\265\272\377\352\355\362\377\352\354\361\377\353"
  "\354\363\377\353\355\363\377\351\354\361\377\352\354\362\377\352\355\363"
  "\377\353\355\362\377\353\355\363\377\353\356\363\377\352\355\363\377\353"
  "\356\363\377\352\355\362\377\351\355\362\377\352\356\363\377\353\356\363"
  "\377\202\353\355\363\377\15\353\356\363\377\354\356\364\377\354\357\364\377"
  "\354\356\364\377\355\357\364\377\355\360\365\377\355\360\364\377\214\215"
  "\220\377\2\3\3\377\2\2\3\377\211\213\215\377\355\360\365\377\354\360\365"
  "\377\202\356\361\366\377\202\355\360\365\377\1\356\360\365\377\202\355\360"
  "\366\377+\357\361\366\377\357\362\367\377\355\360\365\377\356\361\366\377"
  "\357\361\366\377\360\363\370\377**+\377\6\7\7\377\10\13\13\377\12\14\14\377"
  "0\36$\377s4K\377\272Qx\377\354b\227\377\352a\226\377\347_\225\377\351X\222"
  "\377\354]\224\377\357b\230\377\353^\224\377\13\15\14\376\13\13\13\377\22"
  "\24\25\377\22\25\25\377\25\30\31\377\17\21\22\377\3\3\3\377\204\205\207\377"
  "\357\362\367\377\356\361\366\377\356\361\367\377\357\362\370\377\356\361"
  "\367\377\357\361\366\377\356\360\366\377\356\361\367\377\357\362\367\377"
  "\355\360\365\377\357\361\366\377\356\360\366\377\357\361\367\377\356\360"
  "\366\377\355\360\366\377\202\355\357\365\377\10\353\355\364\377\354\357\365"
  "\377\355\357\365\377\355\360\366\377\355\360\365\377\354\356\365\377\352"
  "\356\364\377\353\356\364\377\202\352\355\363\377\3\352\355\364\377\355\357"
  "\365\377\354\357\365\377\202\355\357\365\377\17\353\356\363\377\352\355\363"
  "\377\351\353\360\377\354\357\364\377\354\360\366\377\354\357\365\377\353"
  "\356\364\377\354\356\365\377\354\357\365\377\354\357\364\377\354\356\364"
  "\377\353\356\363\377\354\356\364\377\354\357\364\377\352\354\361\377\203"
  "\352\355\363\377\2\352\355\362\377\351\354\361\377\203\353\355\363\377\13"
  "\353\356\364\377IJK\377\3\3\3\377\21\23\24\377\17\20\20\377\1\1\1\377\262"
  "\265\272\377\351\355\362\377\351\354\361\377\351\353\360\377\352\354\362"
  "\377\202\353\355\363\377#\351\354\362\377\352\355\363\377\353\355\363\377"
  "\352\354\362\377\353\354\362\377\352\354\362\377\351\354\362\377\347\353"
  "\360\377\350\355\362\377\351\354\362\377\351\355\363\377\353\356\363\377"
  "\351\354\362\377\354\356\363\377\354\356\364\377\354\357\364\377\355\357"
  "\364\377\353\356\364\377\354\356\364\377\213\215\220\377\3\3\4\377\6\6\10"
  "\377\211\212\215\377\354\356\364\377\355\357\365\377\353\356\364\377\355"
  "\360\365\377\354\357\363\377\355\360\365\377\354\357\365\377\354\356\364"
  "\377\356\360\365\377\355\360\365\377\356\361\366\377\355\357\365\377\202"
  "\355\360\365\377\31\361\363\370\377-,.\3776\33%\377\206A\\\377\311T\201\377"
  "\353]\224\377\355a\227\377\354\\\223\377\354b\227\377\352_\224\377\344S\214"
  "\377\347]\222\377\355a\227\377\354`\225\377\355_\225\377\16\17\17\376\24"
  "\30\31\377\13\14\14\377\23\25\26\377\22\24\25\377\33\37!\377\36\36!\377,"
  ",-\377\361\363\370\377\357\361\367\377\202\357\362\367\377\1\356\361\367"
  "\377\203\357\361\367\377\15\357\361\366\377\355\361\366\377\357\361\367\377"
  "\355\360\365\377\356\360\366\377\355\360\365\377\356\361\366\377\355\357"
  "\365\377\354\356\364\377\352\355\363\377\355\360\366\377\356\360\365\377"
  "\355\360\365\377\202\356\360\366\377\2\355\360\365\377\356\360\365\377\202"
  "\356\360\366\377\12\354\356\364\377\355\357\364\377\355\360\365\377\355\360"
  "\364\377\355\360\365\377\354\357\364\377\353\355\363\377\351\354\362\377"
  "\354\357\364\377\354\356\365\377\203\353\356\364\377\3\352\355\363\377\354"
  "\356\364\377\353\356\363\377\202\354\356\364\377\202\354\356\363\377\24\353"
  "\356\364\377\354\356\364\377\352\355\363\377\353\354\362\377\352\354\362"
  "\377\353\355\362\377\353\355\363\377\353\356\364\377\332\334\341\377\6\6"
  "\6\377\11\11\11\377\"(+\377\13\13\13\377\0\0\0\377\261\264\271\377\352\354"
  "\362\377\351\353\357\377\351\353\360\377\350\353\361\377\351\354\361\377"
  "\203\352\355\362\377\6\353\355\363\377\352\354\362\377\353\355\363\377\352"
  "\355\363\377\352\355\362\377\347\353\360\377\202\352\355\362\377\6\352\354"
  "\362\377\353\354\362\377\352\355\363\377\353\355\363\377\353\356\363\377"
  "\354\357\364\377\202\354\356\364\377\15\354\357\364\377\213\215\220\377\3"
  "\3\4\377\2\3\4\377\211\213\215\377\354\356\363\377\354\357\365\377\353\357"
  "\365\377\355\360\365\377\355\357\365\377\354\360\364\377\355\357\365\377"
  "\354\357\364\377\202\355\360\365\377%\356\361\366\377\354\357\365\377\353"
  "\353\361\377\343\303\323\377\344\233\272\377\332c\220\377\357d\231\377\354"
  "a\226\377\351Y\223\377\352^\224\377\350Y\221\377\354`\226\377\354a\224\377"
  "\351Y\220\377\344U\214\377\347X\221\377\351\\\223\377\352[\222\377\352X\221"
  "\377\15\17\17\376\15\17\16\377\14\16\16\377\16\20\20\377\13\15\16\377\25"
  "\26\27\377\11\11\12\377\0\0\0\377\275\277\303\377\360\363\370\377\357\362"
  "\370\377\360\362\370\377\357\361\367\377\357\362\367\377\360\361\370\377"
  "\357\361\367\377\356\361\367\377\357\361\366\377\202\356\361\366\377\11\356"
  "\360\366\377\355\360\366\377\356\360\366\377\355\360\365\377\354\356\364"
  "\377\354\357\364\377\355\357\365\377\356\360\366\377\356\360\365\377\202"
  "\360\362\367\377\1\356\361\365\377\202\355\357\365\377\7\355\357\364\377"
  "\354\357\365\377\355\357\364\377\355\356\364\377\355\357\365\377\354\356"
  "\364\377\354\357\365\377\202\354\357\364\377\202\354\357\365\377\17\353\356"
  "\364\377\354\356\364\377\353\356\364\377\353\355\364\377\353\356\363\377"
  "\354\356\364\377\355\357\364\377\354\357\364\377\353\356\364\377\354\356"
  "\364\377\352\354\364\377\352\355\363\377\351\354\362\377\352\355\363\377"
  "\351\354\362\377\202\352\355\363\377\16\353\356\364\377\202\203\207\377\1"
  "\2\2\377\24\26\27\377\20\21\22\377\15\17\17\377\0\0\0\377\261\263\270\377"
  "\351\353\361\377\351\353\360\377\352\354\362\377\352\354\361\377\352\354"
  "\362\377\353\355\362\377\202\351\354\362\377\202\352\354\362\377\4\352\355"
  "\363\377\352\354\363\377\352\354\362\377\352\356\363\377\202\353\356\363"
  "\377\4\353\355\363\377\352\355\363\377\353\355\363\377\353\356\363\377\202"
  "\354\357\364\377\4\353\356\363\377\354\357\365\377\354\357\364\377\213\214"
  "\217\377\202\1\2\2\377\7\212\213\215\377\356\360\365\377\354\357\365\377"
  "\355\360\365\377\356\360\365\377\354\356\364\377\356\361\366\377\202\354"
  "\357\365\377\"\356\361\366\377\351\342\352\377\343\265\312\377\341\212\255"
  "\377\345a\224\377\351[\222\377\350Y\221\377\352]\224\377\352`\225\377\351"
  "[\222\377\350\\\222\377\347W\217\377\346Y\221\377\351b\226\377\352Y\220\377"
  "\347[\221\377\346V\216\377\347Z\221\377\347Y\221\377\353^\224\377\353]\224"
  "\377\26\32\33\376\36!\"\377,03\377\17\20\21\377\15\15\16\377\27\31\32\377"
  "\13\13\13\377\5\5\5\377RRT\377\361\363\370\377\357\361\367\377\357\361\370"
  "\377\357\362\367\377\202\357\361\367\377\14\357\362\370\377\357\361\367\377"
  "\357\362\367\377\356\361\367\377\356\360\366\377\357\361\366\377\355\357"
  "\365\377\355\360\365\377\355\360\366\377\356\360\365\377\354\357\365\377"
  "\353\356\364\377\203\355\357\365\377\202\356\361\366\377\4\354\357\365\377"
  "\355\360\366\377\354\356\364\377\353\356\364\377\202\354\357\364\377\12\355"
  "\357\365\377\354\357\364\377\355\360\365\377\355\357\365\377\355\360\365"
  "\377\354\357\364\377\354\357\365\377\353\356\364\377\355\357\365\377\354"
  "\357\364\377\203\353\356\364\377\10\354\356\363\377\354\356\364\377\353\355"
  "\363\377\352\355\363\377\352\355\362\377\352\354\362\377\350\353\361\377"
  "\352\354\362\377\202\352\354\363\377\16\352\355\363\377\350\353\361\377\35"
  "\35\36\377\20\21\23\377\17\21\22\377\7\10\10\377\14\14\14\377\0\0\0\377\263"
  "\264\271\377\352\354\361\377\352\355\363\377\354\357\364\377\355\357\364"
  "\377\354\357\364\377\202\353\355\363\377\7\351\354\361\377\353\355\363\377"
  "\352\355\363\377\354\356\364\377\353\356\364\377\353\356\363\377\353\357"
  "\363\377\202\354\357\365\377\12\355\360\365\377\354\360\365\377\354\357\365"
  "\377\356\360\365\377\355\357\364\377\355\360\366\377\354\357\365\377\355"
  "\360\366\377\356\361\366\377\214\216\220\377\202\1\2\2\377+\213\214\216\377"
  "\357\362\367\377\360\363\370\377\361\363\371\377\362\364\371\377\360\363"
  "\370\377\360\363\371\377\352\336\350\377\350\254\306\377\346\200\250\377"
  "\351_\224\377\352a\226\377\345V\217\377\351]\222\377\343U\217\377\345]\222"
  "\377\345Z\221\377\344U\220\377\344Y\217\377\347[\223\377\346X\220\377\347"
  "X\220\377\351Y\223\377\351[\223\377\346X\222\377\352`\226\377\345U\215\377"
  "\347W\221\377\347]\223\377\347[\222\377\25\30\31\376\16\22\23\377\23\24\25"
  "\377\21\24\25\377\15\17\17\377\17\22\22\377\12\13\13\377\6\7\7\377\2\2\2"
  "\377\311\313\317\377\357\361\366\377\357\361\367\377\356\361\367\377\202"
  "\357\362\367\377\1\356\361\367\377\203\357\362\367\377\2\356\360\366\377"
  "\357\361\366\377\202\356\361\366\377\11\355\360\365\377\356\360\366\377\355"
  "\360\366\377\355\357\365\377\355\360\365\377\354\357\365\377\354\357\366"
  "\377\356\361\367\377\356\360\365\377\202\355\357\365\377\10\355\360\365\377"
  "\354\356\363\377\355\357\363\377\355\357\365\377\354\356\364\377\354\360"
  "\365\377\354\357\365\377\354\356\364\377\203\354\357\365\377\2\352\356\363"
  "\377\354\356\365\377\202\353\356\364\377\7\353\356\363\377\352\355\363\377"
  "\353\355\362\377\352\354\361\377\352\355\363\377\351\354\362\377\352\355"
  "\363\377\202\351\354\362\377\26\352\355\363\377\352\355\362\377\352\355\363"
  "\377\353\355\363\377\222\223\227\377\2\2\2\377\21\24\24\377\14\16\16\377"
  "\13\15\16\377\13\13\14\377\0\0\0\377\262\264\271\377\352\355\363\377\356"
  "\360\365\377\355\360\365\377\356\360\365\377\356\360\366\377\353\356\363"
  "\377\352\355\363\377\353\356\363\377\352\355\362\377\351\355\362\377\202"
  "\353\356\364\377\21\353\356\363\377\352\356\364\377\354\356\364\377\355\360"
  "\366\377\355\360\365\377\355\360\366\377\355\357\365\377\355\357\364\377"
  "\354\357\364\377\355\360\365\377\354\357\365\377\356\361\366\377\357\361"
  "\366\377\215\215\220\377\3\4\4\377\5\6\7\377\34\35\35\377\202113\377/556"
  "\377_IS\377\253a\177\377\330f\223\377\347]\222\377\353c\226\377\353a\226"
  "\377\351_\224\377\351`\225\377\350^\223\377\352a\225\377\347]\222\377\346"
  "Y\220\377\345Y\221\377\343Z\216\377\340V\215\377\347^\224\377\352_\224\377"
  "\351[\221\377\347[\222\377\351\\\221\377\351\\\222\377\345X\221\377\350]"
  "\222\377\350]\223\377\344X\216\377\344Z\222\377\27\30\32\376\14\16\16\377"
  "\16\20\21\377\25\27\31\377\22\24\25\377\13\14\14\377\13\15\15\377\12\13\12"
  "\377\1\2\3\377LMN\377\361\363\370\377\357\361\367\377\357\362\370\377\360"
  "\362\367\377\361\363\370\377\357\362\367\377\360\362\370\377\360\362\367"
  "\377\357\361\367\377\356\360\366\377\202\356\361\366\377\5\356\362\366\377"
  "\355\360\365\377\356\360\366\377\355\360\366\377\355\357\366\377\202\355"
  "\360\365\377\7\354\357\365\377\356\360\366\377\357\361\366\377\356\361\366"
  "\377\356\360\365\377\355\360\365\377\355\360\366\377\202\355\360\365\377"
  "\14\354\357\364\377\353\356\364\377\353\357\363\377\354\357\365\377\353\356"
  "\364\377\352\355\364\377\354\356\364\377\353\356\364\377\354\356\364\377"
  "\353\356\364\377\352\355\364\377\354\356\364\377\202\354\357\364\377\7\353"
  "\356\364\377\353\355\363\377\352\355\362\377\352\355\363\377\354\356\364"
  "\377\353\355\363\377\353\356\363\377\202\354\356\364\377\27\346\350\354\377"
  "\33\33\34\377\25\30\30\377\12\12\12\377\16\20\21\377\34\36\40\377\15\15\15"
  "\377\0\0\0\377\262\265\271\377\354\356\364\377\355\360\365\377\355\362\367"
  "\377\357\361\366\377\356\360\366\377\354\356\364\377\352\355\362\377\353"
  "\356\363\377\354\357\364\377\353\356\364\377\355\357\364\377\354\356\363"
  "\377\351\355\362\377\354\360\365\377\202\355\360\365\3776\355\357\365\377"
  "\354\357\365\377\355\357\365\377\356\361\366\377\357\362\367\377\356\361"
  "\366\377\355\361\366\377\356\361\366\377\356\361\365\377\214\215\220\377"
  "\1\1\1\377\12\14\14\377\11\15\13\377F#0\377\220>]\377\322T\204\377\347Y\217"
  "\377\342S\214\377\342U\214\377\350^\223\377\347\\\223\377\350^\224\377\347"
  "]\222\377\351a\224\377\352c\227\377\344[\221\377\346]\223\377\345Z\221\377"
  "\345[\220\377\341R\213\377\342U\213\377\351_\225\377\351_\224\377\350\\\222"
  "\377\350]\223\377\347Y\221\377\347[\222\377\351\\\221\377\351^\223\377\346"
  "W\220\377\350Z\222\377\345Z\217\377\12\13\13\376\25\26\30\377\16\20\21\377"
  "\40#&\377\22\24\26\377>CH\377\16\16\17\377\11\13\13\377\11\11\11\377\0\0"
  "\0\377\255\260\263\377\357\362\370\377\202\357\362\367\377\4\360\362\367"
  "\377\357\362\367\377\357\362\370\377\360\363\370\377\202\360\362\367\377"
  "\202\357\361\366\377\3\357\361\367\377\355\360\365\377\356\361\367\377\202"
  "\355\360\366\377\7\356\360\365\377\356\361\367\377\355\360\366\377\356\360"
  "\366\377\357\361\366\377\356\361\367\377\357\361\366\377\202\355\360\365"
  "\377\12\355\360\366\377\356\360\367\377\356\360\366\377\355\357\365\377\354"
  "\357\365\377\354\357\364\377\352\356\364\377\353\357\364\377\353\356\364"
  "\377\352\356\364\377\202\353\356\364\377\13\354\356\364\377\353\356\363\377"
  "\354\356\363\377\355\357\365\377\353\355\363\377\352\355\363\377\353\356"
  "\364\377\353\355\362\377\354\356\364\377\353\356\362\377\352\355\363\377"
  "\202\354\357\364\377\13vwy\377\1\1\1\377\14\15\15\377\33\36\40\377\16\21"
  "\20\377\23\24\24\377\13\14\15\377\0\0\0\377\264\266\273\377\353\356\363\377"
  "\354\357\364\377\202\355\357\365\377\5\354\357\364\377\354\356\362\377\352"
  "\355\363\377\354\356\364\377\354\357\364\377\202\354\357\365\377\10\355\360"
  "\366\377\355\357\365\377\354\360\365\377\356\360\366\377\354\357\365\377"
  "\356\361\366\377\354\357\365\377\356\360\366\377\202\357\362\366\377B\357"
  "\362\367\377\356\362\367\377\357\361\367\377\357\362\367\377\225\220\225"
  "\377Q%5\377\235Ce\377\331]\214\377\352_\223\377\352_\224\377\351]\224\377"
  "\346Y\220\377\345U\216\377\342X\215\377\343X\216\377\345Y\221\377\346[\220"
  "\377\351^\222\377\350^\222\377\344Y\217\377\340X\216\377\340S\214\377\341"
  "X\216\377\343U\215\377\350\\\222\377\343X\220\377\350\\\224\377\347U\216"
  "\377\353\\\222\377\352Z\221\377\347V\220\377\346W\217\377\351Y\221\377\352"
  "^\223\377\351^\224\377\350`\226\377\350[\221\377\37!#\376\16\17\17\377\20"
  "\22\23\377\15\17\17\377\22\23\26\377\14\15\15\377\12\13\13\377\11\10\10\377"
  "\14\15\15\377\2\3\3\377\37\40\40\377\345\350\354\377\356\361\367\377\356"
  "\362\366\377\357\362\370\377\356\361\367\377\357\361\367\377\356\361\367"
  "\377\357\361\367\377\357\362\367\377\357\361\367\377\357\361\366\377\360"
  "\362\370\377\356\361\366\377\356\360\366\377\356\361\367\377\356\361\366"
  "\377\357\361\367\377\356\360\366\377\202\355\360\366\377\1\355\360\365\377"
  "\202\356\360\365\377\17\355\360\365\377\355\357\366\377\356\361\366\377\357"
  "\361\366\377\356\360\366\377\356\360\365\377\355\360\365\377\353\356\364"
  "\377\354\357\365\377\353\356\364\377\354\357\365\377\352\355\363\377\353"
  "\356\364\377\354\356\364\377\353\355\363\377\202\353\356\363\377\7\355\357"
  "\364\377\352\355\362\377\352\354\362\377\353\356\363\377\353\355\363\377"
  "\353\356\363\377\354\356\364\377\202\353\356\364\377\33\304\306\313\377\6"
  "\6\6\377\5\6\5\377\14\15\16\377\22\24\24\377\15\17\16\377\20\21\22\377\25"
  "\27\30\377\0\0\0\377\263\265\272\377\352\355\363\377\355\356\363\377\352"
  "\355\363\377\353\356\363\377\353\355\363\377\353\356\363\377\354\357\364"
  "\377\354\356\364\377\355\360\364\377\355\360\365\377\354\357\364\377\355"
  "\360\366\377\356\360\365\377\354\360\365\377\356\360\365\377\355\360\365"
  "\377\356\361\366\377\203\355\360\366\377+\356\361\366\377\357\362\370\377"
  "\355\340\353\377\346\263\313\377\342~\244\377\342Y\217\377\347Y\221\377\346"
  "\\\223\377\344V\217\377\346V\216\377\353c\226\377\353_\224\377\351Z\221\377"
  "\345Y\217\377\345[\220\377\346[\221\377\345X\220\377\350[\221\377\351`\223"
  "\377\347[\221\377\342T\215\377\342W\216\377\343S\214\377\343X\216\377\346"
  "[\222\377\350[\221\377\351`\224\377\350X\220\377\351Z\222\377\347Y\217\377"
  "\347Y\221\377\346[\221\377\347]\223\377\351]\223\377\347\\\222\377\347]\224"
  "\377\347W\220\377\352Z\222\377\32\36\37\376*02\377\13\13\13\377\15\20\20"
  "\377\15\16\16\377\202\11\11\11\377\23\11\13\13\377\11\11\11\377\10\11\10"
  "\377\1\1\1\377]^`\377\357\362\367\377\356\361\367\377\357\361\367\377\356"
  "\361\366\377\357\361\366\377\357\362\367\377\357\361\367\377\356\360\366"
  "\377\357\361\367\377\356\361\366\377\357\362\370\377\357\361\367\377\356"
  "\362\367\377\356\361\366\377\202\357\362\367\377\12\357\361\366\377\356\361"
  "\367\377\356\360\366\377\357\361\366\377\356\360\366\377\357\361\366\377"
  "\355\357\365\377\354\357\366\377\356\362\367\377\356\360\366\377\202\355"
  "\360\366\377$\353\356\365\377\355\360\365\377\353\356\364\377\352\355\363"
  "\377\354\356\365\377\353\356\364\377\354\357\365\377\354\357\364\377\353"
  "\356\364\377\354\357\365\377\353\356\364\377\353\356\363\377\353\355\363"
  "\377\354\355\363\377\352\354\361\377\353\356\364\377\353\355\363\377\354"
  "\356\363\377\353\355\363\377\345\350\356\377*+,\377\3\3\2\377\7\10\10\377"
  "\12\12\12\377\14\14\15\377\20\17\16\377\15\17\20\377\22\24\25\377\0\0\0\377"
  "\262\265\272\377\353\356\363\377\353\355\362\377\353\356\364\377\353\356"
  "\363\377\353\356\364\377\353\356\363\377\202\355\357\365\377\2\355\360\365"
  "\377\355\357\364\377\202\356\360\366\377\2\354\357\365\377\355\361\366\377"
  "\202\356\361\366\377G\357\361\366\377\355\361\366\377\355\360\366\377\350"
  "\323\340\377\345\244\300\377\345y\240\377\345W\217\377\344X\220\377\345Y"
  "\217\377\343W\215\377\343U\215\377\346[\217\377\351]\223\377\350X\221\377"
  "\351]\222\377\350X\217\377\351Z\220\377\350]\222\377\352[\221\377\352^\224"
  "\377\350[\222\377\350^\221\377\350]\221\377\347[\221\377\342U\214\377\347"
  "\\\221\377\343U\213\377\342R\211\377\345Z\217\377\344V\214\377\343V\214\377"
  "\342U\214\377\346X\216\377\347X\220\377\345W\216\377\343W\216\377\346X\217"
  "\377\345Y\217\377\350]\224\377\345Y\217\377\345T\215\377\351\\\222\377\17"
  "\23\22\376\20\22\21\377\13\14\14\377\11\11\10\377\10\10\7\377\11\13\12\377"
  "\15\16\17\377\26\26\30\377\12\13\14\377\7\10\10\377\20\21\21\377\0\0\0\377"
  "\226\230\232\377\355\361\366\377\357\360\366\377\356\360\365\377\355\360"
  "\366\377\360\362\367\377\357\361\367\377\357\362\370\377\356\361\366\377"
  "\357\362\367\377\360\362\370\377\356\361\366\377\356\360\366\377\356\361"
  "\366\377\357\361\367\377\355\360\366\377\356\361\366\377\202\356\361\367"
  "\377\13\356\360\366\377\356\361\366\377\355\360\366\377\356\360\366\377\356"
  "\360\367\377\356\361\366\377\355\360\366\377\356\360\366\377\357\361\367"
  "\377\356\361\366\377\354\357\365\377\202\353\356\364\377\2\353\357\365\377"
  "\354\357\365\377\203\354\357\364\377\31\354\356\364\377\353\356\363\377\354"
  "\356\364\377\353\355\363\377\354\356\364\377\352\354\361\377\354\356\364"
  "\377\353\356\364\377\354\357\364\377\353\356\364\377]]_\377\1\1\0\377\10"
  "\10\7\377\10\10\10\377\15\16\16\377\14\15\15\377\15\17\17\377\14\15\15\377"
  "\15\17\17\377\0\0\0\377\263\266\273\377\353\356\363\377\353\355\362\377\354"
  "\357\365\377\353\356\363\377\202\355\360\365\3777\354\357\365\377\353\355"
  "\364\377\355\357\365\377\355\357\364\377\355\360\366\377\356\360\366\377"
  "\356\361\367\377\354\360\364\377\356\361\366\377\355\356\364\377\351\307"
  "\330\377\347\230\272\377\345n\235\377\345_\222\377\345]\220\377\344Z\217"
  "\377\342V\216\377\345Y\220\377\345Z\220\377\343Y\217\377\342U\214\377\346"
  "Z\220\377\354d\226\377\351\\\221\377\353]\223\377\352[\221\377\352^\223\377"
  "\353b\226\377\354]\223\377\350X\220\377\350\\\221\377\346Z\220\377\347_\224"
  "\377\343V\215\377\343T\214\377\341P\212\377\340U\214\377\336Q\210\377\337"
  "Q\210\377\340S\213\377\342S\214\377\344Y\217\377\344V\215\377\350Y\221\377"
  "\346U\215\377\344T\214\377\345X\216\377\347[\220\377\342W\216\377\345X\217"
  "\377\344V\215\377\347\\\223\377\13\15\15\376\10\11\12\377\12\15\15\377\202"
  "\13\13\13\377\12\22\24\25\377\14\15\15\377\11\13\12\377\12\14\14\377\24\27"
  "\27\377\26\27\30\377\14\16\16\377\6\6\7\377\270\272\275\377\357\361\367\377"
  "\202\357\362\367\377\21\360\362\370\377\361\363\370\377\357\362\367\377\360"
  "\362\370\377\357\362\370\377\357\361\367\377\357\362\367\377\357\361\366"
  "\377\356\361\367\377\357\361\366\377\357\361\367\377\356\362\367\377\355"
  "\360\366\377\357\361\367\377\356\361\367\377\356\360\366\377\355\361\366"
  "\377\202\355\360\365\377\12\356\361\367\377\356\361\366\377\356\361\367\377"
  "\356\360\366\377\356\361\367\377\354\357\364\377\355\360\365\377\354\357"
  "\364\377\354\357\365\377\354\356\364\377\202\354\357\364\377\202\354\357"
  "\365\377\4\354\356\365\377\354\356\364\377\354\357\364\377\355\357\365\377"
  "\202\353\356\363\377\6\353\356\364\377\355\360\364\377\204\206\210\377\0"
  "\0\0\377\7\7\6\377\11\12\11\377\202\14\15\15\377\15\25\27\30\377\10\10\10"
  "\377\27\33\35\377\26\30\32\377\0\0\0\377\264\266\273\377\354\356\364\377"
  "\352\356\363\377\354\357\365\377\354\360\365\377\355\357\365\377\355\360"
  "\365\377\355\360\366\377\202\354\357\364\377C\355\357\365\377\356\360\366"
  "\377\355\360\366\377\354\352\361\377\345\273\316\377\344\223\263\377\343"
  "f\227\377\344Y\222\377\350_\223\377\351d\224\377\353i\230\377\351a\222\377"
  "\345Y\217\377\342S\215\377\347[\220\377\350`\223\377\343Z\216\377\342U\214"
  "\377\344Z\220\377\346[\220\377\345W\216\377\351Y\220\377\353b\224\377\353"
  "\\\222\377\350X\217\377\350[\222\377\347Z\220\377\350\\\221\377\347[\221"
  "\377\345Y\220\377\344W\216\377\337Q\213\377\340T\214\377\343X\216\377\341"
  "T\213\377\341S\212\377\343W\216\377\345W\216\377\344Z\217\377\347[\222\377"
  "\347Z\220\377\346W\216\377\343U\215\377\343T\215\377\344Z\221\377\342T\214"
  "\377\345X\220\377\345X\217\377\346X\220\377\23\24\24\376\11\12\12\377\15"
  "\16\17\377\30\32\33\377\16\21\23\377\11\12\12\377\14\16\16\377\12\12\11\377"
  "\12\15\15\377\26\31\31\377\16\17\20\377\7\10\7\377\3\4\3\377\20\20\20\377"
  "\307\311\314\377\360\363\370\377\356\361\367\377\357\362\367\377\202\360"
  "\362\367\377\10\360\363\370\377\360\362\367\377\357\362\367\377\360\362\370"
  "\377\357\361\367\377\356\361\366\377\357\362\366\377\360\362\370\377\202"
  "\357\362\367\377\21\357\361\367\377\356\361\366\377\355\360\365\377\356\361"
  "\366\377\356\360\366\377\355\360\366\377\355\360\365\377\356\361\367\377"
  "\356\360\365\377\357\361\366\377\356\361\366\377\354\357\365\377\355\360"
  "\366\377\355\357\364\377\354\357\366\377\354\357\364\377\354\357\365\377"
  "\202\355\357\365\377\203\354\357\364\377\27\355\357\364\377\356\360\365\377"
  "\354\357\364\377\353\356\364\377\354\356\364\377\231\233\237\377\2\2\2\377"
  "\23\24\26\377\10\10\7\377\11\12\11\377\12\12\12\377\33\35\36\377\14\15\15"
  "\377\12\13\13\377\15\16\20\377\14\15\14\377\0\0\0\377\264\267\273\377\355"
  "\357\365\377\354\357\364\377\354\357\365\377\354\360\365\377\354\357\365"
  "\377\202\355\360\365\377\202\355\360\366\377E\354\341\352\377\355\265\316"
  "\377\354\213\261\377\347f\227\377\347]\224\377\346b\227\377\345\\\222\377"
  "\346Z\220\377\352^\223\377\356g\230\377\353b\222\377\345X\215\377\344Y\220"
  "\377\344X\220\377\346\\\221\377\346Z\220\377\344W\214\377\343W\216\377\345"
  "X\217\377\345X\216\377\342V\216\377\345Y\217\377\350\\\222\377\351_\224\377"
  "\351\\\222\377\352_\224\377\346Y\217\377\347[\221\377\346Y\217\377\351\\"
  "\222\377\350X\220\377\350_\222\377\347Z\220\377\345X\216\377\343W\216\377"
  "\344T\214\377\343Y\217\377\345Z\217\377\346W\216\377\350\\\222\377\352^\224"
  "\377\347W\220\377\346V\215\377\346Y\221\377\347Y\220\377\345Z\221\377\346"
  "Y\220\377\347V\217\377\346W\217\377\30\33\34\376\12\13\12\377\12\15\15\377"
  "+01\377\20\21\22\377\12\13\12\377\11\12\11\377\26\33\32\377\32\34\35\377"
  "!$'\377\15\17\17\377\13\15\15\377\24\26\30\377\3\3\3\377\24\24\25\377\304"
  "\306\311\377\356\361\367\377\357\361\367\377\360\363\370\377\360\363\371"
  "\377\203\360\362\370\377\12\360\361\367\377\357\362\367\377\356\362\367\377"
  "\357\362\370\377\357\361\367\377\357\362\367\377\360\362\370\377\356\361"
  "\367\377\356\361\366\377\356\360\366\377\202\355\360\366\377\202\356\361"
  "\367\377!\357\361\367\377\355\360\366\377\356\360\365\377\354\360\366\377"
  "\355\360\366\377\356\361\366\377\355\360\365\377\354\357\366\377\354\357"
  "\365\377\355\360\365\377\354\357\365\377\353\357\364\377\355\360\365\377"
  "\353\356\364\377\355\360\366\377\356\360\365\377\354\356\364\377\353\356"
  "\364\377\354\357\365\377\230\232\236\377\3\3\4\377\6\7\7\377\14\15\15\377"
  "\16\20\21\377\13\13\13\377\17\20\20\377#%'\377\23\23\23\377\12\11\11\377"
  "\15\17\20\377\10\11\10\377\0\0\0\377\264\266\273\377\202\355\357\365\377"
  "<\354\357\365\377\355\360\365\377\356\360\366\377\356\361\366\377\353\332"
  "\346\377\355\255\311\377\347{\246\377\351_\224\377\351_\226\377\352c\226"
  "\377\350Z\221\377\345[\224\377\346^\222\377\347]\221\377\344U\214\377\345"
  "U\215\377\352\\\220\377\350^\220\377\343W\215\377\342V\215\377\344W\215\377"
  "\346V\216\377\350W\217\377\343U\216\377\342W\215\377\342T\214\377\343T\215"
  "\377\343X\215\377\345[\220\377\350^\224\377\353d\230\377\352\\\223\377\351"
  "Z\220\377\344V\215\377\344W\217\377\346X\217\377\346Y\220\377\351[\222\377"
  "\354a\225\377\347W\217\377\344U\216\377\346Y\220\377\347X\217\377\350Z\220"
  "\377\345Z\220\377\346[\220\377\342R\213\377\347\\\221\377\350[\221\377\347"
  "X\220\377\347\\\221\377\346W\216\377\345Z\220\377\351Z\221\377\350Y\220\377"
  "\351]\224\377\22\25\26\3766;@\377\10\12\11\377\10\11\11\377\202\12\13\13"
  "\377\20\13\14\14\377\7\10\10\377\31\35\40\377\27\30\30\377\10\11\10\377\17"
  "\21\22\377\16\17\17\377\14\14\15\377\5\6\5\377\15\15\16\377\261\264\266\377"
  "\360\363\370\377\357\362\367\377\360\363\370\377\360\362\370\377\360\363"
  "\370\377\202\360\362\370\377\1\356\361\366\377\202\357\362\367\377\1\356"
  "\361\366\377\202\357\362\370\377\1\360\362\367\377\202\357\361\366\377\24"
  "\356\360\366\377\357\361\367\377\357\362\367\377\360\362\367\377\357\362"
  "\370\377\357\362\367\377\356\360\366\377\355\360\366\377\356\360\366\377"
  "\355\360\366\377\354\357\364\377\354\357\365\377\355\357\365\377\353\356"
  "\364\377\354\357\365\377\355\357\365\377\354\357\365\377\353\356\364\377"
  "\355\357\365\377\354\357\364\377\202\355\357\365\377X\203\204\207\377\2\2"
  "\2\377\5\6\5\377\32\36\37\377\17\17\17\377\10\10\7\377\12\14\14\377\14\15"
  "\15\377**,\377\7\10\10\377\10\11\10\377\13\13\13\377\16\17\20\377\0\0\0\377"
  "\264\267\273\377\355\360\365\377\356\360\364\377\356\361\365\377\353\324"
  "\341\377\353\244\301\377\356}\251\377\356g\230\377\346Y\220\377\345Y\220"
  "\377\350Z\222\377\347]\222\377\351b\226\377\347X\220\377\347^\223\377\351"
  "_\224\377\351a\225\377\344U\214\377\344V\214\377\345Z\216\377\346[\220\377"
  "\345Z\220\377\343Z\216\377\346Z\220\377\351a\223\377\351_\224\377\343X\217"
  "\377\343X\216\377\344X\217\377\342S\214\377\342X\216\377\345\\\221\377\351"
  "^\223\377\354b\227\377\353[\221\377\350[\220\377\347Z\221\377\344V\215\377"
  "\345Z\217\377\347[\222\377\350[\220\377\353a\225\377\346T\216\377\346W\217"
  "\377\351_\222\377\347[\221\377\350\\\222\377\347W\220\377\344W\216\377\350"
  "[\220\377\352]\222\377\350[\221\377\346[\221\377\347T\216\377\352_\225\377"
  "\350Y\220\377\353a\225\377\352Z\222\377\350Z\220\377\17\22\22\376\15\21\21"
  "\377\35!\"\377\23\23\24\377\11\11\11\377\32\35\35\377.16\377\17\20\20\377"
  "\26\27\30\377\13\16\16\377\35\37\37\377\11\11\11\377\11\13\13\377\13\14\14"
  "\377\13\14\13\377\202\4\4\4\377\16\210\212\214\377\360\362\367\377\356\362"
  "\367\377\360\361\367\377\360\363\370\377\357\363\370\377\360\363\370\377"
  "\360\362\370\377\357\361\366\377\360\363\370\377\357\362\367\377\356\360"
  "\365\377\360\362\370\377\357\361\367\377\203\356\361\366\377\10\357\362\367"
  "\377\357\362\370\377\360\362\367\377\356\362\367\377\357\362\367\377\356"
  "\361\367\377\360\362\367\377\355\361\366\377\202\355\360\365\377\6\355\360"
  "\366\377\354\357\365\377\353\356\364\377\352\356\363\377\354\357\365\377"
  "\355\360\366\377\202\355\360\365\377\35\355\360\364\377\346\351\357\377["
  "[]\377\0\0\0\377\6\7\6\377\31\33\35\377\15\17\17\377\11\11\10\377\10\11\11"
  "\377\7\7\7\377\7\10\10\377\5\6\6\377\7\7\7\377\6\7\6\377\21\23\24\377\13"
  "\15\16\377\0\0\0\377\264\263\270\377\351\310\330\377\351\230\270\377\352"
  "m\237\377\351]\223\377\351\\\224\377\353^\225\377\350_\225\377\350]\223\377"
  "\347\\\222\377\350\\\222\377\347`\225\377\202\351a\225\377\177\352a\226\377"
  "\345W\216\377\347[\220\377\344V\214\377\342V\211\377\340T\214\377\345X\216"
  "\377\345V\217\377\347W\217\377\347^\222\377\347X\220\377\345[\217\377\345"
  "Y\217\377\341T\213\377\336P\210\377\341T\212\377\342X\216\377\346`\223\377"
  "\350]\223\377\354c\226\377\351[\222\377\352^\223\377\352]\224\377\352]\223"
  "\377\350[\221\377\346U\215\377\352^\223\377\351\\\222\377\350_\224\377\343"
  "W\215\377\345Y\217\377\346X\217\377\346X\220\377\351Y\221\377\350Z\220\377"
  "\351[\222\377\350Y\221\377\346X\221\377\350\\\222\377\350Z\220\377\351X\221"
  "\377\345S\215\377\347Y\217\377\346W\220\377\352_\224\377\24\27\30\376\22"
  "\26\25\377FJP\377036\377\15\20\17\377\20\21\23\377\26\27\31\377\20\21\22"
  "\377\16\20\17\377\40\40\"\377\32\34\35\377\13\13\13\377\10\11\11\377\12\12"
  "\12\377\17\20\20\377\11\11\11\377\10\10\7\377\0\0\0\377KKM\377\334\337\343"
  "\377\357\362\367\377\361\363\371\377\357\362\370\377\360\362\370\377\360"
  "\363\370\377\360\362\370\377\360\363\366\377\361\363\370\377\357\362\370"
  "\377\360\363\370\377\357\362\367\377\357\361\366\377\356\361\366\377\357"
  "\361\367\377\356\361\367\377\357\361\367\377\360\363\370\377\357\363\370"
  "\377\357\361\367\377\360\362\370\377\355\360\366\377\355\360\365\377\356"
  "\361\367\377\353\356\364\377\354\357\366\377\354\357\364\377\353\356\364"
  "\377\354\357\364\377\354\357\365\377\354\357\364\377\355\360\365\377\354"
  "\357\365\377\304\306\311\377***\377\1\1\1\377\7\10\10\377\17\20\21\377\12"
  "\13\14\377\6\7\6\377\10\7\7\377\12\14\14\377\10\12\11\377\13\14\15\377\11"
  "\12\12\377\7\7\7\377\34\36!\377\35\27\32\377c1D\377\243Ei\377\342\\\217\377"
  "\351X\221\377\350[\222\377\350^\224\377\352[\223\377\350\\\223\377\343R\214"
  "\377\345Y\220\377\343V\215\377\344W\217\377\347`\224\377\344X\217\377\351"
  "_\224\377\202\352]\223\377(\350[\222\377\347`\223\377\346\\\221\377\342T"
  "\215\377\341U\214\377\343V\216\377\351\\\221\377\354g\230\377\347X\216\377"
  "\347Y\217\377\346\\\221\377\343Y\220\377\347]\221\377\345Y\216\377\343V\214"
  "\377\344W\216\377\340M\207\377\343V\216\377\350\\\223\377\353^\223\377\353"
  "]\222\377\350^\223\377\352b\226\377\351Y\221\377\351\\\221\377\350]\222\377"
  "\351]\223\377\347Y\217\377\344U\217\377\342T\214\377\344T\214\377\345W\215"
  "\377\350\\\222\377\347X\217\377\350[\222\377\346Y\221\377\351[\222\377\351"
  "\\\224\377\350Z\220\377\347X\217\377\202\346Y\217\377\10\351^\223\377\352"
  "^\224\377\32\36\40\376\37!#\377*.0\377\14\15\15\377\34\40\"\377\11\12\12"
  "\377\202\11\12\11\377\24\12\14\13\377\10\10\7\377\7\7\6\377\10\12\11\377"
  "\13\15\15\377\12\13\12\377\11\12\11\377\13\14\14\377\13\14\15\377\12\12\12"
  "\377\2\2\2\377\22\22\23\377\225\227\231\377\360\362\367\377\360\363\370\377"
  "\361\364\371\377\361\363\370\377\360\363\370\377\360\362\366\377\361\363"
  "\370\377\202\360\363\370\377\3\360\362\370\377\357\361\367\377\356\361\366"
  "\377\205\357\362\370\377\27\357\362\367\377\360\362\367\377\357\362\370\377"
  "\356\361\367\377\356\360\366\377\355\360\365\377\355\360\367\377\355\360"
  "\365\377\354\357\365\377\353\357\364\377\354\357\365\377\354\357\364\377"
  "\345\347\354\377qqt\377\5\5\5\377\3\4\3\377\12\12\12\377\14\16\16\377\20"
  "\23\23\377\10\10\10\377\7\10\7\377\14\16\17\377\15\16\16\377\202\12\13\13"
  "\377`&\30\35\377n7J\377\303]\204\377\354c\225\377\352\\\223\377\352`\225"
  "\377\350Y\221\377\350\\\223\377\345W\217\377\347Y\221\377\351\\\222\377\352"
  "b\227\377\347[\221\377\345W\217\377\347\\\222\377\347Z\222\377\346`\223\377"
  "\351_\225\377\352\\\223\377\354b\226\377\351`\224\377\345X\216\377\345T\214"
  "\377\345Y\220\377\341T\213\377\344U\217\377\342T\214\377\350]\220\377\351"
  "_\222\377\347Y\217\377\350`\224\377\344Y\220\377\346[\220\377\346]\221\377"
  "\342S\213\377\341Q\212\377\350\\\222\377\344U\214\377\346X\217\377\351[\222"
  "\377\357\204\255\377\370\312\333\377\375\363\367\377\376\375\376\377\375"
  "\366\371\377\363\246\304\377\350]\222\377\345W\216\377\346W\217\377\347["
  "\221\377\345V\215\377\343U\214\377\344T\213\377\351_\223\377\346W\216\377"
  "\345U\216\377\343V\217\377\345Y\217\377\347X\220\377\347\\\222\377\347Y\221"
  "\377\345T\215\377\350Z\222\377\351[\221\377\351]\222\377\27\32\33\376\20"
  "\22\23\377\15\17\17\377,14\377\11\13\12\377\27\31\32\377!#%\377\12\13\13"
  "\377\6\7\6\377\11\12\11\377\10\10\10\377\17\17\17\377\31\32\33\377\15\16"
  "\15\377\17\23\24\377$%)\377\10\10\10\377\24\27\30\377\11\13\13\377\4\4\3"
  "\377\0\0\0\377001\377\254\256\261\377\362\363\370\377\361\363\370\377\360"
  "\362\370\377\360\363\367\377\360\362\367\377\357\362\367\377\360\363\371"
  "\377\361\362\370\377\203\357\361\367\377\3\360\362\370\377\356\361\370\377"
  "\356\361\367\377\202\357\362\370\377\5\360\362\367\377\360\363\370\377\356"
  "\361\367\377\356\361\366\377\355\361\366\377\202\356\360\367\377\202\355"
  "\360\365\377o\351\353\360\377\215\216\220\377\30\30\31\377\1\1\1\377\7\6"
  "\7\377\12\11\12\377\15\15\15\377\31\32\35\377\27\25\26\377\7\7\7\377\16\17"
  "\17\377\20\22\23\3770\31!\377|9R\377\305Q}\377\355Z\222\377\352X\221\377"
  "\354\\\222\377\352[\221\377\354^\224\377\350Z\220\377\346Z\221\377\352^\224"
  "\377\347X\220\377\351]\223\377\352^\223\377\353a\226\377\344V\216\377\344"
  "X\217\377\346Z\222\377\351_\223\377\351^\224\377\346X\217\377\346T\216\377"
  "\350X\221\377\345W\216\377\346U\217\377\342W\212\377\343Q\214\377\346X\220"
  "\377\346W\217\377\344S\214\377\347X\217\377\347W\216\377\345Y\216\377\345"
  "Z\217\377\342T\214\377\342U\214\377\344Y\216\377\345X\216\377\351^\223\377"
  "\347]\222\377\346W\215\377\347W\217\377\366\271\321\377\377\376\376\377\376"
  "\376\376\377\372\344\355\377\366\310\331\377\371\332\347\377\372\340\353"
  "\377\346Z\220\377\345Z\220\377\346Z\221\377\347Y\220\377\346W\220\377\343"
  "W\215\377\345Y\220\377\344W\216\377\344U\216\377\345X\221\377\351`\225\377"
  "\351`\224\377\351^\223\377\350Z\221\377\350^\225\377\350^\224\377\353b\226"
  "\377\352^\223\377\353a\224\377\12\16\15\376\14\17\17\377\33\37\"\377\36\40"
  "!\377178\377'(,\377\23\26\27\377\10\11\12\377\10\12\11\377\20\23\23\3779"
  "?D\377\14\13\14\377\7\10\7\377\10\12\11\377\13\14\15\377\13\14\13\377\11"
  "\12\12\377\7\10\7\377\7\7\7\377\11\12\12\377\7\11\11\377\3\4\4\377\0\0\0"
  "\377../\377\227\230\233\377\351\353\360\377\360\363\367\377\360\362\370\377"
  "\357\362\367\377\360\363\370\377\361\363\371\377\202\357\361\367\377\5\357"
  "\362\367\377\360\363\370\377\360\363\371\377\360\363\370\377\357\362\370"
  "\377\202\360\362\370\377M\361\363\370\377\357\362\367\377\357\362\370\377"
  "\356\361\366\377\356\361\367\377\357\362\367\377\330\333\340\377~\177\202"
  "\377\30\31\31\377\0\0\0\377\12\14\14\377\14\15\15\377\25\27\27\377\23\25"
  "\26\377\11\10\10\377\10\10\10\377\15\15\15\377A\",\377\213B^\377\324X\207"
  "\377\361_\225\377\356]\224\377\352[\221\377\347U\216\377\354]\224\377\355"
  "_\225\377\354[\221\377\350X\221\377\347Y\217\377\353_\224\377\351^\223\377"
  "\347Z\221\377\347X\220\377\347Y\220\377\347Z\221\377\344W\216\377\350^\224"
  "\377\350^\223\377\350\\\222\377\346Y\220\377\343S\214\377\350W\217\377\347"
  "W\216\377\346S\213\377\345V\213\377\343S\214\377\347\\\223\377\343T\215\377"
  "\347Y\220\377\346Y\221\377\346Z\221\377\350]\223\377\351`\223\377\350]\223"
  "\377\346X\215\377\343S\212\377\343R\213\377\345V\216\377\351Y\217\377\350"
  "Z\220\377\347[\220\377\362\250\304\377\377\377\377\377\374\347\357\377\355"
  "{\246\377\345W\217\377\342T\214\377\346X\217\377\351j\234\377\346Y\221\377"
  "\346X\217\377\347X\217\377\351[\221\377\350_\223\377\350\\\221\377\345W\220"
  "\377\342W\217\377\202\344Z\220\377(\344Y\220\377\351Y\221\377\353a\226\377"
  "\347Z\222\377\351\\\224\377\352^\223\377\352]\221\377\353_\223\377\353_\224"
  "\377\14\15\14\376%,.\377-.0\377\11\12\13\377\40$'\377CIO\377\12\13\13\377"
  "\11\12\11\377\14\14\14\377\37\"$\377\15\20\17\377\10\11\10\377\10\11\7\377"
  "\36\40\"\377\7\11\11\377\10\11\10\377\7\7\6\377\5\6\6\377\6\6\6\377\11\12"
  "\13\377\6\7\7\377\4\6\5\377\5\6\6\377\3\3\3\377\0\0\0\377\14\14\14\377VV"
  "X\377\242\243\246\377\337\342\346\377\362\366\372\377\361\363\371\377\202"
  "\360\362\370\377\177\357\362\367\377\360\363\371\377\362\364\372\377\362"
  "\364\371\377\360\363\371\377\360\363\370\377\357\362\367\377\361\363\371"
  "\377\357\362\370\377\360\363\370\377\322\324\331\377\220\221\224\377BCE\377"
  "\4\4\4\377\0\0\1\377\6\6\6\377\21\22\25\377\7\7\7\377\20\22\22\377\31\32"
  "\33\377\23\20\21\377R'7\377\236Tn\377\341d\222\377\362g\233\377\357\\\225"
  "\377\357`\227\377\357f\230\377\355\\\223\377\353[\224\377\351W\220\377\354"
  "^\223\377\356_\225\377\356`\225\377\356_\225\377\350[\222\377\355d\230\377"
  "\353`\225\377\352b\226\377\347X\217\377\351[\222\377\352]\223\377\347W\217"
  "\377\346V\215\377\344X\220\377\345Z\221\377\347W\216\377\345U\215\377\346"
  "X\217\377\346Z\217\377\347[\221\377\347\\\217\377\345W\216\377\350`\223\377"
  "\345X\217\377\342Q\212\377\345Y\220\377\347Y\220\377\347Z\221\377\350]\223"
  "\377\346S\214\377\353p\237\377\363\247\304\377\356\215\263\377\344S\214\377"
  "\350U\217\377\350Z\220\377\352f\230\377\376\367\372\377\376\372\374\377\347"
  "l\234\377\342U\216\377\345T\215\377\347\\\222\377\346Z\220\377\347Z\222\377"
  "\350[\222\377\346Y\220\377\350X\220\377\346\\\222\377\346Z\220\377\344Y\216"
  "\377\343R\215\377\344W\216\377\342W\216\377\342Q\213\377\346Y\220\377\347"
  "Z\223\377\351Z\222\377\344U\215\377\346X\220\377\350Z\221\377\350[\221\377"
  "\354_\222\377\352[\221\377\22\25\25\376\12\14\13\377\36\"$\377EGK\377\35"
  "\"#\377\13\14\14\377\15\17\21\377\33\37\"\377\24\26\26\377\23\25\25\377\14"
  "\15\14\377\7\10\10\377\12\14\14\377\7\7\6\377\10\11\11\377\13\15\15\377\14"
  "\16\16\377\13\14\15\377\10\11\11\377\11\12\12\377\36\40\"\377349\377\7\7"
  "\7\377\14\17\17\377\11\11\11\377\7\10\10\377\3\3\4\377\1\2\1\377\2\2\3\377"
  "()*\377[\\]\377\201\202\205\377\13\241\243\245\377\266\270\274\377\307\311"
  "\315\377\316\320\324\377\315\317\322\377\304\306\312\377\261\263\267\377"
  "\232\234\236\377y{}\377PQR\377\34\34\35\377\202\0\0\0\377\22\2\2\3\377\5"
  "\6\10\377\16\20\21\377\12\14\15\377\6\11\10\377#\34!\377`*>\377\251Jn\377"
  "\344b\224\377\355a\230\377\360h\234\377\362j\235\377\360d\231\377\355^\224"
  "\377\355[\222\377\357a\227\377\356b\230\377\354_\226\377\202\351Y\221\377"
  "L\355a\226\377\355_\223\377\355[\223\377\351Z\222\377\351]\223\377\350[\221"
  "\377\342R\214\377\341T\214\377\352]\224\377\347[\222\377\344U\215\377\347"
  "\\\221\377\345Y\217\377\346Y\221\377\345S\214\377\352\\\223\377\350^\222"
  "\377\351[\221\377\350_\220\377\351`\224\377\352^\225\377\350\\\222\377\347"
  "\\\222\377\346Y\220\377\350[\222\377\345U\216\377\351^\224\377\350\\\220"
  "\377\351Z\220\377\362\252\306\377\377\377\377\377\370\325\343\377\345U\216"
  "\377\347V\216\377\346W\217\377\356\217\263\377\377\377\377\377\366\315\335"
  "\377\336N\210\377\342T\214\377\347Z\221\377\353c\226\377\347Y\220\377\351"
  "Z\221\377\353a\226\377\351^\223\377\353\\\223\377\344U\215\377\346Z\220\377"
  "\344V\215\377\344Z\221\377\342V\215\377\342S\213\377\344T\215\377\350Z\222"
  "\377\351^\223\377\347U\216\377\347X\220\377\351Z\221\377\353`\224\377\350"
  "]\222\377\351X\220\377\351Z\221\377\36!\"\376\12\14\15\377\16\21\21\3770"
  "37\377\26\30\32\377\14\16\16\377\20\23\24\377ot{\377\"$&\377\35!#\377\11"
  "\13\13\377\13\15\15\377\14\16\15\377\202\10\11\10\377\21'+-\377\15\16\16"
  "\377\7\10\6\377\17\21\22\377\16\20\21\377\6\7\6\377\6\7\7\377\30\32\33\377"
  "\5\6\5\377\7\7\7\377\12\14\13\377\6\6\6\377\21\22\23\377\7\7\7\377\5\7\6"
  "\377\2\2\2\377\1\1\1\377\207\0\0\0\377A\2\2\2\377\1\1\1\377\3\4\4\377\5\6"
  "\5\377\11\13\13\377\11\11\10\377\11\12\11\377\34\37$\3773$-\377n2I\377\271"
  "Qy\377\355j\234\377\356e\232\377\354_\224\377\350Y\222\377\352^\223\377\356"
  "`\227\377\356^\226\377\354Z\224\377\356]\224\377\356]\223\377\362b\227\377"
  "\355]\224\377\354[\221\377\352]\223\377\351\\\222\377\354^\224\377\355b\226"
  "\377\355`\225\377\352a\226\377\352W\220\377\352_\224\377\344W\217\377\346"
  "X\220\377\347Y\220\377\345W\220\377\350`\225\377\353`\225\377\350`\224\377"
  "\346Y\221\377\347Y\220\377\350_\223\377\346]\220\377\345\\\216\377\351a\224"
  "\377\352b\227\377\350^\224\377\346Z\220\377\347^\224\377\356\211\260\377"
  "\351e\230\377\345R\214\377\345T\215\377\351]\223\377\352a\225\377\357{\247"
  "\377\377\376\376\377\376\374\375\377\347d\227\377\347[\220\377\350X\220\377"
  "\362\250\304\377\377\377\377\377\364\273\322\377\343Y\217\377\202\350[\221"
  "\377Q\350\\\221\377\351]\223\377\346W\217\377\352\\\222\377\354`\225\377"
  "\351\\\221\377\347V\217\377\347Y\220\377\346[\221\377\347\\\223\377\346X"
  "\217\377\345U\216\377\351[\222\377\351^\223\377\353]\222\377\352]\222\377"
  "\353[\221\377\351[\222\377\352^\223\377\352\\\222\377\350\\\221\377\347X"
  "\220\377\36!\"\376HOT\377&+-\377\16\16\16\377\21\25\27\377\30\34\37\377\14"
  "\16\16\377.46\377035\377\"%(\3775:>\377\14\15\15\377\11\13\13\377\7\7\7\377"
  "\21\22\22\377\11\13\13\377\26\32\32\377\12\13\14\377\12\12\11\377\6\7\6\377"
  "\7\10\10\377\5\7\6\377\6\7\7\377\7\10\10\377\11\12\12\377\12\13\13\377\36"
  "!$\377\24\27\30\377!&(\377\7\11\11\377\7\10\10\377\6\7\7\377\5\6\6\377\6"
  "\7\6\377\6\10\10\377\10\10\10\377\6\6\6\377\12\11\11\377\12\13\12\377\13"
  "\13\12\377\30\32\34\377%)-\377\11\11\11\377\11\14\14\3772\32#\377};S\377"
  "\306^\206\377\357e\231\377\352]\225\377\352Z\223\377\355`\227\377\356^\226"
  "\377\356b\230\377\352Z\223\377\354]\224\377\353[\222\377\354Z\222\377\352"
  "X\221\377\353W\220\377\202\355Z\223\377\177\354Z\222\377\352X\221\377\352"
  "[\222\377\351Z\221\377\353\\\223\377\344`\222\377\350_\223\377\352_\224\377"
  "\353a\225\377\350X\220\377\350Z\221\377\346Z\220\377\344W\220\377\343T\216"
  "\377\347Z\222\377\346X\220\377\343R\214\377\340R\213\377\344V\216\377\350"
  "^\223\377\345V\213\377\347Y\220\377\350_\223\377\344T\214\377\342W\216\377"
  "\345U\215\377\370\326\343\377\377\377\377\377\360\235\276\377\345W\216\377"
  "\346V\215\377\346W\216\377\347\\\221\377\347X\217\377\373\347\357\377\377"
  "\377\377\377\361\231\272\377\350]\222\377\346Y\220\377\363\252\305\377\377"
  "\377\377\377\366\277\324\377\350\\\221\377\350_\223\377\351]\222\377\355"
  "b\226\377\352Z\221\377\347W\217\377\354m\237\377\363\242\301\377\351b\226"
  "\377\351\\\221\377\352`\224\377\351_\225\377\347\\\222\377\345U\214\377\350"
  "Y\220\377\350Z\221\377\350X\220\377\347W\217\377\355b\226\377\353^\222\377"
  "\351X\217\377\353`\224\377\350Z\220\377\350Y\217\377\345U\215\377\16\20\21"
  "\376/68\377ZZ`\377\15\17\17\377\14\15\15\377\23\30\32\377\30\32\35\377\36"
  "!$\377\40#%\377ov~\377\33\35\37\377\16\21\20\377\12\14\14\377\21\22\23\377"
  "\23\24\26\377\22\25\26\377\11\12\12\377\15\17\20\377\15\16\16\377\6\6\6\377"
  "\16\20\21\377\7\10\10\377\6\7\6\377\7\6\6\377\6\6\6\377\7\10\10\377\10\11"
  "\11\377\10\7\10\377\7\7\7\377\20\22\24\377\14\16\17\377\7\10\10\377\10\12"
  "\11\377\10\10\10\377\7\10\7\377\10\10\10\377\7\7\7\377\13\14\14\377\16\17"
  "\20\377\11\14\13\377\37\"$\377E&1\377\230Lk\377\321\\\210\377\360g\234\377"
  "\354d\230\377\355`\226\377\354_\227\377\352Z\222\377\352\\\223\377\354\\"
  "\225\377\355\\\224\377\352\\\223\377\352^\224\377\353\\\223\377\352X\223"
  "\377\352U\217\377\354\\\222\377\355Y\223\377\357]\224\377\177\355\\\224\377"
  "\354\\\224\377\353Z\222\377\350Y\221\377\351_\225\377\350Z\221\377\345X\217"
  "\377\347[\221\377\351\\\222\377\351Z\221\377\350[\221\377\352\\\222\377\346"
  "U\215\377\347Z\222\377\344T\215\377\346X\220\377\347W\217\377\345V\215\377"
  "\346X\220\377\342S\214\377\346X\220\377\343V\213\377\346Y\221\377\346W\217"
  "\377\346W\220\377\345U\216\377\346[\221\377\362\244\303\377\377\377\377\377"
  "\371\327\344\377\345_\223\377\343S\212\377\344T\215\377\345W\215\377\345"
  "W\216\377\362\261\312\377\377\377\377\377\367\313\335\377\347^\224\377\350"
  "]\223\377\362\236\277\377\377\377\377\377\371\333\347\377\346X\217\377\346"
  "W\217\377\347\\\221\377\353c\226\377\364\256\311\377\372\337\352\377\376"
  "\376\376\377\377\377\377\377\361\214\262\377\352[\220\377\351Z\221\377\351"
  "`\224\377\345V\215\377\347W\217\377\347U\216\377\347X\220\377\345W\216\377"
  "\350X\220\377\352Z\220\377\354c\226\377\353_\223\377\356b\227\377\354c\226"
  "\377\351[\221\377\353[\223\377$((\376\33\35\37\377\14\20\20\377\21\24\25"
  "\377\33\36!\377\13\16\15\377037\377+02\377\30\33\35\377#'*\377%+.\377\24"
  "\24\25\377\14\16\17\377\26\27\31\377\15\15\15\377\7\10\10\377#&(\377\10\12"
  "\11\377\6\10\7\377\17\17\20\377\7\10\7\377\22\24\25\377\10\10\10\377\7\7"
  "\7\377\13\14\13\377\14\16\16\377\22\24\25\377\17\21\23\377\10\11\11\377\11"
  "\11\10\377\11\11\11\377\35\37!\377\15\17\15\377\6\6\6\377\5\6\5\377\6\7\6"
  "\377\11\11\11\377\17\15\15\377]8H\377\237Ll\377\340b\223\377\360g\232\377"
  "\356^\226\377\353Z\223\377\356_\227\377\353`\226\377\351\\\224\377\353a\227"
  "\377\353]\223\377\352^\225\377\353^\225\377\354_\226\377\352\\\224\377\351"
  "X\221\377\352X\222\377\356^\224\377\356_\224\377\355`\224\377\357`\227\377"
  "\177\356]\225\377\357_\224\377\355Z\223\377\354\\\223\377\347W\220\377\350"
  "[\223\377\347Z\221\377\352\\\223\377\350X\221\377\350Y\220\377\351]\224\377"
  "\346U\215\377\350[\221\377\345Y\217\377\350\\\223\377\350^\223\377\350`\226"
  "\377\353`\225\377\347]\220\377\350v\241\377\360\251\305\377\370\327\344\377"
  "\374\356\364\377\373\347\356\377\362\263\314\377\351f\230\377\346X\220\377"
  "\347\\\222\377\350o\236\377\377\376\376\377\376\374\375\377\352h\232\377"
  "\344W\220\377\346\\\221\377\351[\222\377\344W\217\377\346u\244\377\377\377"
  "\377\377\376\370\372\377\347`\224\377\337Q\213\377\355\202\254\377\377\377"
  "\377\377\376\372\374\377\350c\226\377\352\\\222\377\351Y\220\377\346Y\220"
  "\377\373\352\360\377\376\371\373\377\374\352\360\377\377\377\377\377\366"
  "\272\321\377\350W\217\377\350Y\220\377\346Y\217\377\344U\215\377\347V\217"
  "\377\351[\222\377\352]\223\377\346S\215\377\350X\220\377\345X\217\377\352"
  "]\222\377\351[\221\377\351Z\221\377\350U\216\377\351]\222\377\350Z\221\377"
  "\33\35\36\376\13\16\16\377\13\15\14\377\25\30\32\377\24\30\33\377\37\"#\377"
  "\15\17\17\377Y]d\377\32\33\35\377\20\22\24\377\17\22\24\377\22\27\30\377"
  "\25\31\33\377\16\21\21\377\10\11\10\377\12\13\13\377\13\16\17\377\15\15\16"
  "\377\14\15\14\377\7\10\10\377\35\37\40\377\15\16\16\377\7\7\7\377\17\21\21"
  "\377\10\11\11\377!$&\377\27\31\33\377\11\11\11\377\7\11\11\377\11\12\12\377"
  "\16\20\21\377\22\26\26\377\33\34\36\377\5\10\6\377\24\15\20\377Y);\377\244"
  "Fi\377\344`\223\377\360c\231\377\360d\231\377\360_\225\377\355Y\221\377\355"
  "\\\222\377\350T\216\377\347W\220\377\354[\224\377\354^\225\377\353^\223\377"
  "\353Z\222\377\353_\224\377\355\\\224\377\355^\224\377\356]\225\377\357a\227"
  "\377\356_\225\377\361d\231\377\356c\227\377\357_\225\377\202\353Z\222\377"
  "\22\353Z\221\377\355[\223\377\355\\\222\377\353[\222\377\352[\223\377\350"
  "^\222\377\350Z\221\377\346W\220\377\350\\\222\377\345U\215\377\350[\222\377"
  "\347Z\221\377\346X\220\377\347[\220\377\347[\224\377\355\201\253\377\364"
  "\266\317\377\374\353\362\377\202\377\377\377\377\"\376\372\373\377\372\350"
  "\360\377\376\373\374\377\377\377\377\377\371\333\346\377\347^\222\377\344"
  "W\217\377\345W\220\377\372\344\355\377\377\377\377\377\361\234\274\377\345"
  "W\217\377\343P\213\377\350Z\221\377\347]\222\377\344Z\217\377\374\356\363"
  "\377\377\377\377\377\355\213\262\377\343W\216\377\344\\\222\377\375\366\371"
  "\377\377\377\377\377\360\216\263\377\350W\220\377\347W\217\377\345V\215\377"
  "\353u\243\377\350c\226\377\356|\251\377\377\377\377\377\374\356\364\377\350"
  "^\223\377\347^\224\377\202\345T\215\377\177\345S\212\377\351[\221\377\351"
  "]\223\377\350[\221\377\346V\215\377\347W\217\377\351]\223\377\347W\217\377"
  "\344R\213\377\345R\214\377\346W\217\377\353]\222\377\23\24\25\376\15\17\20"
  "\377\23\27\30\377\16\20\20\377\36\40$\377(,0\377\35\37!\377\12\14\14\377"
  "!%(\377\10\12\11\377\12\14\14\377047\377\33\37\"\377\14\16\17\377\22\21\22"
  "\377\10\12\12\377\6\10\7\37749=\377\6\7\5\377\20\23\24\377\40\"$\377\11\11"
  "\12\377\21\23\24\377\16\17\17\377\34\40#\377\17\21\22\377\12\13\14\377\23"
  "\26\27\377\12\14\14\377\7\10\7\377\11\11\12\377)\36#\377h3I\377\257Kq\377"
  "\347^\223\377\354^\226\377\356c\231\377\355`\227\377\357`\227\377\356_\225"
  "\377\356[\223\377\352X\220\377\352W\220\377\354X\221\377\355]\225\377\360"
  "a\230\377\354^\225\377\346S\216\377\352Y\222\377\356\\\225\377\354^\225\377"
  "\360^\225\377\361b\231\377\357`\226\377\357a\230\377\353\\\226\377\353]\224"
  "\377\350X\221\377\356^\226\377\351X\223\377\353Y\221\377\356b\227\377\357"
  "^\224\377\353^\224\377\351\\\222\377\344U\215\377\344Q\214\377\346X\217\377"
  "\343W\216\377\346Y\220\377\351]\224\377\352d\227\377\346Y\221\377\350Z\221"
  "\377\346[\221\377\365\301\326\377\377\377\377\377\375\367\371\377\366\303"
  "\326\377\356\216\263\377\347a\225\377\342R\216\377\346k\234\377\375\364\367"
  "\377\377\377\377\377\356\225\267\377\344X\217\377\345\\\221\377\363\257\311"
  "\377\377\377\377\377\366\314\334\377\342Z\216\377\345Z\220\377\347Y\221\377"
  "\351\\\222\377\350^\223\377\365\275\322\377\377\377\377\377\367\304\330\377"
  "\347[\220\377\343S\214\377\366\303\327\377\377\377\377\377\367\314\335\377"
  "\347X\217\377\347Y\221\377\344O\213\377\346W\220\377\346V\215\377\345W\216"
  "\377\374\356\363\377\377\377\377\377\354|\251\377\350\\\222\377\352_\224"
  "\377\177\347\\\221\377\351Y\221\377\350Y\220\377\344R\213\377\345V\213\377"
  "\351Y\217\377\354_\224\377\352Y\220\377\346Z\217\377\344V\216\377\347\\\221"
  "\377\351X\217\377\355b\226\377\17\21\22\376\36#%\377\15\16\17\377,14\377"
  "\16\20\22\377\31\35\35\377\40\"%\377\14\16\17\377\20\21\22\377\15\20\20\377"
  "\40\"&\377\14\16\16\377\27\34\36\377&+-\377\37!%\377\12\13\13\377\13\16\17"
  "\377\15\17\17\377(+.\377\21\22\23\377\32\33\35\377\21\23\24\377\16\20\20"
  "\377\36!\"\377%%(\377\12\13\14\377\30\34\35\377\12\14\14\377>-7\377\204F"
  "`\377\266Lx\377\351d\231\377\352^\226\377\353]\223\377\347Y\222\377\352^"
  "\224\377\353^\225\377\357b\227\377\357b\230\377\354_\225\377\355\\\224\377"
  "\352X\221\377\353V\217\377\354Z\221\377\357_\227\377\357^\226\377\355^\224"
  "\377\353Z\223\377\353Z\222\377\357`\227\377\355]\223\377\360`\227\377\357"
  "c\231\377\356a\227\377\355_\226\377\352[\223\377\352Y\223\377\360b\231\377"
  "\354]\224\377\355_\226\377\352]\223\377\354\\\224\377\355a\226\377\347Y\221"
  "\377\351\\\223\377\347W\217\377\345U\216\377\351]\222\377\352a\227\377\356"
  "\213\261\377\366\301\325\377\374\362\366\377\357\215\263\377\350V\220\377"
  "\351^\224\377\357\220\265\377\377\377\377\377\374\357\364\377\350^\221\377"
  "\351^\224\377\347\\\223\377\344Y\220\377\344W\217\377\363\270\317\377\377"
  "\377\377\377\365\265\315\377\350\\\223\377\345[\221\377\352{\247\377\377"
  "\377\377\377\376\371\373\377\344^\224\377\346]\223\377\352`\225\377\351_"
  "\224\377\346]\223\377\354\205\255\377\377\377\377\377\375\364\367\377\351"
  "^\223\377\353^\223\377\355~\247\377\377\376\377\377\376\375\376\377\354v"
  "\243\377\341U\213\377\344S\214\377\344V\216\377\342S\213\377\344T\215\377"
  "\363\266\317\377\377\377\377\377\362\257\312\377\346P\214\377S\352\\\222"
  "\377\345U\214\377\350Y\221\377\347[\221\377\345T\215\377\352\\\222\377\350"
  "T\214\377\351Z\221\377\352]\222\377\350[\221\377\343R\212\377\345T\214\377"
  "\351V\216\377\354`\224\377\16\21\21\376\31\34\36\377*.1\377\32\32\33\377"
  "/47\377\13\15\15\377\20\21\22\377+/2\377\7\11\11\377(03\377DGL\377\13\15"
  "\16\377\30\33\35\37716;\377\35\37!\377/47\377\11\12\12\377\11\13\13\377\14"
  "\16\16\377QV\\\377\25\27\30\377\25\30\33\377EJO\377&')\377\33\36\37\377N"
  "3@\377\200;U\377\315^\211\377\354b\227\377\352_\225\377\352[\224\377\355"
  "`\226\377\353^\226\377\355_\225\377\354^\224\377\354`\226\377\353Y\221\377"
  "\357_\225\377\361a\230\377\355^\226\377\355^\223\377\353X\221\377\356]\224"
  "\377\353Y\223\377\355]\223\377\355]\224\377\352U\220\377\356_\226\377\354"
  "\\\224\377\354Z\222\377\360`\230\377\362d\232\377\361e\232\377\357b\231\377"
  "\357b\230\377\352\\\224\377\355a\227\377\356`\227\377\354^\225\377\357d\230"
  "\377\353`\226\377\355^\225\377\356b\230\377\353[\223\377\353a\226\377\353"
  "j\234\377\361\231\273\377\370\311\333\377\376\367\371\377\202\377\377\377"
  "\377E\375\362\366\377\362\236\275\377\352`\226\377\350\\\223\377\347_\224"
  "\377\375\370\372\377\377\377\377\377\350}\247\377\347\\\223\377\352^\223"
  "\377\347_\224\377\345X\217\377\363\277\324\377\377\377\377\377\357\233\274"
  "\377\344V\217\377\347\\\221\377\347]\222\377\374\355\363\377\377\377\377"
  "\377\355\220\266\377\345V\217\377\347\\\221\377\351Y\222\377\351^\224\377"
  "\346Y\221\377\375\365\370\377\377\377\377\377\361\212\257\377\352]\222\377"
  "\344U\216\377\367\315\336\377\377\377\377\377\370\330\344\377\345X\217\377"
  "\345W\216\377\340N\210\377\343Q\211\377\343T\214\377\356\221\265\377\377"
  "\377\377\377\373\342\353\377\347X\217\377\347V\217\377\346U\216\377\350X"
  "\217\377\346T\214\377\347U\216\377\350^\222\377\345S\213\377\352^\224\377"
  "\352Y\221\377\346S\213\377\346V\216\377\346U\215\377\351W\217\377\355b\225"
  "\377\20\24\24\376\12\15\16\377PT[\377\40\"%\377\13\15\15\377-15\377\11\12"
  "\12\377\17\21\21\377/47\377\12\14\14\377\23\27\31\377059\377\202\23\26\27"
  "\3774V[b\377\27\30\32\377\16\16\17\377\13\12\12\377\15\17\17\377\23\27\27"
  "\377ADI\377\30\31\33\377aBR\377\234Mm\377\325\\\213\377\354_\226\377\353"
  "_\226\377\352_\226\377\350^\225\377\353^\225\377\354`\226\377\353\\\223\377"
  "\355a\227\377\353]\222\377\353Z\223\377\354`\226\377\353Z\221\377\354V\220"
  "\377\357\\\223\377\361d\230\377\354Y\223\377\353Z\222\377\355[\224\377\353"
  "X\221\377\353X\222\377\353Z\223\377\355]\224\377\352[\223\377\354\\\224\377"
  "\356_\226\377\356\\\225\377\360]\225\377\360c\231\377\357`\225\377\360d\232"
  "\377\353]\225\377\354[\222\377\353Z\223\377\353[\225\377\356b\227\377\355"
  "]\224\377\354Y\222\377\354Z\222\377\362\214\263\377\372\326\344\377\376\373"
  "\374\377\202\377\377\377\3777\374\355\363\377\363\266\316\377\354\203\254"
  "\377\350[\221\377\352_\225\377\353_\225\377\347Y\217\377\346Z\221\377\370"
  "\315\335\377\377\377\377\377\362\263\315\377\347\\\222\377\346Y\220\377\346"
  "Z\221\377\357\240\277\377\376\374\375\377\370\320\337\377\344Y\217\377\346"
  "Y\220\377\345W\217\377\345Y\217\377\362\267\316\377\377\377\377\377\364\300"
  "\325\377\344V\217\377\346X\220\377\350X\221\377\352]\223\377\352Z\221\377"
  "\371\312\333\377\377\377\377\377\365\263\315\377\345U\214\377\345V\217\377"
  "\354l\235\377\375\361\366\377\377\377\377\377\366\316\335\377\345b\226\377"
  "\345S\214\377\346[\221\377\356\217\263\377\374\357\364\377\377\377\377\377"
  "\361\241\301\377\345U\214\377\352]\222\377\352[\221\377\354]\222\377\351"
  "Y\217\377\346U\214\377\347Z\217\377\343S\214\377\350]\223\377\353]\224\377"
  "\202\351[\221\377\177\347X\215\377\346U\216\377\352Z\222\37728;\376'+/\377"
  "\13\14\14\377\34\37!\377\35\40\"\377\15\16\16\377\20\21\22\377\17\21\22\377"
  "-13\377\21\23\24\377\17\22\23\377'),\37716:\377\35!$\377\25\27\27\377)-1"
  "\377\15\17\17\377#&(\377\26\17\22\377d:M\377\240Jm\377\334^\220\377\353b"
  "\230\377\354`\226\377\354a\226\377\353[\223\377\347Y\220\377\346U\217\377"
  "\353]\223\377\355`\225\377\354_\226\377\355a\225\377\353Y\222\377\352[\222"
  "\377\354`\226\377\356d\231\377\355_\225\377\355\\\224\377\356]\224\377\355"
  "^\224\377\355[\222\377\346S\215\377\350U\217\377\353X\220\377\355a\226\377"
  "\357b\230\377\356]\225\377\353Y\222\377\355^\224\377\354_\225\377\353X\222"
  "\377\353[\223\377\356\\\224\377\356a\226\377\354Y\222\377\353Z\223\377\354"
  "]\225\377\355a\224\377\353[\223\377\357b\231\377\353[\223\377\353X\222\377"
  "\356a\226\377\365\233\274\377\377\377\377\377\376\374\375\377\365\263\314"
  "\377\356\177\252\377\351Z\221\377\350]\223\377\347[\222\377\347]\224\377"
  "\350^\226\377\347Z\222\377\350[\222\377\351]\222\377\362\233\272\377\377"
  "\377\377\377\372\346\356\377\350\202\253\377\364\275\322\377\374\361\365"
  "\377\377\377\377\377\376\375\376\377\372\340\352\377\365\304\327\377\350"
  "s\240\377\342V\215\377\344U\216\377\353\201\253\377\377\377\377\377\375\365"
  "\370\377\346Y\221\377\347W\222\377\351[\222\377\351Z\221\377\354^\224\377"
  "\362\225\270\377\377\377\377\377\372\335\350\377\346W\217\377\347X\220\377"
  "\354`\225\377\354v\242\377\374\353\362\377\377\377\377\377\376\375\375\377"
  "\374\355\363\377\376\370\372\377\377\377\377\377\376\373\374\377\362\246"
  "\303\377\350Z\221\377\350Y\220\377\353`\225\377\352\\\223\377\352Z\217\377"
  "\352^\223\377\351W\216\377\350[\220\377\345X\217\377\350Z\222\377\345T\215"
  "\377\344T\216\377\1\350X\217\377\202\346T\215\377O\353\\\222\377\40\"$\376"
  "\22\23\23\377\21\23\22\377\30\31\34\377\20\22\24\377\12\14\15\377\22\25\26"
  "\377ACI\377\12\13\13\377(,/\377\31\33\35\377\13\14\14\377afm\377,-0\377\13"
  "\15\15\3775'.\377\250o\213\377\262Lu\377\342[\217\377\347Z\222\377\351\\"
  "\223\377\350^\224\377\346X\223\377\352^\223\377\355_\226\377\356`\227\377"
  "\353_\225\377\350X\221\377\354^\225\377\351\\\223\377\354a\227\377\354^\225"
  "\377\353Y\223\377\351X\221\377\354^\225\377\355^\223\377\354\\\223\377\346"
  "U\216\377\354]\224\377\357a\227\377\354X\222\377\352Z\222\377\352U\220\377"
  "\351V\217\377\354]\225\377\356a\225\377\354]\224\377\351U\217\377\352W\220"
  "\377\357^\225\377\354\\\224\377\353\\\223\377\354X\221\377\353[\223\377\354"
  "\\\223\377\352\\\224\377\352Y\224\377\352Z\222\377\350Y\222\377\357b\230"
  "\377\360b\227\377\355`\225\377\355_\225\377\357k\235\377\376\374\375\377"
  "\377\376\376\377\355z\246\377\346[\222\377\352^\223\377\353]\223\377\351"
  "Z\220\377\347^\224\377\347]\223\377\350^\223\377\351\\\223\377\351b\223\377"
  "\353i\233\377\376\374\375\377\203\377\377\377\3771\373\354\362\377\364\274"
  "\322\377\360\252\306\377\367\315\336\377\377\377\377\377\376\370\372\377"
  "\350u\242\377\341U\215\377\340U\214\377\374\364\367\377\377\377\377\377\357"
  "\210\260\377\346W\216\377\345T\215\377\346V\217\377\350X\220\377\354m\236"
  "\377\377\377\377\377\375\362\366\377\346P\212\377\347X\220\377\353]\223\377"
  "\347X\217\377\345\\\222\377\361\247\304\377\372\332\346\377\374\353\361\377"
  "\372\333\347\377\366\262\313\377\354n\236\377\350V\217\377\345T\216\377\347"
  "V\217\377\351[\222\377\353^\222\377\351[\220\377\355d\226\377\354^\222\377"
  "\346V\215\377\350Z\217\377\352]\222\377\351Y\220\377\344T\215\377\346S\215"
  "\377\351[\222\377\351Y\221\377\352[\220\377\13\14\14\376\14\16\17\377\202"
  "\24\27\30\377\177\10\11\7\377.37\37789<\377\17\22\22\377\30\33\36\377\11"
  "\11\11\377).0\377\"%'\377;!+\377\235\\w\377\313d\212\377\357f\231\377\354"
  "^\224\377\351W\217\377\355_\224\377\352[\222\377\353_\225\377\352\\\223\377"
  "\353`\225\377\356`\224\377\357e\231\377\354a\227\377\353]\224\377\352Y\220"
  "\377\351T\216\377\353]\224\377\353_\226\377\350W\216\377\351_\224\377\353"
  "^\225\377\352X\222\377\357d\231\377\352X\221\377\347T\217\377\351V\220\377"
  "\356]\225\377\354Z\222\377\352U\217\377\352Z\221\377\350X\221\377\352Y\222"
  "\377\347U\217\377\354\\\223\377\354Z\222\377\354\\\224\377\353W\220\377\356"
  "[\222\377\355Z\222\377\357f\233\377\366\230\272\377\370\300\325\377\373\337"
  "\352\377\373\344\356\377\372\327\344\377\364\251\306\377\355f\233\377\353"
  "`\225\377\355[\224\377\355]\224\377\354Z\221\377\373\327\345\377\377\377"
  "\377\377\364\250\306\377\351\\\222\377\351[\223\377\355b\225\377\354^\224"
  "\377\350Y\221\377\347e\230\377\356\201\252\377\351_\221\377\347]\223\377"
  "\345Z\221\377\370\324\342\377\377\377\377\377\370\323\342\377\352v\244\377"
  "\343R\213\377\344T\215\377\342V\215\377\344V\217\377\365\277\323\377\377"
  "\377\377\377\371\330\345\377\351_\223\377\344W\216\377\366\276\323\377\377"
  "\377\377\377\365\276\324\377\347W\220\377\345T\215\377\350\\\223\377\352"
  "\\\223\377\356~\251\377\377\377\377\377\373\343\355\377\347S\215\377\344"
  "R\212\377\346U\216\377\343V\215\377\344R\213\377\347S\215\377\347S\214\377"
  "\350W\217\377\351Z\221\377\352Z\221\377\351X\220\377\351Z\221\377\346U\216"
  "\377\350V\216\377\352_\223\377\351[\221\377\353]\222\377\353_\222\377\351"
  "\\\221\377\346R\213\377\352W\220\377\356e\230\377\350\\\222\377\346Y\216"
  "\377\350X\220\377\355]\224\377\355`\225\377\354`\225\377\26\31\32\376\11"
  "\11\10\377\17\23\24\3772$%'\377\21\25\25\377\"$&\377\21\22\23\377\24\27\30"
  "\377\33\30\32\377S)9\377\236Hi\377\347l\230\377\356`\226\377\356b\227\377"
  "\356^\226\377\356^\225\377\354]\222\377\356^\225\377\355a\226\377\351Y\221"
  "\377\353[\223\377\350V\220\377\351\\\222\377\351Z\221\377\354]\224\377\354"
  "\\\223\377\356e\230\377\350X\217\377\352Z\222\377\352[\223\377\347V\220\377"
  "\347X\220\377\353\\\225\377\354^\225\377\360a\227\377\356^\223\377\352Y\222"
  "\377\351[\222\377\350W\217\377\350U\217\377\353Z\221\377\353[\222\377\350"
  "X\220\377\346T\216\377\354[\223\377\354Z\223\377\354X\221\377\351U\216\377"
  "\351V\220\377\351T\217\377\356r\242\377\372\315\336\377\376\371\373\377\202"
  "\377\377\377\377b\375\371\372\377\375\365\370\377\377\376\376\377\377\377"
  "\377\377\374\350\357\377\356n\240\377\357`\226\377\355]\226\377\354Z\223"
  "\377\363\234\276\377\377\377\377\377\373\337\352\377\350W\220\377\347V\217"
  "\377\357v\243\377\363\243\302\377\371\326\344\377\376\374\375\377\373\351"
  "\360\377\345Z\217\377\346^\223\377\345Z\221\377\361\240\277\377\377\377\377"
  "\377\372\336\351\377\344R\214\377\347[\222\377\342R\213\377\342S\213\377"
  "\345V\216\377\351j\234\377\376\375\375\377\376\376\376\377\352q\241\377\344"
  "U\215\377\352u\241\377\376\376\376\377\376\372\373\377\353y\246\377\342R"
  "\214\377\347X\217\377\353x\245\377\373\346\356\377\377\377\377\377\361\240"
  "\300\377\347W\217\377\352Y\217\377\352[\223\377\350Z\221\377\347W\217\377"
  "\351[\222\377\346W\217\377\344Y\220\377\351X\221\377\351]\224\377\351X\220"
  "\377\345U\216\377\347[\221\377\353c\226\377\355d\226\377\353]\222\377\354"
  "]\223\377\355b\227\377\354^\222\377\347Z\217\377\350Y\221\377\351^\222\377"
  "\347Y\217\377\345T\214\377\353]\222\377\354_\225\377\353^\223\377\353]\223"
  "\377\25\30\32\376\16\20\21\377\7\11\10\377\26\30\33\37738<\377)\37#\377m"
  "6K\377\263Qw\377\347a\223\377\356`\225\377\356a\224\377\356_\223\377\354"
  "Z\222\377\355`\227\377\354Z\222\377\353[\221\377\352]\223\377\352^\225\377"
  "\353\\\224\377\353[\221\377\351Y\221\377\347V\220\377\353\\\223\377\353]"
  "\223\377\350W\220\377\202\352[\223\377&\353[\223\377\351[\221\377\354[\224"
  "\377\351X\220\377\352Z\222\377\355]\225\377\357c\230\377\357b\230\377\357"
  "b\227\377\355^\223\377\355]\224\377\353\\\225\377\352Y\221\377\353W\221\377"
  "\354X\220\377\355Y\223\377\353W\220\377\361a\227\377\355^\225\377\355Z\222"
  "\377\354[\223\377\352U\220\377\354W\220\377\355d\230\377\376\374\375\377"
  "\377\377\377\377\370\275\323\377\363~\252\377\357f\232\377\354\\\224\377"
  "\357t\244\377\372\334\350\377\377\377\377\377\374\346\356\377\354b\230\377"
  "\352W\220\377\351U\216\377\355o\237\377\202\376\376\376\377\13\363\257\313"
  "\377\372\337\352\377\376\376\376\377\377\377\377\377\376\376\376\377\373"
  "\342\353\377\362\253\306\377\346^\223\377\344\\\222\377\347]\224\377\352"
  "n\236\377\202\376\376\376\377\1\352l\235\377\202\347\\\221\377o\345Y\220"
  "\377\346T\215\377\345W\216\377\372\340\352\377\377\377\377\377\360\224\270"
  "\377\350Z\220\377\345X\216\377\365\300\324\377\377\377\377\377\376\374\375"
  "\377\371\334\350\377\373\346\356\377\376\376\376\377\377\377\377\377\365"
  "\274\323\377\350X\220\377\351Z\220\377\351]\223\377\351Z\221\377\350Y\220"
  "\377\352Y\222\377\350W\216\377\344U\216\377\345R\214\377\350[\223\377\351"
  "[\220\377\347Y\217\377\344U\215\377\342S\213\377\352]\223\377\357i\233\377"
  "\356f\227\377\356e\231\377\354_\223\377\351]\222\377\351`\224\377\352_\224"
  "\377\351Z\222\377\354`\224\377\355b\225\377\353]\223\377\353_\223\377\352"
  "]\224\377\352Y\222\377(\36$\376\33\34\36\377D,7\377\201;W\377\310Y\200\377"
  "\356d\230\377\355f\232\377\355`\225\377\353`\225\377\355a\225\377\351]\217"
  "\377\352\\\223\377\353Z\222\377\352X\222\377\353\\\224\377\351Y\220\377\350"
  "Y\220\377\352\\\221\377\353\\\223\377\352W\220\377\353\\\222\377\353]\223"
  "\377\353a\225\377\356_\225\377\355_\225\377\354\\\224\377\353^\224\377\353"
  "Z\221\377\355^\225\377\355a\226\377\353Y\220\377\354[\224\377\356^\225\377"
  "\355\\\224\377\354^\225\377\357a\227\377\363g\232\377\360c\227\377\355]\224"
  "\377\354\\\223\377\354]\224\377\357_\226\377\356^\225\377\353\\\223\377\355"
  "Z\222\377\356_\227\377\360a\230\377\353Z\222\377\356Z\222\377\357^\225\377"
  "\355]\223\377\373\331\346\377\377\377\377\377\366\251\306\377\356_\224\377"
  "\355Z\222\377\357]\224\377\354Y\221\377\360m\236\377\376\361\366\377\377"
  "\377\377\377\364\254\310\377\352Z\222\377\351W\220\377\353[\222\377\372\336"
  "\351\377\202\377\377\377\377\17\376\375\375\377\372\332\346\377\361\242\301"
  "\377\353k\235\377\346Y\215\377\350]\223\377\346Z\222\377\351]\223\377\353"
  "_\224\377\347Y\220\377\372\334\347\377\377\377\377\377\361\242\301\377\344"
  "V\217\377\347Y\220\377\202\347Y\217\377\177\347X\220\377\372\337\352\377"
  "\377\377\377\377\361\226\270\377\351]\223\377\343Q\214\377\344W\217\377\357"
  "\245\302\377\373\347\357\377\376\372\373\377\375\362\366\377\370\311\333"
  "\377\357\205\256\377\346S\215\377\347X\217\377\352[\221\377\352]\222\377"
  "\350X\220\377\346T\216\377\350\\\220\377\353^\224\377\351[\220\377\351Z\221"
  "\377\353W\217\377\353_\224\377\354a\224\377\350]\222\377\347\\\220\377\352"
  "_\222\377\356a\225\377\352_\223\377\352[\222\377\350[\222\377\351[\221\377"
  "\347X\217\377\350W\217\377\346X\217\377\353d\226\377\352]\221\377\354`\225"
  "\377\352_\224\377\354]\224\377\354^\223\377\314U\204\376\332\\\213\377\356"
  "`\225\377\352]\223\377\355_\224\377\355c\227\377\356a\225\377\353_\224\377"
  "\351]\224\377\352^\217\377\343[\220\377\353_\225\377\355^\225\377\354b\225"
  "\377\354_\224\377\353]\223\377\351X\221\377\353_\224\377\356_\223\377\353"
  "\\\222\377\354Z\222\377\356_\225\377\352Y\223\377\352Z\221\377\354\\\222"
  "\377\355]\225\377\353Z\222\377\354]\223\377\354\\\224\377\354\\\225\377\353"
  "[\222\377\356`\227\377\355_\225\377\356b\230\377\354]\225\377\353Z\223\377"
  "\357a\230\377\356]\224\377\354\\\224\377\354[\223\377\357b\230\377\357b\227"
  "\377\352W\221\377\355Z\223\377\356\\\223\377\356b\227\377\354]\224\377\355"
  "\\\224\377\355Z\223\377\356]\224\377\353X\222\377\364\243\302\377\377\377"
  "\377\377\373\334\350\377\357]\223\377\360^\225\377\356[\222\377\355Y\222"
  "\377\356]\225\377\364\237\277\377\377\377\377\377\376\365\371\377\353a\225"
  "\377\353Z\222\377\354]\224\377\364\251\305\377\377\377\377\377\373\346\356"
  "\377\352j\233\377\351V\217\377\350Z\220\377\346Y\215\377\344Y\220\377\344"
  "W\221\377\350[\223\377\351Z\223\377\350X\220\377\346W\220\377\362\246\304"
  "\377\377\377\377\377\370\324\343\377\344Q\212\377\351\\\222\377\352\\\223"
  "\377/\352\\\222\377\362\235\276\377\376\376\376\377\375\366\371\377\347c"
  "\226\377\344U\216\377\337P\211\377\344Q\213\377\344Q\212\377\346S\213\377"
  "\350X\221\377\354a\226\377\355\\\224\377\354[\221\377\352`\224\377\351^\223"
  "\377\351[\220\377\347\\\222\377\350Y\221\377\351\\\223\377\353]\223\377\351"
  "`\224\377\351Z\220\377\354_\224\377\352Z\222\377\354b\226\377\353_\224\377"
  "\352^\223\377\350[\222\377\350Y\222\377\352_\223\377\350X\220\377\346Y\220"
  "\377\352^\223\377\347Z\221\377\345Y\220\377\343T\213\377\347Z\217\377\354"
  "b\225\377\351[\222\377\353\\\223\377\341Z\215\377\230Dc\377{mx\377\350Y\220"
  "\376\347Y\220\377\352_\225\377\202\353^\224\377r\354a\225\377\352]\224\377"
  "\351\\\223\377\350]\220\377\353]\222\377\354b\226\377\355`\226\377\355\\"
  "\224\377\352\\\223\377\353Y\221\377\352]\224\377\352^\224\377\354_\224\377"
  "\354^\223\377\354Z\221\377\355]\223\377\355\\\223\377\354\\\223\377\353]"
  "\223\377\353\\\223\377\356_\226\377\356`\225\377\356_\226\377\353Z\221\377"
  "\351]\223\377\347Y\221\377\346X\220\377\353^\225\377\354a\226\377\354^\225"
  "\377\355]\225\377\355[\224\377\353Y\222\377\357_\226\377\355a\226\377\356"
  "`\226\377\355[\222\377\354W\221\377\355^\224\377\353Z\223\377\353[\222\377"
  "\353^\225\377\355\\\225\377\357^\224\377\356]\224\377\355Z\223\377\356m\240"
  "\377\377\376\376\377\376\375\376\377\356l\236\377\356_\225\377\354Z\222\377"
  "\355[\222\377\356]\224\377\354a\227\377\375\366\371\377\377\377\377\377\362"
  "\230\272\377\354]\225\377\351W\220\377\354q\241\377\377\376\376\377\376\374"
  "\375\377\351c\230\377\347X\217\377\351Y\217\377\347]\222\377\345Z\220\377"
  "\352^\225\377\352[\221\377\352\\\223\377\351]\224\377\347V\216\377\355t\242"
  "\377\377\376\376\377\376\374\375\377\353e\230\377\352l\234\377\360\235\275"
  "\377\372\335\351\377\377\377\377\377\376\372\374\377\355\211\257\377\343"
  "T\214\377\346W\217\377\350X\220\377\345T\215\377\346U\215\377\346X\220\377"
  "\352^\223\377\354`\225\377\354`\224\377\352[\222\377\352Z\221\377\351Y\221"
  "\377\345W\215\377\344T\214\377\347[\222\377\350X\221\377\347Z\221\377\344"
  "S\214\377\350Z\220\377\350[\221\377\347X\220\377\353\\\223\377\352_\224\377"
  "\355b\226\377\351[\221\377\352^\223\377\352]\222\377\345U\215\377\350]\222"
  "\377\351_\223\377\352b\224\377\202\352a\225\377\13\352Y\221\377\321S\204"
  "\377\215=[\377c?P\377\21\20\22\377\27\33\35\377\24\25\26\377\352Z\222\376"
  "\353[\221\377\352`\224\377\353b\230\377\202\355_\225\377$\352V\221\377\353"
  "]\222\377\353[\221\377\354^\224\377\352\\\224\377\355]\223\377\354_\225\377"
  "\353Z\221\377\346W\217\377\352]\223\377\355]\224\377\356b\226\377\357e\230"
  "\377\354^\223\377\357`\226\377\355\\\224\377\355[\222\377\353[\223\377\354"
  "^\225\377\356_\225\377\357a\226\377\352X\221\377\350X\221\377\344U\216\377"
  "\346U\217\377\345S\215\377\347V\217\377\351[\222\377\354]\225\377\356^\226"
  "\377\355X\222\377\357Z\223\377\363l\235\377\356a\227\377\356_\227\377\360"
  "a\227\377\202\357_\225\377?\352W\221\377\352Y\222\377\354Y\221\377\353Y\223"
  "\377\355]\225\377\354]\223\377\354X\221\377\353Z\221\377\373\341\353\377"
  "\377\377\377\377\365\244\303\377\353[\224\377\352Z\221\377\355c\227\377\354"
  "^\225\377\353\\\223\377\370\304\327\377\377\377\377\377\370\312\333\377\351"
  "Z\222\377\354a\225\377\354X\220\377\374\347\357\377\377\377\377\377\360\226"
  "\270\377\352[\221\377\347]\220\377\347Y\217\377\346Z\221\377\345U\216\377"
  "\350W\221\377\350\\\223\377\351V\220\377\353\\\224\377\352]\222\377\373\346"
  "\356\377\377\377\377\377\374\352\361\377\376\375\375\377\377\377\377\377"
  "\376\374\375\377\370\312\333\377\353r\240\377\345U\215\377\347X\220\377\351"
  "Z\221\377\352\\\222\377\353_\224\377\352a\224\377\352]\223\377\353_\224\377"
  "\356`\225\377\355`\226\377\352Z\220\377\351]\223\377\350Y\217\377\350Z\221"
  "\377\350V\217\377\351\\\222\377\345W\220\377\351\\\222\377\350Y\221\377\350"
  "W\220\377\202\352\\\222\377E\351]\221\377\345X\215\377\350_\222\377\350^"
  "\222\377\351`\224\377\345W\216\377\347Y\221\377\350Y\221\377\353a\225\377"
  "\345g\226\377\300U~\377\213Fd\377_JX\377\21\25\26\37739<\377&*.\377\16\20"
  "\21\377\10\11\12\37737:\377\354^\225\376\353_\224\377\353^\224\377\352]\223"
  "\377\354`\224\377\354_\224\377\354\\\223\377\354_\221\377\355]\223\377\354"
  "]\222\377\353\\\223\377\352Z\221\377\354_\224\377\352]\223\377\350W\220\377"
  "\354^\223\377\357_\225\377\355a\224\377\356d\230\377\356^\225\377\357`\226"
  "\377\356a\226\377\356[\222\377\355_\224\377\351Y\221\377\354\\\224\377\353"
  "X\222\377\350X\222\377\351\\\224\377\353Z\223\377\353\\\223\377\350W\217"
  "\377\352]\225\377\354^\224\377\357a\227\377\356_\225\377\353[\223\377\360"
  "b\230\377\360c\230\377\355\\\223\377\355]\223\377\361`\226\377\356]\223\377"
  "\356a\227\377\352Y\221\377\352V\216\377\352W\220\377\351W\220\377\354^\225"
  "\377\352S\217\377\202\353[\222\377X\366\254\310\377\377\377\377\377\372\323"
  "\342\377\352T\216\377\351Y\221\377\351U\217\377\351Y\221\377\347U\216\377"
  "\360\222\267\377\377\377\377\377\375\361\366\377\350V\220\377\353Z\223\377"
  "\354]\224\377\366\261\314\377\377\377\377\377\371\316\336\377\347V\214\377"
  "\346V\216\377\345W\217\377\344T\215\377\347[\222\377\347Z\222\377\352\\\222"
  "\377\353`\226\377\351Z\221\377\350W\217\377\365\262\314\377\377\377\377\377"
  "\376\372\373\377\367\317\336\377\360\230\273\377\356n\236\377\352`\224\377"
  "\350Z\221\377\347V\217\377\347U\215\377\347V\216\377\352[\223\377\353^\223"
  "\377\352Z\220\377\353]\224\377\354]\222\377\355a\227\377\352[\222\377\352"
  "Z\222\377\347Z\220\377\347X\217\377\353]\224\377\350[\222\377\347]\222\377"
  "\345Y\221\377\352^\223\377\357d\227\377\353[\221\377\351[\221\377\350Y\221"
  "\377\346X\217\377\344Y\220\377\350^\221\377\353`\226\377\353_\224\377\350"
  "Z\221\377\345\\\223\377\251Gn\377yE[\377H@H\377\13\14\14\377ILR\377)+-\377"
  "\37\"&\377\34\36!\37726<\377\7\7\10\377\26\31\33\377\40$&\377\355_\225\376"
  "\352[\223\377\352Z\221\377\351V\217\377\353]\223\377\354`\226\377\351^\220"
  "\377\352\\\224\377\351[\222\377\354^\224\377\350T\220\377\350Y\220\377\202"
  "\353_\224\377\12\353`\225\377\354[\222\377\357`\225\377\354\\\222\377\355"
  "]\224\377\353]\224\377\351X\220\377\354^\224\377\355[\223\377\353Y\220\377"
  "\203\352Y\222\377\177\353]\223\377\345Y\217\377\352Y\222\377\353[\223\377"
  "\351[\221\377\353Z\223\377\355`\226\377\357`\227\377\355]\225\377\354]\225"
  "\377\355a\227\377\353^\224\377\354]\224\377\356b\227\377\356a\230\377\354"
  "\\\223\377\356]\224\377\353W\221\377\353[\222\377\354^\224\377\354]\224\377"
  "\356_\226\377\357\\\224\377\356\\\223\377\356_\224\377\361|\247\377\377\376"
  "\377\377\376\373\375\377\355e\232\377\355]\224\377\352X\221\377\353[\223"
  "\377\353^\224\377\356p\237\377\377\377\377\377\377\377\376\377\353h\232\377"
  "\346Y\221\377\347X\221\377\354|\250\377\377\377\377\377\376\370\372\377\350"
  "Z\217\377\346S\215\377\344S\214\377\346X\217\377\355\205\256\377\365\273"
  "\321\377\374\356\363\377\367\277\324\377\346U\216\377\347V\217\377\355r\241"
  "\377\357\221\265\377\347a\225\377\343N\211\377\351Y\220\377\353`\225\377"
  "\350Y\220\377\355c\230\377\353]\222\377\352`\225\377\351[\222\377\347W\220"
  "\377\354_\224\377\352Z\221\377\353[\222\377\352\\\222\377\353`\225\377\351"
  "[\222\377\351]\222\377\345Z\220\377\350\\\221\377\353^\223\377\346X\217\377"
  "\351]\224\377\360g\232\377\355a\224\377\354`\225\377\351Z\222\377\350[\221"
  "\377\347X\221\377\353b\225\377\354b\225\377\356d\227\377\330X\210\377\225"
  "?_\377lHZ\377\40\35\40\377\26\30\32\377\14\15\16\377\32\36\37\377LOV\377"
  "\13\16\16\377GJN\377>BF\377ILQ\377\14\15\16\377\12\14\15\377\14\15\17\377"
  "%)+\377\354^\225\376\353^\224\377\354]\223\377\352[\221\377\354_\224\377"
  "\354^\222\377\351[\220\377\351[\222\377\346X\217\377\354a\225\377\347Y\220"
  "\377\352X\221\377\350W\216\377\347U\216\377\352[\221\377\353\\\224\377\353"
  "Z\221\377\352Z\221\377\353a\226\377\350\\\223\377\344S\215\377\350Y\220\377"
  "\352Y\221\377\352]\224\377\350X\221\377\350Y\222\377/\353`\226\377\354]\225"
  "\377\353Y\222\377\350S\215\377\355^\224\377\354Z\224\377\353Y\222\377\356"
  "c\230\377\356[\223\377\356]\225\377\353Z\222\377\354Y\223\377\355\\\224\377"
  "\352[\222\377\357_\224\377\355X\220\377\356]\224\377\355^\226\377\352W\221"
  "\377\354\\\224\377\355^\225\377\360e\230\377\357b\226\377\360^\226\377\360"
  "]\224\377\357^\224\377\355^\224\377\374\352\361\377\377\377\377\377\364\231"
  "\273\377\355]\223\377\354^\224\377\353X\221\377\352\\\224\377\352Y\223\377"
  "\376\371\373\377\377\377\377\377\355t\243\377\352Z\222\377\351Z\222\377\347"
  "\\\222\377\374\356\364\377\377\377\377\377\362\224\270\377\360\215\263\377"
  "\365\304\326\377\374\364\367\377\202\377\377\377\377\23\375\366\370\377\364"
  "\264\315\377\344P\212\377\346U\216\377\352X\217\377\352Y\222\377\347S\216"
  "\377\346V\216\377\347T\217\377\350Y\222\377\350Y\220\377\347[\221\377\351"
  "X\217\377\351Z\222\377\350W\220\377\347X\220\377\351[\223\377\353^\223\377"
  "\353[\222\377\202\352Y\221\3771\351^\224\377\351]\222\377\345Z\221\377\345"
  "U\216\377\344X\220\377\347`\226\377\355c\226\377\357h\232\377\352`\224\377"
  "\353^\222\377\354_\223\377\352^\223\377\353_\224\377\314Z\206\377\210E`\377"
  ";\36(\377\12\12\13\377\20\23\24\377\37\"%\377\31\34\37\377\20\22\24\377\17"
  "\20\21\3776:>\377\26\30\33\377LOT\377\24\27\30\377\20\22\24\377(,0\377\31"
  "\35\37\377\10\12\12\377\12\15\16\377\40$&\377\350W\220\376\350Z\221\377\352"
  "]\223\377\351Z\220\377\353]\223\377\354`\223\377\352[\223\377\345W\220\377"
  "\350[\221\377\352\\\223\377\350W\221\377\353Y\220\377\354`\225\377\352Y\220"
  "\377\355a\225\377\353]\224\377\350[\222\377\203\352Y\222\377\12\352]\224"
  "\377\351\\\223\377\353\\\223\377\350U\217\377\350Y\221\377\350\\\223\377"
  "\353a\230\377\355`\226\377\351W\221\377\353\\\224\377\202\360c\230\377$\353"
  "[\224\377\354_\226\377\355\\\224\377\353[\224\377\354[\224\377\354[\223\377"
  "\352W\221\377\351Z\222\377\353Z\222\377\352U\217\377\355[\224\377\356`\225"
  "\377\355_\224\377\354[\224\377\356a\226\377\357c\227\377\356_\225\377\355"
  "\\\223\377\356a\225\377\357c\230\377\352Z\221\377\366\265\316\377\377\377"
  "\377\377\371\314\335\377\351W\220\377\353X\220\377\351X\220\377\351W\220"
  "\377\355e\231\377\376\372\374\377\377\376\376\377\354f\231\377\353Z\222\377"
  "\345X\217\377\346U\217\377\366\272\321\377\204\377\377\377\377b\374\360\365"
  "\377\364\270\317\377\354\205\255\377\346W\217\377\344T\214\377\345S\213\377"
  "\346T\216\377\351Y\217\377\345R\215\377\350W\217\377\350Z\221\377\347Z\221"
  "\377\352[\224\377\351\\\223\377\344T\215\377\345U\216\377\350`\225\377\353"
  "c\226\377\350\\\221\377\347]\221\377\354_\224\377\356a\227\377\353^\223\377"
  "\351Z\222\377\351X\221\377\352^\223\377\352_\224\377\350Z\221\377\353b\227"
  "\377\347^\223\377\353]\224\377\353_\224\377\353]\223\377\347]\222\377\257"
  "Hp\377\177D]\377,\35%\377\12\14\15\377AEJ\377\17\20\22\377\12\14\15\377\35"
  "\40!\377\37!$\377&'*\3777:>\377\33\35\40\377\31\33\34\377\33\35\37\377.1"
  "5\377\40#'\377\21\23\24\377\14\16\17\377\16\20\21\377OSX\377\13\14\15\377"
  "\34\37\"\377\347X\220\376\345T\216\377\347W\216\377\352^\224\377\352]\220"
  "\377\352]\223\377\351W\217\377\350Y\222\377\351[\223\377\351\\\222\377\346"
  "W\220\377\354`\227\377\355]\224\377\353\\\222\377\354a\227\377\352Y\220\377"
  "\346U\216\377\351V\220\377\355_\225\377\352^\224\377\354a\227\377\355_\226"
  "\377\355\\\223\377\352Y\223\377\351X\220\377\351\\\223\377\353_\227\377\353"
  "Y\223\377\351X\222\377\351[\223\377\355]\224\377\357a\227\377\356[\223\377"
  "\355[\224\377\355Y\221\377\355]\224\377\354^\224\377\347V\217\377\352W\221"
  "\377\350Y\220\377\351X\220\377\353X\220\377\202\357_\225\377\177\356Z\223"
  "\377\352X\221\377\355_\225\377\356b\227\377\353\\\222\377\351Y\220\377\350"
  "Z\220\377\350Y\221\377\350V\217\377\357\177\252\377\377\377\377\377\376\367"
  "\372\377\350X\220\377\352V\221\377\346S\216\377\353Z\222\377\357\206\257"
  "\377\377\377\377\377\373\346\356\377\353Z\223\377\351X\222\377\343S\214\377"
  "\352]\223\377\360\210\257\377\377\377\377\377\374\351\360\377\365\264\315"
  "\377\355|\250\377\352Z\220\377\351U\217\377\352W\220\377\347T\216\377\352"
  "Z\221\377\350X\217\377\347X\217\377\351Y\221\377\350V\217\377\347X\221\377"
  "\353]\222\377\351W\221\377\351[\222\377\351^\224\377\346Y\221\377\343T\214"
  "\377\346V\216\377\350Z\221\377\351Z\222\377\347Y\220\377\352\\\223\377\354"
  "_\224\377\352^\224\377\352\\\223\377\353a\225\377\354a\226\377\353b\227\377"
  "\351]\222\377\346]\224\377\351[\221\377\337U\212\377\237Bg\377zOd\377-'-"
  "\377\5\10\7\37736;\377\27\30\33\377,14\377\21\23\25\377\11\11\11\377DGM\377"
  "\16\17\22\377\17\21\22\377/25\377358\377.14\3778<@\377#&)\377\15\16\17\377"
  "7;?\377\14\15\16\377\37\40#\377$'*\377\23\25\27\377\10\12\13\377\35\40\""
  "\377\350Y\221\376\347Z\220\377\342W\220\377\344X\215\377\351`\225\377\352"
  "\\\222\377\350X\222\377\350T\216\377\350W\220\377\351\\\222\377\350X\220"
  "\377\347[\221\377\353Z\222\377\351X\220\377\352X\221\377\352W\220\377\352"
  "Z\222\377\355[\223\377\354[\222\377\351[\222\377\355]\224\377\357d\227\377"
  "\356[\224\377\355a\227\377\352Y\222\377\352[\222\377\353[\223\377\353]\224"
  "\377\353]\223\377\353^\224\377\354_\226\377\355^\226\377\356a\230\377\354"
  "[\222\377\353Y\221\377\354Z\223\377\353\\\225\377\354a\225\377\355^\223\377"
  "\355\\\223\377\354_\225\377\354Z\223\377\357c\227\377,\356[\223\377\354X"
  "\222\377\353Y\223\377\352X\221\377\353Z\221\377\353Z\220\377\350V\217\377"
  "\352X\217\377\350V\217\377\350V\220\377\352W\222\377\375\360\365\377\377"
  "\377\377\377\361\210\260\377\350S\214\377\347S\216\377\353r\241\377\374\354"
  "\362\377\377\377\377\377\361\225\271\377\352Y\221\377\345T\215\377\347Z\221"
  "\377\350Z\216\377\355`\227\377\360{\246\377\354Y\221\377\354X\220\377\352"
  "Y\221\377\350U\216\377\351Y\221\377\353]\226\377\353Z\222\377\353\\\222\377"
  "\344T\212\377\344T\216\377\350S\216\377\350Y\222\377\352Z\222\377\347W\220"
  "\377\351Y\222\377\353^\224\377\353^\223\377\351Z\222\377\202\347Y\220\377"
  "\177\352\\\223\377\351Y\222\377\354]\223\377\354Z\222\377\355_\224\377\354"
  "[\223\377\351[\222\377\354c\227\377\353]\224\377\352_\224\377\353g\234\377"
  "\317i\222\377s;P\377*\32\40\3778<?\377\21\23\24\377\30\32\34\377\26\30\33"
  "\377\27\31\33\377MOU\377\32\33\36\377\15\17\17\377\25\30\32\377IMS\377\25"
  "\27\30\3778;?\377.04\377+.2\377),.\377BFK\377(*,\377%*-\377\11\13\13\377"
  "\36\"%\377047\377\"%'\377\14\15\16\377\10\12\12\37747;\377\346X\221\376\344"
  "V\217\377\344X\216\377\346\\\217\377\351_\224\377\347[\222\377\350[\220\377"
  "\352[\222\377\350U\217\377\350T\217\377\344R\214\377\340P\210\377\351Y\222"
  "\377\352[\224\377\353[\223\377\354[\222\377\355^\225\377\353[\222\377\353"
  "Z\223\377\353\\\224\377\360b\230\377\352W\221\377\352X\221\377\352\\\224"
  "\377\353]\225\377\353Z\223\377\354Z\223\377\355a\226\377\353]\225\377\351"
  "X\222\377\353\\\225\377\354]\225\377\353]\225\377\355]\225\377\357a\230\377"
  "\360d\230\377\353\\\223\377\354[\223\377\354a\225\377\356_\226\377\354\\"
  "\223\377\354[\223\377\351U\216\377\353W\221\377\355]\224\377\354Y\221\377"
  "\351X\220\377\354\\\223\377\355]\223\377\353[\223\377\354[\222\377\355_\225"
  "\377\352V\220\377\351Y\221\377\367\276\324\377\377\377\377\377\370\304\327"
  "\377\356}\250\377\365\271\321\377\376\372\373\377\377\377\377\377\365\267"
  "\317\377\347W\220\377\352^\223\377\350X\221\377\345U\212\377\350Z\221\377"
  "\352V\220\377\354_\225\377\354\\\223\377\354[\223\377\347Z\220\377\346X\220"
  "\377\350Z\221\377\345S\215\377\351\\\222\377\351[\221\377\350Y\220\377\351"
  "Z\221\377\353^\225\377\355d\231\377\352\\\222\377\350W\220\377\353Z\223\377"
  "\355^\226\377\353^\224\377\352\\\223\377\351W\217\377_\351Y\220\377\352X"
  "\221\377\346U\217\377\354\\\224\377\357c\226\377\355]\225\377\352`\225\377"
  "\351Z\222\377\341W\214\377\253Hm\377e2G\3771'.\377&*-\377)22\377\14\15\15"
  "\377\32\34\36\377\24\27\30\377'*-\377\14\17\17\377\210\216\231\377\13\13"
  "\14\377\13\14\14\3778<@\377/48\377\24\26\30\377PRW\377>CI\377%'+\377\26\31"
  "\33\37736=\377\23\26\30\377\33\36\40\377\20\21\22\377-15\377\12\14\15\377"
  "%),\377\17\22\24\377\27\32\33\377\12\13\13\377#&)\377\345Y\221\376\345Z\221"
  "\377\347[\217\377\351^\224\377\346X\220\377\347`\225\377\352_\225\377\351"
  "Z\220\377\346Q\214\377\351Y\221\377\341L\210\377\344R\214\377\354^\224\377"
  "\352X\220\377\355`\225\377\356b\227\377\353Y\221\377\355_\225\377\356`\226"
  "\377\356_\226\377\356b\227\377\355_\227\377\352^\224\377\351V\221\377\352"
  "\\\224\377\350U\220\377\355_\226\377\360d\231\377\354_\226\377\350Y\222\377"
  "\355^\224\377\352Y\222\377\353[\223\377\351Y\222\377\355c\231\377\353\\\223"
  "\377\352]\223\377\352Z\222\377\356_\226\377\355_\224\377\354\\\224\377\351"
  "X\217\377\350W\220\377\353Z\222\377\354Z\222\377\353V\217\377\353X\220\377"
  "\356`\225\377\355_\224\377\355b\230\377\355`\225\377\355Z\224\377\352W\222"
  "\377\351V\220\377\360\207\260\377\204\377\377\377\377\30\374\350\360\377"
  "\360\217\265\377\352Y\223\377\353a\225\377\350U\217\377\346V\214\377\342"
  "Q\213\377\347Y\217\377\352Z\223\377\354]\224\377\353\\\223\377\352Y\221\377"
  "\351Y\222\377\347Z\222\377\347Z\223\377\350X\220\377\346W\217\377\341S\214"
  "\377\344V\216\377\351W\221\377\351[\223\377\352]\224\377\352[\224\377\353"
  "[\223\377\202\352Y\221\377V\347Y\221\377\352^\224\377\355_\226\377\353Y\222"
  "\377\354_\224\377\352[\221\377\355a\226\377\354]\225\377\334T\211\377\231"
  "Be\377S*;\377ECI\377\27\31\33\377\12\13\14\377\40#&\377569\377V[`\377\16"
  "\17\20\377\12\12\13\377TY^\377*+.\377\30\32\34\377&),\377\12\13\15\377\31"
  "\33\35\377FJO\377\32\34\36\377MPV\377.14\377Z`f\377\40\"$\377ADH\377\34\36"
  "\40\377:?C\377\13\13\13\377\23\25\27\377\32\36!\377$'*\377\12\13\14\377-"
  "-1\377SY_\377\6\10\10\377\27\31\32\377\346Z\221\376\344X\216\377\347[\222"
  "\377\351]\223\377\350]\224\377\351_\225\377\352b\226\377\350\\\224\377\354"
  "c\226\377\352`\224\377\354d\227\377\355_\224\377\353Z\221\377\354Y\221\377"
  "\353]\224\377\350W\220\377\355\\\223\377\357]\224\377\357_\226\377\361d\231"
  "\377\354[\224\377\355]\225\377\354^\225\377\347U\220\377\352Y\221\377\354"
  "\\\223\377\356\\\224\377\352]\224\377\350X\222\377\353[\223\377\354Y\223"
  "\377\351Y\222\377\353]\225\377\353W\221\377\353[\224\377\347W\217\377\351"
  "W\220\377\352W\221\377\356]\225\377\357^\225\377\355[\222\377\353W\220\377"
  "\352Z\221\377\202\355\\\224\377v\353W\217\377\353[\222\377\356_\226\377\353"
  "X\220\377\351X\221\377\355Y\221\377\354X\222\377\354Z\222\377\352V\220\377"
  "\347V\220\377\375\365\370\377\375\355\363\377\367\270\320\377\360\205\255"
  "\377\353[\222\377\353^\225\377\355^\224\377\353Z\221\377\352\\\223\377\346"
  "W\215\377\342O\212\377\343T\215\377\351Y\222\377\351Z\222\377\352\\\222\377"
  "\351\\\222\377\354^\225\377\352\\\223\377\344T\215\377\351_\224\377\352\\"
  "\223\377\351\\\222\377\346T\215\377\344V\216\377\347V\217\377\350\\\221\377"
  "\352[\222\377\346T\216\377\347X\217\377\352Z\223\377\350Y\221\377\354\\\224"
  "\377\354Z\222\377\355^\226\377\361d\232\377\331e\220\377\244Xw\377U7E\377"
  "\26\27\31\377\12\13\13\377>BF\377)*.\377\24\26\27\377\31\32\34\377\23\25"
  "\26\37737;\377\32#\"\377\10\11\10\377(,/\377\23\24\25\377_em\377\12\14\15"
  "\377\10\12\12\377\16\20\21\377/15\377=AF\377\27\30\32\377\16\15\17\377qv"
  "\177\377\26\25\26\377GLQ\377\40#&\377\31\34\37\377\33\35\40\377\16\20\22"
  "\377\17\21\22\3779>C\377\30\31\33\377&*,\377\22\24\26\377\26\31\34\377\16"
  "\20\21\377\11\12\13\377\346X\216\376\344X\216\377\346Z\222\377\346[\222\377"
  "\347^\223\377\344X\220\377\344V\216\377\350Z\221\377\356f\230\377\357g\232"
  "\377\361m\234\377\356^\224\377\351X\220\377\352\\\222\377\351S\216\377\352"
  "Y\221\377\356`\226\377\355[\224\377\353]\224\377\356\\\224\377\352W\220\377"
  "\350X\222\377\353Y\222\377\353[\224\377\353]\224\377\354^\225\377\353a\226"
  "\377\347[\222\377\353\\\223\377\357b\227\377\356`\226\377\355^\225\377\356"
  "a\227\377\353[\224\377\353X\220\377\202\351W\220\377\11\354[\223\377\356"
  "[\223\377\360`\226\377\361g\231\377\355[\223\377\354Z\223\377\355`\226\377"
  "\354\\\223\377\352[\223\377\202\354]\223\377S\351Z\221\377\353Y\222\377\354"
  "[\224\377\356_\225\377\353V\221\377\352W\220\377\352Y\221\377\353k\236\377"
  "\351U\216\377\352R\216\377\350U\216\377\352Y\222\377\353Y\222\377\347Z\221"
  "\377\353_\227\377\352]\220\377\346T\217\377\352X\222\377\353]\224\377\355"
  "b\227\377\353b\226\377\354[\224\377\354a\226\377\352_\224\377\347X\221\377"
  "\350Y\221\377\350\\\222\377\354[\222\377\352Z\222\377\347W\220\377\344S\214"
  "\377\345Q\214\377\350Z\222\377\355`\227\377\355^\225\377\351W\220\377\354"
  "^\224\377\356_\225\377\357a\230\377\322a\216\377\210Ga\3777#+\377\20\22\22"
  "\377DGL\377\17\20\20\377\25\30\33\377\26\26\30\377\40\"$\377(+-\377&*.\377"
  "\17\20\21\377\20\22\24\377\22\24\25\377\33!\40\377\10\11\12\377<@B\377=A"
  "G\377\14\16\16\377\16\21\22\377\13\14\15\377\17\21\22\37746;\3775:=\377\25"
  "\25\27\377,/2\377\34\35\40\377}\203\213\377&()\377!#&\377\31\32\34\377%)"
  ",\377-12\37715;\377\13\14\15\377\31\34\37\377,04\377?DH\377\31\33\36\377"
  "\14\15\16\377GKP\377\351]\223\376\350X\221\377\347]\224\377\202\350^\224"
  "\377\177\350b\227\377\350\\\223\377\352`\226\377\353[\223\377\356_\225\377"
  "\357a\226\377\355Y\221\377\353]\224\377\350V\217\377\355Z\223\377\354^\225"
  "\377\354^\224\377\353[\221\377\347S\215\377\351X\223\377\351X\221\377\346"
  "U\215\377\347T\217\377\351Y\222\377\351Y\221\377\351V\220\377\352Z\220\377"
  "\353`\225\377\354`\226\377\352[\223\377\355b\231\377\353]\223\377\353^\225"
  "\377\352^\225\377\350Z\221\377\352V\217\377\351V\217\377\354\\\225\377\354"
  "^\225\377\360_\226\377\356[\223\377\355Y\223\377\353V\220\377\352Y\221\377"
  "\353Y\221\377\353[\221\377\355\\\222\377\356d\227\377\353^\224\377\352Z\223"
  "\377\352Z\221\377\353\\\224\377\355[\223\377\356b\226\377\354]\224\377\353"
  "\\\222\377\354]\225\377\353[\223\377\352V\217\377\354]\224\377\352]\224\377"
  "\345V\216\377\347X\217\377\350[\222\377\351\\\223\377\352]\225\377\355b\230"
  "\377\355a\226\377\355`\225\377\353Z\223\377\355^\224\377\346W\217\377\345"
  "T\215\377\345U\215\377\355a\226\377\354\\\223\377\353]\223\377\355`\225\377"
  "\350W\217\377\354[\224\377\352U\221\377\353]\224\377\357a\227\377\354b\226"
  "\377\324o\227\377n6L\377!\24\31\377\35\40!\377$%(\377,/2\377&),\377\11\12"
  "\12\377\23\24\23\377\17\20\20\37758=\377\13\14\15\377\13\15\15\377,04\377"
  "\30\33\35\377\15\16\17\377\23\25\26\377\16\27\24\377\13\14\14\37758;\377"
  ">CG\377\31\34\36\377\12\13\14\377\25\27\32\377.26\377\33\34\37\377\15\17"
  "\17\377\20\21\22\377.25\377&*-\377149\377\"&)\377\12\13\14\377'+/\377DIN"
  "\377\30\32\34\377\32\34\36\37735:\377\13\15\15\377.16\377\33\35\40\377QT"
  "Y\377148\377\23\26\27\377\353_\226\376\352[\223\377\353_\226\377\353]\224"
  "\377\177\351`\225\377\346Z\221\377\352\\\223\377\351\\\224\377\352\\\223"
  "\377\354c\227\377\357c\227\377\354]\225\377\356c\230\377\352W\221\377\351"
  "Z\222\377\352[\222\377\352S\220\377\351X\222\377\355^\226\377\355Y\223\377"
  "\353Z\221\377\352W\221\377\353\\\223\377\351Z\223\377\351Y\221\377\353^\225"
  "\377\354\\\223\377\350X\222\377\351[\222\377\347W\220\377\352]\225\377\354"
  "b\230\377\354[\224\377\353Z\222\377\353]\224\377\353X\221\377\354Z\222\377"
  "\353Z\222\377\352W\220\377\360c\227\377\354Z\221\377\354_\225\377\354\\\223"
  "\377\351W\217\377\354X\222\377\356]\224\377\357`\226\377\355_\225\377\356"
  "b\230\377\353X\221\377\347U\217\377\354]\224\377\357c\230\377\356d\230\377"
  "\354^\226\377\352Y\221\377\351Z\222\377\352X\220\377\351X\220\377\347U\216"
  "\377\346X\217\377\347Z\217\377\347Y\216\377\352]\223\377\354^\225\377\354"
  "]\225\377\356d\230\377\360h\232\377\355`\226\377\350[\222\377\346T\215\377"
  "\346Q\214\377\352]\223\377\351Y\221\377\351X\221\377\352Y\220\377\355]\225"
  "\377\355[\223\377\355b\226\377\357c\231\377\337`\221\377\245Rr\377\220f|"
  "\377627\377!%'\377\20\21\22\377\17\21\22\377\16\17\20\377\17\20\22\377ps"
  "y\377\24\25\27\377\30\32\33\377\22\23\24\377IMR\377\11\11\11\377LOV\377\16"
  "\20\21\377\16\17\20\377\21\22\24\377\21\24\26\377\15\16\17\377\20\30\27\377"
  "\13\16\17\377:>A\37749<\377\25\26\31\377*.2\377>@F\377\24\24\26\37759=\377"
  "GLQ\377\15\16\17\377!$(\377mrz\377\35\37\40\377\22\24\25\377\22\26\30\377"
  "\26\27\30\37736:\377\17\22\24\377\40#&\377!$'\377LPU\377\27\31\33\377`ci"
  "\377lqy\377\32\34\36\377?CH\377\355_\226\376\354d\230\377\354`\226\377\177"
  "\353e\230\377\352b\227\377\350]\223\377\350^\224\377\351[\220\377\352`\225"
  "\377\351a\225\377\355b\230\377\355`\226\377\354`\226\377\352Y\223\377\353"
  "]\225\377\354]\226\377\353_\225\377\353Z\223\377\352X\220\377\352Z\223\377"
  "\347W\217\377\351V\221\377\351V\217\377\352[\223\377\353Y\220\377\357`\226"
  "\377\355^\225\377\353_\224\377\354^\224\377\350V\220\377\355\\\224\377\354"
  "]\225\377\355[\223\377\355^\224\377\354\\\223\377\355]\225\377\354Z\223\377"
  "\353Z\221\377\351[\221\377\355\\\223\377\354\\\223\377\347W\217\377\351Y"
  "\222\377\352Y\221\377\353[\222\377\354[\224\377\352]\224\377\347X\217\377"
  "\350V\217\377\345R\216\377\347V\217\377\352Z\222\377\352[\222\377\351Z\222"
  "\377\351\\\223\377\352V\220\377\351U\217\377\350T\216\377\352X\221\377\352"
  "\\\223\377\353]\224\377\351\\\216\377\352^\225\377\351^\223\377\354b\227"
  "\377\355`\226\377\355b\227\377\354`\226\377\352]\224\377\344S\214\377\346"
  "V\217\377\353[\222\377\354[\224\377\352Y\221\377\353]\223\377\354c\230\377"
  "\354_\226\377\327^\213\377\254c\203\377F\"0\377\14\14\15\377\27\31\34\377"
  "*/3\377*.2\377\12\12\13\377\13\13\13\377\15\17\20\377&),\377\17\20\20\377"
  "\30\30\32\377\21\23\24\377\32\35\37\377\\^e\377\14\15\15\377\34\36!\377\21"
  "\21\23\377\31\33\35\377\27\32\34\377\20\21\22\377#&)\377\37\"%\377\12\22"
  "\16\377\17\21\22\377\261\266\277\377/24\377\27\31\33\377FHM\377\17\21\22"
  "\377138\377JLQ\377(+-\377\26\30\31\377(+/\377:=A\377\33\36\40\377\22\24\25"
  "\377\33\34\34\377RW]\377\35\37#\377\31\32\34\377=?D\3776:?\377\26\33\35\377"
  "\33\37\"\377\40\"$\377?CH\377?DJ\377'*-\377\352\\\224\376\351]\224\377~\352"
  "[\223\377\354`\226\377\352`\225\377\350\\\223\377\353b\226\377\353`\224\377"
  "\354]\225\377\352\\\224\377\354`\227\377\356f\232\377\354]\224\377\353[\224"
  "\377\356a\227\377\356b\227\377\356`\227\377\352W\221\377\350W\222\377\353"
  "[\222\377\353[\223\377\352\\\224\377\354a\226\377\352Y\221\377\354^\224\377"
  "\355`\226\377\355_\225\377\355]\225\377\353[\223\377\354]\224\377\352\\\223"
  "\377\351W\220\377\353W\221\377\355]\226\377\356]\225\377\355[\224\377\356"
  "]\226\377\353\\\223\377\353Z\223\377\352Y\221\377\352Y\222\377\347T\215\377"
  "\344S\214\377\350V\220\377\355\\\223\377\354[\224\377\350Y\220\377\350U\217"
  "\377\346S\216\377\347T\215\377\346S\216\377\350Z\221\377\350W\220\377\351"
  "Z\221\377\351Z\223\377\351Z\221\377\353Z\221\377\353X\220\377\351\\\221\377"
  "\354^\225\377\352b\224\377\351]\224\377\352c\227\377\352a\226\377\353c\227"
  "\377\351\\\223\377\352Z\221\377\346S\216\377\351X\217\377\352Y\223\377\354"
  "_\225\377\356b\226\377\355a\227\377\351_\223\377\304X\202\377z:S\377F1<\377"
  "\14\17\17\377)+/\377\26\30\33\377\23\26\27\377<AE\377)-0\377\13\13\13\377"
  "\17\20\21\377\10\11\11\377\17\22\23\377+.1\377\12\13\14\377\10\11\11\377"
  ").0\377CGK\377\15\15\15\377;?C\377\17\17\17\377\15\16\16\377&*,\377\21\23"
  "\25\377\23\24\26\377\25\27\31\377*.1\377$,+\377\22\24\26\377&)+\377dip\377"
  "!$&\377\13\14\14\377+.1\377\"$(\377258\377#%'\377\24\26\30\37737;\377\11"
  "\11\11\377\26\30\32\377&),\377\20\21\22\37748;\377\17\23\24\377\15\15\15"
  "\377[af\377!$&\377\37!\"\377*.1\377\26\31\32\377\35\36\40\377\36!#\377\16"
  "\17\17\377"
};

#line 0 "../libs/openFrameworks/app/ofAppBaseWindow.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofWindowSettings.h" */

class ofBaseApp;
class ofBaseRenderer;
class ofCoreEvents;

#if defined(TARGET_LINUX) && !defined(TARGET_OPENGLES)
struct __GLXcontextRec;
typedef __GLXcontextRec * GLXContext;
#endif

#if defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI)
typedef unsigned long Window;
struct _XDisplay;
typedef struct _XDisplay Display;
#endif

class ofAppBaseWindow{

public:

	ofAppBaseWindow(){};
	virtual ~ofAppBaseWindow(){};

	virtual void setup(const ofWindowSettings & settings)=0;
	virtual void update()=0;
	virtual void draw()=0;
	virtual bool getWindowShouldClose(){
		return false;
	}
	virtual void setWindowShouldClose(){
	}
	virtual void close(){
	}
	virtual ofCoreEvents & events() = 0;
	virtual std::shared_ptr<ofBaseRenderer> & renderer() = 0;

	virtual void hideCursor() {}
	virtual void showCursor() {}

	virtual void	setWindowPosition(int x, int y) {}
	virtual void	setWindowShape(int w, int h) {}

	virtual glm::vec2	getWindowPosition() {return glm::vec2(); }
	virtual glm::vec2	getWindowSize(){return glm::vec2(); }
	virtual glm::vec2	getScreenSize(){return glm::vec2(); }

	virtual void			setOrientation(ofOrientation orientation){ }
	virtual ofOrientation	getOrientation(){ return OF_ORIENTATION_DEFAULT; }
	virtual bool	doesHWOrientation(){return false;}

	//this is used by ofGetWidth and now determines the window width based on orientation
	virtual int		getWidth(){ return 0; }
	virtual int		getHeight(){ return 0; }

	virtual float	getPixelScreenCoordScale() { return 1; }

	virtual void	setWindowTitle(std::string title){}

	virtual ofWindowMode	getWindowMode() {return OF_WINDOW ;}

	virtual void	setFullscreen(bool fullscreen){}
	virtual void	toggleFullscreen(){}

	virtual void	enableSetupScreen(){}
	virtual void	disableSetupScreen(){}
	
	virtual void	setVerticalSync(bool enabled){};
    virtual void    setClipboardString(const std::string& text) {}
    virtual std::string  getClipboardString() { return ""; }

    virtual void makeCurrent(){};
	virtual void swapBuffers() {}
	virtual void startRender() {}
	virtual void finishRender() {}

    virtual void * getWindowContext(){return nullptr;};

#if defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI)
	virtual Display* getX11Display(){return nullptr;}
	virtual Window  getX11Window() {return 0;}
#endif

#if defined(TARGET_LINUX) && !defined(TARGET_OPENGLES)
	virtual GLXContext getGLXContext(){return 0;}
#endif

#if defined(TARGET_LINUX) && defined(TARGET_OPENGLES)
	virtual EGLDisplay getEGLDisplay(){return 0;}
	virtual EGLContext getEGLContext(){return 0;}
	virtual EGLSurface getEGLSurface(){return 0;}
#endif

#if defined(TARGET_OSX)
	virtual void * getNSGLContext(){return nullptr;}
	virtual void * getCocoaWindow(){return nullptr;}
#endif

#if defined(TARGET_WIN32)
	virtual HGLRC getWGLContext(){return 0;}
	virtual HWND getWin32Window(){return 0;}
#endif

#if defined(TARGET_QT)
    virtual void * getQtContext(){return nullptr;}
    virtual void * getQtWindow(){return nullptr;}
#endif
};

class ofAppBaseGLWindow: public ofAppBaseWindow{
public:
	virtual ~ofAppBaseGLWindow(){}
	virtual void setup(const ofGLWindowSettings & settings)=0;
	void setup(const ofWindowSettings & settings){
		const ofGLWindowSettings * glSettings = dynamic_cast<const ofGLWindowSettings*>(&settings);
		if(glSettings){
			setup(*glSettings);
		}else{
			setup(ofGLWindowSettings(settings));
		}
	}
};

class ofAppBaseGLESWindow: public ofAppBaseWindow{
public:
	virtual ~ofAppBaseGLESWindow(){}
	virtual void setup(const ofGLESWindowSettings & settings)=0;
	void setup(const ofWindowSettings & settings){
		const ofGLESWindowSettings * glSettings = dynamic_cast<const ofGLESWindowSettings*>(&settings);
		if(glSettings){
			setup(*glSettings);
		}else{
			setup(ofGLESWindowSettings(settings));
		}
	}
};

#line 0 "../libs/openFrameworks/app/ofAppQtWindow.h"
#pragma once

/* #include "ofConstants.h" */

/* #include "ofAppBaseWindow.h" */
/* #include "ofEvents.h" */
/* #include "ofPixels.h" */
/* #include "ofRectangle.h" */

#include <string>
#include <memory>

class Window;
class ofBaseApp;

#ifdef TARGET_OPENGLES
class ofQtWindowSettings: public ofGLESWindowSettings{
#else
class ofQtWindowSettings: public ofGLWindowSettings{
#endif
public:
	ofQtWindowSettings(){}

#ifdef TARGET_OPENGLES
	ofQtWindowSettings(const ofGLESWindowSettings & settings)
	:ofGLESWindowSettings(settings){}
#else
	ofQtWindowSettings(const ofGLWindowSettings & settings)
	:ofGLWindowSettings(settings){}
#endif

	int numSamples = 4;
	bool doubleBuffering = true;
	int redBits = 8;
	int greenBits = 8;
	int blueBits = 8;
	int alphaBits = 8;
	int depthBits = 24;
	int stencilBits = 0;
	bool stereo = false;
	bool visible = true;
	bool iconified = false;
	bool decorated = true;
	bool resizable = true;
	int monitor = 0;
	bool multiMonitorFullScreen = false;
	std::shared_ptr<ofAppBaseWindow> shareContextWith;
};

#ifdef TARGET_OPENGLES
class ofAppQtWindow : public ofAppBaseGLESWindow{
#else
class ofAppQtWindow : public ofAppBaseGLWindow{
#endif

public:

    ofAppQtWindow();
	~ofAppQtWindow();

	// Can't be copied, use shared_ptr
	ofAppQtWindow(ofAppQtWindow & w) = delete;
	ofAppQtWindow & operator=(ofAppQtWindow & w) = delete;

	static void loop(){};
	static bool doesLoop(){ return false; }
	static bool allowsMultiWindow(){ return true; }
	static bool needsPolling(){ return true; }
	static void pollEvents();

    // this functions are only meant to be called from inside OF don't call them from your code
    using ofAppBaseWindow::setup;
#ifdef TARGET_OPENGLES
	void setup(const ofGLESWindowSettings & settings);
#else
	void setup(const ofGLWindowSettings & settings);
#endif
	void setup(const ofQtWindowSettings & settings);
	void update();
	void draw();

    bool getWindowShouldClose();
	void setWindowShouldClose();

	void close();

	void hideCursor();
	void showCursor();

	int getHeight();
	int getWidth();

	ofCoreEvents & events();
	std::shared_ptr<ofBaseRenderer> & renderer();
    ofQtWindowSettings getSettings(){ return settings; }

	glm::vec2 getWindowSize();
	glm::vec2 getScreenSize();
	glm::vec2  getWindowPosition();

	void setWindowTitle(std::string title);
	void setWindowPosition(int x, int y);
	void setWindowShape(int w, int h);

	void setOrientation(ofOrientation orientation);
	ofOrientation getOrientation();

	ofWindowMode getWindowMode();

	void setFullscreen(bool fullscreen);
	void toggleFullscreen();

	void enableSetupScreen();
	void disableSetupScreen();

	void setVerticalSync(bool bSync);

    void setClipboardString(const std::string& text);
    std::string getClipboardString();

    float getPixelScreenCoordScale();

    void makeCurrent();
	void swapBuffers();
	void startRender();
	void finishRender();

	static void listVideoModes();
	static void listMonitors();
	bool isWindowIconified();
	bool isWindowActive();
	bool isWindowResizeable();
	void iconify(bool bIconify);

protected:
	static ofAppQtWindow * setCurrent(Window* windowP);

    void * getQtContext();
    void * getQtWindow();

private:
	void setWindowIcon(const std::string & path);
	void setWindowIcon(const ofPixels & iconPixels);

	ofCoreEvents coreEvents;
	std::shared_ptr<ofBaseRenderer> currentRenderer;
	ofQtWindowSettings settings;

	ofWindowMode	windowMode;

	bool bEnableSetupScreen;
    bool bWindowShouldClose;

	ofRectangle windowRect;

	int buttonInUse;
	bool buttonPressed;

	int nFramesSinceWindowResized;

	Window * windowP;

    int getCurrentMonitor();

	ofBaseApp *	ofAppPtr;

    bool iconSet;
    
    friend class Window;
};

#line 0 "../addons/ofxXmlSettings/libs/tinyxml.h"
/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/


#ifndef TINYXML_INCLUDED
#define TINYXML_INCLUDED

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable : 4530 )
#pragma warning( disable : 4786 )
#endif

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// Help out windows:
#if defined( _DEBUG ) && !defined( DEBUG )
#define DEBUG
#endif

#define TIXML_USE_STL		// for now, OFXML will use STL for string stuff

#ifdef TIXML_USE_STL
	#include <string>
 	#include <iostream>
	#include <sstream>
	#define TIXML_STRING		std::string
#else
	#include "tinystr.h"
	#define TIXML_STRING		TiXmlString
#endif

// Deprecated library function hell. Compilers want to use the
// new safe versions. This probably doesn't fully address the problem,
// but it gets closer. There are too many compilers for me to fully
// test. If you get compilation troubles, undefine TIXML_SAFE
#define TIXML_SAFE

#ifdef TIXML_SAFE
	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
		// Microsoft visual studio, version 2005 and higher.
		#define TIXML_SNPRINTF _snprintf_s
		#define TIXML_SNSCANF  _snscanf_s
		#define TIXML_SSCANF   sscanf_s
	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
		// Microsoft visual studio, version 6 and higher.
		//#pragma message( "Using _sn* functions." )
		#define TIXML_SNPRINTF _snprintf
		#define TIXML_SNSCANF  _snscanf
		#define TIXML_SSCANF   sscanf
	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
		// GCC version 3 and higher.s
		//#warning( "Using sn* functions." )
		#define TIXML_SNPRINTF snprintf
		#define TIXML_SNSCANF  snscanf
		#define TIXML_SSCANF   sscanf
	#else
		#define TIXML_SSCANF   sscanf
	#endif
#endif	

class TiXmlDocument;
class TiXmlElement;
class TiXmlComment;
class TiXmlUnknown;
class TiXmlAttribute;
class TiXmlText;
class TiXmlDeclaration;
class TiXmlParsingData;

const int TIXML_MAJOR_VERSION = 2;
const int TIXML_MINOR_VERSION = 5;
const int TIXML_PATCH_VERSION = 3;

/*	Internal structure for tracking location of items 
	in the XML file.
*/
struct TiXmlCursor
{
	TiXmlCursor()		{ Clear(); }
	void Clear()		{ row = col = -1; }

	int row;	// 0 based.
	int col;	// 0 based.
};


/**
	If you call the Accept() method, it requires being passed a TiXmlVisitor
	class to handle callbacks. For nodes that contain other nodes (Document, Element)
	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
	are simple called with Visit().

	If you return 'true' from a Visit method, recursive parsing will continue. If you return
	false, <b>no children of this node or its sibilings</b> will be Visited.

	All flavors of Visit methods have a default implementation that returns 'true' (continue 
	visiting). You need to only override methods that are interesting to you.

	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.

	You should never change the document from a callback.

	@sa TiXmlNode::Accept()
*/
class TiXmlVisitor
{
public:
	virtual ~TiXmlVisitor() {}

	/// Visit a document.
	virtual bool VisitEnter( const TiXmlDocument& /*doc*/ )			{ return true; }
	/// Visit a document.
	virtual bool VisitExit( const TiXmlDocument& /*doc*/ )			{ return true; }

	/// Visit an element.
	virtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )	{ return true; }
	/// Visit an element.
	virtual bool VisitExit( const TiXmlElement& /*element*/ )		{ return true; }

	/// Visit a declaration
	virtual bool Visit( const TiXmlDeclaration& /*declaration*/ )	{ return true; }
	/// Visit a text node
	virtual bool Visit( const TiXmlText& /*text*/ )					{ return true; }
	/// Visit a comment node
	virtual bool Visit( const TiXmlComment& /*comment*/ )			{ return true; }
	/// Visit an unknow node
	virtual bool Visit( const TiXmlUnknown& /*unknown*/ )			{ return true; }
};

// Only used by Attribute::Query functions
enum 
{ 
	TIXML_SUCCESS,
	TIXML_NO_ATTRIBUTE,
	TIXML_WRONG_TYPE
};


// Used by the parsing routines.
enum TiXmlEncoding
{
	TIXML_ENCODING_UNKNOWN,
	TIXML_ENCODING_UTF8,
	TIXML_ENCODING_LEGACY
};

const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;

/** TiXmlBase is a base class for every class in TinyXml.
	It does little except to establish that TinyXml classes
	can be printed and provide some utility functions.

	In XML, the document and elements can contain
	other elements and other types of nodes.

	@verbatim
	A Document can contain:	Element	(container or leaf)
							Comment (leaf)
							Unknown (leaf)
							Declaration( leaf )

	An Element can contain:	Element (container or leaf)
							Text	(leaf)
							Attributes (not on tree)
							Comment (leaf)
							Unknown (leaf)

	A Decleration contains: Attributes (not on tree)
	@endverbatim
*/
class TiXmlBase
{
	friend class TiXmlNode;
	friend class TiXmlElement;
	friend class TiXmlDocument;

public:
	TiXmlBase()	:	userData(0)		{}
	virtual ~TiXmlBase()			{}

	/**	All TinyXml classes can print themselves to a filestream
		or the string class (TiXmlString in non-STL mode, std::string
		in STL mode.) Either or both cfile and str can be null.
		
		This is a formatted print, and will insert 
		tabs and newlines.
		
		(For an unformatted stream, use the << operator.)
	*/
	virtual void Print( FILE* cfile, int depth ) const = 0;

	/**	The world does not agree on whether white space should be kept or
		not. In order to make everyone happy, these global, static functions
		are provided to set whether or not TinyXml will condense all white space
		into a single space or not. The default is to condense. Note changing this
		value is not thread safe.
	*/
	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }

	/// Return the current white space setting.
	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }

	/** Return the position, in the original source file, of this node or attribute.
		The row and column are 1-based. (That is the first row and first column is
		1,1). If the returns values are 0 or less, then the parser does not have
		a row and column value.

		Generally, the row and column value will be set when the TiXmlDocument::Load(),
		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
		when the DOM was created from operator>>.

		The values reflect the initial load. Once the DOM is modified programmatically
		(by adding or changing nodes and attributes) the new values will NOT update to
		reflect changes in the document.

		There is a minor performance cost to computing the row and column. Computation
		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.

		@sa TiXmlDocument::SetTabSize()
	*/
	int Row() const			{ return location.row + 1; }
	int Column() const		{ return location.col + 1; }	///< See Row()

	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.

	// Table that returs, for a given lead byte, the total number of bytes
	// in the UTF-8 sequence.
	static const int utf8ByteTable[256];

	virtual const char* Parse(	const char* p, 
								TiXmlParsingData* data, 
								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;

	/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, 
		or they will be transformed into entities!
	*/
	static void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );

	enum
	{
		TIXML_NO_ERROR = 0,
		TIXML_ERROR,
		TIXML_ERROR_OPENING_FILE,
		TIXML_ERROR_OUT_OF_MEMORY,
		TIXML_ERROR_PARSING_ELEMENT,
		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
		TIXML_ERROR_READING_ELEMENT_VALUE,
		TIXML_ERROR_READING_ATTRIBUTES,
		TIXML_ERROR_PARSING_EMPTY,
		TIXML_ERROR_READING_END_TAG,
		TIXML_ERROR_PARSING_UNKNOWN,
		TIXML_ERROR_PARSING_COMMENT,
		TIXML_ERROR_PARSING_DECLARATION,
		TIXML_ERROR_DOCUMENT_EMPTY,
		TIXML_ERROR_EMBEDDED_NULL,
		TIXML_ERROR_PARSING_CDATA,
		TIXML_ERROR_DOCUMENT_TOP_ONLY,

		TIXML_ERROR_STRING_COUNT
	};

protected:

	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );
	inline static bool IsWhiteSpace( char c )		
	{ 
		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 
	}
	inline static bool IsWhiteSpace( int c )
	{
		if ( c < 256 )
			return IsWhiteSpace( (char) c );
		return false;	// Again, only truly correct for English/Latin...but usually works.
	}

	#ifdef TIXML_USE_STL
	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
	#endif

	/*	Reads an XML name into the string provided. Returns
		a pointer just past the last character of the name,
		or 0 if the function has an error.
	*/
	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );

	/*	Reads text. Returns a pointer past the given end tag.
		Wickedly complex options, but it keeps the (sensitive) code in one place.
	*/
	static const char* ReadText(	const char* in,				// where to start
									TIXML_STRING* text,			// the string read
									bool ignoreWhiteSpace,		// whether to keep the white space
									const char* endTag,			// what ends this text
									bool ignoreCase,			// whether to ignore case in the end tag
									TiXmlEncoding encoding );	// the current encoding

	// If an entity has been found, transform it into a character.
	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );

	// Get a character, while interpreting entities.
	// The length can be from 0 to 4 bytes.
	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
	{
		assert( p );
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			*length = utf8ByteTable[ *((const unsigned char*)p) ];
			assert( *length >= 0 && *length < 5 );
		}
		else
		{
			*length = 1;
		}

		if ( *length == 1 )
		{
			if ( *p == '&' )
				return GetEntity( p, _value, length, encoding );
			*_value = *p;
			return p+1;
		}
		else if ( *length )
		{
			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
												// and the null terminator isn't needed
			for( int i=0; p[i] && i<*length; ++i ) {
				_value[i] = p[i];
			}
			return p + (*length);
		}
		else
		{
			// Not valid text.
			return 0;
		}
	}

	// Return true if the next characters in the stream are any of the endTag sequences.
	// Ignore case only works for english, and should only be relied on when comparing
	// to English words: StringEqual( p, "version", true ) is fine.
	static bool StringEqual(	const char* p,
								const char* endTag,
								bool ignoreCase,
								TiXmlEncoding encoding );

	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];

	TiXmlCursor location;

    /// Field containing a generic user pointer
	void*			userData;
	
	// None of these methods are reliable for any language except English.
	// Good for approximation, not great for accuracy.
	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
	inline static int ToLower( int v, TiXmlEncoding encoding )
	{
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			if ( v < 128 ) return tolower( v );
			return v;
		}
		else
		{
			return tolower( v );
		}
	}
	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );

private:
	TiXmlBase( const TiXmlBase& );				// not implemented.
	void operator=( const TiXmlBase& base );	// not allowed.

	struct Entity
	{
		const char*     str;
		unsigned int	strLength;
		char		    chr;
	};
	enum
	{
		NUM_ENTITY = 5,
		MAX_ENTITY_LENGTH = 6

	};
	static Entity entity[ NUM_ENTITY ];
	static bool condenseWhiteSpace;
};


/** The parent class for everything in the Document Object Model.
	(Except for attributes).
	Nodes have siblings, a parent, and children. A node can be
	in a document, or stand on its own. The type of a TiXmlNode
	can be queried, and it can be cast to its more defined type.
*/
class TiXmlNode : public TiXmlBase
{
	friend class TiXmlDocument;
	friend class TiXmlElement;

public:
	#ifdef TIXML_USE_STL	

	    /** An input stream operator, for every class. Tolerant of newlines and
		    formatting, but doesn't expect them.
	    */
	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);

	    /** An output stream operator, for every class. Note that this outputs
		    without any newlines or formatting, as opposed to Print(), which
		    includes tabs and new lines.

		    The operator<< and operator>> are not completely symmetric. Writing
		    a node to a stream is very well defined. You'll get a nice stream
		    of output, without any extra whitespace or newlines.
		    
		    But reading is not as well defined. (As it always is.) If you create
		    a TiXmlElement (for example) and read that from an input stream,
		    the text needs to define an element or junk will result. This is
		    true of all input streams, but it's worth keeping in mind.

		    A TiXmlDocument will read nodes until it reads a root element, and
			all the children of that root element.
	    */	
	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);

		/// Appends the XML node or attribute to a std::string.
		friend std::string& operator<< (std::string& out, const TiXmlNode& base );

	#endif

	/** The types of XML nodes supported by TinyXml. (All the
			unsupported types are picked up by UNKNOWN.)
	*/
	enum NodeType
	{
		DOCUMENT,
		ELEMENT,
		COMMENT,
		UNKNOWN,
		TEXT,
		DECLARATION,
		TYPECOUNT
	};

	virtual ~TiXmlNode();

	/** The meaning of 'value' changes for the specific type of
		TiXmlNode.
		@verbatim
		Document:	filename of the xml file
		Element:	name of the element
		Comment:	the comment text
		Unknown:	the tag contents
		Text:		the text string
		@endverbatim

		The subclasses will wrap this function.
	*/
	const char *Value() const { return value.c_str (); }

    #ifdef TIXML_USE_STL
	/** Return Value() as a std::string. If you only use STL,
	    this is more efficient than calling Value().
		Only available in STL mode.
	*/
	const std::string& ValueStr() const { return value; }
	#endif

	const TIXML_STRING& ValueTStr() const { return value; }

	/** Changes the value of the node. Defined as:
		@verbatim
		Document:	filename of the xml file
		Element:	name of the element
		Comment:	the comment text
		Unknown:	the tag contents
		Text:		the text string
		@endverbatim
	*/
	void SetValue(const char * _value) { value = _value;}

    #ifdef TIXML_USE_STL
	/// STL std::string form.
	void SetValue( const std::string& _value )	{ value = _value; }
	#endif

	/// Delete all the children of this node. Does not affect 'this'.
	void Clear();

	/// One step up the DOM.
	TiXmlNode* Parent()							{ return parent; }
	const TiXmlNode* Parent() const				{ return parent; }

	const TiXmlNode* FirstChild()	const		{ return firstChild; }	///< The first child of this node. Will be null if there are no children.
	TiXmlNode* FirstChild()						{ return firstChild; }
	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
	/// The first child of this node with the matching 'value'. Will be null if none found.
	TiXmlNode* FirstChild( const char * _value ) {
		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
		// call the method, cast the return back to non-const.
		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
	}
	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
	TiXmlNode* LastChild()	{ return lastChild; }
	
	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
	TiXmlNode* LastChild( const char * _value ) {
		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
	#endif

	/** An alternate way to walk the children of a node.
		One way to iterate over nodes is:
		@verbatim
			for( child = parent->FirstChild(); child; child = child->NextSibling() )
		@endverbatim

		IterateChildren does the same thing with the syntax:
		@verbatim
			child = 0;
			while( child = parent->IterateChildren( child ) )
		@endverbatim

		IterateChildren takes the previous child as input and finds
		the next one. If the previous child is null, it returns the
		first. IterateChildren will return null when done.
	*/
	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
	}

	/// This flavor of IterateChildren searches for children with a particular 'value'
	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
	#endif

	/** Add a new node related to this. Adds a child past the LastChild.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );


	/** Add a new node related to this. Adds a child past the LastChild.

		NOTE: the node to be added is passed by pointer, and will be
		henceforth owned (and deleted) by tinyXml. This method is efficient
		and avoids an extra copy, but should be used with care as it
		uses a different memory model than the other insert functions.

		@sa InsertEndChild
	*/
	TiXmlNode* LinkEndChild( TiXmlNode* addThis );

	/** Add a new node related to this. Adds a child before the specified child.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );

	/** Add a new node related to this. Adds a child after the specified child.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );

	/** Replace a child of this node.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );

	/// Delete a child of this node.
	bool RemoveChild( TiXmlNode* removeThis );

	/// Navigate to a sibling node.
	const TiXmlNode* PreviousSibling() const			{ return prev; }
	TiXmlNode* PreviousSibling()						{ return prev; }

	/// Navigate to a sibling node.
	const TiXmlNode* PreviousSibling( const char * ) const;
	TiXmlNode* PreviousSibling( const char *_prev ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
	#endif

	/// Navigate to a sibling node.
	const TiXmlNode* NextSibling() const				{ return next; }
	TiXmlNode* NextSibling()							{ return next; }

	/// Navigate to a sibling node with the given 'value'.
	const TiXmlNode* NextSibling( const char * ) const;
	TiXmlNode* NextSibling( const char* _next ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
	}

	/** Convenience function to get through elements.
		Calls NextSibling and ToElement. Will skip all non-Element
		nodes. Returns 0 if there is not another element.
	*/
	const TiXmlElement* NextSiblingElement() const;
	TiXmlElement* NextSiblingElement() {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
	}

	/** Convenience function to get through elements.
		Calls NextSibling and ToElement. Will skip all non-Element
		nodes. Returns 0 if there is not another element.
	*/
	const TiXmlElement* NextSiblingElement( const char * ) const;
	TiXmlElement* NextSiblingElement( const char *_next ) {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
	#endif

	/// Convenience function to get through elements.
	const TiXmlElement* FirstChildElement()	const;
	TiXmlElement* FirstChildElement() {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
	}

	/// Convenience function to get through elements.
	const TiXmlElement* FirstChildElement( const char * _value ) const;
	TiXmlElement* FirstChildElement( const char * _value ) {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
	#endif

	/** Query the type (as an enumerated value, above) of this node.
		The possible types are: DOCUMENT, ELEMENT, COMMENT,
								UNKNOWN, TEXT, and DECLARATION.
	*/
	int Type() const	{ return type; }

	/** Return a pointer to the Document this node lives in.
		Returns null if not in a document.
	*/
	const TiXmlDocument* GetDocument() const;
	TiXmlDocument* GetDocument() {
		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
	}

	/// Returns true if this node has no children.
	bool NoChildren() const						{ return !firstChild; }

	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	/** Create an exact duplicate of this node and return it. The memory must be deleted
		by the caller. 
	*/
	virtual TiXmlNode* Clone() const = 0;

	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
		XML tree will be conditionally visited and the host will be called back
		via the TiXmlVisitor interface.

		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
		interface versus any other.)

		The interface has been based on ideas from:

		- http://www.saxproject.org/
		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern 

		Which are both good references for "visiting".

		An example of using Accept():
		@verbatim
		TiXmlPrinter printer;
		tinyxmlDoc.Accept( &printer );
		const char* xmlcstr = printer.CStr();
		@endverbatim
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;

protected:
	TiXmlNode( NodeType _type );

	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
	// and the assignment operator.
	void CopyTo( TiXmlNode* target ) const;

	#ifdef TIXML_USE_STL
	    // The real work of the input operator.
	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
	#endif

	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );

	TiXmlNode*		parent;
	NodeType		type;

	TiXmlNode*		firstChild;
	TiXmlNode*		lastChild;

	TIXML_STRING	value;

	TiXmlNode*		prev;
	TiXmlNode*		next;

private:
	TiXmlNode( const TiXmlNode& );				// not implemented.
	void operator=( const TiXmlNode& base );	// not allowed.
};


/** An attribute is a name-value pair. Elements have an arbitrary
	number of attributes, each with a unique name.

	@note The attributes are not TiXmlNodes, since they are not
		  part of the tinyXML document object model. There are other
		  suggested ways to look at this problem.
*/
class TiXmlAttribute : public TiXmlBase
{
	friend class TiXmlAttributeSet;

public:
	/// Construct an empty attribute.
	TiXmlAttribute() : TiXmlBase()
	{
		document = 0;
		prev = next = 0;
	}

	#ifdef TIXML_USE_STL
	/// std::string constructor.
	TiXmlAttribute( const std::string& _name, const std::string& _value )
	{
		name = _name;
		value = _value;
		document = 0;
		prev = next = 0;
	}
	#endif

	/// Construct an attribute with a name and value.
	TiXmlAttribute( const char * _name, const char * _value )
	{
		name = _name;
		value = _value;
		document = 0;
		prev = next = 0;
	}

	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
	#ifdef TIXML_USE_STL
	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
	#endif
	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.

	// Get the tinyxml string representation
	const TIXML_STRING& NameTStr() const { return name; }

	/** QueryIntValue examines the value string. It is an alternative to the
		IntValue() method with richer error checking.
		If the value is an integer, it is stored in 'value' and 
		the call returns TIXML_SUCCESS. If it is not
		an integer, it returns TIXML_WRONG_TYPE.

		A specialized but useful call. Note that for success it returns 0,
		which is the opposite of almost all other TinyXml calls.
	*/
	int QueryIntValue( int* _value ) const;
	/// QueryDoubleValue examines the value string. See QueryIntValue().
	int QueryDoubleValue( double* _value ) const;

	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.

	void SetIntValue( int _value );										///< Set the value from an integer.
	void SetDoubleValue( double _value );								///< Set the value from a double.

    #ifdef TIXML_USE_STL
	/// STL std::string form.
	void SetName( const std::string& _name )	{ name = _name; }	
	/// STL std::string form.	
	void SetValue( const std::string& _value )	{ value = _value; }
	#endif

	/// Get the next sibling attribute in the DOM. Returns null at end.
	const TiXmlAttribute* Next() const;
	TiXmlAttribute* Next() {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() ); 
	}

	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
	const TiXmlAttribute* Previous() const;
	TiXmlAttribute* Previous() {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() ); 
	}

	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }

	/*	Attribute parsing starts: first letter of the name
						 returns: the next char after the value end quote
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	// Prints this Attribute to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const {
		Print( cfile, depth, 0 );
	}
	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;

	// [internal use]
	// Set the document pointer so the attribute can report errors.
	void SetDocument( TiXmlDocument* doc )	{ document = doc; }

private:
	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
	void operator=( const TiXmlAttribute& base );	// not allowed.

	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
	TIXML_STRING name;
	TIXML_STRING value;
	TiXmlAttribute*	prev;
	TiXmlAttribute*	next;
};


/*	A class used to manage a group of attributes.
	It is only used internally, both by the ELEMENT and the DECLARATION.
	
	The set can be changed transparent to the Element and Declaration
	classes that use it, but NOT transparent to the Attribute
	which has to implement a next() and previous() method. Which makes
	it a bit problematic and prevents the use of STL.

	This version is implemented with circular lists because:
		- I like circular lists
		- it demonstrates some independence from the (typical) doubly linked list.
*/
class TiXmlAttributeSet
{
public:
	TiXmlAttributeSet();
	~TiXmlAttributeSet();

	void Add( TiXmlAttribute* attribute );
	void Remove( TiXmlAttribute* attribute );

	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }

	const TiXmlAttribute*	Find( const char* _name ) const;
	TiXmlAttribute*	Find( const char* _name ) {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
	}
	#ifdef TIXML_USE_STL
	const TiXmlAttribute*	Find( const std::string& _name ) const;
	TiXmlAttribute*	Find( const std::string& _name ) {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
	}

	#endif

private:
	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)

	TiXmlAttribute sentinel;
};


/** The element is a container class. It has a value, the element name,
	and can contain other elements, text, comments, and unknowns.
	Elements also contain an arbitrary number of attributes.
*/
class TiXmlElement : public TiXmlNode
{
public:
	/// Construct an element.
	TiXmlElement (const char * in_value);

	#ifdef TIXML_USE_STL
	/// std::string constructor.
	TiXmlElement( const std::string& _value );
	#endif

	TiXmlElement( const TiXmlElement& );

	void operator=( const TiXmlElement& base );

	virtual ~TiXmlElement();

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
	*/
	const char* Attribute( const char* name ) const;

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
		If the attribute exists and can be converted to an integer,
		the integer value will be put in the return 'i', if 'i'
		is non-null.
	*/
	const char* Attribute( const char* name, int* i ) const;

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
		If the attribute exists and can be converted to an double,
		the double value will be put in the return 'd', if 'd'
		is non-null.
	*/
	const char* Attribute( const char* name, double* d ) const;

	/** QueryIntAttribute examines the attribute - it is an alternative to the
		Attribute() method with richer error checking.
		If the attribute is an integer, it is stored in 'value' and 
		the call returns TIXML_SUCCESS. If it is not
		an integer, it returns TIXML_WRONG_TYPE. If the attribute
		does not exist, then TIXML_NO_ATTRIBUTE is returned.
	*/	
	int QueryIntAttribute( const char* name, int* _value ) const;
	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
	int QueryDoubleAttribute( const char* name, double* _value ) const;
	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
	int QueryFloatAttribute( const char* name, float* _value ) const {
		double d;
		int result = QueryDoubleAttribute( name, &d );
		if ( result == TIXML_SUCCESS ) {
			*_value = (float)d;
		}
		return result;
	}

    #ifdef TIXML_USE_STL
	/** Template form of the attribute query which will try to read the
		attribute into the specified type. Very easy, very powerful, but
		be careful to make sure to call this with the correct type.
		
		NOTE: This method doesn't work correctly for 'string' types.

		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
	*/
	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
	{
		const TiXmlAttribute* node = attributeSet.Find( name );
		if ( !node )
			return TIXML_NO_ATTRIBUTE;

		std::stringstream sstream( node->ValueStr() );
		sstream >> *outValue;
		if ( !sstream.fail() )
			return TIXML_SUCCESS;
		return TIXML_WRONG_TYPE;
	}
	/*
	 This is - in theory - a bug fix for "QueryValueAtribute returns truncated std::string"
	 but template specialization is hard to get working cross-compiler. Leaving the bug for now.
	 
	// The above will fail for std::string because the space character is used as a seperator.
	// Specialize for strings. Bug [ 1695429 ] QueryValueAtribute returns truncated std::string
	template<> int QueryValueAttribute( const std::string& name, std::string* outValue ) const
	{
		const TiXmlAttribute* node = attributeSet.Find( name );
		if ( !node )
			return TIXML_NO_ATTRIBUTE;
		*outValue = node->ValueStr();
		return TIXML_SUCCESS;
	}
	*/
	#endif

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetAttribute( const char* name, const char * _value );

    #ifdef TIXML_USE_STL
	const std::string* Attribute( const std::string& name ) const;
	const std::string* Attribute( const std::string& name, int* i ) const;
	const std::string* Attribute( const std::string& name, double* d ) const;
	int QueryIntAttribute( const std::string& name, int* _value ) const;
	int QueryDoubleAttribute( const std::string& name, double* _value ) const;

	/// STL std::string form.
	void SetAttribute( const std::string& name, const std::string& _value );
	///< STL std::string form.
	void SetAttribute( const std::string& name, int _value );
	#endif

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetAttribute( const char * name, int value );

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetDoubleAttribute( const char * name, double value );

	/** Deletes an attribute with the given name.
	*/
	void RemoveAttribute( const char * name );
    #ifdef TIXML_USE_STL
	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
	#endif

	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }

	/** Convenience function for easy access to the text inside an element. Although easy
		and concise, GetText() is limited compared to getting the TiXmlText child
		and accessing it directly.
	
		If the first child of 'this' is a TiXmlText, the GetText()
		returns the character string of the Text node, else null is returned.

		This is a convenient method for getting the text of simple contained text:
		@verbatim
		<foo>This is text</foo>
		const char* str = fooElement->GetText();
		@endverbatim

		'str' will be a pointer to "This is text". 
		
		Note that this function can be misleading. If the element foo was created from
		this XML:
		@verbatim
		<foo><b>This is text</b></foo> 
		@endverbatim

		then the value of str would be null. The first child node isn't a text node, it is
		another element. From this XML:
		@verbatim
		<foo>This is <b>text</b></foo> 
		@endverbatim
		GetText() will return "This is ".

		WARNING: GetText() accesses a child node - don't become confused with the 
				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
				 safe type casts on the referenced node.
	*/
	const char* GetText() const;

	/// Creates a new Element and returns it - the returned element is a copy.
	virtual TiXmlNode* Clone() const;
	// Print the Element to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/*	Attribtue parsing starts: next char past '<'
						 returns: next char past '>'
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:

	void CopyTo( TiXmlElement* target ) const;
	void ClearThis();	// like clear, but initializes 'this' object as well

	// Used to be public [internal use]
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif
	/*	[internal use]
		Reads the "value" of the element -- another element, or text.
		This should terminate with the current end tag.
	*/
	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );

private:

	TiXmlAttributeSet attributeSet;
};


/**	An XML comment.
*/
class TiXmlComment : public TiXmlNode
{
public:
	/// Constructs an empty comment.
	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
	/// Construct a comment from text.
	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::COMMENT ) {
		SetValue( _value );
	}
	TiXmlComment( const TiXmlComment& );
	void operator=( const TiXmlComment& base );

	virtual ~TiXmlComment()	{}

	/// Returns a copy of this Comment.
	virtual TiXmlNode* Clone() const;
	// Write this Comment to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/*	Attribtue parsing starts: at the ! of the !--
						 returns: next char past '>'
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
	void CopyTo( TiXmlComment* target ) const;

	// used to be public
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif
//	virtual void StreamOut( TIXML_OSTREAM * out ) const;

private:

};


/** XML text. A text node can have 2 ways to output the next. "normal" output 
	and CDATA. It will default to the mode it was parsed from the XML file and
	you generally want to leave it alone, but you can change the output mode with 
	SetCDATA() and query it with CDATA().
*/
class TiXmlText : public TiXmlNode
{
	friend class TiXmlElement;
public:
	/** Constructor for text element. By default, it is treated as 
		normal, encoded text. If you want it be output as a CDATA text
		element, set the parameter _cdata to 'true'
	*/
	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TEXT)
	{
		SetValue( initValue );
		cdata = false;
	}
	virtual ~TiXmlText() {}

	#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
	{
		SetValue( initValue );
		cdata = false;
	}
	#endif

	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }

	// Write this text object to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/// Queries whether this represents text using a CDATA section.
	bool CDATA() const				{ return cdata; }
	/// Turns on or off a CDATA representation of text.
	void SetCDATA( bool _cdata )	{ cdata = _cdata; }

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected :
	///  [internal use] Creates a new Element and returns it.
	virtual TiXmlNode* Clone() const;
	void CopyTo( TiXmlText* target ) const;

	bool Blank() const;	// returns true if all white space and new lines
	// [internal use]
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:
	bool cdata;			// true if this should be input and output as a CDATA style text element
};


/** In correct XML the declaration is the first entry in the file.
	@verbatim
		<?xml version="1.0" standalone="yes"?>
	@endverbatim

	TinyXml will happily read or write files without a declaration,
	however. There are 3 possible attributes to the declaration:
	version, encoding, and standalone.

	Note: In this version of the code, the attributes are
	handled as special cases, not generic attributes, simply
	because there can only be at most 3 and they are always the same.
*/
class TiXmlDeclaration : public TiXmlNode
{
public:
	/// Construct an empty declaration.
	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}

#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlDeclaration(	const std::string& _version,
						const std::string& _encoding,
						const std::string& _standalone );
#endif

	/// Construct.
	TiXmlDeclaration(	const char* _version,
						const char* _encoding,
						const char* _standalone );

	TiXmlDeclaration( const TiXmlDeclaration& copy );
	void operator=( const TiXmlDeclaration& copy );

	virtual ~TiXmlDeclaration()	{}

	/// Version. Will return an empty string if none was found.
	const char *Version() const			{ return version.c_str (); }
	/// Encoding. Will return an empty string if none was found.
	const char *Encoding() const		{ return encoding.c_str (); }
	/// Is this a standalone document?
	const char *Standalone() const		{ return standalone.c_str (); }

	/// Creates a copy of this Declaration and returns it.
	virtual TiXmlNode* Clone() const;
	// Print this declaration to a FILE stream.
	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
	virtual void Print( FILE* cfile, int depth ) const {
		Print( cfile, depth, 0 );
	}

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
	void CopyTo( TiXmlDeclaration* target ) const;
	// used to be public
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:

	TIXML_STRING version;
	TIXML_STRING encoding;
	TIXML_STRING standalone;
};


/** Any tag that tinyXml doesn't recognize is saved as an
	unknown. It is a tag of text, but should not be modified.
	It will be written back to the XML, unchanged, when the file
	is saved.

	DTD tags get thrown into TiXmlUnknowns.
*/
class TiXmlUnknown : public TiXmlNode
{
public:
	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
	virtual ~TiXmlUnknown() {}

	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }

	/// Creates a copy of this Unknown and returns it.
	virtual TiXmlNode* Clone() const;
	// Print this Unknown to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected:
	void CopyTo( TiXmlUnknown* target ) const;

	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:

};


/** Always the top level node. A document binds together all the
	XML pieces. It can be saved, loaded, and printed to the screen.
	The 'value' of a document node is the xml file name.
*/
class TiXmlDocument : public TiXmlNode
{
public:
	/// Create an empty document, that has no name.
	TiXmlDocument();
	/// Create a document with a name. The name of the document is also the filename of the xml.
	TiXmlDocument( const char * documentName );

    // Altered header
    bool ReadFromMemory( const char* pBuf, size_t sz, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING);

	#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlDocument( const std::string& documentName );
	#endif

	TiXmlDocument( const TiXmlDocument& copy );
	void operator=( const TiXmlDocument& copy );

	virtual ~TiXmlDocument() {}

	/** Load a file using the current document value.
		Returns true if successful. Will delete any existing
		document data before loading.
	*/
	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the current document value. Returns true if successful.
	bool SaveFile() const;
	/// Load a file using the given filename. Returns true if successful.
	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the given filename. Returns true if successful.
	bool SaveFile( const char * filename ) const;
	/** Load a file using the given FILE*. Returns true if successful. Note that this method
		doesn't stream - the entire object pointed at by the FILE*
		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
		file location. Streaming may be added in the future.
	*/
	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the given FILE*. Returns true if successful.
	bool SaveFile( FILE* ) const;

	#ifdef TIXML_USE_STL
	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
	{
//		StringToBuffer f( filename );
//		return ( f.buffer && LoadFile( f.buffer, encoding ));
		return LoadFile( filename.c_str(), encoding );
	}
	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
	{
//		StringToBuffer f( filename );
//		return ( f.buffer && SaveFile( f.buffer ));
		return SaveFile( filename.c_str() );
	}
	#endif

	/** Parse the given null terminated block of xml data. Passing in an encoding to this
		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
		to use that encoding, regardless of what TinyXml might otherwise try to detect.
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

	/** Get the root element -- the only top level element -- of the document.
		In well formed XML, there should only be one. TinyXml is tolerant of
		multiple elements at the document level.
	*/
	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
	TiXmlElement* RootElement()					{ return FirstChildElement(); }

	/** If an error occurs, Error will be set to true. Also,
		- The ErrorId() will contain the integer identifier of the error (not generally useful)
		- The ErrorDesc() method will return the name of the error. (very useful)
		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
	*/	
	bool Error() const						{ return error; }

	/// Contains a textual (english) description of the error if one occurs.
	const char * ErrorDesc() const	{ return errorDesc.c_str (); }

	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
		prefer the ErrorId, this function will fetch it.
	*/
	int ErrorId()	const				{ return errorId; }

	/** Returns the location (if known) of the error. The first column is column 1, 
		and the first row is row 1. A value of 0 means the row and column wasn't applicable
		(memory errors, for example, have no row/column) or the parser lost the error. (An
		error in the error reporting, in that case.)

		@sa SetTabSize, Row, Column
	*/
	int ErrorRow() const	{ return errorLocation.row+1; }
	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()

	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
		to report the correct values for row and column. It does not change the output
		or input in any way.
		
		By calling this method, with a tab size
		greater than 0, the row and column of each node and attribute is stored
		when the file is loaded. Very useful for tracking the DOM back in to
		the source file.

		The tab size is required for calculating the location of nodes. If not
		set, the default of 4 is used. The tabsize is set per document. Setting
		the tabsize to 0 disables row/column tracking.

		Note that row and column tracking is not supported when using operator>>.

		The tab size needs to be enabled before the parse or load. Correct usage:
		@verbatim
		TiXmlDocument doc;
		doc.SetTabSize( 8 );
		doc.Load( "myfile.xml" );
		@endverbatim

		@sa Row, Column
	*/
	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }

	int TabSize() const	{ return tabsize; }

	/** If you have handled the error, it can be reset with this call. The error
		state is automatically cleared if you Parse a new XML block.
	*/
	void ClearError()						{	error = false; 
												errorId = 0; 
												errorDesc = ""; 
												errorLocation.row = errorLocation.col = 0; 
												//errorLocation.last = 0; 
											}

	/** Write the document to standard out using formatted printing ("pretty print"). */
	void Print() const						{ Print( stdout, 0 ); }

	/* Write the document to a string using formatted printing ("pretty print"). This
		will allocate a character array (new char[]) and return it as a pointer. The
		calling code pust call delete[] on the return char* to avoid a memory leak.
	*/
	//char* PrintToMemory() const; 

	/// Print this Document to a FILE stream.
	virtual void Print( FILE* cfile, int depth = 0 ) const;
	// [internal use]
	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );

	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected :
	// [internal use]
	virtual TiXmlNode* Clone() const;
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:
	void CopyTo( TiXmlDocument* target ) const;

	bool error;
	int  errorId;
	TIXML_STRING errorDesc;
	int tabsize;
	TiXmlCursor errorLocation;
	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
};


/**
	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
	DOM structure. It is a separate utility class.

	Take an example:
	@verbatim
	<Document>
		<Element attributeA = "valueA">
			<Child attributeB = "value1" />
			<Child attributeB = "value2" />
		</Element>
	<Document>
	@endverbatim

	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
	easy to write a *lot* of code that looks like:

	@verbatim
	TiXmlElement* root = document.FirstChildElement( "Document" );
	if ( root )
	{
		TiXmlElement* element = root->FirstChildElement( "Element" );
		if ( element )
		{
			TiXmlElement* child = element->FirstChildElement( "Child" );
			if ( child )
			{
				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
				if ( child2 )
				{
					// Finally do something useful.
	@endverbatim

	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe 
	and correct to use:

	@verbatim
	TiXmlHandle docHandle( &document );
	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
	if ( child2 )
	{
		// do something useful
	@endverbatim

	Which is MUCH more concise and useful.

	It is also safe to copy handles - internally they are nothing more than node pointers.
	@verbatim
	TiXmlHandle handleCopy = handle;
	@endverbatim

	What they should not be used for is iteration:

	@verbatim
	int i=0; 
	while ( true )
	{
		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
		if ( !child )
			break;
		// do something
		++i;
	}
	@endverbatim

	It seems reasonable, but it is in fact two embedded while loops. The Child method is 
	a linear walk to find the element, so this code would iterate much more than it needs 
	to. Instead, prefer:

	@verbatim
	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();

	for( child; child; child=child->NextSiblingElement() )
	{
		// do something
	}
	@endverbatim
*/
class TiXmlHandle
{
public:
	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
	/// Copy constructor
	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }

	/// Return a handle to the first child node.
	TiXmlHandle FirstChild() const;
	/// Return a handle to the first child node with the given name.
	TiXmlHandle FirstChild( const char * value ) const;
	/// Return a handle to the first child element.
	TiXmlHandle FirstChildElement() const;
	/// Return a handle to the first child element with the given name.
	TiXmlHandle FirstChildElement( const char * value ) const;

	/** Return a handle to the "index" child with the given name. 
		The first child is 0, the second 1, etc.
	*/
	TiXmlHandle Child( const char* value, int index ) const;
	/** Return a handle to the "index" child. 
		The first child is 0, the second 1, etc.
	*/
	TiXmlHandle Child( int index ) const;
	/** Return a handle to the "index" child element with the given name. 
		The first child element is 0, the second 1, etc. Note that only TiXmlElements
		are indexed: other types are not counted.
	*/
	TiXmlHandle ChildElement( const char* value, int index ) const;
	/** Return a handle to the "index" child element. 
		The first child element is 0, the second 1, etc. Note that only TiXmlElements
		are indexed: other types are not counted.
	*/
	TiXmlHandle ChildElement( int index ) const;

	#ifdef TIXML_USE_STL
	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }

	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
	#endif

	/** Return the handle as a TiXmlNode. This may return null.
	*/
	TiXmlNode* ToNode() const			{ return node; } 
	/** Return the handle as a TiXmlElement. This may return null.
	*/
	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
	/**	Return the handle as a TiXmlText. This may return null.
	*/
	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
	/** Return the handle as a TiXmlUnknown. This may return null.
	*/
	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }

	/** @deprecated use ToNode. 
		Return the handle as a TiXmlNode. This may return null.
	*/
	TiXmlNode* Node() const			{ return ToNode(); } 
	/** @deprecated use ToElement. 
		Return the handle as a TiXmlElement. This may return null.
	*/
	TiXmlElement* Element() const	{ return ToElement(); }
	/**	@deprecated use ToText()
		Return the handle as a TiXmlText. This may return null.
	*/
	TiXmlText* Text() const			{ return ToText(); }
	/** @deprecated use ToUnknown()
		Return the handle as a TiXmlUnknown. This may return null.
	*/
	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }

private:
	TiXmlNode* node;
};


/** Print to memory functionality. The TiXmlPrinter is useful when you need to:

	-# Print to memory (especially in non-STL mode)
	-# Control formatting (line endings, etc.)

	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
	Before calling Accept() you can call methods to control the printing
	of the XML document. After TiXmlNode::Accept() is called, the printed document can
	be accessed via the CStr(), Str(), and Size() methods.

	TiXmlPrinter uses the Visitor API.
	@verbatim
	TiXmlPrinter printer;
	printer.SetIndent( "\t" );

	doc.Accept( &printer );
	fprintf( stdout, "%s", printer.CStr() );
	@endverbatim
*/
class TiXmlPrinter : public TiXmlVisitor
{
public:
	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
					 buffer(), indent( "    " ), lineBreak( "\n" ) {}

	virtual bool VisitEnter( const TiXmlDocument& doc );
	virtual bool VisitExit( const TiXmlDocument& doc );

	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
	virtual bool VisitExit( const TiXmlElement& element );

	virtual bool Visit( const TiXmlDeclaration& declaration );
	virtual bool Visit( const TiXmlText& text );
	virtual bool Visit( const TiXmlComment& comment );
	virtual bool Visit( const TiXmlUnknown& unknown );

	/** Set the indent characters for printing. By default 4 spaces
		but tab (\t) is also useful, or null/empty string for no indentation.
	*/
	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
	/// Query the indention string.
	const char* Indent()							{ return indent.c_str(); }
	/** Set the line breaking string. By default set to newline (\n). 
		Some operating systems prefer other characters, or can be
		set to the null/empty string for no indenation.
	*/
	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
	/// Query the current line breaking string.
	const char* LineBreak()							{ return lineBreak.c_str(); }

	/** Switch over to "stream printing" which is the most dense formatting without 
		linebreaks. Common when the XML is needed for network transmission.
	*/
	void SetStreamPrinting()						{ indent = "";
													  lineBreak = "";
													}	
	/// Return the result.
	const char* CStr()								{ return buffer.c_str(); }
	/// Return the length of the result string.
	size_t Size()									{ return buffer.size(); }

	#ifdef TIXML_USE_STL
	/// Return the result.
	const std::string& Str()						{ return buffer; }
	#endif

private:
	void DoIndent()	{
		for( int i=0; i<depth; ++i )
			buffer += indent;
	}
	void DoLineBreak() {
		buffer += lineBreak;
	}

	int depth;
	bool simpleTextPrint;
	TIXML_STRING buffer;
	TIXML_STRING indent;
	TIXML_STRING lineBreak;
};


#ifdef _MSC_VER
#pragma warning( pop )
#endif

#endif


#line 0 "../addons/ofxXmlSettings/src/ofxXmlSettings.h"
#pragma once

/* #include "ofMain.h" */
#include <string.h>
#if (_MSC_VER)
/* #include "../libs/tinyxml.h" */
#else
/* #include "tinyxml.h" */
#endif

using namespace std;

/*
	Q: what is the which = 0 argument?

	A: Glad you asked - most of the time you can ignore this and treat it as if it weren't there
	   But if specified it selects the nth tag with the same tag name at the current root of the document
	   Normally this just means the top level tags in the document - but if you use the pushTag and popTag
	   you can temporarily set the root of the document to be that specified tag.
	   The main idea is to allow you to have multiple tags with the same name.

	   So here is an example without pushTag

	   <time>102229</time>  <-- which = 0
	   <time>298292</time>  <-- which = 1
	   <time>393393</time>  <-- which = 2
	   <time>447373</time>  <-- which = 3

		But if we wanted to group these into multiple <recording> tags and have multiple time values inside
		we can use push and pop to move into the recording tags as if they were the document root

	   <recording> <-- we temporarily push into here with pushTag("recording", 0);
			<time>19222</time>  <-- to set this we call setValue("time", 19222, 0);   ( which = 0 )
			<time>23232</time>  <-- to set this we call setValue("time", 23232, 1);   ( which = 1 )
	   </recording> <-- we pop back out here with popTag();

		<recording>  <-- we temporarily push into here with pushTag("recording", 1); <-- now we use 1 to select the 2nd recording tag
			<time>33342</time>  <-- setValue("time", 33342, 0);   ( which = 0 )
			<time>22722</time>  <-- setValue("time", 22722, 0);   ( which = 1 )
	   </recording>

*/


#define MAX_TAG_VALUE_LENGTH_IN_CHARS		1024

class ofxXmlSettings{

	public:
        ofxXmlSettings();
        ofxXmlSettings(const string& xmlFile);

        ~ofxXmlSettings();

		void setVerbose(bool _verbose);

		bool loadFile(const string& xmlFile);
		bool saveFile(const string& xmlFile);
		bool saveFile();

		bool load(const string & path);
		bool save(const string & path);

		void clearTagContents(const string& tag, int which = 0);
		void removeTag(const string& tag, int which = 0);

		bool tagExists(const string& tag, int which = 0) const;

		// removes all tags from within either the whole document
		// or the tag you are currently at using pushTag
		void	clear();

		int 	getValue(const string&  tag, int            defaultValue, int which = 0) const;
		double 	getValue(const string&  tag, double         defaultValue, int which = 0) const;
		string 	getValue(const string&  tag, const string& 	defaultValue, int which = 0) const;

		int 	setValue(const string&  tag, int            value, int which = 0);
		int 	setValue(const string&  tag, double         value, int which = 0);
		int 	setValue(const string&  tag, const string& 	value, int which = 0);

		//advanced

		//-- pushTag/popTag
		//pushing a tag moves you inside it which has the effect of
		//temporarily treating the tag you are in as the document root
		//all setValue, readValue and getValue commands are then be relative to the tag you pushed.
		//this can be used with addValue to create multiple tags of the same name within
		//the pushed tag - normally addValue only lets you create multiple tags of the same
		//at the top most level.

		bool	pushTag(const string&  tag, int which = 0);
		int		popTag();
		int		getPushLevel();

		//-- numTags
		//this only works for tags at the current root level
		//use pushTag and popTag to get number of tags whithin other tags
		// both getNumTags("PT"); and getNumTags("PT:X"); will just return the
		//number of <PT> tags at the current root level.
		int		getNumTags(const string& tag) const;

		//-- addValue/addTag
		//adds a tag to the document even if a tag with the same name
		//already exists - returns an index which can then be used to
		//modify the tag by passing it as the last argument to setValue

		//-- important - this only works for top level tags
		//   to put multiple tags inside other tags - use pushTag() and popTag()

		int 	addValue(const string&  tag, int            value);
		int 	addValue(const string&  tag, double         value);
		int 	addValue(const string&  tag, const string& 	value);

		int		addTag(const string& tag); //adds an empty tag at the current level

        // Attribute-related methods
		int		addAttribute(const string& tag, const string& attribute, int value, int which = 0);
		int		addAttribute(const string& tag, const string& attribute, double value, int which = 0);
		int		addAttribute(const string& tag, const string& attribute, const string& value, int which = 0);

		int		addAttribute(const string& tag, const string& attribute, int value);
		int		addAttribute(const string& tag, const string& attribute, double value);
		int		addAttribute(const string& tag, const string& attribute, const string& value);

		void	removeAttribute(const string& tag, const string& attribute, int which = 0);
		void	clearTagAttributes(const string& tag, int which = 0);

		int		getNumAttributes(const string& tag, int which = 0) const;

		bool	attributeExists(const string& tag, const string& attribute, int which = 0) const;

		bool    getAttributeNames(const string& tag, vector<string>& outNames, int which = 0) const;

		int		getAttribute(const string& tag, const string& attribute, int defaultValue, int which = 0) const;
		double	getAttribute(const string& tag, const string& attribute, double defaultValue, int which = 0) const;
		string	getAttribute(const string& tag, const string& attribute, const string& defaultValue, int which = 0) const;

		int		setAttribute(const string& tag, const string& attribute, int value, int which = 0);
		int		setAttribute(const string& tag, const string& attribute, double value, int which = 0);
		int		setAttribute(const string& tag, const string& attribute, const string& value, int which = 0);

		int		setAttribute(const string& tag, const string& attribute, int value);
		int		setAttribute(const string& tag, const string& attribute, double value);
		int		setAttribute(const string& tag, const string& attribute, const string& value);

		bool	loadFromBuffer( string buffer );
		void	copyXmlToString(string & str) const;

		TiXmlDocument 	doc;
		bool 			bDocLoaded;

	protected:

		TiXmlHandle     storedHandle;
		int             level;


		int 	writeTag(const string&  tag, const string& valueString, int which = 0);
		bool 	readTag(const string&  tag, TiXmlHandle& valHandle, int which = 0) const;	// max 1024 chars...


		int		writeAttribute(const string& tag, const string& attribute, const string& valueString, int which = 0);

		TiXmlElement* getElementForAttribute(const string& tag, int which) const;
		bool readIntAttribute(const string& tag, const string& attribute, int& valueString, int which) const;
		bool readDoubleAttribute(const string& tag, const string& attribute, double& outValue, int which) const;
		bool readStringAttribute(const string& tag, const string& attribute, string& outValue, int which) const;
};   

void ofSerialize(ofxXmlSettings & settings, const ofAbstractParameter & parameter);
void ofDeserialize(const ofxXmlSettings & settings, ofAbstractParameter & parameter);

#line 0 "../addons/ofxSvg/src/ofxSvg.h"
#pragma once

///* #include "ofMain.h" */
/* #include "ofPath.h" */
/* #include "ofTypes.h" */

class ofxSVG {
	public: ~ofxSVG();


		float getWidth() const {
			return width;
		}
		float getHeight() const {
			return height;
		}
		void load(std::string path);
		void draw();

		int getNumPath(){
			return paths.size();
		}
		ofPath & getPathAt(int n){
			return paths[n];
		}

		const std::vector <ofPath> & getPaths() const;

	private:

		float width, height;

		std::vector <ofPath> paths;

		void setupDiagram(struct svgtiny_diagram * diagram);
		void setupShape(struct svgtiny_shape * shape, ofPath & path);

};

#line 0 "../addons/ofxGui/src/ofxBaseGui.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofParameter.h" */
/* #include "ofTrueTypeFont.h" */
/* #include "ofBitmapFont.h" */

class ofxBaseGui {
	public:
		ofxBaseGui();

		virtual ~ofxBaseGui();
		void draw();

		void saveToFile(const std::string& filename);
		void loadFromFile(const std::string& filename);

		template<class T>
		void saveTo(T & serializer){
			ofSerialize(serializer, getParameter());
		}

		template<class T>
		void loadFrom(T & serializer){
			ofDeserialize(serializer, getParameter());
		}

		std::string getName();
		void setName(const std::string& name);

		virtual void setPosition(const ofPoint & p);
		virtual void setPosition(float x, float y);
		virtual void setSize(float w, float h);
		virtual void setShape(ofRectangle r);
		virtual void setShape(float x, float y, float w, float h);

		ofPoint getPosition() const;
		ofRectangle getShape() const;
		float getWidth() const;
		float getHeight() const;

		ofColor getHeaderBackgroundColor() const;
		ofColor getBackgroundColor() const;
		ofColor getBorderColor() const;
		ofColor getTextColor() const;
		ofColor getFillColor() const;

		void setHeaderBackgroundColor(const ofColor & color);
		void setBackgroundColor(const ofColor & color);
		void setBorderColor(const ofColor & color);
		void setTextColor(const ofColor & color);
		void setFillColor(const ofColor & color);

		static void setDefaultHeaderBackgroundColor(const ofColor & color);
		static void setDefaultBackgroundColor(const ofColor & color);
		static void setDefaultBorderColor(const ofColor & color);
		static void setDefaultTextColor(const ofColor & color);
		static void setDefaultFillColor(const ofColor & color);

		static void setDefaultTextPadding(int padding);
		static void setDefaultWidth(int width);
		static void setDefaultHeight(int height);

		static void setDefaultEventsPriority(ofEventOrder eventsPriority);

		static void loadFont(const std::string& filename, int fontsize, bool _bAntiAliased = true, bool _bFullCharacterSet = false, int dpi = 0);
		static void loadFont(const ofTrueTypeFontSettings & fontSettings);
		static void setUseTTF(bool bUseTTF);

		void registerMouseEvents();
		void unregisterMouseEvents();

		virtual void sizeChangedCB();
		virtual void setParent(ofxBaseGui * parent);
		ofxBaseGui * getParent();

		virtual ofAbstractParameter & getParameter() = 0;
		virtual bool mouseMoved(ofMouseEventArgs & args) = 0;
		virtual bool mousePressed(ofMouseEventArgs & args) = 0;
		virtual bool mouseDragged(ofMouseEventArgs & args) = 0;
		virtual bool mouseReleased(ofMouseEventArgs & args) = 0;
		virtual bool mouseScrolled(ofMouseEventArgs & args) = 0;
		virtual void mouseEntered(ofMouseEventArgs &){
		}
		virtual void mouseExited(ofMouseEventArgs &){
		}

	protected:
		virtual void render() = 0;
		virtual bool setValue(float mx, float my, bool bCheckBounds) = 0;
		virtual void generateDraw() = 0;

		bool isGuiDrawing();
		void bindFontTexture();
		void unbindFontTexture();
		ofMesh getTextMesh(const std::string & text, float x, float y);
		ofRectangle getTextBoundingBox(const std::string & text, float x, float y);

		ofxBaseGui * parent;

		ofRectangle b;
		static ofTrueTypeFont font;
		static bool fontLoaded;
		static bool useTTF;
		static ofBitmapFont bitmapFont;

		static ofColor headerBackgroundColor;
		static ofColor backgroundColor;
		static ofColor borderColor;
		static ofColor textColor;
		static ofColor fillColor;

		ofColor thisHeaderBackgroundColor;
		ofColor thisBackgroundColor;
		ofColor thisBorderColor;
		ofColor thisTextColor;
		ofColor thisFillColor;

		static int textPadding;
		static int defaultWidth;
		static int defaultHeight;
		static ofEventOrder defaultEventsPriority;

		static std::string saveStencilToHex(const ofImage & img);
		static void loadStencilFromHex(ofImage & img, unsigned char * data);

		void setNeedsRedraw();

	private:
		bool needsRedraw;
		unsigned long currentFrame;
		bool bRegisteredForMouseEvents;
		//std::vector<ofEventListener> coreListeners;
};

#line 0 "../addons/ofxGui/src/ofxToggle.h"
#pragma once

/* #include "ofParameter.h" */
/* #include "ofxBaseGui.h" */

class ofxToggle : public ofxBaseGui{
public:
	ofxToggle(){};
	~ofxToggle();
	ofxToggle(ofParameter<bool> _bVal, float width = defaultWidth, float height = defaultHeight);
	ofxToggle * setup(ofParameter<bool> _bVal, float width = defaultWidth, float height = defaultHeight);
	ofxToggle * setup(const std::string& toggleName, bool _bVal, float width = defaultWidth, float height = defaultHeight);
	

	virtual bool mouseMoved(ofMouseEventArgs & args);
	virtual bool mousePressed(ofMouseEventArgs & args);
	virtual bool mouseDragged(ofMouseEventArgs & args);
	virtual bool mouseReleased(ofMouseEventArgs & args);
	virtual bool mouseScrolled(ofMouseEventArgs & args){return false;}
	

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		value.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		value.removeListener(listener,method);
	}



	bool operator=(bool v);
	operator const bool & ();

	virtual ofAbstractParameter & getParameter();

protected:
	virtual void render();
	ofRectangle checkboxRect;
	ofParameter<bool> value;
	bool bGuiActive;
	
	bool setValue(float mx, float my, bool bCheck);
	void generateDraw();
	void valueChanged(bool & value);
	ofPath bg,fg,cross;
	ofVboMesh textMesh;
};

#line 0 "../addons/ofxGui/src/ofxButton.h"
#pragma once

/* #include "ofxToggle.h" */
/* #include "ofParameter.h" */

class ofxButton : public ofxToggle{
	friend class ofPanel;
	
public:
	ofxButton();
	ofxButton(ofParameter<void> _bVal, float width = defaultWidth, float height = defaultHeight);
	~ofxButton();
	ofxButton* setup(ofParameter<void> _bVal, float width = defaultWidth, float height = defaultHeight);
    ofxButton* setup(const std::string& toggleName, float width = defaultWidth, float height = defaultHeight);

	virtual bool mouseReleased(ofMouseEventArgs & args);
	virtual bool mouseMoved(ofMouseEventArgs & args);
	virtual bool mousePressed(ofMouseEventArgs & args);
	virtual bool mouseDragged(ofMouseEventArgs & args);

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		parameter.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		parameter.removeListener(listener,method);
	}
	virtual ofAbstractParameter & getParameter();

private:
	ofParameter<void> parameter;
	void valueChanged(bool & v);

};

#line 0 "../addons/ofxGui/src/ofxLabel.h"
#pragma once

/* #include "ofxBaseGui.h" */
/* #include "ofParameter.h" */

class ofxLabel: public ofxBaseGui {
public:
	ofxLabel(){label.setSerializable(false);}
    ofxLabel(ofParameter<std::string> _label, float width = defaultWidth, float height = defaultHeight);

	template<typename F>
	ofxLabel(ofReadOnlyParameter<std::string,F> _label, float width = defaultWidth, float height = defaultHeight){
		setup(_label, width, height);
	}

    virtual ~ofxLabel();

    ofxLabel * setup(ofParameter<std::string> _label, float width = defaultWidth, float height = defaultHeight);

	template<typename F>
	ofxLabel* setup(ofReadOnlyParameter<std::string,F> _label, float width, float height) {
		label.makeReferenceTo(_label);
		b.width  = width;
		b.height = height;
		setNeedsRedraw();
		_label.addListener(this,&ofxLabel::valueChanged);
		return this;
	}
    ofxLabel * setup(const std::string& labelName, std::string label, float width = defaultWidth, float height = defaultHeight);

    // Abstract methods we must implement, but have no need for!
    virtual bool mouseMoved(ofMouseEventArgs & args){return false;}
    virtual bool mousePressed(ofMouseEventArgs & args){return false;}
    virtual bool mouseDragged(ofMouseEventArgs & args){return false;}
    virtual bool mouseReleased(ofMouseEventArgs & args){return false;}
    virtual bool mouseScrolled(ofMouseEventArgs & args){return false;}

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		label.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		label.removeListener(listener,method);
	}


	std::string operator=(std::string v) { label = v; return v; }
    operator const std::string & ()       { return label; }

    ofAbstractParameter & getParameter();

protected:
    void render();
	ofReadOnlyParameter<std::string, ofxLabel> label;
    void generateDraw();
    void valueChanged(std::string & value);
    bool setValue(float mx, float my, bool bCheckBounds){return false;}
    ofPath bg;
    ofVboMesh textMesh;
};

#line 0 "../addons/ofxGui/src/ofxInputField.h"
//
//  ofxInputField.cpp
//  ofxInputField
//
//  Based on ofxInputField by Felix Lange
//
//

#pragma once

/* #include "ofxBaseGui.h" */

template<typename Type>
class ofxInputField : public ofxBaseGui{
	template<typename T>
	friend class ofxSlider;

	
public:	
	ofxInputField();
	ofxInputField(ofParameter<Type> _val, float width = defaultWidth, float height = defaultHeight);
	ofxInputField* setup(ofParameter<Type> _val, float width = defaultWidth, float height = defaultHeight);
	ofxInputField* setup(const std::string& _name, Type _val, Type _min, Type _max, float width = defaultWidth, float height = defaultHeight);
	ofxInputField* setup(const std::string& _name, Type _val);
	
	void setMin(Type min);
	Type getMin();
	void setMax(Type max);
	Type getMax();

	void setBlinkingCursor(bool blink);
	void setShowLabelWhileEditing(bool show);

	virtual bool mouseMoved(ofMouseEventArgs & args);
	virtual bool mousePressed(ofMouseEventArgs & args);
	virtual bool mouseDragged(ofMouseEventArgs & args);
	virtual bool mouseReleased(ofMouseEventArgs & args);
	virtual bool mouseScrolled(ofMouseEventArgs & args);
	virtual bool keyPressed(ofKeyEventArgs & args);
	virtual bool charPressed(uint32_t & key);

	bool containsValidValue() const;

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		value.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		value.removeListener(listener,method);
	}

	Type operator=(Type v);
	operator const Type & ();

	ofAbstractParameter & getParameter();

protected:
	enum Inside{
		InsideSlider,
	};
	void ofxSlider(Inside){
		insideSlider = true;
	}
	virtual void render();
	ofParameter<Type> value;
	bool bGuiActive=false, bMousePressed=false, bMouseOver=false;
	bool setValue(float mx, float my, bool bCheck);
	void generateDraw();
	void valueChanged(Type & value);
	ofVboMesh bg;
	ofVboMesh textMesh;

	std::string input;        // input text
	std::string visibleInput; // input text currently visible, i.e. not obscured by gui
	int visibleInputStart = 0, visibleInputEnd = 0; // boundaries for visible input text

	void parseInput();
	int insertKeystroke(uint32_t character);
	int insertAlphabetic(uint32_t character);

	bool hasSelectedText();

	int mousePressedPos = -1; //set by mouse interaction
	float selectStartX = -1, selectionWidth = 0; //calculated from select indices
	int selectStartPos = -1, selectEndPos = -1;
	void calculateSelectionArea(int selectIdx1, int selectIdx2);
	void moveCursor(int cursorPos);

	virtual void drawCursor();

	bool insideSlider = false;
	bool blinkingCursor = true;
	bool validValue = true;
	bool showLabelWhileEditing = false;
	bool overlappingLabel = false;
	uint64_t errorTime = 0;  // time last input error occured, used for animations
	uint64_t lastCursorMoveTime = 0; // last time cursor was moved, used to calculate whether to blink

	void leaveFocus();

	std::vector<ofFloatColor> originalColors;

	ofEvent<void> leftFocus;
	ofEventListeners listeners;
};

typedef ofxInputField<float> ofxFloatField;
typedef ofxInputField<int> ofxIntField;
typedef ofxInputField<std::string> ofxTextField;

#line 0 "../addons/ofxGui/src/ofxSlider.h"
#pragma once

/* #include "ofxBaseGui.h" */
/* #include "ofParameter.h" */
/* #include "ofxInputField.h" */

template<typename Type>
class ofxSlider : public ofxBaseGui{
	friend class ofPanel;
	
public:	
	ofxSlider();
	~ofxSlider();
	ofxSlider(ofParameter<Type> _val, float width = defaultWidth, float height = defaultHeight);
	ofxSlider* setup(ofParameter<Type> _val, float width = defaultWidth, float height = defaultHeight);
	ofxSlider* setup(const std::string& sliderName, Type _val, Type _min, Type _max, float width = defaultWidth, float height = defaultHeight);
	
	void setMin(Type min);
	Type getMin();
	void setMax(Type max);
	Type getMax();

	virtual bool mouseMoved(ofMouseEventArgs & args);
	virtual bool mousePressed(ofMouseEventArgs & args);
	virtual bool mouseDragged(ofMouseEventArgs & args);
	virtual bool mouseReleased(ofMouseEventArgs & args);
    virtual bool mouseScrolled(ofMouseEventArgs & args);

	void setUpdateOnReleaseOnly(bool bUpdateOnReleaseOnly);


	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		value.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		value.removeListener(listener,method);
	}



	double operator=(Type v);
	operator const Type & ();


	virtual void setPosition(const ofPoint & p);
	virtual void setPosition(float x, float y);
	virtual void setSize(float w, float h);
	virtual void setShape(ofRectangle r);
	virtual void setShape(float x, float y, float w, float h);
	

	ofAbstractParameter & getParameter();

protected:
	virtual void render();
	ofParameter<Type> value;
	bool bUpdateOnReleaseOnly;
	bool bGuiActive;
	bool mouseInside;
	bool overlappingLabel;
	bool setValue(float mx, float my, bool bCheck);
	virtual void generateDraw();
	virtual void generateText();
	void valueChanged(Type & value);
	ofPath bg, bar;
	ofVboMesh textMesh;
	ofxInputField<Type> input{ofxInputField<Type>::InsideSlider};

	enum State{
		Slider,
		Input,
	} state = Slider;
	ofEventListener listener;
	float errorTime = 0;
};

typedef ofxSlider<float> ofxFloatSlider;
typedef ofxSlider<int> ofxIntSlider;

#line 0 "../addons/ofxGui/src/ofxColorPicker.h"
//
//  ofxColorPicker.h
//  ofxColorPicker
//
//  Based on ofxColorPicker by Lukasz Karluk on 13/08/2015.
//
//

#pragma once

/* #include "ofColor.h" */
/* #include "ofEvents.h" */
/* #include "ofxBaseGui.h" */
/* #include "ofxSlider.h" */



template<typename ColorType>
class ofxColorPicker_: public ofxBaseGui {

public :
	
	ofxColorPicker_();
	ofxColorPicker_(ofParameter<ofColor_<ColorType>> parameter, float w = defaultWidth, float h = defaultWidth / 9. * 16.);
	ofxColorPicker_ * setup(ofParameter<ofColor_<ColorType>> parameter, float w = defaultWidth, float h = defaultWidth / 9. * 16.);

	void setShape(float x, float y, float w, float h);
	void setShape(ofRectangle r);
    
    void setColorScale(float value);
    float getColorScale();
    
    void setColorRadius(float value);
    float getColorRadius();
    
    void setColorAngle(float value);
	float getColorAngle();

	ofAbstractParameter & getParameter();
	
private :
	void render();
	bool setValue(float mx, float my, bool bCheckBounds);
	void generateDraw();

	ofMesh getBackground();
	ofMesh getColorPoint();
	ofMesh getColorWheel();
	ofMesh getColorScaleBar();

	bool mouseMoved(ofMouseEventArgs & args);
	bool mousePressed(ofMouseEventArgs & args);
	bool mouseDragged(ofMouseEventArgs & args);
	bool mouseReleased(ofMouseEventArgs & args);
	bool mouseScrolled(ofMouseEventArgs & args);

	bool mouseUpdate(ofMouseEventArgs& args);
	
	glm::vec2 colorPoint;
    float colorScale;
    float colorRadius;
	float colorAngle;
	bool bSettingColor = false;

    int colorWheelRadius;
    int colorWheelPad;

	ofRectangle rectBackground;
	ofRectangle rectColorWheel;
	ofRectangle rectColorScaleBar;

	ofVboMesh geometry;
	ofParameter<ofColor_<ColorType>> color;

	enum State{
		Waiting,
		ChangingWheel,
		ChangingScale,
	}state = Waiting;

	ofEventListener listener;
};

#line 0 "../addons/ofxGui/src/ofxGuiGroup.h"
#pragma once
/* #include "ofxBaseGui.h" */

/* #include "ofxSlider.h" */
/* #include "ofxButton.h" */
/* #include "ofxLabel.h" */
/* #include "ofParameterGroup.h" */
/* #include "ofParameter.h" */

class ofxGuiGroup : public ofxBaseGui {
	public:
		ofxGuiGroup();
		ofxGuiGroup(const ofParameterGroup & parameters, const std::string& _filename = "settings.xml", float x = 10, float y = 10);
		virtual ~ofxGuiGroup(){
		}
		ofxGuiGroup * setup(const std::string& collectionName = "", const std::string& filename = "settings.xml", float x = 10, float y = 10);
		ofxGuiGroup * setup(const ofParameterGroup & parameters, const std::string& filename = "settings.xml", float x = 10, float y = 10);

		void add(ofxBaseGui * element);
		void add(const ofParameterGroup & parameters);

		template<typename T>
		typename std::enable_if<std::is_arithmetic<T>::value, void>::type add(ofParameter<T> & p){
			add(new ofxSlider<T>(p));
		}
		void add(ofParameter <void> & parameter);
		void add(ofParameter <bool> & parameter);
		void add(ofParameter <std::string> & parameter);

		template<typename F>
		void add(ofReadOnlyParameter <std::string, F> & parameter){
			add(new ofxLabel(parameter));
		}
		void add(ofParameter <ofVec2f> & parameter);
		void add(ofParameter <ofVec3f> & parameter);
		void add(ofParameter <ofVec4f> & parameter);
		void add(ofParameter <glm::vec2> & parameter);
		void add(ofParameter <glm::vec3> & parameter);
		void add(ofParameter <glm::vec4> & parameter);
		void add(ofParameter <ofColor> & parameter);
		void add(ofParameter <ofShortColor> & parameter);
		void add(ofParameter <ofFloatColor> & parameter);

		void minimize();
		void maximize();
		void minimizeAll();
		void maximizeAll();
		bool isMinimized() const;

		void setWidthElements(float w);

		void clear();

		virtual void sizeChangedCB();

		virtual bool mouseMoved(ofMouseEventArgs & args);
		virtual bool mousePressed(ofMouseEventArgs & args);
		virtual bool mouseDragged(ofMouseEventArgs & args);
		virtual bool mouseReleased(ofMouseEventArgs & args);
		virtual bool mouseScrolled(ofMouseEventArgs & args);


		std::vector <std::string> getControlNames() const;
		std::size_t getNumControls() const;

		ofxIntSlider & getIntSlider(const std::string& name);
		ofxFloatSlider & getFloatSlider(const std::string& name);
		ofxToggle & getToggle(const std::string& name);
		ofxButton & getButton(const std::string& name);
		ofxGuiGroup & getGroup(const std::string& name);

		ofxBaseGui * getControl(const std::string& name);
		ofxBaseGui * getControl(std::size_t num);

		virtual ofAbstractParameter & getParameter();

		virtual void setPosition(const ofPoint& p);
		virtual void setPosition(float x, float y);
	protected:
		virtual void render();
		virtual bool setValue(float mx, float my, bool bCheck);
		virtual void onMinimize();
		virtual void onMaximize();

		float spacing, spacingNextElement;
		float header;

		template <class ControlType>
		ControlType & getControlType(const std::string& name);

		virtual void generateDraw();

		std::vector <ofxBaseGui *> collection;
		ofParameterGroup parameters;

		std::string filename;
		bool minimized;
		bool bGuiActive;

		ofPath border, headerBg;
		ofVboMesh textMesh;
};

template <class ControlType>
ControlType & ofxGuiGroup::getControlType(const std::string& name){
	ControlType * control = dynamic_cast <ControlType *>(getControl(name));
	if(control){
		return *control;
	}else{
		ofLogWarning() << "getControlType " << name << " not found, creating new";
		control = new ControlType;
		control->setName(name);
		add(control);
		return *control;
	}
}

#line 0 "../addons/ofxGui/src/ofxPanel.h"
#pragma once

/* #include "ofxGuiGroup.h" */
/* #include "ofImage.h" */

#ifndef TARGET_EMSCRIPTEN
constexpr const char* ofxPanelDefaultFilename = "settings.xml";
#else
constexpr const char* ofxPanelDefaultFilename = "settings.json";
#endif

class ofxGuiGroup;

class ofxPanel : public ofxGuiGroup {
public:
	ofxPanel();
	ofxPanel(const ofParameterGroup & parameters, const std::string& filename=ofxPanelDefaultFilename, float x = 10, float y = 10);
	~ofxPanel();

	ofxPanel * setup(const std::string& collectionName="", const std::string& filename=ofxPanelDefaultFilename, float x = 10, float y = 10);
	ofxPanel * setup(const ofParameterGroup & parameters, const std::string& filename=ofxPanelDefaultFilename, float x = 10, float y = 10);

	bool mouseReleased(ofMouseEventArgs & args);

	ofEvent<void> loadPressedE;
	ofEvent<void> savePressedE;
protected:
	void render();
	bool setValue(float mx, float my, bool bCheck);
	void generateDraw();
	void loadIcons();
private:
	ofRectangle loadBox, saveBox;
	ofImage loadIcon, saveIcon;
    
    ofPoint grabPt;
	bool bGrabbed;
};

#line 0 "../addons/ofxGui/src/ofxSliderGroup.h"
#pragma once

/* #include "ofxGuiGroup.h" */
/* #include "ofxSlider.h" */
/* #include "ofxColorPicker.h" */

template<class VecType>
class ofxVecSlider_ : public ofxGuiGroup {
public:
    ofxVecSlider_(){
        sliderChanging = false;
    };
    ofxVecSlider_(ofParameter<VecType> value, float width = defaultWidth, float height = defaultHeight);

    ofxVecSlider_ * setup(ofParameter<VecType> value, float width = defaultWidth, float height = defaultHeight);
    ofxVecSlider_ * setup(const std::string& controlName, const VecType & value, const VecType & min, const VecType & max, float width = defaultWidth, float height = defaultHeight);

    ofAbstractParameter & getParameter();

    VecType operator=(const VecType & v);
	operator const VecType & ();
	const VecType * operator->();
protected:
    void changeSlider(const void * parameter, float & value);
    void changeValue(VecType & value);
	static size_t dim();
    ofParameter<VecType> value;
    bool sliderChanging;
};

typedef ofxVecSlider_<ofDefaultVec3> ofxVec3Slider;
typedef ofxVecSlider_<ofDefaultVec2> ofxVec2Slider;
typedef ofxVecSlider_<ofDefaultVec4> ofxVec4Slider;
typedef ofxVecSlider_<ofVec3f> ofxPointSlider;

template<typename ColorType>
class ofxColorSlider_: public ofxGuiGroup{

public:
	ofxColorSlider_(){
	    sliderChanging = false;
	};
	ofxColorSlider_(ofParameter<ofColor_<ColorType> > value, float width = defaultWidth, float height = defaultHeight);

	ofxColorSlider_ * setup(ofParameter<ofColor_<ColorType> > value, float width = defaultWidth, float height = defaultHeight);
	ofxColorSlider_ * setup(const std::string& controlName, const ofColor_<ColorType> & value, const ofColor_<ColorType> & min, const ofColor_<ColorType> & max, float width = defaultWidth, float height = defaultHeight);

	ofAbstractParameter & getParameter();

	ofColor_<ColorType> operator=(const ofColor_<ColorType> & v);
	operator const ofColor_<ColorType> & ();
protected:
	void onMinimize();
	void onMaximize();
    void changeSlider(const void * parameter, ColorType & value);
	void changeValue(ofColor_<ColorType> & value);
    bool sliderChanging;
	ofColor originalHeaderBackground;
	ofColor originalHeaderText;
	ofxColorPicker_<ColorType> picker;
};

typedef ofxColorSlider_<unsigned char> ofxColorSlider;
typedef ofxColorSlider_<unsigned short> ofxShortColorSlider;
typedef ofxColorSlider_<float> ofxFloatColorSlider;

#line 0 "../addons/ofxGui/src/ofxGui.h"
#pragma once

/* #include "ofxToggle.h" */
/* #include "ofxSlider.h" */
/* #include "ofxSliderGroup.h" */
/* #include "ofxPanel.h" */
/* #include "ofxButton.h" */
/* #include "ofxLabel.h" */
/* #include "ofxInputField.h" */
/* #include "ofTrueTypeFont.h" */
/* #include "ofxColorPicker.h" */
/* #include "ofEvents.h" */

void ofxGuiSetFont(const std::string & fontPath,int fontsize, bool _bAntiAliased=true, bool _bFullCharacterSet=true, int dpi=0);
void ofxGuiSetFont(const ofTrueTypeFontSettings & fontSettings);
void ofxGuiSetBitmapFont();

void ofxGuiSetHeaderColor(const ofColor & color);
void ofxGuiSetBackgroundColor(const ofColor & color);
void ofxGuiSetBorderColor(const ofColor & color);
void ofxGuiSetTextColor(const ofColor & color);
void ofxGuiSetFillColor(const ofColor & color);

void ofxGuiSetTextPadding(int padding);
void ofxGuiSetDefaultWidth(int width);
void ofxGuiSetDefaultHeight(int height);
void ofxGuiSetDefaultEventsPriority(ofEventOrder eventsPriority);

#line 0 "../addons-all/ofxTriangle/libs/Triangle/include/assert.hpp"

namespace tpp {

/*! \file assert.hpp
        \brief Implements a better 'Assert'
 */

#ifndef REVIVER_ASSERT_HPP
#define REVIVER_ASSERT_HPP


/*! \def MyAssertFunction
    \brief Function used by 'Assert' function in _DEBUG mode.
   
    Details.
*/
extern bool MyAssertFunction( bool b, const char* desc, int line, const char* file);


#if defined( _DEBUG )
#define Assert( exp, description ) MyAssertFunction( (int)(exp), description, __LINE__, __FILE__ )
#else
#define Assert( exp, description )
#endif


#endif

}

#line 0 "../addons-all/ofxTriangle/libs/Triangle/include/dpoint.hpp"


/*! \file dpoint.hpp
        \brief d-dimensional point class
	
	A d-dimensional point class which is written
	carefully using templates. It allows for basic
	operations on points in any dimension. Orientation
	tests for 2 and 3 dimensional points are supported
	using 
        <a href="http://www.cs.berkeley.edu/~jrs/">Jonathan's</a> 
        code. This class forms
	the building block of other classes like dplane, dsphere etc.

  \author <a href="www.compgeom.com/~piyush">Piyush Kumar</a>
  \bug    No known bugs.

 */

#ifndef REVIVER_POINT_HPP
#define REVIVER_POINT_HPP


/* #include "assert.hpp" */
#include <iostream>
#include <valarray>
#include <stdio.h>
#include <limits>



//! The reviver namespace signifies the part of the code borrowed from reviver (dpoint.hpp). 
namespace reviver {


// Forward Declaration of the main Point Class
// Eucledian d-dimensional point. The distance
// is L_2

template<typename NumType, unsigned D>
class dpoint;


///////////////////////////////////////////////////////
// Internal number type traits for dpoint
///////////////////////////////////////////////////////

template<typename T> 
class InternalNumberType;

template<>
class InternalNumberType<float>{
public: 
  typedef double __INT;
};


template<>
class InternalNumberType<int>{
public: 
  typedef long long __INT;
};


template<>
class InternalNumberType<double>{
public: 
  typedef double __INT;
};

template<>
class InternalNumberType<long>{
public: 
  typedef long long __INT;
};




///////////////////////////////////////////////////////
// Origin of d-dimensional point
///////////////////////////////////////////////////////
template< typename NumType, unsigned D, unsigned I > struct origin
{
   static inline void eval( dpoint<NumType,D>& p )
   {
	  p[I] = 0.0;
      origin< NumType, D, I-1 >::eval( p );
   }
};


// Partial Template Specialization
template <typename NumType, unsigned D> struct origin<NumType, D, 0>
{
   static inline void eval( dpoint<NumType,D>& p )
   {
	  p[0] = 0.0;
   }
};


//! A structure to compute squared distances between points
/*!
    Uses unrolling of loops using templates.
*/
///////////////////////////////////////////////////////
// Squared Distance of d-dimensional point
///////////////////////////////////////////////////////
template< typename NumType, unsigned D, unsigned I > struct Distance
{
   static inline double eval( const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
     double sum = ((double)p[I] -  (double)q[I] ) *( (double)p[I] - (double)q[I] );
	  return sum + Distance< NumType, D, I-1 >::eval( p,q );
   }
};


//!  Partial Template Specialization for distance calculations
template <typename NumType, unsigned D> struct Distance<NumType, D, 0>
{
   static inline double eval( const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
     return ((double) p[0] - (double)q[0] )*( (double)p[0] - (double)q[0] );
   }
};


//! A structure to compute dot product between two points or associated vectors
/*!
    Uses unrolling of loops using templates.
*/
///////////////////////////////////////////////////////
// Dot Product of two d-dimensional points
///////////////////////////////////////////////////////
template< typename __INT, typename NumType, unsigned D, unsigned I > struct DotProd
{
   static inline __INT eval( const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
	  __INT sum = ( ((__INT)p[I]) * ((__INT)q[I]) );
	  return sum + DotProd< __INT, NumType, D, I-1 >::eval( p,q );
   }
};


//! Partial Template Specialization for dot product calculations
template < typename __INT, typename NumType, unsigned D> struct DotProd<__INT,NumType, D, 0>
{
   static inline __INT eval( const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
	  return ( ((__INT)p[0]) * ((__INT)q[0]) );
   }
};


///////////////////////////////////////////////////////
// Equality of two d-dimensional points
///////////////////////////////////////////////////////
template< typename NumType, unsigned D, unsigned I > struct IsEqual
{
   static inline bool eval( const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
	  if( p[I]  != q[I] ) return false;
	  else return IsEqual< NumType, D, I-1 >::eval( p,q );
   }
};


// Partial Template Specialization
template <typename NumType, unsigned D> struct IsEqual<NumType, D, 0>
{
   static inline NumType eval( const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
	   return (p[0] == q[0])?1:0;
   }
};



//!   Equate two d-dimensional points. 
/*!
    Uses unrolling of loops using templates. 
    A class used to implement operator= for points.
    This class also helps in automatic type conversions 
    of points (with explicit calls for conversion).
*/
template< 
  typename NumType1, 
  typename NumType2, 
  unsigned D, 
  unsigned I 
  > struct Equate
{
   static inline void eval( dpoint<NumType1,D>& p,const dpoint<NumType2,D>& q )
   {
	  p[I]  = q[I];
	  Equate< NumType1, NumType2, D, I-1 >::eval( p,q );
   }
};


//! Partial Template Specialization for Equate
template <
  typename NumType1, 
  typename NumType2,
  unsigned D
  > struct Equate<NumType1,NumType2, D, 0>
{
   static inline void  eval( dpoint<NumType1,D>& p,const dpoint<NumType2,D>& q )
   {
	   p[0] = q[0];
   }
};


//! A structure to add two points
/*!
    Uses unrolling of loops using templates.
*/
///////////////////////////////////////////////////////
// Add two d-dimensional points
///////////////////////////////////////////////////////
template< typename NumType, unsigned D, unsigned I > struct Add
{
   static inline void eval( dpoint<NumType,D>& result, const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
	  result[I] = p[I]  + q[I];
	  Add< NumType, D, I-1 >::eval( result,p,q );
   }
};


//! Partial Template Specialization for Add structure
template <typename NumType, unsigned D> struct Add<NumType, D, 0>
{
   static inline void eval( dpoint<NumType,D>& result, const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
	   result[0] = p[0] + q[0];
   }
};


///////////////////////////////////////////////////////
// Subtract two d-dimensional points
///////////////////////////////////////////////////////
// Could actually be done using scalar multiplication
// and addition


// What about unsigned types?
template< typename NumType > 
inline NumType Subtract_nums(const NumType& x, const NumType& y) {
  if(!std::numeric_limits<NumType>::is_signed) {std::cerr << "Exception: Can't subtract unsigned types."; exit(1);}
  return x - y;
}


//!   Subtract two d-dimensional vectors
/*!
      Caution: Do not use on unsigned types.
*/
template< typename NumType, unsigned D, unsigned I > struct Subtract
{
   static inline void eval( dpoint<NumType,D>& result, const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
     
          result[I] = Subtract_nums(p[I] , q[I]);
	  Subtract< NumType, D, I-1 >::eval( result,p,q );
   }
};


//! Partial Template Specialization for subtraction of points (associated vectors)
template <typename NumType, unsigned D> struct Subtract<NumType, D, 0>
{
   static inline void eval( dpoint<NumType,D>& result, const dpoint<NumType,D>& p, const dpoint<NumType,D>& q )
   {
	   result[0] = Subtract_nums(p[0] , q[0]);
   }
};





//!   Mutiply scalar with d-dimensional point
/*!
      Scalar mulipltication of d-dimensional point
      with a number using template unrolling.
*/
template< typename NumType, unsigned D, unsigned I > struct Multiply
{
   static inline void eval( dpoint<NumType,D>& result, const dpoint<NumType,D>& p, NumType k)
   {
	  result[I] = p[I] * k;
	  Multiply< NumType, D, I-1 >::eval( result,p,k );
   }
};


//! Partial Template Specialization for scalar multiplication
template <typename NumType, unsigned D> struct Multiply<NumType, D, 0>
{
   static inline void eval( dpoint<NumType,D>& result, const dpoint<NumType,D>& p, NumType k )
   {
	   result[0] = p[0] * k;
   }
};



//!  Main d dimensional Point Class
/*!
	-  NumType = Floating Point Type
	-  D       = Dimension of Point
*/
template<typename NumType = double, unsigned D = 3>
class dpoint {

		// Makes Swap operation fast
		NumType  x[D];

public:


        typedef NumType NT;
        typedef typename InternalNumberType<NumType>::__INT __INT;

	// To be defined in a cpp file
	//  const MgcVector2 MgcVector2::ZERO(0,0);
	//  static const dpoint<NumType,D> Zero;

	inline void move2origin(){ origin<NumType, D, D-1>::eval(*this); };

	dpoint(){ 
		Assert( (D >= 1), "Dimension < 1 not allowed" ); 
		// move2origin(); 
	};

	//! 1 D Point
	dpoint(NumType x0){ x[0] = x0; };
	//! 2 D Point
	dpoint(NumType x0,NumType x1){ x[0] = x0;  x[1] = x1; };
	//! 3 D Point
	dpoint(NumType x0,NumType x1,NumType x2){  x[0] = x0;  x[1] = x1; x[2] = x2; };
	//! Array Initialization
	dpoint(NumType ax[]){ for(int i =0; i < D; ++i) x[i] = ax[i]; };
	//! Initialization from another point : Copy Constructor
        dpoint(const dpoint<NumType,D>& p){  Equate<NumType,NumType,D,D-1>::eval((*this),p);	};

         
        //! Automatic type conversions of points.
        //! Only allowed if the conversion is specified explicitly by the programmer.
        template<class OtherNumType>
        explicit dpoint(const dpoint<OtherNumType,D>& p){ Equate<NumType,OtherNumType,D,D-1>::eval((*this),p); };

	// Destructor
	~dpoint(){};

	inline int      dim() const { return D; };
	inline double   sqr_dist(const dpoint<NumType,D> q) const ;
	inline double   distance(const dpoint<NumType,D> q) const ;
	inline __INT    dotprod (const dpoint<NumType,D> q) const ;
	inline __INT    sqr_length(void)  const;
	inline void     normalize (void);
	inline NumType& operator[](int i);
	inline NumType  operator[](int i) const;

	inline dpoint&  operator= (const dpoint<NumType,D>& q);

	template<typename NT, unsigned __DIM>
	friend dpoint<NT,__DIM>   operator- (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q);

	template<typename NT, unsigned __DIM>
	friend dpoint<NT,__DIM>   operator+ (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q);

	template<typename NT, unsigned __DIM>
	friend bool   operator== (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q);

	template<typename NT, unsigned __DIM>
	friend bool   operator!= (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q);


//	inline dpoint&  operator= (const valarray<NumType>& v);
//	inline operator valarray<NumType>() const;

	template<typename __NT,unsigned __DIM>
	friend void iswap(dpoint<__NT,__DIM>& p,dpoint<__NT,__DIM>& q);
};

template<typename NumType, unsigned D>
void dpoint<NumType,D>::normalize (void){
	double len = sqrt(sqr_length());
	if (len > 0.00001)
	for(int i = 0; i < D; ++i){
		x[i] /= len;
	}
}

/*
template<typename NumType, unsigned D>
dpoint<NumType,D>::operator valarray<NumType>() const{
	valarray<NumType> result((*this).x , D);
	return result;
}

//Warning : Valarray should be of size D
//TODO: Unwind this for loop into a template system
template<typename NumType, unsigned D>
dpoint<NumType,D>&
dpoint<NumType,D>::operator= (const valarray<NumType>& v){
	dpoint<NumType,D> result;
	for(int i = 0; i < D; i++) (*this).x[i] = v[i];
	return (*this);
}
*/

template<typename NT, unsigned __DIM>
dpoint<NT,__DIM>
operator+ (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q){
	dpoint<NT,__DIM> result;
	Add<NT,__DIM,__DIM-1>::eval(result,p,q);	
	return result;
}

template<typename NT, unsigned __DIM>
dpoint<NT,__DIM>
operator- (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q){
	dpoint<NT,__DIM> result;
	// cout << "Subtracting..." << p << " from " << q << " = ";
	Subtract<NT,__DIM,__DIM-1>::eval(result,p,q);	
	// cout << result << endl;	
	return result;
}

template<typename NT, unsigned __DIM>
bool
operator== (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q){
	return IsEqual<NT,__DIM,__DIM-1>::eval(p,q);	
}

template<typename NT, unsigned __DIM>
bool
operator!= (const dpoint<NT,__DIM>& p, const dpoint<NT,__DIM>& q){
	return !(IsEqual<NT,__DIM,__DIM-1>::eval(p,q));	
}

template<typename NT, unsigned __DIM>
dpoint<NT,__DIM>
operator* (const dpoint<NT,__DIM>& p, const NT k){
	dpoint<NT,__DIM> result;
	Multiply<NT,__DIM,__DIM-1>::eval(result,p,k);	
	return result;
}

template<typename NT, unsigned __DIM>
dpoint<NT,__DIM>
operator/ (const dpoint<NT,__DIM>& p, const NT k){
	Assert( (k != 0), "Hell division by zero man...\n");
	dpoint<NT,__DIM> result;
	Multiply<NT,__DIM,__DIM-1>::eval(result,p,((double)1.0)/k);	
	return result;
}

template < typename NumType, unsigned D >
dpoint<NumType,D>&
dpoint<NumType,D>::operator=(const dpoint<NumType,D> &q)
{
  Assert((this != &q), "Error p = p");
  Equate<NumType,NumType,D,D-1>::eval(*this,q);	
  return *this;
}

template < typename NumType, unsigned D >
NumType
dpoint<NumType,D>::operator[](int i) const
{ return x[i]; }

template < typename NumType, unsigned D >
NumType&
dpoint<NumType,D>::operator[](int i)
{
 return x[i]; }


template<typename NumType, unsigned D>
double
dpoint<NumType,D>::sqr_dist (const dpoint<NumType,D> q) const {
	return Distance<NumType,D,D-1>::eval(*this,q);	
}

template<typename NumType, unsigned D>
double 
dpoint<NumType,D>::distance (const dpoint<NumType,D> q) const {
	return sqrt(static_cast<double>(Distance<NumType,D,D-1>::eval(*this,q)));	
}


template<typename NumType, unsigned D>
typename dpoint<NumType,D>::__INT
dpoint<NumType,D>::dotprod (const dpoint<NumType,D> q) const {
	return DotProd<__INT,NumType,D,D-1>::eval(*this,q);	
}

template<typename NumType, unsigned D>
typename dpoint<NumType,D>::__INT
dpoint<NumType,D>::sqr_length (void) const {
#ifdef _DEBUG	
    if( DotProd<__INT,NumType,D,D-1>::eval(*this,*this) < 0) {
          std::cerr << "Point that caused error: ";
	  std::cerr << *this << std::endl;
	  std::cerr << DotProd<__INT,NumType,D,D-1>::eval(*this,*this) << std::endl;
	  std::cerr << "Fatal: Hell!\n"; exit(1);
	}
#endif
	return DotProd<__INT,NumType,D,D-1>::eval(*this,*this);	
	
}

template < class NumType, unsigned D >
std::ostream&
operator<<(std::ostream& os,const dpoint<NumType,D> &p)
{
     os << "Point (d=";
	 os << D << ", (";
	 for (unsigned int i=0; i<D-1; ++i)
		os << p[i] << ", ";
	return os << p[D-1] << "))";
    
};

template < class NumType, unsigned D >
std::istream&
operator>>(std::istream& is,dpoint<NumType,D> &p)
{
	 for (int i=0; i<D; ++i)
		 if(!(is >> p[i])){
			 if(!is.eof()){
				std::cerr << "Error Reading Point" 
					  /* << is */ << std::endl;
				exit(1);
			 }
		 }
		 
	return is;
    
};

/*
template<typename __NT,unsigned __DIM>
static inline void iswap(dpoint<__NT,__DIM>& p,dpoint<__NT,__DIM>& q){
	__NT *y;
	y = p.x;
	p.x = q.x;
	q.x = y;
}
*/



template < typename NumType, unsigned D >
dpoint<NumType, D> CrossProd(const dpoint<NumType, D>& vector1, 
			     const dpoint<NumType, D>& vector2) {
   Assert(D == 3, "Cross product only defined for 3d vectors");
   dpoint<NumType, D> vector;
   vector[0] = (vector1[1] * vector2[2]) - (vector2[1] * vector1[2]);
   vector[1] = (vector2[0] * vector1[2]) - (vector1[0] * vector2[2]);
   vector[2] = (vector1[0] * vector2[1]) - (vector2[0] * vector1[1]); 
   return vector;
}




template < typename __NT, unsigned __DIM >
int
orientation(const dpoint<__NT,__DIM> p[__DIM+1])
{
	int _sign = + 1;
	// To be implemented
	std::cerr << "Not yet implemented\n";
	exit(1);
	return _sign;
    
}


template < typename __NT >
inline __NT
orientation(
	    const dpoint<__NT,2>& p,
	    const dpoint<__NT,2>& q,
	    const dpoint<__NT,2>& r
	    )
{
   // 2D speaciliazation for orientation
	std::cout << "FATAL";
  exit(1);
  return ((p[0]-r[0])*(q[1]-r[1]))-((q[0]-r[0])*(p[1]-r[1]));
}


extern "C" double orient2d(double *p, double *q, double *r);

template < >
inline double
orientation<double>(
	    const dpoint<double,2>& p,
	    const dpoint<double,2>& q,
	    const dpoint<double,2>& r
	    )
{
   // 2D speaciliazation for orientation
  double pp[2] = { p[0], p[1] };
  double qq[2] = { q[0], q[1] };
  double rr[2] = { r[0], r[1] };
  return orient2d(pp,qq,rr);
}


template < >
inline float
orientation<float>(
	    const dpoint<float,2>& p,
	    const dpoint<float,2>& q,
	    const dpoint<float,2>& r
	    )
{
   // 2D speaciliazation for orientation
  double pp[2] = { p[0], p[1] };
  double qq[2] = { q[0], q[1] };
  double rr[2] = { r[0], r[1] };
  return orient2d(pp,qq,rr);
}



};	// Namespace Ends here




#endif



#line 0 "../addons-all/ofxTriangle/libs/Triangle/include/del_interface.hpp"


/*! \mainpage Triangle++

	\section intro Introduction

<table border="0">
<tr>

<td>
If you do not know, what a delaunay triangulation is, you can read more about it 
<a href="http://www.compgeom.com/~piyush/teach/5930/slides/lecture8.ppt">here</a> and 
<a href="http://en.wikipedia.org/wiki/Delaunay_triangulation">here</a>.
This C++ library module is just a wrapper class on the 
<a href="http://www.cs.berkeley.edu/~jrs/">Triangle</a> 
package of <a href="http://www.cs.berkeley.edu/~jrs/">Jonathan</a>.
Many times I have had to use triangle in C++ code bases of mine
and have been forced to use C. At last I thought I would put a 
wrapper on his cool C code and it seems that this is what I got.
The design is not perfect and the code was written in a day,
but it does compile and run on the machines I tried (cygwin/redhat).
The C++ wrapper will certainly slow access down if you want to
mess with the triangulation but the basic delaunay triangulation
should be as fast as triangle. Look at the del_interface.hpp file
for getting started on what this wrapper can do for you. Also
have a look at main.cpp which shows an example of using this
class. The class is thread-safe.

<p>
<b>Requirements</b> : Python, make and C++ compilers. 
Supported C/C++ Compilers: g++ / icpc (Intel C++). 
Also needed is doxygen for generating documentation.
</p>

<p>
<b>Compilation</b> : Just type 'make'
</p>

<p>
<b>Testing</b> : Goto the bin directory, and type 
'./test ../data/input.dat' (after compilation of course).
</p>


</td>

<td><img src="http://upload.wikimedia.org/wikipedia/en/9/92/Delaunay_triangulation.png" 
alt="Delaunay Triangulation Example"></td>


</tr>
</table>


\section Downloads

You can download the latest version of the source code from <a href="triangle++.tar.gz">here</a>.


\section authors Authors
	<ul>
		<li><a href="http://compgeom.com/~piyush">Piyush Kumar</a></li>
		<li>Hopefully more to come... (please feel free to extend this wrapper)</li>
	</ul>
        
\section changelog Change Log

10/21/06: Replaced vertexsort with C++ sort.<br>
10/25/06: Wrapped in tpp namespace for usage with other libraries with similar names. 
Added some more documentation/small changes. Used doxygen 1.5.0 and dot. Tested compilation with
icc 9.0/9.1, gcc-4.1/3.4.6. <br>
11/03/06: Fixed the compilation system. <br>

\todo

<ol> 
    <li> Intel Compiler Warnings with -Wall </li>
    <ul>
         <li> remove the compiler warnings for icpc 9.0/9.1</li>
    </ul>

    <li> Implement vertexmedian() in C++. </li>
    <li> Implement the flip operator as a member function of Delaunay. </li>
</ol>

	
 */




//-----------------------------------------------------------





/*! \file del_interface.hpp
        \brief The main delaunay C++ class for users.

		All one needs to do is include this header and
		understand how to call the member functions and
		what they do. You should be ready to write your
		own delaunay triangulation packages based on this
		c++ wrapper of triangle.
 */
#ifndef DEL_INTERFACE
#define DEL_INTERFACE

/* #include <dpoint.hpp> */
#include <vector>
#include <string>

//! The main namespace in which the Triangle++ project lives
namespace tpp {



//!  The main Delaunay Class that wraps around triangle.
/*!
  This is a C++ wrapper of the triangle package by JRS.
  It currently uses the dpoint class written by me (the
  point class is a d-dimensional point class but for this
  application it only uses the d=2 case).
*/
class Delaunay {
public:
	//! Point Typedef
    /*! Warning: If you want to use your own point class, 
	    you might have to work hard...
	*/
	typedef  reviver::dpoint <double, 2> Point; 

private:
	
	std::vector< Point >  PList;/*! Stores the input point list. */
	void *in;					/*! Used for intput to triangle  */
	void *delclass;				/*! triangle is wrapped in this pointer. */
	void *pmesh;				/*! pointer to triangle mesh */
	void *pbehavior;
	bool Triangulated;

	void Triangulate(std::string& triswitches);

public:
	//! The main constructor.
    /*!
      Takes a vector of 2 dimensional points where
	  each of the coordinates is expressed as double.
    */
	Delaunay(std::vector< Point >& v){
		PList.assign(v.begin(), v.end());
		Triangulated = false;
	}

	//! Delaunay Triangulate the input points
    /*!
      This function calls triangle to delaunay triangulate
	  points given as input to the constructor of this class.
    */
	void Triangulate() { std::string s = "vzQ"; Triangulate( s ); } ;

	//! Output a geomview .off file containing the delaunay triangulation
    /*!
      \param fname output file name.
    */
	void writeoff(std::string& fname);

	//! Number of edges in the triangulation
	 /*!
      \return Number of Edges
      Remember to call Triangulate before using this function.
    */
	int nedges();
	
	//! Number of triangles in the triangulation
	 /*!
      \return Number of Triangles
      Remember to call Triangulate before using this function.
    */
	
	int ntriangles();

	//! Number of edges in the triangulation
	 /*!
      \return Number of Edges
      Remember to call Triangulate before using this function.
    */
	
 	 //! Number of vertices in the triangulation
	 /*!
      \return Number of Vertices
      Remember to call Triangulate before using this function.
    */
	int nvertices();

	 //! Number of vertices on the convex hull.
	 /*!
      \return Number of vertices on the convex hull.
      Remember to call Triangulate before using this function.
    */
	int hull_size();

	//! The main destructor.
    /*!
      Does memory cleanup mostly.
    */
	
	~Delaunay();

	///////////////////////////////
	//
	// Vertex Iterator
	//
	///////////////////////////////

	//!  The vertex iterator for the Delaunay class
	class vIterator {
		private:
			vIterator(Delaunay *);  //! To set container
			Delaunay *MyDelaunay;     //! Which container do I point

			void *vloop;		  //! Triangles Internal data.

		public:
			vIterator operator++();
			vIterator():vloop(NULL) {};
			Point &operator*() const; 
			~vIterator();

		friend class Delaunay;
		friend bool operator==(vIterator const &, vIterator const &);
		friend bool operator!=(vIterator const &, vIterator const &);
	};
	
	//! Vertex iterator begin function
    vIterator vbegin(){ return vIterator(this);} ;
	//! Vertex iterator end function
	vIterator vend();

	//! Given an iterator, find its index in the input vector of points.
	int vertexId(vIterator const &);

	//! Given an index, return the actual double Point
	const Point& point_at_vertex_id(int i) {return PList[i];};


	friend class vIterator; 


	///////////////////////////////
	//
	// Face Iterator
	//
	///////////////////////////////

	//!  The face iterator for the Delaunay class
	class fIterator {
                private:

					struct tdata {
						double ***tri;
						int orient;
					};

					typedef struct tdata  poface;

                        fIterator(Delaunay *);  //! To set container
                        Delaunay *MyDelaunay;     //! Which container do I point

                        //void *floop;              //! Triangles Internal data.
						poface floop;
						
                public:
                        void operator++();
						fIterator() {floop.tri = NULL;};
			            ~fIterator();

                friend class Delaunay;
                friend bool operator==(fIterator const &, fIterator const &);
                friend bool operator!=(fIterator const &, fIterator const &);
        };

		//! Face iterator begin function
        fIterator fbegin(){ return fIterator(this);	} ;
		//! Face iterator end function
        fIterator fend();
        int faceId(fIterator const &);


	//! Access the origin (Org) vertex of a face.
	 /*!
	  \param fit  Face interator.
      \return Index of the vertex in pList.

	  A triangle abc has origin (org) a,destination (dest) b, and apex (apex)  
      c.  These vertices occur in counterclockwise order about the triangle.  
      Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */
	int Org (fIterator const & fit);

	//! Access the destination (Dest) vertex of a face.
	 /*!
	  \param fit  Face interator.
      \return Index of the vertex in pList.

	  A triangle abc has origin (org) a,destination (dest) b, and apex (apex)  
      c.  These vertices occur in counterclockwise order about the triangle.  
      Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */

	int Dest(fIterator const & fit);

	//! Access the apex (Apex) vertex of a face.
	 /*!
	  \param fit  Face interator.
      \return Index of the vertex in pList.

	  A triangle abc has origin (org) a,destination (dest) b, and apex (apex)  
      c.  These vertices occur in counterclockwise order about the triangle.  
      Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */

	int Apex(fIterator const & fit);


	//! Access the triangle adjoining edge i
	 /*!
	  \param fit  Face Iterator
	  \param i  edge number  
          \return The vertex on the opposite face

	  A triangle abc has origin (org) a,destination (dest) b, and apex (apex)  
          c.  These vertices occur in counterclockwise order about the triangle.  
	  <ul>
	  <li>sym(abc, 0) -> ba*</li>
	  <li>sym(abc, 1) -> cb*</li>
	  <li>sym(abc, 2) -> ac*</li>
	  </ul>
	  * is the farthest vertex on the adjoining triangle whose index
	  is returned. A -1 is returned if the edge is part of the convex hull.
      Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */

	int Sym(fIterator const & fit, char i);


	//! Access the triangle opposite to current edge of the face
	 /*!
	  \param fit  Face iterator
          \return The iterator of the opposite face

	  A triangle abc has origin (org) a,destination (dest) b, and apex (apex)  
          c.  These vertices occur in counterclockwise order about the triangle.  
	  The iterator
	  to the triangle is returned. The iterator is empty if the edge
	  is on the convex hull.
          Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */

	fIterator Sym(fIterator const & fit);


	//! Is the iterator empty?
	 /*!
	  \param fit  Face interator.
      \return true if the iterator is empty
    */

	inline bool empty(fIterator const & fit)
		{ return fit.floop.tri == NULL; };

	//! Is the iterator pointing to the dummy triangle?
	 /*!
	  \param fit  Face interator.
      \return true if the iterator is of the dummy triangle.
    */

	bool isdummy(fIterator const & fit);


     
	//! Find the next edge (counterclockwise) of a triangle.   
	 /*!
	  \param fit  face iterator
      \return The face iterator corresponding to the next counterclockwise edge of a triangle

	  Lnext(abc) -> bca.
	  Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */
	fIterator L_next(fIterator const & fit);

	//! Find the previous edge (clockwise) of a triangle.   
	 /*!
	  \param fit  face iterator
      \return The face iterator corresponding to the previous clockwise edge of a triangle

	  Lprev(abc) -> cab.
	  Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */
	fIterator L_prev(fIterator const & fit);

	//! Find the next edge (counterclockwise) of a triangle with the same origin
	 /*!
	  \param fit  face iterator
      \return The face iterator corresponding to the next edge counterclockwise with the same origin.

	  Onext(abc) -> ac*.
	  Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */
	fIterator O_next(fIterator const & fit);

	
	//! Find the next edge clockwise with the same origin.
	 /*!
	  \param fit  face iterator
      \return The face iterator corresponding to the next edge clockwise with the same origin.

	  Onext(abc) -> a*b.
	  Remember to call Triangulate before using this function.
	  Do not use it on a null iterator.
    */
	fIterator O_prev(fIterator const & fit);


// TODO List: (for face iterators)
/*  dnext:  Find the next edge counterclockwise with the same destination.   */
/*  dnext(abc) -> *ba                                                        */
/*                                                                           */
/*  dprev:  Find the next edge clockwise with the same destination.          */
/*  dprev(abc) -> cb*                                                        */
/*                                                                           */
/*  rnext:  Find the next edge (counterclockwise) of the adjacent triangle.  */
/*  rnext(abc) -> *a*                                                        */
/*                                                                           */
/*  rprev:  Find the previous edge (clockwise) of the adjacent triangle.     */
/*  rprev(abc) -> b**                                                        */



	//! Calculate incident triangles around a vertex.
	 /*!
	  \param vertexid The vertex for which you want incident triangles.
          \param ivv Returns triangles around a vertex in counterclockwise order.

	  Note that behaviour is undefined if vertexid is greater than 
	  number of vertices - 1. Remember to call Triangulate before using this function.
	  All triangles returned have Org(triangle) = vertexid.
	  All triangles returned are in counterclockwise order.
    */

	void trianglesAroundVertex(int vertexid, std::vector<int>& ivv );

	//! Calculate the area of a face. 
	 /*!
	  \param fit  Face interator.
      \return area of the face associated with the iterator.

    */

	double area(fIterator const & fit);



	//! Point locate a vertex v
	/*!
   	  \param vertexid  vertex id
          \return a face iterator whose origin is v.
        */

	fIterator locate(int vertexid);



    friend class fIterator;


}; // Class delaunay

} // namespace tpp ends.

#endif



#line 0 "../addons-all/ofxTriangle/src/ofxTriangle.h"
/*!
* ofxTriangle by kikko.fr
* -> C++ Triangle warper by Piyush Kumar
* -> Point inside polygon by Theo
*/

#ifndef OFXTRIANGLE_H_INCLUDED
#define OFXTRIANGLE_H_INCLUDED

//JG added this #define to allow to be decoupled from OpenCV
//along with the ability to pass in any vector of points
//allows for use with contours from OpenTSPS

//#define USE_OPENCV

/* #include "ofMain.h" */
#ifdef USE_OPENCV
#include "ofxOpenCv.h"
#endif

/* #include <del_interface.hpp> */

using namespace tpp;
//using namespace std;

typedef struct
{
    ofPoint a;
    ofPoint b;
    ofPoint c;

    float area;

} ofxTriangleData;

template<class T> class ofxTriangle_ {
    public :

	ofxTriangle_(){}
	~ofxTriangle_(){}
#ifdef USE_OPENCV
	// Triangulate a openCV blob
	void triangulate(ofxCvBlob &cvblob, int resolution = 50)
    {
        triangulate(cvblob.pts, resolution);
    }
#endif
	void triangulate(vector<T> contour, int resolution = 50);

	T getTriangleCenter(T *tr);
	bool isPointInsidePolygon(T *polygon,int N, T p);

	void draw() {
        draw(ofRandom(0, 255),ofRandom(0, 255),ofRandom(0, 255));
    }
	void draw(float r, float g, float b) {
        ofFill();

        for (int i=0; i<nTriangles; i++){
            ofSetColor(r,g,b);
            ofTriangle( triangles[i].a.x, triangles[i].a.y,
                    triangles[i].b.x, triangles[i].b.y,
                    triangles[i].c.x, triangles[i].c.y);
        }
    }
	void draw(float x, float y) {
        ofPushMatrix();
        ofTranslate(x, y, 0);
        draw();
        ofPopMatrix();
    }
	void clear() {
        triangles.clear();
        nTriangles = 0;
    }

	Delaunay* delobject;

	int nTriangles;
	vector <ofxTriangleData> triangles;

};

using ofxTriangle = ofxTriangle_<ofDefaultVertexType>;

/* #include "ofxTriangle.inl" */

#endif // OFXTRIANGLE_H_INCLUDED

#line 0 "../addons-all/ofxTriangle/src/ofxTriangle.inl"

template <class T>
void ofxTriangle_<T>::triangulate(vector<T> contour, int resolution){
    int bSize = contour.size();
    float maxi = min(resolution, bSize);
	
    Delaunay::Point tempP;
    vector<Delaunay::Point> v;
	
    for(int i = 0; i < maxi; i++) {
        //int id = (int) ( (float)i/maxi*bSize );
		int indx = ofMap(i, 0, maxi, 0, bSize);
        tempP[0] = contour[indx].x;
        tempP[1] = contour[indx].y;
		
        v.push_back(tempP);
    }
	
    delobject = new Delaunay(v);
    delobject->Triangulate();

    Delaunay::fIterator fit;
    for ( fit = delobject->fbegin(); fit != delobject->fend(); ++fit ) {
        int pta = delobject->Org(fit);
        int ptb = delobject->Dest(fit);
        int ptc = delobject->Apex(fit);

        int pta_id = (int)ofMap(pta, 0, maxi, 0, bSize);
        int ptb_id = (int)ofMap(ptb, 0, maxi, 0, bSize);
        int ptc_id = (int)ofMap(ptc, 0, maxi, 0, bSize);
		
        T tr[3];
        tr[0] = T(contour[pta_id].x, contour[pta_id].y, 0);
        tr[1] = T(contour[ptb_id].x, contour[ptb_id].y, 0);
        tr[2] = T(contour[ptc_id].x, contour[ptc_id].y, 0);
		
        if( isPointInsidePolygon(&contour[0], contour.size(), getTriangleCenter(tr) ) ) {
            ofxTriangleData td;
            td.a = T(tr[0].x, tr[0].y, 0);
            td.b = T(tr[1].x, tr[1].y, 0);
            td.c = T(tr[2].x, tr[2].y, 0);

            td.area = delobject->area(fit);

            triangles.push_back(td);
			
            nTriangles++;
        }
    }
	
    delete delobject;
}

template <class T>
T ofxTriangle_<T>::getTriangleCenter(T *tr){
    float c_x = (tr[0].x + tr[1].x + tr[2].x) / 3;
    float c_y = (tr[0].y + tr[1].y + tr[2].y) / 3;

    return T(c_x, c_y, 0);
}

template <class T>
bool ofxTriangle_<T>::isPointInsidePolygon(T *polygon,int N, T p)
{
    int counter = 0;
    int i;
    double xinters;
    T p1,p2;

    p1 = polygon[0];

    for (i=1;i<=N;i++)
    {
        p2 = polygon[i % N];
        if (p.y > MIN(p1.y,p2.y)) {
            if (p.y <= MAX(p1.y,p2.y)) {
                if (p.x <= MAX(p1.x,p2.x)) {
                    if (p1.y != p2.y) {
                        xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
                        if (p1.x == p2.x || p.x <= xinters){
                            counter++;
						}
                    }
                }
            }
        }
        p1 = p2;
    }

	return counter % 2 != 0;
}

#line 0 "../addons-all/ofxControlPanel/src/simpleColor.h"
#pragma once

/* #include "ofMain.h" */

class simpleColor{

    public:

    //----------------------------------------------------------
    simpleColor();

	//----------------------------------------------------------
	simpleColor(int _r, int _g, int _b, int _a);

	//----------------------------------------------------------
	simpleColor(int hexColor);

    //----------------------------------------------------------
    void setColor(int _r, int _g, int _b, int _a);

    //----------------------------------------------------------
    void setColor(int hexColor);

    //----------------------------------------------------------
    simpleColor& getColor();

    //----------------------------------------------------------
    float * getColorF();

    //------------------
    //------------------
    union  {
        struct {
            float r;
            float g;
            float b;
            float a;
        };
        float color[4];
    };

};



#line 0 "../addons-all/ofxControlPanel/src/simpleLogger.h"
#pragma once

/* #include "ofMain.h" */
/* #include "ofxXmlSettings.h" */

typedef struct{
    string msg;
    int level;

    string logStr;
	string dateStr;
	string timeStr;
	string levelStr;

    long timestamp;
    int year;
    int month;
    int day;
    int hour;
    int minute;
    int seconds;
}logRecord;

class simpleLogger : public ofBaseDraws{

     public:

        simpleLogger();
        ~simpleLogger();

        void setup(string logFileName, bool overwrite);
        void setIncludeDate(bool bIncludeDate);
        void setIncludeTime(bool bIncludeTime);
        void setIncludeLevelbool(bool  bIncludeLevel);

        //--------------------------------------------------
        void log(int logLevel, const char* format, ...);

        float getWidth();
        float getHeight();

        //----------------------------------------------
        string convertToString(logRecord & record);

        void logToXml(logRecord & record);
        void saveFile();

        void draw(float x, float y);
        void draw(float x, float y, float width, float height);

        string logFile;
        ofxXmlSettings xml;
        bool fileLoaded;

        bool bLevel;
        bool bTime;
        bool bDate;

        vector <logRecord> logs;
};

#line 0 "../addons-all/ofxControlPanel/src/simpleFileLister.h"
#pragma once

/* #include "ofMain.h" */

typedef struct{
    string filename;
    string fullpath;
}entry;


class simpleFileLister : public ofDirectory {

     public:

        simpleFileLister();
        int refreshDir();

        int listDir(string directory);

        void reverseOrder();

        bool selectedHasChanged();
        void clearChangedFlag();

		int getNumEntries() { return entries.size(); }
        string getName(int which);
        string getPath(int which);
        void setSelectedFile(int which);
        string getSelectedName();
        string getSelectedPath();
		
        int  selected;
        bool selectedChanged;
        bool bRevSort;

        string lastDirectory;

        vector <entry> entries;
};

#line 0 "../addons-all/ofxControlPanel/src/guiValue.h"
#pragma once

/* #include "ofMain.h" */

class guiValue{

    public:
        guiValue();

       //------------------------------------------------
        void addValue(float val, float _min, float _max);

        //------------------------------------------------
        void addValueI(int val, int _min, int _max);

        //------------------------------------------------
        void addValueB(bool val);

       //------------------------------------------------
        bool setValue(float val, unsigned int which = 0);

        //------------------------------------------------
        bool setValueAsPct(float percent, unsigned int which = 0);

       //------------------------------------------------
        float getValueF(unsigned int which = 0);

       //------------------------------------------------
        float getValueI(unsigned int which = 0);

       //------------------------------------------------
        float getValueB(unsigned int which = 0);

        //------------------------------------------------
        float getMin(unsigned int which = 0);

        //------------------------------------------------
        float getMax(unsigned int which = 0);
		void setMax( int new_max, unsigned int which=0 );

        //------------------------------------------------
        float getPct(unsigned int which = 0);

        //------------------------------------------------		
		bool hasValueChanged(unsigned int which = 0);
		
        //------------------------------------------------		
		void clearChangedFlag();

        //------------------------------------------------
        int getNumValues();

    protected:

        //-----------------------------------------------
        void updatePct(int which);

        //--------------
        //--------------
        vector <float> value;
        vector <float> valueI;
        vector <float> valueB;

        vector <float> min;
        vector <float> max;
        vector <float> pct;

		vector<bool> bChanged;

};


#line 0 "../addons-all/ofxControlPanel/src/guiVariablePointer.h"
/*
 *  guiVariablePointer.h
 *  ofxControlPanelDemo
 *
 *  Created by theo on 01/04/2010.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */
#pragma once
/* #include "ofMain.h" */

typedef enum{
	GUI_VAR_NONE,
	GUI_VAR_INT,
	GUI_VAR_FLOAT,
	GUI_VAR_STRING,
	GUI_VAR_BOOL
}guiVarType;

class guiVariablePointer{
	public:
		guiVariablePointer(){
			displayName = "No name";
			ptr			= NULL;
			dataType	= GUI_VAR_NONE;
			precision   = 7;
		}
		
		guiVariablePointer( string displayNameIn, void * varPtr, guiVarType theDataType, float floatPrecision = 7){
			displayName = displayNameIn;
			ptr			= varPtr;
			dataType	= theDataType;		
			precision   = floatPrecision;
		} 
	
		ofRectangle bounds;
		string varAsString;
		string displayName;
		void * ptr;
		guiVarType dataType;
		float precision;
};
#line 0 "../addons-all/ofxControlPanel/src/guiXmlValue.h"
#pragma once


class guiXmlValue{

    public:
        guiXmlValue(){

        }

       //------------------------------------------------
        void addValue(float val, float _min, float _max){
            value.push_back(val);
            valueI.push_back((int)val);
            valueB.push_back((bool)val);
            min.push_back(_min);
            max.push_back(_max);
            pct.push_back( 0.0 );

            //update our pct
            updatePct(value.size()-1);
        }

        //------------------------------------------------
        void addValueI(int val, int _min, int _max){
            value.push_back((float)val);
            valueI.push_back(val);
            valueB.push_back((bool)val);
            min.push_back((float)_min);
            max.push_back((float)_max);
            pct.push_back( 0.0 );

            //update our pct
            updatePct(value.size()-1);
        }

        //------------------------------------------------
        void addValueB(bool val){
            value.push_back((float)val);
            valueI.push_back((int)val);
            valueB.push_back(val);
            min.push_back(0);
            max.push_back(1);
            pct.push_back( 0.0 );

            //update our pct
            updatePct(value.size()-1);
        }

       //------------------------------------------------
        bool setValue(float val, int which = 0){
            if(which >= 0 && which < value.size() ){

                if( max[which] - min[which] == 0 ) return false;

                //check out bounds
                if(val < min[which])        val = min[which];
                else if(val > max[which])   val = max[which];

                value[which]  =  val;
                valueI[which] = (int)val;
                valueB[which] = (bool)val;

                //recalulate our pct
                updatePct(which);

                return true;
            }
            return false;
        }

        //------------------------------------------------
        bool setValueAsPct(float percent, int which = 0){
            if(which >= 0 && which < value.size() ){

                if( max[which] - min[which] == 0 ) return false;

                if(percent < 0.0) percent = 0.0;
                else if(percent > 1.0) percent = 1.0;

                pct[which]    =  percent;

                value[which]  =  ( pct[which] * ( max[which] - min[which] ) ) + min[which];
                valueI[which] = (int)value[which];
                valueB[which] = (bool)value[which];

                return true;
            }
            return false;
        }

       //------------------------------------------------
        float getValueF(int which = 0){
            if(which >= 0 && which < value.size() ){
                return value[which];
            }
            return 0.0;
        }

       //------------------------------------------------
        float getValueI(int which = 0){
            if(which >= 0 && which < valueI.size() ){
                return valueI[which];
            }
            return false;
        }

       //------------------------------------------------
        float getValueB(int which = 0){
            if(which >= 0 && which < valueB.size() ){
                return valueB[which];
            }
            return false;
        }

        //------------------------------------------------
        float getMin(int which = 0){
            if(which >= 0 && which < min.size() ){
                return min[which];
            }
            return 0.0;
        }

        //------------------------------------------------
        float getMax(int which = 0){
            if(which >= 0 && which < max.size() ){
                return max[which];
            }
            return 0.0;
        }

        //------------------------------------------------
        float getPct(int which = 0){
            if(which >= 0 && which < pct.size() ){
                return pct[which];
            }
            return 0.0;
        }

        //------------------------------------------------
        int getNumValues(){
            return value.size();
        }

    protected:

        //-----------------------------------------------
        void updatePct(int which){
            pct[which] = (value[which] - min[which]) / (max[which] - min[which]);
        }

        //--------------
        //--------------
        vector <float> value;
        vector <float> valueI;
        vector <float> valueB;

        vector <float> min;
        vector <float> max;
        vector <float> pct;

};


#line 0 "../addons-all/ofxControlPanel/src/guiColor.h"
#pragma once

/* #include "simpleColor.h" */

class guiColor{

    public:

        //------------------------------------------------
        guiColor();
		void setColor(int r, int g, int b, int a);
		void setColor(int hexValue);
		void setSelectedColor(int r, int g, int b, int a);
		void setSelectedColor(int hexValue);
		void setDisabledColor(int r, int g, int b, int a);
		void setDisabledColor(int hexValue);
		void setGuiColorMode(int whichColor);
		
		simpleColor& getColor();
		
		float* getColorF();
		float* getSelectedColorF();
        float* getNormalColorF();

        //---------------
        //---------------
        simpleColor color;
        simpleColor selected;
        simpleColor disabled;

        int colorMode;
        bool bUseDisabled;
        bool bUseSelected;

};


#line 0 "../addons-all/ofxControlPanel/src/guiTextBase.h"
#pragma once

/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTextBase{

    public:

        //-------------------------------------------
        guiTextBase();
        virtual void setFont(ofTrueTypeFont * fontPtr);

		virtual float getTextWidth(string textIn);
		virtual float getTextWidth();
		
		virtual float getTextHeight();

		virtual float getTextSingleLineHeight();

		virtual void setText(string textStr); 

		virtual void renderText(float x, float y);
		virtual void renderString(string textToRender, float x, float y);

        virtual float stringHeight(string textToRender);
		virtual float stringWidth(string textToRender);

		virtual bool usingTTF(){
			return ourFont != NULL;
		}

        //--------------------------------------------
        ofTrueTypeFont * ourFont;

        string textString;

        int numNewLines;
        int fontSize;
        bool bRealFont;
        bool bShowText;
};

#line 0 "../addons-all/ofxControlPanel/src/guiCallbackValue.h"
/*
 *  guiCallbackValue.h
 *  ofxControlPanelDemo
 *
 *  Created by theo on 31/03/2010.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */

#pragma once

/* #include "ofMain.h" */

typedef enum{
	CB_VALUE_NOT_SET,
	CB_VALUE_INT,
	CB_VALUE_FLOAT,
	CB_VALUE_STRING
}guiCBValueType;

class cbValue{
	public:
		cbValue(){
			valF = 0.0f;
			valI = 0;
			valueType = CB_VALUE_NOT_SET;
		}
		
		void setValue(float val){
			valF = val;
			valueType = CB_VALUE_FLOAT;
		}

		void setValue(int val){
			valI = val;
			valueType = CB_VALUE_INT;
		}

		void setValue(string val){
			valS = val;
			valueType = CB_VALUE_STRING;
		}
		
		guiCBValueType getType(){
			return valueType;
		}
		
		float getFloat(){
			if( valueType == CB_VALUE_FLOAT ){
				return valF;
			}else if( valueType == CB_VALUE_INT ){
				return (float)valI;
			}
			return 0.0f;
		}
		
		int getInt(){
			if( valueType == CB_VALUE_INT ){
				return valI;
			}else if( valueType == CB_VALUE_FLOAT ){
				return (int)valF;
			}
			return 0;
		}
		
		string getString(){
			if( valueType == CB_VALUE_STRING ){
				return valS;
			}else if( valueType == CB_VALUE_FLOAT ){
				return ofToString(valF);
			}else{
				return ofToString(valI);
			}
			return "";
		}
				
		guiCBValueType valueType;
		float   valF;
		int     valI;
		string  valS;
};

class guiCallbackData{
	public:
	
		void setup(string xmlNameIn, string displayNameIn){
			xmlName	    = xmlNameIn;
			displayName = displayNameIn;
		}
		
		void addValueF(float val){
			values.push_back(cbValue());
			values.back().setValue(val);
		}

		void addValueI(int val){
			values.push_back(cbValue());
			values.back().setValue(val);
		}

		void addValueS(string val){
			values.push_back(cbValue());
			values.back().setValue(val);
		}
		
		bool isElement(string nameToMatch){
			if( nameToMatch == xmlName || nameToMatch == displayName) return true;
			return false;
		}
		
		string getXmlName(){
			return xmlName;
		}
		
		string getDisplayName(){
			return displayName;
		}
				
		int getNumValues(){
			return values.size();
		}
		
		float getFloat(int which){
			if( which < values.size() ){
				return values[which].getFloat();
			}
			return 0.0;	
		}

		int getInt(int which){
			if( which < values.size() ){
				return values[which].getInt();
			}
			return 0;
		}
		
		guiCBValueType getType(int which){
			if( which < values.size() ){
				return values[which].getType();
			}
			return CB_VALUE_NOT_SET;
		}

		string getString(int which){
			if( which < values.size() ){
				return values[which].getString();
			}
			return "";
		}
		
		protected:
		
		string displayName;
		string xmlName;
		vector <cbValue> values;	
};


class guiCallbackValue{
	public:
		guiCallbackData val;
};


#line 0 "../addons-all/ofxControlPanel/src/guiCallback.h"
/*
 *  guiCallback.h
 *  ofxControlPanelDemo
 *
 *  Created by theo on 31/03/2010.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */

#pragma once
/* #include "ofMain.h" */
/* #include "guiCallbackValue.h" */

class guiCustomEvent{
	public:
		vector <string> names;
		string group;
		
		ofEvent <guiCallbackData> guiEvent;		
};
#line 0 "../addons-all/ofxControlPanel/src/guiBaseObject.h"
#pragma once

/* #include "simpleColor.h" */
/* #include "guiColor.h" */
/* #include "guiValue.h" */
/* #include "guiTextBase.h" */
/* #include "guiCallback.h" */

typedef enum{
SG_STATE_NORMAL,
SG_STATE_SELECTED
}sgState;

typedef enum{
	SG_TYPE_FLOAT,
	SG_TYPE_INT,
	SG_TYPE_BOOL
}sgType;

static bool isInsideRect(float x, float y, ofRectangle rect){
    return ( x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height );
}

class guiBaseObject{

    public:
        guiBaseObject();

        //------------------------------------------
        virtual void setXmlName(string _xmlName);

        //--------------------------------------------
        virtual void setFont(ofTrueTypeFont * fontPtr);

        //should be called on mousedown
        //-------------------------------------------
        virtual bool checkHit(float x, float y, bool isRelative);

        //this is the equivilant of mouse moved if the gui element has been selected
        //this is empty as it really should be specified by
        //the extending class (gui element).
        //------------------------------------------------
        virtual void updateGui(float x, float y, bool firstHit, bool isRelative);

        //should  be called on mouse up
        //-------------------------------------------
        virtual void release();
	
		//should be called when a key is pressed; return true if we consume the key
		virtual bool keyPressed( int k);
		
        //these are here for the custom control types
        //we notify all elements about these actions
        virtual void saveSettings(string filename);
        virtual void reloadSettings();
        virtual void saveSettings();
        virtual void loadSettings(string filename);

        virtual void lock();
        virtual void unlock();
        bool isLocked();

        //------------------------------------------------
		virtual void makeXmlNameFromDisplayName(){
			xmlName = name;
			size_t found;
			found=xmlName.find_first_of(" ");
			while (found!=string::npos){
				xmlName[found]='_';
				found=xmlName.find_first_of(" ",found+1);
			}
			transform(xmlName.begin(), xmlName.end(), xmlName.begin(), ::toupper);
		}

        //------------------------------------------------
        virtual void setShowText(bool showText);
		
        //-----------------------------------------------
        virtual void setTypeInt();

        //-----------------------------------------------
        virtual void setTypeFloat();
		
        //-----------------------------------------------
        virtual void setTypeBool();
		
        //-----------------------------------------------
        virtual void setPosition(float x, float y);

        //------------------------------------------------
        virtual void setDimensions(float width, float height);

        //-----------------------------------------------
        virtual float getPosX();
		
        //------------------------------------------------
        virtual float getPosY();
		
        //------------------------------------------------
        virtual float getWidth();

        //-----------------------------------------------
        virtual float getHeight();

        //-----------------------------------------------
        virtual void update();

		//-----------------------------------------------
		virtual bool hasValueChanged(unsigned int which = 0);

		//-----------------------------------------------
		virtual void notify();
		
        //-----------------------------------------------
        virtual void checkPrescison();
		
//        //-----------------------------------------------
//        virtual void setIsRelative( bool bIsRelative ){
//            isRelative = bIsRelative;
//        }

        //every time we update the value of our text
        //-----------------------------------------------
        virtual void updateText();

        //---------------------------------------------
        virtual void updateBoundingBox();

        //---------------------------------------------
        virtual void renderText();

        //this also needs to be specified by the extending class
        //--------------------------------------------
        virtual void render();

         //-------------------------------------------
         virtual void setSelected();

         //-------------------------------------------
         virtual void setNormal();
		 
         //-------------------------------------------
         virtual void setForegroundColor( int norR, int norG, int norB, int norA);

         //-------------------------------------------
         virtual void setForegroundSelectColor(int selR, int selG, int selB, int selA);

         //-------------------------------------------
         virtual void setBackgroundColor( int norR, int norG, int norB, int norA);

         //-------------------------------------------
         virtual void setBackgroundSelectColor(int selR, int selG, int selB, int selA);

         //-------------------------------------------
         virtual void setOutlineColor( int norR, int norG, int norB, int norA);

         //-------------------------------------------
         virtual void setOutlineSelectColor(int selR, int selG, int selB, int selA);

         //-------------------------------------------
         virtual void setTextColor( int norR, int norG, int norB, int norA);

         //-------------------------------------------
         virtual void setTextSelectColor(int selR, int selG, int selB, int selA);

         virtual void setValue(float _value, int whichParam);

        virtual void updateValue();

        //list of properties
        //------------------
        string name;
        string drawStr;
        string xmlName;

        ofRectangle boundingBox;
        ofRectangle hitArea;

        guiColor fgColor;
        guiColor bgColor;
        guiColor outlineColor;
        guiColor textColor;

        int numDecimalPlaces;

        //------------------
        guiTextBase displayText;

        //-------------------
        vector <guiBaseObject *>children;

		ofEvent <guiCallbackData> guiEvent;		

        //bool isRelative;
        bool locked;
		bool bRemoveFromLayout;

        float storedTextWidth;
        float titleSpacing;
        float fontSize;
        bool bShowText;
        bool readOnly;
        int  state;
        int  dataType;

//protected:

        guiValue value;

};


#line 0 "../addons-all/ofxControlPanel/src/guiCustomImpl.h"
#pragma once

/* #include "ofMain.h" */

class guiCustomImpl{

     public:

        guiCustomImpl(){
            mouseIsRelative = false;
        }

        virtual ~guiCustomImpl(){

        }

        virtual void saveSettings(string filename){}
        virtual void reloadSettings(){}
        virtual void saveSettings(){}
        virtual void loadSettings(string filename){}

        virtual  void update(){}
        virtual  void draw(float x, float y, float w, float h){}

        virtual void mousePressed(float x, float y){}
        virtual void mouseDragged(float x, float y){}
        virtual void mouseReleased(){}

        bool mouseIsRelative;
		
		ofRectangle boundingRect;
};

#line 0 "../addons-all/ofxControlPanel/src/guiType2DSlider.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiType2DSlider : public guiBaseObject{

    public:

        guiType2DSlider();

        void setup(string sliderName, float defaultVal1, float min1, float max1, float defaultVal2, float min2, float max2);
        
		void updateGui(float x, float y, bool firstHit, bool isRelative);
        void setKnobSize(float _knobSize);
        
		virtual void setValue(float _value, int whichParam);
        virtual void updateValue();
		
		virtual void notify();	
		
        void render();

        float knobSize;

};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeChartPlotter.h"
/*
 *  guiTypeChartPlotter.h
 *  ofxControlPanelDemo
 *
 *  Created by theo on 01/04/2010.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */

#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "guiVariablePointer.h" */

class guiStatVarPointer : public guiVariablePointer{
	public:
		guiStatVarPointer(){
			displayName = "none";
			ptr			= NULL;
			dataType	= GUI_VAR_FLOAT;		
			precision   = 7;
			autoUpdate  = true;		
		}

		guiStatVarPointer( string displayNameIn, void * varPtr, guiVarType theDataType, bool autoUpdateGraph, float floatPrecision = 7){
			displayName = displayNameIn;
			ptr			= varPtr;
			dataType	= theDataType;		
			precision   = floatPrecision;
			autoUpdate  = autoUpdateGraph;
		} 
	
		void setup( string displayNameIn, void * varPtr, guiVarType theDataType, bool autoUpdateGraph, float floatPrecision = 7){
			displayName = displayNameIn;
			ptr			= varPtr;
			dataType	= theDataType;		
			precision   = floatPrecision;
			autoUpdate  = autoUpdateGraph;
		} 
		
		void updateManually(){
			bDoUpdate = true;
		}

		bool autoUpdate;
		bool bDoUpdate;
};

class guiTypeChartPlotter : public guiBaseObject{

    public:

        guiTypeChartPlotter(){
			minVal = 0.0;
			maxVal = 1.0;
			maxNum = 100;
		}

        void setup(string elementName, guiStatVarPointer varPtr, float width, float height, int maxValues, float minValY, float maxValY){
			name		   = elementName;
			
			hitArea.width  = width;
			hitArea.height = height;
			
			minVal         = minValY;
			maxVal		   = maxValY;
			
			var			   = varPtr;
			maxNum		   = maxValues;
		}
		
		//-----------------------------------------------
		void update(){			
			updateBoundingBox();
			
			if( var.ptr == NULL ){
				ofLog(OF_LOG_ERROR, "guiTypeChartPlotter::update - variable ptr is not set!");
			}
			
			if( var.dataType == GUI_VAR_FLOAT ){
				var.varAsString = ofToString( *((float *)var.ptr), var.precision);
			}else if( var.dataType == GUI_VAR_INT ){
				var.varAsString = ofToString( *((int *)var.ptr));
			}
			
			if( var.autoUpdate || var.bDoUpdate ){
			
				float valIn = 0.0;
				
				if( var.dataType == GUI_VAR_FLOAT ){
					valIn = *( (float *)var.ptr) ;
				}else if( var.dataType == GUI_VAR_INT ){
					valIn = (int)( *( (int *)var.ptr) );
				}

				valueHistory.push_back( valIn );
				if( valueHistory.size() > maxNum ){
					valueHistory.erase(valueHistory.begin(), valueHistory.begin()+1);
				}
				
				var.bDoUpdate = false;
			}
			
		}
		
		//-----------------------------------------------
		void render(){
			ofPushStyle();
				glPushMatrix();
				
					glColor4fv(textColor.getColorF());				
					guiBaseObject::renderText();

					//draw the background
					ofFill();
					glColor4fv(bgColor.getColorF());
					ofRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
					
					float x = hitArea.x;
					float y = hitArea.y + hitArea.height;
					
					if( valueHistory.size() ){
						glColor4fv(fgColor.getSelectedColorF());
					
						ofNoFill();
						ofBeginShape();
						for(int i = 0; i < valueHistory.size(); i++){
							float xx = ofMap(i, 0, maxNum, x, x + hitArea.width, true);
							float yy = ofMap(valueHistory[i], minVal, maxVal, y, y - hitArea.height, true);
							
							ofVertex(xx, yy);
						}
						ofEndShape(false);
					}
					
					ofFill();

					glColor4fv(textColor.getColorF());				
					displayText.renderString(var.displayName + ": " + var.varAsString, x + 2, y - displayText.getTextSingleLineHeight()*3);
					displayText.renderString("max: "+ofToString(maxVal, 0), x + 2, hitArea.y + displayText.getTextSingleLineHeight()+2);
					displayText.renderString("min: "+ofToString(minVal, 0), x + 2, y - 8);
					
					//draw the outline
					ofNoFill();
					glColor4fv(outlineColor.getColorF());
					ofRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
				glPopMatrix();
			ofPopStyle();
		}
		
		float minVal, maxVal;
		vector <float> valueHistory;
		int maxNum;
		guiStatVarPointer var;
		
		
//        
//		void updateGui(float x, float y, bool firstHit, bool isRelative);
//        void setKnobSize(float _knobSize);
//        
//		virtual void setValue(float _value, int whichParam);
//        virtual void updateValue();
//		
//		virtual void notify();	
//		
//        void render();

};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeCustom.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "guiCustomImpl.h" */

class guiTypeCustom : public guiBaseObject{

     public:

        guiTypeCustom();
        void setup(string customName, guiCustomImpl * customIn, float panelWidth, float panelHeight);
        virtual void saveSettings();
        virtual void saveSettings(string filename);
        virtual void loadSettings(string filename);
        virtual void reloadSettings();
        virtual void update();
        void updateGui(float x, float y, bool firstHit, bool isRelative);
        virtual void release();
        void render();

        guiCustomImpl * custom;
};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeDrawable.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

//alows you to stack ofBaseDraw objects as layers on top of each other and then pass it to guiTypeDrawable::setup
//handy if you want to render drawing from one class ontop of a video of another class. 

class drawableStacker : public ofBaseDraws{
    public:

    void addDrawer(ofBaseDraws * drawer);

    void setWidth(float w);

    void setHeight(float h);

    float getWidth();

    float getHeight();

    void draw(float x, float y, float w, float h);
    void draw(float x, float y);

    vector <ofBaseDraws *> drawers;
    float width;
    float height;
};

//pass in any ofBaseDraws class ( videoPlayer, videoGrabber, image, or your own class ) 
class guiTypeDrawable : public guiBaseObject{

     public:

        guiTypeDrawable();

        void setup(string videoName, ofBaseDraws * vidIn, float videoWidth, float videoHeight);
        void updateGui(float x, float y, bool firstHit, bool isRelative);

        void render();

        ofBaseDraws * vid;
};


#line 0 "../addons-all/ofxControlPanel/src/guiTypeFileLister.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "simpleFileLister.h" */

class guiTypeFileLister : public guiBaseObject{

     public:

        guiTypeFileLister();
        void setup(string listerName, simpleFileLister * listerPtr , float listerWidth, float listerHeight);

        void updateGui(float x, float y, bool firstHit, bool isRelative);
        void release();
        void drawRecords(float x, float y, float width, float height);
        void render();

		void notify();
	
	void clearSelection();
	
			
		int lineSpacing;
		int dblClickTime;			

        int selection;
        int selectionTmp;
        long lastClickTime;
        bool usingSlider;
        float sliderWidth;
        float selectPct;
        float pct;
        int startPos, endPos;
        simpleFileLister * lister;
	
	
	bool hasSelectionChanged() { return selection_has_changed; }
	void clearSelectionChangedFlag() { selection_has_changed = false; }
	
private:
	
	bool selection_has_changed;
};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeLabel.h"
/*
 *  guiTypeLabel.h
 *  artvertiser
 *
 *  Created by damian on 10/10/10.
 *  Copyright 2010 frey damian@frey.co.nz. All rights reserved.
 *
 */

#pragma once


/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTypeLabel : public guiBaseObject{
	
public:
	
	//------------------------------------------------
	void setup(string text );
	void setText( string new_text );
	void render();
	
};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeLogger.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "simpleLogger.h" */

class guiTypeLogger : public guiBaseObject{

     public:

        guiTypeLogger();
        void setup(string loggerName, simpleLogger * logger, float loggerWidth, float loggerHeight);
        void updateGui(float x, float y, bool firstHit, bool isRelative);
        void drawRecords(float x, float y, float width, float height);
        void render();
		
		int toggle;
		float pct;
        simpleLogger * log;
};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeToggle.h"
#pragma once


/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTypeToggle : public guiBaseObject{

    public:

        //------------------------------------------------
        void setup(string toggleName, bool defaultVal);
        virtual void updateValue();
		virtual void updateText();
		void updateGui(float x, float y, bool firstHit, bool isRelative);
        void render();
		void notify();
	
	float getWidth() { return guiBaseObject::getWidth()+labelWidth; }
		
	int labelWidth;
		void updateBoundingBox();
};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeMultiToggle.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTypeMultiToggle : public guiBaseObject{

    public:
        static const int boxSpacing = 2;
        static const int boxSize = 14;

        //------------------------------------------------
        void setup(string multiToggleName, int defaultBox, vector <string> boxNames);

        //-----------------------------------------------
		void notify();

        //-----------------------------------------------
        virtual void updateValue();
        void updateGui(float x, float y, bool firstHit, bool isRelative);
        void render();
		
		vector <string> bNames;
};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeSlider.h"
#pragma once


/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTypeSlider : public guiBaseObject{

    public:

        //------------------------------------------------
        void setup(string sliderName, float defaultVal, float min, float max);

        virtual void updateValue();
		void updateGui(float x, float y, bool firstHit, bool isRelative = false);
		void render();

};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeButtonSlider.h"
#pragma once


/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "guiTypeToggle.h" */
/* #include "guiTypeSlider.h" */

#define INCREMENT 0.005f

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
class guiTypePlusButton : public guiTypeToggle{
    public:
        void render();
};

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

class guiTypeMinusButton : public guiTypeToggle{
    public:
        void render();
};

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
class guiTypeButtonSlider : public guiBaseObject{


     public:

        guiTypeButtonSlider();
		
        ~guiTypeButtonSlider();

        //------------------------------------------------
        void setup(string buttonSliderName, float panelWidth, float panelHeight, float defaultVal, float min, float max, bool isInt);
		
        //-----------------------------------------------
        virtual void saveSettings();
        virtual void saveSettings(string filename);
		virtual void loadSettings(string filename);
        virtual void reloadSettings();

        virtual void setValue(float _value, int whichParam);
        virtual void updateValue();

        virtual void update();		
        void updateGui(float x, float y, bool firstHit, bool isRelative);
        virtual void release();
        void render();

        guiTypeSlider*      slider;
        guiTypeMinusButton* leftButton;
        guiTypePlusButton*  rightButton;
        ofPoint             prevMouse;
        bool                leftButtonOn;

        float 	            timeNow, timeThen;

};

#line 0 "../addons-all/ofxControlPanel/src/guiTypePanel.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

#define LOCK_WIDTH 10
#define LOCK_HEIGHT 10
#define LOCK_BORDER 3

class guiTypePanel : public guiBaseObject{

    public:

        //------------------------------------------------
        guiTypePanel();

        void setup(string panelName, float defaultX = 20, float defaultY = 20);
        void addColumn(float minWidth);

        bool selectColumn(int which);
        void setElementSpacing(float spacingX, float spacingY);
		void setElementYSpacing( float spacingY ) { spacingAmntY = spacingY; }
        virtual bool checkHit(float x, float y, bool isRelative);

		/// add exactly this many pixels of space
		void addSpace( int height );
		/// add a region of blank space, height pixels high. will also add spacingAmntY space
		void addYBlank( float height ) { columns[col].y += height+spacingAmntY; }
        void updateGui(float x, float y, bool firstHit, bool isRelative);
        virtual void update();

        void addElement( guiBaseObject * element );
		void removeElement( guiBaseObject* element );
		bool containsElement( guiBaseObject* element );
		bool containsElement( string xmlName );
		guiBaseObject* getElement( string xmlName );
	
		void drawLocked();
        void drawUnlocked();
        void render();
	
        ofRectangle lockRect;

        float currentXPos;
        float currentYPos;
        float spacingAmntX;
        float spacingAmntY;

        vector <ofRectangle> columns;
        vector <int> whichColumn;
        int col;

};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeText.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiTypeText.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTypeText : public guiBaseObject, public guiTextBase{

    public:



};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeTextDropDown.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTypeTextDropDown : public guiBaseObject{

    public:

        //------------------------------------------------
        void setup(string dropDownName, int defaultBox, vector <string> boxNames);
        virtual void updateValue();
        virtual void update();
		virtual void updateText();
        virtual void release();
        void updateGui(float x, float y, bool firstHit, bool isRelative);
        void render();
	
		string getSelectedBoxName() { return vecDropList[value.getValueI()]; }; 

		void notify();

		void hideDropDown() { bShowDropDown = false; state = SG_STATE_NORMAL; }
	
		vector <string> vecDropList;
		bool    bShowDropDown;
};


#line 0 "../addons-all/ofxControlPanel/src/guiTypeTextInput.h"
#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */

class guiTypeTextInput : public guiBaseObject{

public:

	guiTypeTextInput(){
	}

	//------------------------------------------------
	void setup(string textInputName, string defaultVal);

	
	//--------------------------------------------
	void setFont(ofTrueTypeFont * fontPtr){
		displayText.setFont(fontPtr);
		valueText.setFont(fontPtr);
	}

	//--------------------------------------------
	void release();

	//-----------------------------------------------.
	void updateGui(float x, float y, bool firstHit, bool isRelative);

	
	//-----------------------------------------------.
	void render();
	
	// return true if we eat the key
	bool keyPressed( int k );


	/// deal with the actual value text being edited
	bool valueTextHasChanged() { return changed; }
	void clearValueTextChangedFlag() { changed = false; }
	string getValueText() { return valueText.textString; }
	void setValueText( string new_text );

	// don't append the selected number
	void updateText();

private:
	
	float mouseDraggedDeltaX;
	float preX;
	float selectDragStartX;
	float selectDragEndX;
	float startPositionX;
	float endPositionX;
	int startIndex;
	int endIndex;
	bool textSelected;
	bool changed;
	int text_position;
	guiTextBase valueText;
	

};



#line 0 "../addons-all/ofxControlPanel/src/guiTypeVairableLister.h"
/*
 *  guiTypeVairableLister.h
 *  ofxControlPanelDemo
 *
 *  Created by theo on 01/04/2010.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */

#pragma once

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "guiVariablePointer.h" */

class guiTypeVairableLister : public guiBaseObject{

    public:

        guiTypeVairableLister(){
			typeStartOffset = 0;
		}

        void setup(string listerName, vector <guiVariablePointer> & varsIn){
			name = listerName;
			vars = varsIn;
		}
		
		void update(){			
			updateBoundingBox();
		}
		
		void updateBoundingBox(){
		
			minNameWidth = 20;
			minVarWidth  = 20;
			
			if( displayText.usingTTF() ){
				typeStartOffset = -4;
			}else{
				typeStartOffset = -2;
			}
							
			for(int i = 0; i < vars.size(); i++){
				minNameWidth = MAX(minNameWidth, displayText.getTextWidth(vars[i].displayName));
				
				if( vars[i].dataType == GUI_VAR_FLOAT ){
					vars[i].varAsString = ofToString( *((float *)vars[i].ptr), vars[i].precision);
				}else if( vars[i].dataType == GUI_VAR_INT ){
					vars[i].varAsString = ofToString( *((int *)vars[i].ptr));
				}else if( vars[i].dataType == GUI_VAR_BOOL ){
					
					bool bVar = *((bool *)vars[i].ptr);
					if( bVar ){
						vars[i].varAsString = "true";
					}else{
						vars[i].varAsString = "false";						
					}
				}else if( vars[i].dataType == GUI_VAR_STRING ){
					vars[i].varAsString = *((string *)vars[i].ptr);
				}
				
				minVarWidth = MAX(minVarWidth, displayText.getTextWidth( "= " + vars[i].varAsString));
				
			}
			
			minNameWidth += 5;			
			minVarWidth  += 5;
			
			hitArea.width  = MAX(hitArea.width, minNameWidth + minVarWidth);
			hitArea.height = MAX(20, vars.size() * ( displayText.getTextSingleLineHeight() + 3));
			
			if(bShowText){
				//we need to update out hitArea because the text will have moved the gui down
				hitArea.y = boundingBox.y + displayText.getTextHeight() + titleSpacing;
				boundingBox.height = hitArea.height + displayText.getTextHeight() + titleSpacing;
			}else{
				 //we need to update out hitArea because the text will have moved the gui down
				hitArea.y = boundingBox.y;
			}
		}
		
		//-----------------------------------------------.
		void render(){
			ofPushStyle();
				glPushMatrix();
				
					glColor4fv(textColor.getColorF());				
					guiBaseObject::renderText();

					//draw the background
					ofFill();
					glColor4fv(bgColor.getColorF());
					ofRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);

					float lineH = hitArea.height / (float) MAX(1, vars.size());
					
					float x		= hitArea.x;
					float y		= (hitArea.y + lineH) + typeStartOffset;
					float ly	= (hitArea.y + lineH);
					
					//draw the foreground
					for(int i = 0; i < vars.size(); i++){
						
						if( i != vars.size()-1){
							glColor4fv(outlineColor.getColorF());
							ofLine(x, ly, x + hitArea.width, ly);
						}
						
						glColor4fv(textColor.getColorF());
						displayText.renderString(vars[i].displayName, x + 2, y + 3);
						displayText.renderString("= " + vars[i].varAsString, x + minNameWidth + 2, y + 3);

						y  += lineH;
						ly += lineH;
					}
					
					//draw the outline
					ofNoFill();
					glColor4fv(outlineColor.getColorF());
					ofRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
				glPopMatrix();
			ofPopStyle();
		}
				
		vector <guiVariablePointer> vars;
		float minNameWidth, minVarWidth;
		float typeStartOffset;
		
//        
//		void updateGui(float x, float y, bool firstHit, bool isRelative);
//        void setKnobSize(float _knobSize);
//        
//		virtual void setValue(float _value, int whichParam);
//        virtual void updateValue();
//		
//		virtual void notify();	
//		
//        void render();

};

#line 0 "../addons-all/ofxControlPanel/src/guiTypeVideo.h"
/*
 *  guiTypeVideo.h
 *  ofxControlPanelDemo
 *
 *  Created by theo on 23/03/2010.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */

/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "guiTypeDrawable.h" */

class guiTypeVideo : public guiTypeDrawable{
	
	public:
		 //------------------------------------------------
        void setup(string videoName, ofVideoPlayer * vidIn, float videoWidth, float videoHeight);
        void updateGui(float x, float y, bool firstHit, bool isRelative);
        void render();
		
		float pButtonX, pButtonY, pButtonW, pButtonH;	
		float scX, scY, scW, scH;	
		
		float scrubPct;
		bool playPause;
		ofVideoPlayer * video;
};

#line 0 "../addons-all/ofxControlPanel/src/ofxControlPanel.h"
#pragma once

/* #include "ofMain.h" */
/* #include "ofxXmlSettings.h" */
/* #include "guiIncludes.h" */


class xmlAssociation{
    public:
        xmlAssociation(guiBaseObject * objPtr, string xmlNameIn, int numParamsIn){
            guiObj      = objPtr;
            xmlName     = xmlNameIn;
            numParams   = numParamsIn;
        }

        guiBaseObject * guiObj;
        string xmlName;
        int numParams;
};

extern guiColor gTextColor;
extern guiColor gFgColor;
extern guiColor gBgColor;
extern guiColor gOutlineColor;

class ofxControlPanel: public guiBaseObject{

	public:
	
		static vector <ofxControlPanel *> globalPanelList;
		static ofxControlPanel * getPanelInstance(string panelName);

        static float borderWidth;
        static float topSpacing;
        static float tabWidth;
        static float tabHeight;

        ofxControlPanel();
        ~ofxControlPanel();

        void setup(string controlPanelName, float panelX, float panelY, float width, float height, bool doSaveRestore = true );
        void loadFont( string fontName, int fontsize );

        guiTypePanel * addPanel(string panelName, int numColumns, bool locked = false);
		
		int getSelectedPanel();
		void setSelectedPanel(int whichPanel);
		
        void setWhichPanel(int whichPanel);
        void setWhichPanel(string panelName);
        void setWhichColumn(int column);
		int getWhichPanel() { return currentPanel; }
		void setSize( int new_width, int new_height );

		string getCurrentPanelName();

        void setSliderWidth(int width);
		
		void enableIgnoreLayoutFlag(){
			bIgnoreLayout = true;
		}

		void disableIgnoreLayoutFlag(){
			bIgnoreLayout = false;
		}

		void setLayoutFlag( guiBaseObject * obj ){
			obj->bRemoveFromLayout = bIgnoreLayout;
		}

		static void setBackgroundColor(simpleColor color){
			gBgColor.color		= color;
			gBgColor.selected	= color;
		}
		
		static void setTextColor(simpleColor color){
			gTextColor.color	= color;
			gTextColor.selected = color;
		}

		static void setOutlineColor(simpleColor color){
			gOutlineColor.color		= color;
			gOutlineColor.selected	= color;
		}
		
		static void setForegroundColor(simpleColor color){
			gFgColor.color		= color;
			gFgColor.selected	= color;
		}
			
		static void setBackgroundColor(simpleColor color, simpleColor selectedColor){
			gBgColor.color		= color;
			gBgColor.selected	= selectedColor;
		}
		
		static void setTextColor(simpleColor color, simpleColor selectedColor){
			gTextColor.color	= color;
			gTextColor.selected = selectedColor;
		}

		static void setOutlineColor(simpleColor color, simpleColor selectedColor){
			gOutlineColor.color		= color;
			gOutlineColor.selected	= selectedColor;
		}

		static void setForegroundColor(simpleColor color, simpleColor selectedColor){
			gFgColor.color		= color;
			gFgColor.selected	= selectedColor;
		}
		
		// remove an object
		void removeObject( string xmlName );
        guiTypeToggle * addToggle(string name, string xmlName, bool defaultValue);
        guiTypeMultiToggle * addMultiToggle(string name, string xmlName, int defaultBox, vector <string> boxNames);
        guiTypeSlider * addSlider(string sliderName, string xmlName, float value , float min, float max, bool isInt);
        guiType2DSlider * addSlider2D(string sliderName, string xmlName, float valueX, float valueY, float minX, float maxX, float minY, float maxY, bool isInt);
        guiTypeDrawable * addDrawableRect(string name, ofBaseDraws * drawablePtr, int drawW, int drawH);
		guiTypeVideo * addVideoRect(string name, ofVideoPlayer * drawablePtr, int drawW, int drawH);
        guiTypeCustom * addCustomRect(string name, guiCustomImpl * customPtr, int drawW, int drawH);
        guiTypeButtonSlider * addButtonSlider(string sliderName, string xmlName, float value , float min, float max, bool isInt);
        guiTypeTextDropDown * addTextDropDown(string name, string xmlName, int defaultBox, vector <string> boxNames);
        guiTypeVairableLister * addVariableLister(string name, vector <guiVariablePointer> & varsIn);
		guiTypeChartPlotter * addChartPlotter(string name, guiStatVarPointer varPtr, float width, float height, int maxNum, float minYVal, float maxYVal);
		guiTypeLogger * addLogger(string name, simpleLogger * logger, int drawW, int drawH);
		guiTypeFileLister * addFileLister(string name, simpleFileLister * lister, int drawW, int drawH);
		guiTypeLabel * addLabel( string text );
		guiTypeTextInput* addTextInput( string name, string text, int width );
		
		void setupEvents();
		ofEvent <guiCallbackData> & createEventGroup(string eventGroupName, vector <string> xmlNames);
		ofEvent <guiCallbackData> & createEventGroup(string xmlName);

		void enableEvents();
		void disableEvents();
		ofEvent <guiCallbackData> & getEventsForPanel(int panelNo);
		ofEvent <guiCallbackData> & getAllEvents();
		ofEvent <guiCallbackData> & getEventGroup(string eventGroupName);


        void setValueB(string xmlName, bool value,  int whichParam = 0);
        void setValueI(string xmlName, int value,  int whichParam = 0);
        void setValueF(string xmlName, float value,  int whichParam = 0);
        bool getValueB(string xmlName, int whichParam = 0);
        float getValueF(string xmlName, int whichParam = 0);
        int getValueI(string xmlName, int whichParam = 0);

		bool hasValueChanged(string xmlName, int whichParam = 0);
		bool hasValueChangedInPanel(string whichPanel);
		bool newPanelSelected();		
		
		void clearAllChanged();
		
        void setIncrementSave(string incrmentalFileBaseName);
        void disableIncrementSave();
        void loadSettings(string xmlFile);
        void reloadSettings();
        void saveSettings(string xmlFile, bool bUpdateXmlFile = true);
        void saveSettings();
        void setXMLFilename(string xmlFile);

        void setDraggable(bool bDrag);
        void setMinimized(bool bMinimize);
        void show();
        void hide();

        void toggleView();
        bool mousePressed(float x, float y, int button);
        bool mouseDragged(float x, float y, int button);
        void mouseReleased();
		/// return true if we consume the keypress
		bool keyPressed( int k );

        void updateBoundingBox();
        void update();
        void draw();

        ofTrueTypeFont guiTTFFont;

        vector <xmlAssociation> xmlObjects;
        vector <guiBaseObject *> guiObjects;
        vector <guiTypePanel *> panels;
        vector <ofRectangle> panelTabs;
		
		vector <guiCustomEvent *> customEvents;

		ofxXmlSettings settings;
		string currentXmlFile;
		string settingsDirectory;

		ofRectangle topBar;
		ofRectangle minimizeButton;
		ofRectangle saveButton;
		ofRectangle restoreButton;

        string incrementSaveName;

        bool hidden;
        bool usingXml;
        bool bUseTTFFont;
		bool minimize;
		bool saveDown;
		bool incrementSave;
		bool restoreDown;
		bool bDraggable;
	
	bool bDoSaveRestore;

		int selectedPanel;
        int currentPanel;

        ofPoint prevMouse;

		int sliderWidth;
		
		bool bEventsSetup;
		bool eventsEnabled;
		bool bIgnoreLayout;
		
		ofPoint mouseDownPoint;

		bool dragging;
		bool bNewPanelSelected;
		
		protected:
			void eventsIn(guiCallbackData & data);

private:
	void addXmlAssociation( guiBaseObject* object, string xmlName, int defaultValue );
		

};

#line 0 "../addons-all/ofxControlPanel/src/ofxAutoControlPanel.h"
#pragma once

/*
 r4
 
 ofxAutoControlPanel makes ofxControlPanel a little easier to work with.
 
 the control panel is autoamtically toggle-able using the tab key.
 the panel is hooked up to mouse, draw, and update events automatically.
 addPanel() does an addPanel() followed by a setWhichPanel() to avoid redundancy and mistakes.
 the fps is autoamtically drawn at the lower right corner of the screen.
 */

/* #include "ofxControlPanel.h" */
/* #include "ofEvents.h" */

#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
template <typename T>
struct variadic_ : public vector<T> {
	variadic_(const T& t) {
		(*this)(t);
	}
	variadic_& operator()(const T& t) {
		this->push_back(t);
		return *this;
	}
};

typedef variadic_<string> variadic;

class ofxAutoControlPanel : public ofxControlPanel {
public:
	string msg;
	
	ofxAutoControlPanel() {
		msg = "";
		setXMLFilename("settings.xml");
		ofAddListener(ofEvents().update, this, &ofxAutoControlPanel::update);
		ofAddListener(ofEvents().draw, this, &ofxAutoControlPanel::draw);
		ofAddListener(ofEvents().keyPressed, this, &ofxAutoControlPanel::keyPressed);
		ofAddListener(ofEvents().mousePressed, this, &ofxAutoControlPanel::mousePressed);
		ofAddListener(ofEvents().mouseReleased, this, &ofxAutoControlPanel::mouseReleased);
		ofAddListener(ofEvents().mouseDragged, this, &ofxAutoControlPanel::mouseDragged);
	}
	void setup() {
		ofxControlPanel::setup("Control Panel", 5, 5, 280, 600);
	}
	void setup(int width, int height) {
		ofxControlPanel::setup("Control Panel", 5, 5, width, height);
	}
	void update(ofEventArgs& event) {
		ofxControlPanel::update();
	}
	void draw(ofEventArgs& event) {
		if(!hidden) {
			ofPushMatrix();
			ofSetupScreenPerspective();
			glPushAttrib(GL_ENABLE_BIT);
			glDisable(GL_DEPTH_TEST);
			ofPushStyle();
			ofPushMatrix();
			ofTranslate(.5, .5);
			ofxControlPanel::draw();
			ofPopMatrix();
			if(msg != "") {
				ofSetColor(0);
				ofFill();
				int textWidth =  10 + msg.length() * 8;
				ofRect(5, ofGetHeight() - 22, textWidth, 20);
				ofSetColor(255, 255, 255);
				ofDrawBitmapString(msg, 10, ofGetHeight() - 10);
			}
			
			ofSetColor(255);
			ofFill();
			ofRect(ofGetWidth() - 45, ofGetHeight() - 25, 40, 20);
			ofSetColor(0);
			ofDrawBitmapString(ofToString((int) ofGetFrameRate()), ofGetWidth() - 40, ofGetHeight() - 10);
			ofPopStyle();
			glPopAttrib();
			ofPopMatrix();
		}
	}
	using ofxControlPanel::hasValueChanged;
	// usage: panel.hasValueChanged(variadic(1)(2)(3)(4)(5));
	bool hasValueChanged(const vector<string>& values) {
		for(int i = 0; i < values.size(); i++) {
			string cur = values[i];
			if(ofxControlPanel::hasValueChanged(cur)) {
				return true;
			}
		}
		return false;
	}
	void keyPressed(ofKeyEventArgs& event) {
		if(event.key == '\t') {
			if(hidden) {
				show();
			} else {
				hide();
			}
		}
		if(event.key == 'f') {
			ofToggleFullscreen();
		}
	}
	void show() {
		ofxControlPanel::show();
		//ofShowCursor();
	}
	void hide() {
		ofxControlPanel::hide();
		//ofHideCursor();
	}
	void mousePressed(ofMouseEventArgs& event) {
		ofxControlPanel::mousePressed(event.x, event.y, event.button);
	}
	void mouseReleased(ofMouseEventArgs& event) {
		ofxControlPanel::mouseReleased();
	}
	void mouseDragged(ofMouseEventArgs& event) {
		ofxControlPanel::mouseDragged(event.x, event.y, event.button);
	}
	
	// by default, make sliders float
	using ofxControlPanel::addSlider;
	void addSlider(string name, string xmlName, float value, float low, float high, bool isInt = false) {
		ofxControlPanel::addSlider(name, xmlName, value, low, high, isInt);
	}
	void addSlider(string name, float value, float low, float high, bool isInt = false) {
		ofxControlPanel::addSlider(name, name, value, low, high, isInt);
	}
	using ofxControlPanel::addToggle;
	void addToggle(string name, bool value = false) {
		ofxControlPanel::addToggle(name, name, value);
	}
	using ofxControlPanel::addMultiToggle;
	void addMultiToggle(string name, int initial, vector<string> values) {
		ofxControlPanel::addMultiToggle(name, name, initial, values);
	}
	using ofxControlPanel::addPanel;
	void addPanel(string panelName, int columns = 1) {
		ofxControlPanel::addPanel(panelName, columns);
		ofxControlPanel::setWhichPanel(panelName);
	}
};

#line 0 "../addons-all/ofxControlPanel/src/guiIncludes.h"

//fundementals
/* #include "guiValue.h" */
/* #include "guiBaseObject.h" */
/* #include "guiColor.h" */
/* #include "simpleColor.h" */
/* #include "guiValue.h" */
/* #include "guiVariablePointer.h" */

//interface
/* #include "guiTypePanel.h" */

//elements
/* #include "guiTypeText.h" */
/* #include "guiTypeToggle.h" */
/* #include "guiTypeMultiToggle.h" */
/* #include "guiTypeSlider.h" */
/* #include "guiType2DSlider.h" */
/* #include "guiTypeDrawable.h" */
/* #include "guiTypeButtonSlider.h" */
/* #include "guiTypeTextDropDown.h" */
/* #include "guiTypeCustom.h" */
/* #include "guiCustomImpl.h" */
/* #include "guiTypeVideo.h" */
/* #include "guiTypeVairableLister.h" */
/* #include "guiTypeChartPlotter.h" */
/* #include "guiTypeLogger.h" */
/* #include "guiTypeFileLister.h" */
/* #include "guiTypeLabel.h" */
/* #include "guiTypeTextInput.h" */



#line 0 "../addons-all/ofxGuiExtended/src/DOM/Types.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


#include <type_traits>
#include <utility>
#include <typeinfo>
#include <string>
#include <cassert>
/* #include "ofPoint.h" */
/* #include "ofRectangle.h" */
/* #include "ofTypes.h" */


namespace DOM {


class Element;


typedef ofPoint Position;
typedef ofPoint Size;
typedef ofRectangle Shape;

/// \brief The orientation of a Widget.
/// \todo Replace this with ofOrientation.

//    OF_ORIENTATION_DEFAULT = 1,
//    OF_ORIENTATION_180 = 2,
//    OF_ORIENTATION_90_LEFT = 3,
//    OF_ORIENTATION_90_RIGHT = 4,
//    OF_ORIENTATION_UNKNOWN = 5

enum class Orientation
{
	/// \brief Locks the Orientation to landscape.
	HORIZONTAL,
	/// \brief Locks the Orientation to portrait.
	VERTICAL,
	/// \brief Sets the Orientation based on the aspect ratio.
	DEFAULT
};

/// \brief The float of a gui element in a layout.
enum class LayoutFloat {
	/// \brief Left float.
	LEFT,
	/// \brief Right float.
	RIGHT,
	/// \brief No float.
	NONE
};

/// \brief The position type of a gui element in a layout.
enum class LayoutPosition {
	/// \brief Element is positioned by the floating attribute depending of the positions of its siblings.
	POSITION_STATIC,
	/// \brief Element is positioned by its position independent of siblings.
	POSITION_ABSOLUTE
};

template <class T>
using StorageType = typename std::decay<T>::type;

/// \brief C++11 Any class.
/// \sa https://codereview.stackexchange.com/questions/20058/c11-any-class
/// \note This class may change in the near future.
struct Any
{
	bool is_null() const { return !ptr; }
	bool not_null() const { return ptr; }

	template <typename U> Any(U&& value)
	: ptr(new Derived<StorageType<U>>(std::forward<U>(value)))
	{
	}

	template <class U> bool is() const
	{
		typedef StorageType<U> T;

		auto derived = dynamic_cast<Derived<T>*> (ptr);

		return derived;
	}

	template <class U>
	StorageType<U>& as()
	{
		typedef StorageType<U> T;

		auto derived = dynamic_cast<Derived<T>*> (ptr);

		if (!derived)
			throw std::bad_cast();

		return derived->value;
	}

	template <class U>
	operator U()
	{
		return as<StorageType<U>>();
	}

	Any(): ptr(nullptr)
	{
	}

	Any(Any& that): ptr(that.clone())
	{

	}

	Any(Any&& that): ptr(that.ptr)
	{
		that.ptr = nullptr;
	}

	Any(const Any& that): ptr(that.clone())
	{
	}


	Any(const Any&& that): ptr(that.clone())
	{
	}


	Any& operator=(const Any& a)
	{
		if (ptr == a.ptr)
			return *this;

		auto old_ptr = ptr;

		ptr = a.clone();

		if (old_ptr)
			delete old_ptr;

		return *this;
	}

	Any& operator=(Any&& a)
	{
		if (ptr == a.ptr)
			return *this;

		std::swap(ptr, a.ptr);

		return *this;
	}

	~Any()
	{
		if (ptr)
			delete ptr;
	}

private:
	struct Base
	{
		virtual ~Base() {}

		virtual Base* clone() const = 0;
	};

	template <typename T>
	struct Derived: Base
	{
		template <typename U> Derived(U&& value) : value(std::forward<U>(value)) { }

		T value;

		Base* clone() const { return new Derived<T>(value); }
	};

	Base* clone() const
	{
		if (ptr)
			return ptr->clone();
		else
			return nullptr;
	}

	Base* ptr;
};


} // namespace DOM

#line 0 "../addons-all/ofxGuiExtended/src/DOM/Exceptions.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


#include <stdexcept>
#include <string>


namespace DOM {


/// \brief A generic DOM exception.
class DOMException: public std::runtime_error
{
public:
	using std::runtime_error::runtime_error;

	/// \brief Invalid pointer id exception.
	static const std::string INVALID_POINTER_ID;

	/// \brief Invalid state exception.
	static const std::string INVALID_STATE_ERROR;

	/// \brief Unregistered event exception.
	static const std::string UNREGISTERED_EVENT;

	/// \brief Invalid attribute key exception.
	static const std::string INVALID_ATTRIBUTE_KEY;

};


} // namespace DOM

#line 0 "../addons-all/ofxGuiExtended/src/DOM/Events.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


#include <string>
#include <type_traits>
#include <utility>
#include <ctime>
/* #include "ofEvents.h" */
/* #include "Exceptions.h" */
/* #include "Types.h" */


namespace DOM {


class Element;


/// \brief The base type describing a named Element Event.
///
/// \sa http://www.w3.org/TR/DOM-Level-3-Events/
class EventArgs
{
public:
	/// \brief Create EventArgs with a type.
	/// \param type The event type string (case-insensitive).
	/// \param source The source of the event.
	/// \param target The target element.
	/// \param bubbles True iff the argument bubbles after AT_TARGET phase.
	/// \param cancelable True iff the event can be cancelled by a listener.
	/// \param timestamp The timestamp of the event.
	EventArgs(const std::string& type,
			  Element* source,
			  Element* target,
			  bool bubbles,
			  bool cancelable,
			  uint64_t timestamp);

	/// \brief Create EventArgs with a type.
	/// \param type The event type string (case-insensitive).
	/// \param source The source of the event.
	/// \param target The target element.
	/// \param bubbles True iff the argument bubbles after AT_TARGET phase.
	/// \param cancelable True iff the event can be cancelled by a listener.
	/// \param timestamp The timestamp of the event.
	EventArgs(const std::string& type,
			  Element* source,
			  Element* target,
			  Element* relatedTarget,
			  bool bubbles,
			  bool cancelable,
			  uint64_t timestamp);

	/// \brief Destroy the EventArgs.
	virtual ~EventArgs();

	/// \brief Get the event type.
	/// \returns the event type string.
	const std::string& type() const;

	enum class Phase
	{
		/// \brief Events not currently dispatched are in this phase.
		NONE = 0,
		/// \brief When an event is dispatched to an object that participates in a tree it will be in this phase before it reaches its target attribute value.
		CAPTURING_PHASE = 1,
		/// \brief When an event is dispatched it will be in this phase on its target attribute value.
		AT_TARGET = 2,
		/// \brief When an event is dispatched to an object that participates in a tree it will be in this phase after it reaches its target attribute value.
		BUBBLING_PHASE = 3
	};


	/// \brief Stop the propagation of the event.
	///
	/// The stopPropagation method is used prevent further propagation of an
	/// event during event flow. If this method is called by any EventListener
	/// the event will cease propagating through the tree. The event will
	/// complete dispatch to all listeners on the current EventTarget before
	/// event flow stops. This method may be used during any stage of event
	/// flow.
	void stopPropagation();

	// \brief Stop the propagation of the event, including all other events at the target.
	//
	// If successful this event throws ofEventAttendedException(). This exception
	// should be handled gracefully by the ofEvent dispatching this event.
	//
	// The same effect can be achieved by returning "true" from any event
	// callback with a boolean return type.
	//
	// \throws ofEventAttendedException if the event is cancelable.
	void stopImmediatePropagation();

	/// \brief Prevent any default actions associated with the event.
	///
	/// For some events, there are default actions.  Calling preventDefault will
	/// tell the event dispatcher that it should not call the default action
	/// after the event has been dispatched.  This is different from
	/// stopPropagation.  Calling stopPropagation does not prevent the default
	/// action from taking place.  To stop propagation and prevent the default,
	/// both methods must be called.
	void preventDefault();

	/// \returns true iff the event was cancelled.
	bool isCancelled() const;

	/// \returns true iff the default activity was prevented.
	bool isDefaultPrevented() const;

	/// \brief Set the Phase of the event.
	/// \param phase The phase to set.
	void setPhase(Phase phase);

	/// \returns the Phase of the event.
	Phase getPhase() const;

	/// \brief Determine if the event has a bubbling phase.
	/// \returns true iff the event should bubble.
	bool bubbles() const;

	/// \returns true iff the Event can be cancelled.
	bool isCancelable() const;

	/// \returns the source Element.
	Element* source();

	/// \returns the target Element.
	Element* target();

	/// \returns the related target Element.
	Element* relatedTarget();

	/// \returns a pointer to the current target Element.
	Element* getCurrentTarget();

	/// \returns a pointer to the current target Element.
	const Element* getCurrentTarget() const;

	/// \brief Set the current target Element.
	/// \param target The current target Element.
	void setCurrentTarget(Element* target);

	/// \returns the timestamp (in milliseconds relative to the epoch).
	uint64_t timestamp() const;

	/// \brief A utility method to print get the Event as a std::string.
	/// \returns The Event as a std::string.
	/// \note Not for serialization.
	std::string toString() const;

protected:
	/// \brief The name of the event (case-insensitive).
	std::string _type;

	/// \brief The source of the event.
	Element* _source = nullptr;

	/// \brief The event's target.
	Element* _target = nullptr;

	/// \brief The event's related target.
	Element* _relatedTarget = nullptr;

	/// \brief Used to indicate whether or not an event is a bubbling event.
	/// If the event can bubble the value is true, else the value is false.
	bool _bubbles = true;

	/// \brief Used to indicate whether propgation was stopped.  The currentTarget
	/// will indicate which target stopped propagation.
	bool _cancelable = true;

	/// \brief Used to indicated
	bool _defaultPrevented = false;

	/// \brief Used to indicate the EventTarget whose EventListeners are currently being processed.
	/// This is particularly useful during capturing and bubbling.
	Element* _currentTaget  = nullptr;

	/// \brief Used to indicate which phase of event flow is currently being evaluated.
	Phase _phase = Phase::NONE;

	/// \brief Used to indicate if an event is canceled.
	bool _canceled = false;

	/// \brief Used to specify the time (in milliseconds relative to the epoch)
	/// at which the event was created.
	///
	/// Due to the fact that some systems may not provide this information the
	/// value of timeStamp may be not available for all events. When not
	/// available, a value of 0 will be returned. Examples of epoch time are
	/// the time of the system start or 0:0:0 UTC 1st January 1970.
	uint64_t _timestamp = 0;

	/// \brief The Document class has access to Event data.
	friend class Document;
};


/// can we handle this named ui event at this coordinate?
class UIEventArgs: public EventArgs
{
public:
	using EventArgs::EventArgs;

	virtual ~UIEventArgs()
	{
	}

};


class KeyboardUIEventArgs: public UIEventArgs
{
public:
	KeyboardUIEventArgs(const ofKeyEventArgs& args,
						Element* source,
						Element* target);

	virtual ~KeyboardUIEventArgs();

	const ofKeyEventArgs& key() const;

	static const std::string KEY_DOWN;
	static const std::string KEY_UP;

protected:
	ofKeyEventArgs _key;

};


/// \sa http://www.w3.org/TR/DOM-Level-3-Events/#event-type-focus
class FocusEventArgs: public EventArgs
{
public:
	FocusEventArgs(const std::string& type,
				   Element* source,
				   Element* target,
				   Element* relatedTarget = nullptr);

	virtual ~FocusEventArgs();

	static const std::string FOCUS_IN;
	static const std::string FOCUS;
	static const std::string FOCUS_OUT;
	static const std::string BLUR;

};


class DragDropEventArgs: public EventArgs
{
public:

};


class AbstractDOMEvent
{
public:
	virtual ~AbstractDOMEvent()
	{
	}
};



class BaseDOMEvent
{
public:
	virtual ~BaseDOMEvent()
	{
	}

	//virtual std::string type() const = 0;

	virtual bool hasBubblePhaseListeners() const = 0;
	virtual bool hasCapturePhaseListeners() const = 0;

	bool hasListeners() const
	{
		return hasBubblePhaseListeners() || hasCapturePhaseListeners();
	}

};


/// \brief DOM Events follow the DOM capture, target, bubble propagation scheme.
///
///
template <typename EventArgsType>
class DOMEvent: public BaseDOMEvent
{
public:
	virtual ~DOMEvent()
	{
	}

	bool hasBubblePhaseListeners() const override
	{
		return _bubbleEvent.size() > 0;
	}

	bool hasCapturePhaseListeners() const override
	{
		return _captureEvent.size() > 0;
	}

	ofEvent<EventArgsType>& event(bool useCapture = false)
	{
		return useCapture ? _captureEvent : _bubbleEvent;
	}

	void notify(EventArgsType& e)
	{
		switch (e.getPhase())
		{
			case EventArgs::Phase::NONE:
				throw DOMException(DOMException::INVALID_STATE_ERROR + ": " + "DOMEvent::notify");
			case EventArgs::Phase::CAPTURING_PHASE:
				_captureEvent.notify(e.source(), e);
				return;
			case EventArgs::Phase::AT_TARGET:
				_captureEvent.notify(e.source(), e);
				_bubbleEvent.notify(e.source(), e);
				return;
			case EventArgs::Phase::BUBBLING_PHASE:
				_bubbleEvent.notify(e.source(), e);
				return;
		}
	}

private:
	ofEvent<EventArgsType> _bubbleEvent;
	ofEvent<EventArgsType> _captureEvent;

};


class MoveEventArgs
{
public:
	MoveEventArgs(const Position& position, Element* element);
	virtual ~MoveEventArgs();

	const Position& position() const;
	Element* element();

protected:
	Position _position;
	Element* _element;

};

class ResizeEventArgs
{
public:
	ResizeEventArgs(const Shape& shape);
	virtual ~ResizeEventArgs();

	const Shape& shape() const;

protected:
	Shape _shape;

};


class AttributeEventArgs
{
public:
	AttributeEventArgs(const std::string& key, const Any& value = Any());

	virtual ~AttributeEventArgs();

	const std::string& key() const;

	const Any& value() const;

protected:
	std::string _key;
	Any _value;

};


class EnablerEventArgs
{
public:
	EnablerEventArgs(bool value);
	virtual ~EnablerEventArgs();

	bool value() const;

protected:
	bool _value;

};


class ElementEventArgs
{
public:
	ElementEventArgs(Element* element);

	virtual ~ElementEventArgs();

	Element* element();

protected:
	Element* _element;

};


class ElementOrderEventArgs: public ElementEventArgs
{
public:
	ElementOrderEventArgs(Element* element,
						  std::size_t oldIndex,
						  std::size_t newIndex);

	virtual ~ElementOrderEventArgs();

	std::size_t newIndex() const;

	std::size_t oldIndex() const;

	bool wasMovedForward() const;

	bool wasMovedBackward() const;

	bool isAtFront() const;

	bool isAtBack() const;

protected:
	std::size_t _oldIndex;
	std::size_t _newIndex;

};


} // namespace DOM

#line 0 "../addons-all/ofxGuiExtended/src/DOM/EventTarget.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once

#include <unordered_map>
#include <string>
#include <vector>
/* #include "Events.h" */


namespace DOM {


/// \brief A class representing an EventTarget.
///
/// EventTargets know how to handle events. This class is usually inherited
/// using the curiously-recurring template pattern.
///
/// \tparam EventTargetType The type of the Tvent target.
template <class EventTargetType>
class EventTarget
{
public:
	/// \brief Create an EventTarget.
	EventTarget();

	/// \brief Destroy the EventTarget.
	virtual ~EventTarget();

	template <class EventType, typename ArgumentsType, class ListenerClass>
	void addEventListener(EventType& event,
						  void (ListenerClass::*listenerMethod)(const void*, ArgumentsType&),
						  bool useCapture = false,
						  int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofAddListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}

	template <class EventType, typename ArgumentsType, class ListenerClass>
	void addEventListener(EventType& event,
						  void (ListenerClass::*listenerMethod)(ArgumentsType&),
						  bool useCapture = false,
						  int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofAddListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}

	template <class EventType, typename ArgumentsType, class ListenerClass>
	void addEventListener(EventType& event,
						  bool (ListenerClass::*listenerMethod)(const void*, ArgumentsType&),
						  bool useCapture = false,
						  int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofAddListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}

	template <class EventType, typename ArgumentsType, class ListenerClass>
	void addEventListener(EventType& event,
						  bool (ListenerClass::*listenerMethod)(ArgumentsType&),
						  bool useCapture = false,
						  int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofAddListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}

	template <class EventType, typename ArgumentsType, class ListenerClass>
	void removeEventListener(EventType& event,
							 void (ListenerClass::*listenerMethod)(const void*, ArgumentsType&),
							 bool useCapture = false,
							 int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofRemoveListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}

	template <class EventType, typename ArgumentsType, class ListenerClass>
	void removeEventListener(EventType& event,
							 void (ListenerClass::*listenerMethod)(ArgumentsType&),
							 bool useCapture = false,
							 int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofRemoveListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}


	template <class EventType, typename ArgumentsType, class ListenerClass>
	void removeEventListener(EventType& event,
							 bool (ListenerClass::*listenerMethod)(const void*, ArgumentsType&),
							 bool useCapture = false,
							 int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofRemoveListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}


	template <class EventType, typename ArgumentsType, class ListenerClass>
	void removeEventListener(EventType& event,
							 bool (ListenerClass::*listenerMethod)(ArgumentsType&),
							 bool useCapture = false,
							 int priority = OF_EVENT_ORDER_AFTER_APP)
	{
		ofRemoveListener(event.event(useCapture), dynamic_cast<ListenerClass*>(this), listenerMethod, priority);
	}

	/// \brief Dispatch the given event.
	///
	/// This will return true if the default action for this event should be
	/// prevented.
	///
	/// \param event The Event to dispatch.
	/// \tparam EventType The Event type to dispatch.
	/// \returns true iff one of the responders called Event::preventDefault().
	template <class EventType>
	bool dispatchEvent(EventType& event);

	/// \brief Handle the given event.
	///
	/// This will return true if the default action for this event should be
	/// prevented.
	///
	/// \tparam EventArgsType The EventArgs type to dispatch.
	/// \param event The Event to dispatch.
	/// \returns true if the EventTarget was registered to handle the event.
	template <class EventArgsType>
	bool handleEvent(EventArgsType& e);

	/// \brief Determine if the EventTarget has listeners for an event.
	/// \param event The event name.
	/// \returns true if it has registered listeners for this event.
	bool hasListenersForEventType(const std::string& type) const;

	/// \brief Determine if the EventTarget is registered to receive the type of events.
	/// \param type The event type.
	/// \returns true if it is registered to receive the type of events.
	bool isEventTypeRegistered(const std::string& type) const;

	/// \brief Register a new event type by name.
	/// \param type The event type.
	/// \param event A pointer to the DOMEvent<> that will be called.
	void registerEventType(const std::string& type, BaseDOMEvent* event);

	/// \brief Unregister a new event type by name.
	/// \param type The event type.
	void unregisterEventType(const std::string& type);

	virtual void onSetup()
	{
	}

	virtual void onUpdate()
	{
	}

	virtual void onExit()
	{
	}

	DOMEvent<KeyboardUIEventArgs> keyDown;
	DOMEvent<KeyboardUIEventArgs> keyUp;

	DOMEvent<FocusEventArgs> blur;
	DOMEvent<FocusEventArgs> focusIn;
	DOMEvent<FocusEventArgs> focus;
	DOMEvent<FocusEventArgs> focusOut;

	ofEvent<ElementEventArgs> addedTo;
	ofEvent<ElementEventArgs> removedFrom;
	ofEvent<ElementOrderEventArgs> reordered;

	ofEvent<ElementEventArgs> siblingAdded;
	ofEvent<ElementEventArgs> siblingRemoved;
	ofEvent<ElementOrderEventArgs> siblingReordered;

	ofEvent<ElementEventArgs> childAdded;
	ofEvent<ElementEventArgs> childRemoved;
	ofEvent<ElementOrderEventArgs> childReordered;
	ofEvent<MoveEventArgs> childMoved;

	ofEvent<MoveEventArgs> move;
	ofEvent<ResizeEventArgs> resize;

	ofEvent<AttributeEventArgs> attributeSet;
	ofEvent<AttributeEventArgs> attributeCleared;

	ofEvent<EnablerEventArgs> enabled;
	ofEvent<EnablerEventArgs> locked;
	ofEvent<EnablerEventArgs> hidden;

protected:
	std::unordered_map<std::string, BaseDOMEvent*> _eventRegistry;

};


template <class EventTargetType>
EventTarget<EventTargetType>::EventTarget()
{
	// Register default events.
	// TODO: do we want to automatically register all of these events?
	// TODO: do we need the event target to have all of these events, or could
	// it be on more of an ad hoc basis ... could be a speed optimization not
	// to have each one.

	// theoretically not having any events registered woudl make isEventTypeRegistered much faster.
	_eventRegistry = {

		{ KeyboardUIEventArgs::KEY_DOWN, &keyDown },
		{ KeyboardUIEventArgs::KEY_UP, &keyUp }
	};
}


template <class EventTargetType>
EventTarget<EventTargetType>::~EventTarget()
{
}


template <class EventTargetType>
template <class EventType>
bool EventTarget<EventTargetType>::dispatchEvent(EventType& event)
{
	// Get the target (this Element).
	EventTargetType* target = dynamic_cast<EventTargetType*>(this);

	// Create the path from the target to the document.
	std::vector<EventTargetType*> targets;

	// The target will be at the beginning of the list.
	// The root document will be at the end of the list.
	do
	{
		targets.push_back(target);
		target = target->parent();
	}
	while (target);


	// Capture and Target phase (document -> target).

	// Begin with the document (at the end of the list).
	auto riter = targets.rbegin();

	// Cycle through the targets from the document to the event.target().
	while (riter != targets.rend())
	{
		event.setPhase(event.target() == *riter ? EventArgs::Phase::AT_TARGET : EventArgs::Phase::CAPTURING_PHASE);
		event.setCurrentTarget(*riter);

		// Here we handle event and assume that if the currentTarget
		// can't handle the event, it will return quickly with no errors.
		// This is potentially faster that asking the target to search its
		// registry and then asking it to search its registry _again_ to
		// actually handle the event.
		bool isRegisteredHandler = (*riter)->handleEvent(event);

		// If the event is cancelled, return appropriately.
		if (event.isCancelled())
		{
			return !event.isDefaultPrevented();
		}

		// TODO
		if (!isRegisteredHandler)
		{
			// Here we might remove any listeners from the list of targets that cannot handle ... ?
			// Does this prevent us from dynamically adding and removing listeners between the
			// bubble and capture phases though?
		}

		// Continue iterating.
		++riter;
	}

	// Bubble phase if needed (target -> document).
	if (targets.size() > 1 && event.bubbles())
	{
		// Begin with the _parent_ of the target element (we already dealt
		// with the target element during the capture / target phased).
		auto bubbleIter = targets.begin() + 1;

		while (bubbleIter != targets.end())
		{
			event.setPhase(EventArgs::Phase::BUBBLING_PHASE);

			event.setCurrentTarget(*bubbleIter);

			// Here we handle event and assume that if the currentTarget
			// can't handle the event, it will return quickly with no errors.
			// This is potentially faster that asking the target to search its
			// registry and then asking it to search its registry _again_ to
			// actually handle the event.
			(*bubbleIter)->handleEvent(event);

			if (event.isCancelled())
			{
				return !event.isDefaultPrevented();
			}

			++bubbleIter;
		}
	}

	return event.isDefaultPrevented();
}


template <class EventTargetType>
bool EventTarget<EventTargetType>::hasListenersForEventType(const std::string& type) const
{
	auto iter = _eventRegistry.find(type);

	if (iter != _eventRegistry.end())
	{
		return iter->second->hasListeners();
	}
	else
	{
		return false;
	}
}


template <class EventTargetType>
template <class EventArgsType>
bool EventTarget<EventTargetType>::handleEvent(EventArgsType& e)
{



	auto iter = _eventRegistry.find(e.type());

	if (iter != _eventRegistry.end())
	{
		DOMEvent<EventArgsType>* _event = dynamic_cast<DOMEvent<EventArgsType>*>(iter->second);

		if (_event)
		{
//            if (e.type() == "buttonpressed")
//            {
//                cout << "event: " << e.type() << " being handled by : " << (e.getCurrentTarget() ? e.getCurrentTarget()->getId() : "nullptr") << endl;
//                cout << " hasListeners -> " << _event->hasListeners() << std::endl;
//                cout << " e -> " << e.toString() << std::endl;
//            }
			_event->notify(e);
			return true;
		}
		else
		{
			throw DOMException(DOMException::INVALID_STATE_ERROR + ": " + "EventTarget::handleEvent: " + e.type() + " invalid listener registered.");
		}
	}
	else
	{
		return false;
	}
}


template <class EventTargetType>
bool EventTarget<EventTargetType>::isEventTypeRegistered(const std::string& type) const
{
	return _eventRegistry.find(type) != _eventRegistry.end();
}


template <class EventTargetType>
void EventTarget<EventTargetType>::registerEventType(const std::string& type,
													 BaseDOMEvent* event)
{
	_eventRegistry[type] = event;
}


template <class EventTargetType>
void EventTarget<EventTargetType>::unregisterEventType(const std::string& type)
{
	_eventRegistry.erase(_eventRegistry.find(type));
}


} // namespace DOM

#line 0 "../addons-all/ofxGuiExtended/src/DOM/Element.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


#include <unordered_set>
/* #include "Events.h" */
/* #include "EventTarget.h" */
/* #include "Exceptions.h" */
/* #include "Types.h" */
/* #include "ofParameter.h" */


namespace DOM {


class Document;
class AbstractLayout;
class Layout;


/// \brief A class representing a DOM Element.
///
/// There are several DOM coordiante systems with respect to an Element.
///
/// 1. Local Coordinates: The origin of the local coordiantes are at 0, 0 of the
/// Element Geometry.  The coordiantes of the local Geometry range from (0, 0)
/// - the upper left corner to (width, height) - the lower right corner of the
/// Element.
///
/// 2. Parent Coordinates: The (x, y) position of the Element geometry are in
/// "Parent" Coordinates, meaning they are oriented with respect to the
/// parent's Local Coordinates.
///
/// 3. Screen Coordinates: The screen coordinates are the coordinates (x, y)
/// in terms of the global screen coordiantes where (0, 0) is the upper left
/// corner of the screen / window, and (ofGetWidth(), ofGetHeight()) are the
/// coordiantes of the lower right corner.
class Element: public EventTarget<Element>
{
public:
	/// \brief Construct a new Element with the given parameters.
	///
	/// The Element will take the default id, an empty string.
	///
	/// \param x the X position of the Element in its parent coordinates.
	/// \param y the Y position of the Element in its parent coordinates.
	/// \param width the width of the Element.
	/// \param height the height of the Element.
	Element(float x, float y, float width, float height);

	/// \brief Construct a new Element with the given parameters.
	/// \param id The id of the Element.
	/// \param x the X position of the Element in its parent coordinates.
	/// \param y the Y position of the Element in its parent coordinates.
	/// \param width the width of the Element.
	/// \param height the height of the Element.
	Element(const std::string& id, float x, float y, float width, float height);

	/// \brief Destroy the Element.
	virtual ~Element();

	/// \brief Take ownership of the passed std::unique_ptr<Element>.
	///
	/// This this is "sink" meaning that any child passed to this will be
	/// owned by this Node.
	///
	/// \param element the rvalue reference to the child node.
	/// \returns A pointer to the added Element. The parent Element retains
	/// ownership of the pointer via a std::unique_ptr.
	/// \tparam ElementType The Element Type.
	template <typename ElementType>
	ElementType* add(std::unique_ptr<ElementType> element);

	/// \brief Create a child using a templated Element type.
	///
	/// To create a child Element you can use this method like:
	///
	/// ElementType* element = parentElement->add<ElementType>(arguments ...);
	///
	/// \tparam ElementType The subclass of Element that will be added.
	/// \tparam Args The variable constructor arguments for the ElementType.
	/// \param args The variable constructor arguments for the ElementType.
	/// \returns A pointer to the added Element. The parent Element retains
	/// ownership of the pointer via a std::unique_ptr.
	/// \tparam ElementType The Element Type.
	/// \tparam Args the ElementType constructor arguments.
	template <typename ElementType, typename... Args>
	ElementType* add(Args&&... args);

	/// \brief Release ownership of a child Element.
	/// \param element The Element to release.
	/// \returns a std::unique_ptr<Element> to the child.
	std::unique_ptr<Element> removeChild(Element* element);

	/// \brief Removes all child elements.
	virtual void clear();

	/// \brief Move this Element in front of all of its siblings.
	void moveToFront();

	/// \brief Move this Element in front of its next sibling.
	void moveForward();

	/// \brief Move this Element in back of all of its siblings.
	void moveToBack();

	/// \brief Move this Element in back of its next sibling.
	void moveBackward();

	/// \brief Move the given Element to the the given index.
	///
	/// If the index value is greater than the number of children, the element
	/// will be moved into the last position.
	///
	/// \param element The child element to move.
	/// \param index The child index to move to.
	/// \throws DOMException(DOMException::INVALID_STATE_ERROR) if no matching
	/// child element exists.
	void moveChildToIndex(Element* element, std::size_t index);

	/// \brief Move the given Element in front of all of its siblings.
	/// \throws DOMException(DOMException::INVALID_STATE_ERROR) if no matching
	/// child element exists.
	void moveChildToFront(Element* element);

	/// \brief Move the given Element in front of its next sibling.
	/// \param element The child element to move.
	/// \throws DOMException(DOMException::INVALID_STATE_ERROR) if no matching
	/// child element exists.
	void moveChildForward(Element* element);

	/// \brief Move the given Element in back of all of its siblings.
	/// \param element The child element to move.
	/// \throws DOMException(DOMException::INVALID_STATE_ERROR) if no matching
	/// child element exists.
	void moveChildToBack(Element* element);

	/// \brief Move the given Element in back of its next sibling.
	/// \param element The child element to move.
	/// \throws DOMException(DOMException::INVALID_STATE_ERROR) if no matching
	/// child element exists.
	void moveChildBackward(Element* element);

	/// \brief Determine if the given Element is a child of this Element.
	/// \param element A pointer the the Element to test.
	/// \returns true iff the given element is a child of this Element.
	bool isChild(Element* element) const;

	/// \brief Determine if the given Element is a sibling of this Element.
	/// \param element A pointer the the Element to test.
	/// \returns true iff the given element is a sibling of this Element.
	bool isSibling(Element* element) const;

	/// \returns the number of siblings.
	std::size_t numSiblings() const;

	/// \returns a list of pointers to sibling elements.
	std::vector<Element*> siblings();

	/// \brief Get a list of siblings of a given Element or Element subclass.
	///
	/// If the there are no siblings of the given type,
	///
	/// \returns a list of pointers to sibling elements of a given type.
	template <typename ElementType>
	std::vector<ElementType*> siblings();

	/// \brief Determine if the given Element is the parent of this Element.
	/// \param element A pointer the the Element to test.
	/// \returns true iff the given element is the parent of this Element.
	bool isParent(Element* element) const;

	/// \returns the number of children.
	std::size_t numChildren() const;

	/// \brief Get a list of pointers to the child elements.
	///
	/// The parent Element retains ownership.
	///
	/// \returns a list of pointers to child elements.
	virtual std::vector<Element*> children();

	/// \brief Get a list of pointers to the child elements.
	///
	/// The parent Element retains ownership.
	///
	/// \returns a list of pointers to child elements.
	template <typename ElementType>
	std::vector<ElementType*> children();

	/// \brief Determine if this Element has a parent Element.
	/// \returns true if this Element has a parent Element.
	bool hasParent() const;

	/// \brief Find this Element's first child by its id.
	/// \param id The id of the child Element to find.
	/// \returns a pointer to the first child or nullptr if no such child exists.
	Element* findFirstChildById(const std::string& id);

	/// \brief Find all of this Element's matching the given id.
	/// \param id The id of the child Elements to find.
	/// \returns a vector of pointers to child elements or an empty vector if none exist.
	std::vector<Element*> findChildrenById(const std::string& id);

	/// \brief Get a pointer to the parent.
	/// \returns a pointer to the parent or a nullptr.
	Element* parent();

	/// \brief Get a pointer to the parent.
	/// \returns a pointer to the parent or a nullptr.
	const Element* parent() const;

	/// \brief Get a pointer to the parent Document.
	/// \returns a pointer to the parent Document, self if a Document or a nullptr.
	Document* document();

	/// \brief Get a pointer to the parent Document.
	/// \returns a pointer to the parent Document, self if a Document or a nullptr.
	const Document* document() const;

	/// \brief Create a Layout using a templated Layout type.
	///
	/// To create a Layout you can use this method like:
	///
	/// LayoutType* layout = parentElement->createLayout<LayoutType>(arguments ...);
	///
	/// \tparam ElementType The subclass of Element that will be added.
	/// \tparam Args The variable constructor arguments for the ElementType.
	/// \param args The variable constructor arguments for the ElementType.
	/// \returns A pointer to the added Element. The parent Element retains
	/// ownership of the pointer via a std::unique_ptr.
	/// \tparam ElementType The Element Type.
	/// \tparam Args the ElementType constructor arguments.
	template <typename LayoutType, typename... Args>
	LayoutType* createLayout(Args&&... args);

	/// \brief Take ownership of the passed std::unique_ptr<Layout>.
	///
	/// This this is "sink" meaning that any Layout passed to this will be
	/// owned by this Element.
	///
	/// \param layout the rvalue reference to the Layout.
	/// \returns A pointer to the set Layout. The parent Element retains
	/// ownership of the pointer via a std::unique_ptr.
	/// \tparam LayoutType The Layout Type.
	template <typename LayoutType>
	LayoutType* setLayout(std::unique_ptr<LayoutType> layout);

	/// \brief Release ownership of the Layout.
	/// \returns a std::unique_ptr<Layout> to the Layout or nullptr if none.
	std::unique_ptr<Layout> removeLayout();

	/// \brief Get a pointer to the associated Layout.
	///
	/// The Element retains ownership of the pointer via a std::unique_ptr.
	///
	/// \returns a pointer to the associated Layout or nullptr if there is none.
	Layout* layout();

	/// \brief Updates the current layout.
	///
	virtual void updateLayout();

	/// \brief Perform a hit test on the Element.
	///
	/// For a normal Element, the hit test will test the rectangular geometry
	/// of the Element. Subclasses can override this method for custom hit test
	/// geometry.
	///
	/// Parent coordinates are used because the geometry / position of the
	/// Element are in parent coordinates.
	///
	/// \param parentPosition The Position to test in parent coordinates.
	/// \returns true iff the local position is within the hit test region.
	virtual bool hitTest(const Position& parentPosition) const;

	/// \brief Perform a hit test on a child Element.
	/// \param localPosition The Position to test in local coordinates.
	/// \returns true iff the local position is within the hit test region.
	virtual bool childHitTest(const Position& localPosition) const;

	/// \brief Convert the local coordinates to screen coordinates.
	///
	/// Local coordinates are defined with reference to the position of the box.
	/// The Position of this element will be in its parent's local coordinates.
	///
	/// \param localPosition The local coordinates to convert.
	/// \returns the position converted from local to screen coordinates.
	Position localToScreen(const Position& localPosition) const;

	/// \brief Convert the local coordinates to screen coordinates.
	///
	/// Local coordinates are defined with reference to the position of the box.
	/// The Position of this element will be in its parent's local coordinates.
	///
	/// \param localShape The local shape to convert.
	/// \returns the shape converted from local to screen coordinates.
	Shape localToScreen(const Shape& localShape) const;

	/// \brief Convert the screen coordinates to local coordinates.
	///
	/// Local coordinates are defined with reference to the position of the box.
	/// The Position of this element will be in its parent's local coordinates.
	///
	/// \param screenPosition The screen coordinates to convert.
	/// \returns the position converted from screen to local coordinates.
	Position screenToLocal(const Position& screenPosition) const;

	/// \brief Convert the parent coordinates to screen coordinates.
	/// \param parentPosition The parent coordinates to convert.
	/// \returns the position converted from parent to screen coordinates.
	Position parentToScreen(const Position& parentPosition) const;

	/// \brief Convert the screen coordinates to parent coordinates.
	/// \param screenPosition The screen coordinates to convert.
	/// \returns the position converted from screen to parent coordinates.
	Position screenToParent(const Position& screenPosition) const;

	/// \brief Set the position of the Element in its parent coordinates.
	/// \param x The new x position.
	/// \param y The new y position.
	void setPosition(float x, float y);

	/// \brief Set the position of the Element in its parent coordinates.
	/// \param position The new position.
	void setPosition(const Position& position);

	/// \brief Get the position of the Element in its parent coordinates.
	///
	/// Local coordinates are defined with reference to the position of the box.
	/// The Position of this element will be in its parent's local coordinates.
	///
	/// \returns The position in parent coordinates.
	Position getPosition() const;

	/// \brief Get the X position of the Element in its parent coordinates.
	/// \returns the X position of the Element in its parent coordinates.
	float getX() const;

	/// \brief Get the Y position of the Element in its parent coordinates.
	/// \returns the Y position of the Element in its parent coordinates.
	float getY() const;

	/// \brief Get the Position of the Element in screen coordinates.
	/// \returns the Position of the Element in screen coordinates.
	/// \todo Cache screen position w/ geometry.
	Position getScreenPosition() const;

	/// \brief Get the X position of the Element in screen coordinates.
	/// \returns the X position of the Element in screen coordinates.
	float getScreenX() const;

	/// \brief Get the Y position of the Element in screen coordinates.
	/// \returns the Y position of the Element in screen coordinates.
	float getScreenY() const;

	/// \brief Set the size of the Element.
	/// \param width The new width of the Element.
	/// \param height The new height of the Element.
	virtual void setSize(float width, float height);

	/// \brief Set the size of the Element in the current layout.
	/// \param width The new width of the Element.
	/// \param height The new height of the Element.
	virtual void setLayoutSize(float width, float height, bool tellParent = true);

	/// \brief Set the size of the Element that the parent suggests by the current layout.
	/// \param width The new width of the Element.
	/// \param height The new height of the Element.
	virtual void setSizeByParent(float width, float height);

	/// \brief Get the Size of the Element.
	/// \returns the Size of the Element.
	Size getSize() const;

	/// \brief Get the Size of the Element that the parent suggests by the current layout.
	/// \returns the Size of the Element.
	Size getSizeByParent() const;

	/// \brief Set the width of the Element.
	/// param width The new width of the Element.
	virtual void setWidth(float width);

	/// \brief Set the width of the Element in the current layout.
	/// param width The new width of the Element.
	virtual void setLayoutWidth(float width, bool tellParent = true);

	/// \brief Get the width of the Element produced by the layout.
	/// \returns The width of the Element.
	float getWidth() const;

	/// \brief Get the actual minimal width of the Element.
	/// \returns The width of the Element.
	virtual float getMinWidth();

	/// \brief Set the height of the Element.
	/// param height The new height of the Element.
	virtual void setHeight(float height);

	/// \brief Set the height of the Element in the current layout.
	/// param height The new height of the Element.
	virtual void setLayoutHeight(float height, bool tellParent = true);

	/// \brief Get the height of the Element produced by the layout.
	/// \returns The height of the Element.
	float getHeight() const;

	/// \brief Get the actual minimal height of the Element.
	/// \returns The height of the Element.
	virtual float getMinHeight();

	/// \brief Get the shape of the Element in its parent coordinates.
	/// \returns the Shape of the Element in its parent coordinates.
	Shape getShape() const;

	/// \brief Set the shape of the Element in its parent coordinates.
	/// \param shape The new shape of the Element in its parent coordinates.
	virtual void setShape(const Shape& shape);

	/// \brief Set the shape of the Element in its parent coordinates.
	/// \param x The new horizontal position of the Element in its parent coordinates.
	/// \param y The new vertical position of the Element in its parent coordinates.
	/// \param width The new width of the Element in its parent coordinates.
	/// \param height The new height of the Element in its parent coordinates.
	virtual void setShape(float x, float y, float width, float height);

	/// \brief Get the bounding box representing all child elements.
	/// \returns the bounding box representing all child elements, or
	/// a rectangle of zero width and height at the origin if no children.
	Shape getChildShape() const;

	/// \brief Get the bounding box representing the union of the child shape and the element shape.
	/// \returns the bounding box representing the union of the child shape and the element shape.
	Shape getTotalShape() const;

	/// \brief Get the id of this Element.
	///
	/// The id is optional and an empty std::string by default.
	///
	/// \returns the id of the Element.
	std::string getId() const;

	/// \brief Set the id of the Element.
	/// \param id The new id of the Element.
	void setId(const std::string& id);

	/// \brief Determine of the Element has an attribute with the given name.
	/// \param name The name of the Attribute to query.
	/// \returns true iff the Element has an attribute with the given name.
	bool hasAttribute(const std::string& name) const;

	/// \brief Get a named attribute via its key.
	///
	/// Users should check to see if the attribute exists using hasAttribute or
	/// catch the DOMException.
	///
	/// \throws DOMException if no such key.
	/// \throws Poco::BadCastException if the types do not match.
	/// \param key The name of the attribute.
	/// \param inherit True if the Element should query its ancestors for the attribute.
	/// \returns The value corresponding to the key, or throws an exception.
	template <typename AnyType>
	AnyType getAttribute(const std::string& key, bool inherit = false);

	/// \brief Set a value for a named attribute.
	///
	/// If the given attribute exists, it will be overwritten with the given
	/// value.
	///
	/// \param name The name of the attribute.
	/// \param value The new value of the attribute called name.
	void setAttribute(const std::string& name, const Any& value);

	/// \brief Clear a named attribute.
	/// \param The name of the attribute to clear.
	void clearAttribute(const std::string& name);

	/// \brief Request that the parent Document capture the given pointer id.
	///
	/// Captured pointers send all of their revents to the capturing Element.
	///
	/// \param id The pointer id to capture.
	void setPointerCapture(std::size_t id);

	/// \brief Release a captured pointer with the given id.
	///
	/// Usually this call is not required as the parent Document's pointer
	/// dispatching system will automatically release a pointer on the next
	/// POINTER_UP event.  In some cases, the user may want to explicity release
	/// the event to fire the associated lostPointerCapture events.
	///
	/// \param id The pointer id to release.
	void releasePointerCapture(std::size_t id);

	/// \returns true iff the Element is enabled.
	bool isEnabled() const;

	/// \brief Enable or disable this Element.
	/// \param enabled The enabled state to set. True to enable, false to disable.
	void setEnabled(bool enabled);

	/// \returns true iff the Element is visible.
	bool isHidden() const;

	/// \brief Hide or show this Element.
	/// \param hidden The visible state to set. True to hide, false to show.
	void setHidden(bool hidden);

	/// \brief Hide or show this Element.
	/// \param visible The visible state to set. False to hide, true to show.
	void setVisible(bool& visible);

	/// \returns A parameter that determines if the element is visible or not.
	ofParameter<bool>& getVisible();

	/// \returns true iff the Element is locked.
	bool isLocked() const;

	/// \brief Lock or unlock a this Element.
	/// \param locked The locked state to set. True to lock, false to unlock.
	void setLocked(bool locked);

	/// \param If true prevent layout from being computed, if false release block
	void blockLayout(bool block);

	/// \brief Called internally to invalidate the child shape tree.
	virtual void invalidateChildShape();

//	/// \brief Redo layout and children layouts.
//	virtual void redoLayout();

	/// \brief A method to call generateDraw() next time before the object is rendered
	void setNeedsRedraw();


protected:
	/// \brief Setup method called by parent Element.
	/// \param e The event data.
	void _setup(ofEventArgs& e);

	/// \brief Update method called by parent Element.
	/// \param e The event data.
	void _update(ofEventArgs& e);

	/// \brief Draw method called by parent Element.
	/// \param e The event data.
	void _draw(ofEventArgs& e);

	/// \brief Render method to draw content on screen
	virtual void render(){}

	/// \brief A method to generate the content drawn by render()
	virtual void generateDraw(){}

	/// \brief Exit method called by parent Element.
	/// \param e The event data.
	void _exit(ofEventArgs& e);

	/// \brief A recursive hit test to find a target element.
	/// \param parentPosition The parent coordinates to test.
	/// \returns A pointer to the target Element or a nullptr if none found.
	/// \todo Provide a seed position to speed up search?
	Element* recursiveHitTest(const Position& parentPosition);

	/// \brief Find a child by a raw Element pointer.
	/// \param The pointer to the child.
	/// \returns An iterator pointing to the matching Element or the end.
	std::vector<std::unique_ptr<Element>>::iterator findChild(Element* element);


	/// \brief A vector to Elements.
	std::vector<std::unique_ptr<Element>> _children;

//private:
	/// \brief Not construction-copyable.
	Element(const Element& other) = delete; // non-construction-copyable

	/// \brief Non copyable.
	Element& operator = (const Element&) = delete;

	/// \brief A callback for to notify of Element movement
	void _onMoved(MoveEventArgs&);

	/// \brief A callback to notify of Elements size changes
	void _onResized(ResizeEventArgs&);

	/// \brief A callback for child Elements to notify their parent of movement.
	void _onChildMoved(MoveEventArgs &args);

	/// \brief A callback for child Elements to notify their parent size changes.
	void _onChildResized(ResizeEventArgs&);

	/// \brief The id for this element.
	std::string _id;

	/// \brief The basic shape of this element.
	Shape _shape;
	Size _layoutSize;
	Size _sizeSetByParent;

	/// \brief The union of all child shapes.
	mutable Shape _childShape;

	/// \brief True if the child geometry is invalid.
	///
	/// This variable usually set by callbacks from the child elements.
	mutable bool _childShapeInvalid = true;

	/// \brief The enabled state of this Element.
	bool _enabled = true;

	/// \brief The hidden state of this Element.
	bool _hidden = false;

	/// \brief The locked state of this Element.
	bool _locked = false;

	ofParameter<bool> _visible;

	/// \brief A collection of named attributes.
	/// \todo This may not be permanent.
	std::unordered_map<std::string, Any> _attributes;

	/// \brief True if content drawn by render() needs to be regenerated
	bool needsRedraw;

	/// \brief The Layout associated with this
	std::unique_ptr<Layout> _layout;

	/// \brief An optional pointer to a parent Node.
	Element* _parent = nullptr;

	/// \brief The Layout class has access to all private variables.
	friend class Layout;

	/// \brief The Document class has access to all private variables.
	friend class Document;

};


template <typename ElementType, typename... Args>
ElementType* Element::add(Args&&... args)
{
	return add(std::make_unique<ElementType>(std::forward<Args>(args)...));
}


template <typename ElementType>
ElementType* Element::add(std::unique_ptr<ElementType> element)
{

	static_assert(std::is_base_of<Element, ElementType>(), "ElementType must be an Element or derived from Element.");

	if (element)
	{
		// Get a raw pointer to the node for later.
		ElementType* pNode = element.get();

		// Assign the parent to the node via the raw pointer.
		pNode->_parent = this;

		// Take ownership of the node.
		_children.push_back(std::move(element));

		// Invalidate all cached child shape.
		pNode->invalidateChildShape();

		// Alert the node that its parent was set.
		ElementEventArgs addedEvent(this);
		ofNotifyEvent(pNode->addedTo, addedEvent, this);

		ElementEventArgs childAddedEvent(pNode);
		ofNotifyEvent(childAdded, childAddedEvent, this);

		// Attach child listeners.
		ofAddListener(pNode->move, this, &Element::_onChildMoved);
		ofAddListener(pNode->resize, this, &Element::_onChildResized);

		/// Alert the node's siblings that they have a new sibling.
		for (auto& child : _children)
		{
			// Don't alert itself.
			if (child.get() != pNode)
			{
				ElementEventArgs event(pNode);
				ofNotifyEvent(child->siblingAdded, event, this);
			}
		}

		return pNode;
	}
	else
	{
		return nullptr;
	}
}


template <typename ElementType>
std::vector<ElementType*> Element::siblings()
{
	static_assert(std::is_base_of<Element, ElementType>(), "ElementType must be an Element or derived from Element.");

	std::vector<ElementType*> results;

	if (_parent)
	{
		for (auto& child : _parent->_children)
		{
			ElementType* pChild = dynamic_cast<ElementType*>(child.get());

			if (pChild != this)
			{
				results.push_back(pChild);
			}
		}
	}

	return results;
}


template <typename ElementType>
std::vector<ElementType*> Element::children()
{
	static_assert(std::is_base_of<Element, ElementType>(), "ElementType must be an Element or derived from Element.");

	std::vector<ElementType*> results;

	for (auto& child : _children)
	{
		ElementType* pChild = dynamic_cast<ElementType*>(child.get());

		if (pChild)
		{
			results.push_back(pChild);
		}
	}

	return results;
}


template <typename LayoutType, typename... Args>
LayoutType* Element::createLayout(Args&&... args)
{
	return setLayout(std::make_unique<LayoutType>(std::forward<Args>(args)...));
}


template <typename LayoutType>
LayoutType* Element::setLayout(std::unique_ptr<LayoutType> layout)
{
	if (layout)
	{
		// Get a raw pointer to the node for later.
		LayoutType* pLayout = layout.get();

		// Assign the parent to the node via the raw pointer.
		pLayout->_parent = this;

		// Take ownership of the layout.
		_layout = std::move(layout);

		_layoutSize.x = 0;
		_layoutSize.y = 0;

		// Invalidate all cached child shape.
		invalidateChildShape();

		return pLayout;
	}
	else
	{
		return nullptr;
	}
}


template <typename AnyType>
AnyType Element::getAttribute(const std::string& key, bool inherit)
{
	auto iter = _attributes.find(key);

	if (iter != _attributes.end() && iter->second.is<AnyType>())
	{
		return iter->second.as<AnyType>();
	}
	else if (inherit && hasParent())
	{
		return parent()->getAttribute<AnyType>(key);
	}
	else
	{
		throw DOMException(DOMException::INVALID_ATTRIBUTE_KEY);
	}
}


} // namespace DOM

#line 0 "../addons-all/ofxGuiExtended/src/DOM/Document.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


/* #include "Element.h" */


namespace DOM {


/// \brief The Document represents the root DOM Element in an DOM tree.
class Document: public Element
{
public:
	/// \brief Create a default Document.
	///
	/// The Document will have the default id of "document" and will fill
	/// the entire screen.
	Document();

	/// \brief Destroy the Document.
	virtual ~Document();

	/// \brief Callback for the setup event.
	/// \param e the event data.
	void setup(ofEventArgs& e);

	/// \brief Callback for the update event.
	/// \param e the event data.
	void update(ofEventArgs& e);

	/// \brief Callback for the draw event.
	/// \param e the event data.
	void draw(ofEventArgs& e);

	/// \brief Callback for the exit event.
	/// \param e the event data.
	void exit(ofEventArgs& e);

	/// \brief Callback for the window resized event.
	/// \param e the event data.
	void windowResized(ofResizeEventArgs& e);

	/// \brief Callback for file drag events.
	/// \param e the event data.
	/// \returns true iff the event was handled.
	bool fileDragEvent(ofDragInfo& e);

	/// \brief Callback for key events events.
	/// \param e the event data.
	/// \returns true iff the event was handled.
	bool onKeyEvent(ofKeyEventArgs& e);

	/// \brief Determine if the Document size should always match the screen size.
	/// \param true if if the Document size should always match the screen size.
	void setAutoFillScreen(bool autoFillScreen);

	/// \returns true if the Document size will always match the screen size.
	bool getAutoFillScreen() const;

	/// \brief Can be used to prevent the layout from being computed.
	/// \param blocking True if layout computing should be prevented.
	void setBlockLayout(bool blocking);

	/// \returns True if the layout computing is blocked.
	bool isBlockingLayout();

	virtual float getMinWidth() override;
	virtual float getMinHeight() override;

protected:

	/// \brief True if the Document size should always match the screen size.
	bool _autoFillScreen = true;
	bool _blockLayout = false;
	int _blockLayoutCount = 0;

};


} // namespace DOM

#line 0 "../addons-all/ofxGuiExtended/src/DOM/Layout.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


#include <vector>
/* #include "Types.h" */
/* #include "Element.h" */


namespace DOM {


/// \brief A base class for laying out Elements.
///
/// Generally this class and its subclasses should not be instantiated directly
/// but instead should be created using Element::createLayout<LayoutType>(...).
/// This pattern preserves the ownership of the Layout.
class Layout
{
public:
	/// \brief Create a Layout with a given Element parent.
	/// \param parent The parent Element.
	Layout(Element* parent);

	/// \brief Destroy the layout.
	virtual ~Layout();

	/// \returns a pointer to the parent Element or nullptr if none.
	Element* parent();

	/// \returns true iff this layout is currently being done.
	bool isDoingLayout() const;

	/// \brief Get all of the children for this element.
	std::vector<Element*> children();

	/// \brief Do layout.
	virtual void doLayout() = 0;

	virtual void copyTo(Element* parent) const = 0 ;

protected:
	/// \brief The owning Widget class.
	Element* _parent = nullptr;

	/// \brief True if in doLayout(). Used to prevent recusive calls.
	bool _isDoingLayout = false;

	friend class Element;

};


template<typename T>
class _Layout : public Layout {

	public:

		_Layout(Element* parent):Layout(parent){}
		~_Layout(){}

		virtual void copyTo(Element* parent) const {
			parent->createLayout<T>(parent);
		}

};


} // namespace DOM

#line 0 "../addons-all/ofxGuiExtended/src/DOM/ofxDOM.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


/* #include "Document.h" */
/* #include "Element.h" */
/* #include "Types.h" */


#line 0 "../addons-all/ofxGuiExtended/src/ofxGuiElement.h"
#pragma once

/* #include "ofConstants.h" */
/* #include "ofParameter.h" */
/* #include "ofTrueTypeFont.h" */
/* #include "ofBitmapFont.h" */
/* #include "ofJson.h" */

/* #include "DOM/Element.h" */

enum TextAlignment{
	LEFT,
	RIGHT,
	CENTERED
};

class ofxGuiElement : public DOM::Element {
	public:

		ofxGuiElement();
		ofxGuiElement(const ofJson & config);

		void setup();

		virtual ~ofxGuiElement();
		ofxGuiElement(const ofxGuiElement &) = delete;
		ofxGuiElement & operator=(const ofxGuiElement &) = delete;

		void setConfig(const ofJson &config, bool recursive = false);
		void setTheme();
		void setTheme(const ofJson &config);
		void loadConfig(const std::string &filename, bool recursive = false);
		void loadTheme(const std::string &filename, bool updateOnFileChange = false);

		void saveToFile(const std::string& filename);
		void loadFromFile(const std::string& filename);

		template<class T>
		void saveTo(T & serializer){
			ofSerialize(serializer, getParameter());
		}

		template<class T>
		void loadFrom(T & serializer){
			ofDeserialize(serializer, getParameter());
		}

		virtual std::string getName();
		virtual void setName(const std::string& name);

		virtual void setTextAlignment(const TextAlignment& textLayout=TextAlignment::LEFT);
		virtual void setTextAlignment(const std::string& textLayout);
		TextAlignment getTextAlignment() const;

		virtual void setLayoutPosition(DOM::LayoutPosition type);
		virtual DOM::LayoutPosition getLayoutPosition();

		ofColor getHeaderBackgroundColor() const;
		ofColor getBackgroundColor() const;
		ofColor getBorderColor() const;
		ofColor getTextColor() const;
		ofColor getFillColor() const;
		bool getShowName() const;
		float getBorderWidth() const;
		float getFontSize() const;

		virtual void setHeaderBackgroundColor(const ofColor & color);
		virtual void setBackgroundColor(const ofColor & color);
		virtual void setBorderColor(const ofColor & color);
		virtual void setTextColor(const ofColor & color);
		virtual void setFillColor(const ofColor & color);
		virtual void setBorderWidth(float width);
		virtual void setFontSize(float size);

		void setShowName(bool show);

		virtual ofAbstractParameter & getParameter();
		void loadFont(const std::string& filename, int fontsize, bool _bAntiAliased = true, bool _bFullCharacterSet = false, int dpi = 0);
		void setUseTTF(bool bUseTTF);

		/// \returns true if the mouse is over this element.
		bool isMouseOver() const;

		/// \returns true if the mouse is pressed on this element.
		bool isMousePressed() const;

		/// \brief Set draggability for this element.
		/// \param draggable True if draggability is enabled.
		void setDraggable(bool draggable);

		/// \brief Determine if draggability is enabled for this element.
		/// \returns true if the draggability is enabled.
		bool isDraggable() const;

		/// \brief Determine if this element is being dragged.
		/// \returns true if this element is being dragged.
		bool isDragging() const;

		void registerMouseEvents(int priority = OF_EVENT_ORDER_BEFORE_APP);
		void unregisterMouseEvents(int priority = OF_EVENT_ORDER_BEFORE_APP);

		virtual bool mouseMoved(ofMouseEventArgs & args);
		virtual bool mousePressed(ofMouseEventArgs & args);
		virtual bool mouseDragged(ofMouseEventArgs & args);
		virtual bool mouseReleased(ofMouseEventArgs & args);
		virtual bool mouseScrolled(ofMouseEventArgs & args){return false;}
		virtual void mouseEntered(ofMouseEventArgs & args){}
		virtual void mouseExited(ofMouseEventArgs & args){}

		ofJson getTheme();
		ofJson getGlobalConfigTheme();

		static std::string getClassType();

		int getObjectCount();

	protected:

		int objCount;

		virtual std::vector<std::string> getClassTypes();

		virtual void generateDraw();
		virtual void render();

		virtual void _setConfig(const ofJson & config);
		void _setConfigUsingClassifiers(const ofJson &config, bool recursive = false);

		void copyLayoutFromDocument();

		/// \brief Sets the value of the element based on a position
		/// \param mx The horizontal position
		/// \param my The vertical position
		/// \param boundaryCheck If true, it checks whether the position is inside of the element. If not, the value won't be changed.
		virtual bool setValue(float mx, float my, bool boundaryCheck){return false;}
		void bindFontTexture();
		void unbindFontTexture();
		ofMesh getTextMesh(const std::string & text, ofPoint p);
		ofMesh getTextMesh(const std::string & text, float x, float y);
		ofRectangle getTextBoundingBox(const std::string & text, float x=0, float y=0);
		float getTextWidth(const std::string & text);
		float getTextHeight(const std::string & text);

		static std::string saveStencilToHex(const ofImage & img);
		static void loadStencilFromHex(ofImage & img, unsigned char * data);

		ofTrueTypeFont font;
		bool fontLoaded;
		bool useTTF;
		ofBitmapFont bitmapFont;

		/// \brief True if the Widget is configured to be dragged.
		bool _isDraggable = false;

		/// \brief True if the widget is currently being dragged.
		bool _isDragging = false;

		/// \brief True if the pointer is over the widget.
		bool _isMouseOver = false;

		/// \brief Point where element is grabbed for dragging in screen coordinates
		ofPoint grabPoint;

		ofPath bg, border;

		ofParameter<ofColor> headerBackgroundColor;
		ofParameter<ofColor> backgroundColor;
		ofParameter<ofColor> borderColor;
		ofParameter<ofColor> textColor;
		ofParameter<ofColor> fillColor;
		ofParameter<float> borderWidth;
		ofParameter<TextAlignment> textAlignment;
		ofParameter<bool> showName;
		ofParameter<float> fontSize;
		ofParameter<float> textPadding;
		ofParameter<float> borderRadius;

		bool bRegisteredForMouseEvents;

		ofJson theme, individualConfig;
		std::string themeFilename;
		bool updateOnThemeChange;
		void watchTheme(ofEventArgs& args);
		std::time_t themeUpdated;

		ofParameter<void> parameter;

		bool themeLoading = false;

};

#line 0 "../addons-all/ofxGuiExtended/src/util/IDGenerator.h"
#pragma once

class IDGenerator {
   public:
      static IDGenerator&     getInstance() {
          static IDGenerator instance;
          return instance;
      }
      int next () { return _id++; }
   private:
      IDGenerator () : _id(0) {}
      int _id;
};

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiToggle.h"
#pragma once

/* #include "ofParameter.h" */
/* #include "../ofxGuiElement.h" */

class ofxGuiToggleType{
	public:
	enum Type {
		/// \brief Shows toggle as checkbox (default).
		CHECKBOX,
		/// \brief Shows toggle as radio toggle.
		RADIO,
		/// \brief Uses the whole element as toggle.
		FULLSIZE
	};
};

class ofxGuiToggle : public ofxGuiElement{
public:

	ofxGuiToggle();
	ofxGuiToggle(const std::string& toggleName);
	ofxGuiToggle(const std::string& toggleName, const ofJson & config);
	ofxGuiToggle(ofParameter<bool>& _bVal, const ofJson & config = ofJson());
	ofxGuiToggle(const std::string& toggleName, bool _bVal, const ofJson & config = ofJson());

	~ofxGuiToggle();

	void setType(const std::string &type);
	void setType(const ofxGuiToggleType::Type &type);
	ofxGuiToggleType::Type getType();

	virtual float getMinWidth() override;
	virtual float getMinHeight() override;

	virtual bool mousePressed(ofMouseEventArgs & args) override;
	virtual bool mouseReleased(ofMouseEventArgs & args) override;

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		value.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		value.removeListener(listener,method);
	}

	bool operator=(bool v);
	operator const bool & ();

	virtual ofAbstractParameter & getParameter() override;

	static std::string getClassType();

protected:

	void setup();

	virtual std::vector<std::string> getClassTypes() override;

	virtual void _setConfig(const ofJson & config) override;
	virtual void render() override;
	ofRectangle checkboxRect;
	ofParameter<bool> value;

	ofParameter<ofxGuiToggleType::Type> type;
	bool hasFocus;

	virtual bool setValue(float mx, float my, bool bCheck) override;
	virtual void generateDraw() override;
	void valueChanged(bool & value);
	ofVboMesh textMesh;
};

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiButton.h"
#pragma once

/* #include "ofxGuiToggle.h" */
/* #include "ofParameter.h" */

class ofxGuiButton : public ofxGuiToggle{
public:

	ofxGuiButton();
	ofxGuiButton(const std::string& buttonName);
	ofxGuiButton(const std::string& buttonName, const ofJson & config);
	ofxGuiButton(ofParameter<void>& _val, const ofJson & config = ofJson());
	ofxGuiButton(ofParameter<bool>& _bVal, const ofJson & config = ofJson());

	~ofxGuiButton();

	virtual ofAbstractParameter & getParameter() override;

	virtual bool mouseReleased(ofMouseEventArgs & args) override;

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
	voidvalue.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		voidvalue.removeListener(listener,method);
	}

	static std::string getClassType();

protected:

	void setup();

	virtual std::vector<std::string> getClassTypes() override;

	virtual void generateDraw() override;
	virtual bool setValue(float mx, float my, bool bCheck) override;
	ofParameter<void> voidvalue;
	bool useVoidValue {false};

};

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiGraphics.h"
#pragma once

/* #include "../ofxGuiElement.h" */

class ofxGuiGraphics : public ofxGuiElement {
	public:

		ofxGuiGraphics(std::string canvasName="", const ofJson& config = ofJson());
		ofxGuiGraphics(std::string canvasName, ofBaseDraws * graphics, const ofJson& config = ofJson());
		ofxGuiGraphics(std::string canvasName, ofBaseDraws * graphics, float w, float h = 0);
		virtual ~ofxGuiGraphics();

		virtual float getMinWidth() override;
		virtual float getMinHeight() override;

		void setAutoHeight();
		void setAutoWidth();

		virtual void setGraphics(ofBaseDraws* graphics);

		virtual ofAbstractParameter & getParameter() override;

		static std::string getClassType();

	protected:

		void setup(std::string canvasName = "", float w = 0, float h = 0);

		virtual std::vector<std::string> getClassTypes() override;

		bool setValue(float mx, float my, bool bCheckBounds) override {
			return false;
		}
		virtual void render() override;
		virtual void generateDraw() override;

		virtual void onResize(DOM::ResizeEventArgs& args);

		ofPath bg;
		ofVboMesh textMesh;
		ofBaseDraws * graphics;
		ofParameter <std::string> label;
		bool _bLoaded;
		bool resizing = false;
				bool autoWidth, autoHeight;

};

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiValuePlotter.h"
#pragma once

/* #include "../ofxGuiElement.h" */

class ofxGuiValuePlotter : public ofxGuiElement {
	public:

		ofxGuiValuePlotter();
		ofxGuiValuePlotter(const ofJson & config);
		ofxGuiValuePlotter(ofParameter<float>& value, const ofJson & config = ofJson());
		ofxGuiValuePlotter(std::string label, float minValue, float maxValue, int plotSize = 100, const ofJson & config = ofJson());

		virtual ~ofxGuiValuePlotter();

		virtual float getMinWidth() override;
		virtual float getMinHeight() override;

		void setDecimalPlace(int place);

		virtual ofAbstractParameter & getParameter() override;

		static std::string getClassType();

	protected:

		void setup();

		virtual std::vector<std::string> getClassTypes() override;

		virtual void _setConfig(const ofJson & config) override;
		virtual void render() override;
		virtual void generateDraw() override;

		ofVboMesh textMesh;
		std::vector <float> buffer;
		ofPath plot;
		bool autoscale;
		ofParameter <std::string> label;
		ofParameter<float> value;

		ofParameter<int> decimalPlace;
		ofParameter<float> minVal;
		ofParameter<float> maxVal;
		ofParameter<int> plotSize;

		void valueChanged(float & value);

};

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiFpsPlotter.h"
#pragma once

/* #include "ofxGuiValuePlotter.h" */

class ofxGuiFpsPlotter : public ofxGuiValuePlotter {
	public:
		ofxGuiFpsPlotter();
		ofxGuiFpsPlotter(const ofJson & config);
		ofxGuiFpsPlotter(std::string label, float minValue, float maxValue, int plotSize = 100, const ofJson & config = ofJson());

		virtual ~ofxGuiFpsPlotter();

		void update(ofEventArgs &);

	protected:

		void setup();

};

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiFunctionPlotter.h"
#pragma once

/* #include "../ofxGuiElement.h" */
/* #include "ofImage.h" */

class ofxGuiFunctionPlotter : public ofxGuiElement {
	public:

		ofxGuiFunctionPlotter(ofParameter<ofPoint> value, const ofJson & config = ofJson());
		ofxGuiFunctionPlotter(ofParameter<ofPoint> value, std::function<float (float)> function, const ofJson & config = ofJson());

		virtual ~ofxGuiFunctionPlotter();

		virtual float getMinWidth() override;
		virtual float getMinHeight() override;

		void setPlotterStrokeWidth(float width);
		void setFunction(std::function<float (float)> function);

		virtual void setFillColor(const ofColor& color) override;
		virtual void setFillColor(const ofColor& minColor, const ofColor& maxColor);

		void setDecimalPlace(int place);

		virtual ofAbstractParameter & getParameter() override;

		static std::string getClassType();

	protected:

		void setup();

		virtual std::vector<std::string> getClassTypes() override;

		virtual void _setConfig(const ofJson & config) override;
		virtual void render() override;
		virtual void generateDraw() override;

		ofVboMesh textMesh;
		std::vector <float> buffer;
		ofPath plot;
		ofParameter<float> plotterStrokeWidth;
		ofParameter <std::string> label;
		ofParameter<ofPoint> value;
		std::function<float (float)> function;

		ofParameter<int> decimalPlace;
		ofColor minColor, maxColor;
		ofImage background_gradient;

		void valueChanged(ofPoint & value);

};

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiInputField.h"
#pragma once

/* #include "../ofxGuiElement.h" */

template<typename Type>
class ofxGuiInputField : public ofxGuiElement{
public:
	ofxGuiInputField();
	ofxGuiInputField(const ofJson &config);
	ofxGuiInputField(ofParameter<Type>& _val, const ofJson &config = ofJson());
	ofxGuiInputField(const std::string& _name, Type _val, Type _min, Type _max, const ofJson &config = ofJson());
	//TODO the setup non-ofParameter setup is a pain for the Type string (because of the forced min and max)

	~ofxGuiInputField();

	void setMin(Type min);
	Type getMin();
	void setMax(Type max);
	Type getMax();

	virtual float getMinWidth() override;
	virtual float getMinHeight() override;

	virtual bool mouseMoved(ofMouseEventArgs & args) override;
	virtual bool mousePressed(ofMouseEventArgs & args) override;
	virtual bool mouseDragged(ofMouseEventArgs & args) override;
	virtual bool mouseReleased(ofMouseEventArgs & args) override;
	virtual bool mouseScrolled(ofMouseEventArgs & args) override;

	void registerKeyEvents();
	void unregisterKeyEvents();

	virtual bool keyPressed(ofKeyEventArgs & args);
	virtual bool keyReleased(ofKeyEventArgs & args);

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		value.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		value.removeListener(listener,method);
	}

	Type operator=(Type v);
	operator const Type & ();

	ofAbstractParameter & getParameter() override;

	static std::string getClassType();

protected:

	void setup();

	virtual std::vector<std::string> getClassTypes() override;

	virtual void render() override;
	ofParameter<Type> value;
	bool bMousePressed;
	bool mouseInside;
	bool hasFocus;
	bool setValue(float mx, float my, bool bCheck) override;
	virtual void generateDraw() override;
	virtual void generateText();
	void valueChanged(Type & value);
	ofVboMesh textMesh;

	bool bRegisteredForKeyEvents;

	std::string input;
	float inputWidth;
	bool bChangedInternally;
	void parseInput();
	int insertKeystroke(const std::string & character);
	int insertAlphabetic(const std::string & character);

	int mousePressedPos; //set by mouse interaction
	bool hasSelectedText();

	float selectStartX, selectionWidth; //calculated from select indices
	int selectStartPos, selectEndPos;
	void calculateSelectionArea(int selectIdx1, int selectIdx2);

	virtual void drawSelectedArea();
	virtual void drawCursor();
	virtual void drawFocusedBB();
	virtual void drawMesh();

	int pressCounter;

	void leaveFocus();
};

typedef ofxGuiInputField<float> ofxGuiFloatInputField;
typedef ofxGuiInputField<int> ofxGuiIntInputField;
typedef ofxGuiInputField<std::string> ofxGuiTextField;

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiLabel.h"
#pragma once

/* #include "../ofxGuiElement.h" */
/* #include "ofParameter.h" */

template<typename Type>
class ofxGuiValueLabel: public ofxGuiElement {
public:

	ofxGuiValueLabel();
	ofxGuiValueLabel(ofParameter<Type>& _label, const ofJson & config = ofJson());
	ofxGuiValueLabel(const std::string& labelName, const ofJson & config = ofJson());
	ofxGuiValueLabel(ofParameter<Type>& _label, float width, float height);
	ofxGuiValueLabel(const std::string& labelName, const Type & label, const ofJson & config = ofJson());
	ofxGuiValueLabel(const std::string& labelName, const Type & label, float width, float height);

	virtual ~ofxGuiValueLabel();

	virtual float getMinWidth() override;
	virtual float getMinHeight() override;


	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		label.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		label.removeListener(listener,method);
	}


	Type operator=(Type v) { label = v; return v; }
	operator const Type & () { return label; }

	ofAbstractParameter & getParameter() override;

	static std::string getClassType();

protected:

	void setup();

	virtual std::vector<std::string> getClassTypes() override;

	virtual void render() override;
	ofParameter<Type> label;
	virtual void generateDraw() override;
	void valueChanged(Type & value);
	bool setValue(float mx, float my){return false;}
	ofVboMesh textMesh;
};

typedef ofxGuiValueLabel<std::string> ofxGuiLabel;
typedef ofxGuiValueLabel<int> ofxGuiIntLabel;
typedef ofxGuiValueLabel<float> ofxGuiFloatLabel;
typedef ofxGuiValueLabel<bool> ofxGuiBoolLabel;

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiSlider.h"
#pragma once

/* #include "../ofxGuiElement.h" */
/* #include "ofParameter.h" */

class ofxGuiSliderType{
	public:
	enum Type{
		/// \brief Default. Shows slider as a vertical or horizontal bar.
		STRAIGHT,
		/// \brief Displays circular slider.
		CIRCULAR
	};
};

template<typename DataType>
class ofxGuiSlider : public ofxGuiElement, public ofxGuiSliderType{
public:

	ofxGuiSlider();
	ofxGuiSlider(const ofJson & config);
	ofxGuiSlider(ofParameter<DataType>& _val, const ofJson & config = ofJson());
	ofxGuiSlider(const std::string& sliderName, DataType _val, DataType _min, DataType _max, const ofJson & config = ofJson());

	~ofxGuiSlider();

	void setMin(DataType min);
	DataType getMin();
	void setMax(DataType max);
	DataType getMax();

	void setType(const std::string &type);
	void setType(const Type &type);
	Type getType();

	virtual float getMinWidth() override;
	virtual float getMinHeight() override;

	void setPrecision(int precision);

	void setUpdateOnReleaseOnly(bool bUpdateOnReleaseOnly);

	virtual bool mousePressed(ofMouseEventArgs & args) override;
	virtual bool mouseDragged(ofMouseEventArgs & args) override;
	virtual bool mouseReleased(ofMouseEventArgs & args) override;
	virtual bool mouseScrolled(ofMouseEventArgs & args) override;

	template<class ListenerClass, typename ListenerMethod>
	void addListener(ListenerClass * listener, ListenerMethod method){
		value.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListener(ListenerClass * listener, ListenerMethod method){
		value.removeListener(listener,method);
	}

	double operator=(DataType v);
	operator const DataType & ();

	ofAbstractParameter & getParameter() override;

	static std::string getClassType();

protected:

	void setup();

	virtual std::vector<std::string> getClassTypes() override;

	virtual void _setConfig(const ofJson & config) override;
	virtual void render() override;

	virtual void resized(DOM::ResizeEventArgs&);

	ofParameter<DataType> value;
	ofParameter<ofxGuiSliderType::Type> type;
	virtual bool setValue(float mx, float my, bool bCheck) override;
	virtual void generateDraw() override;
	virtual void generateText();
	virtual void _generateText(std::string valStr);
	void valueChanged(DataType & value);
	virtual std::string getText();
	ofPath bar;
	ofVboMesh textMesh;

	ofParameter<bool> updateOnReleaseOnly;
	ofParameter<bool> showValue;
	ofParameter<unsigned int> precision;
	/// \brief The Slider orientation.
	bool horizontal;

	bool hasFocus;

	//circular type
	void arcStrip(ofPath & path, ofPoint center, float outer_radius, float inner_radius, float percent);
	float _mouseOffset;


};

typedef ofxGuiSlider<float> ofxGuiFloatSlider;
typedef ofxGuiSlider<int> ofxGuiIntSlider;

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiRangeSlider.h"
#pragma once

/* #include "ofxGuiSlider.h" */
/* #include "ofParameter.h" */

template<typename DataType>
class ofxGuiRangeSlider : public ofxGuiSlider<DataType> {
public:

	ofxGuiRangeSlider();
	ofxGuiRangeSlider(const ofJson & config);
	ofxGuiRangeSlider(ofParameter<DataType>& _valStart, ofParameter<DataType>& _valEnd, const ofJson & config = ofJson());
	ofxGuiRangeSlider(const std::string& sliderName, DataType _valStart, DataType _valEnd, DataType _min, DataType _max, const ofJson & config = ofJson());

	~ofxGuiRangeSlider();

	void setMin(DataType min);
	DataType getMin();
	void setMax(DataType max);
	DataType getMax();

	virtual bool mouseReleased(ofMouseEventArgs & args) override;

	template<class ListenerClass, typename ListenerMethod>
	void addListenerStart(ListenerClass * listener, ListenerMethod method){
		valueStart.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void addListenerEnd(ListenerClass * listener, ListenerMethod method){
		valueEnd.addListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListenerStart(ListenerClass * listener, ListenerMethod method){
		valueStart.removeListener(listener,method);
	}

	template<class ListenerClass, typename ListenerMethod>
	void removeListenerEnd(ListenerClass * listener, ListenerMethod method){
		valueEnd.removeListener(listener,method);
	}

	ofAbstractParameter & getParameter() override;

	static std::string getClassType();

protected:

	void setup();

	virtual std::vector<std::string> getClassTypes() override;

	virtual void render() override;

	ofParameter<DataType> valueStart,valueEnd;
	ofParameterGroup values;
	virtual bool setValue(float mx, float my, bool bCheck) override;
	virtual void generateDraw() override;
	virtual void generateText() override;
	virtual void _generateText(std::string valStr) override;
	void valueStartChanged(DataType & value);
	void valueEndChanged(DataType & value);
	virtual std::string getText();

	ofParameter<DataType> *activeValue;

};

typedef ofxGuiRangeSlider<float> ofxGuiFloatRangeSlider;
typedef ofxGuiRangeSlider<int> ofxGuiIntRangeSlider;

#line 0 "../addons-all/ofxGuiExtended/src/controls/ofxGuiZoomableGraphics.h"
#pragma once

/* #include "ofxGuiGraphics.h" */
/* #include "ofFbo.h" */

class ofxGuiZoomableGraphics : public ofxGuiGraphics {
	public:

		ofxGuiZoomableGraphics(std::string canvasName="", const ofJson& config = ofJson());
		ofxGuiZoomableGraphics(std::string canvasName, ofBaseDraws * graphics, const ofJson& config = ofJson());
		ofxGuiZoomableGraphics(std::string canvasName, ofBaseDraws * graphics, float w, float h = 0);

		virtual ~ofxGuiZoomableGraphics();

		virtual bool mousePressed(ofMouseEventArgs & args) override;
		virtual bool mouseDragged(ofMouseEventArgs & args) override;
		virtual bool mouseReleased(ofMouseEventArgs & args) override;
		virtual bool mouseScrolled(ofMouseEventArgs & args) override;

		virtual void onResize(DOM::ResizeEventArgs&args) override;

	protected:

		void setup();

		virtual void render() override;
		virtual void generateDraw() override;

		void setZoomFactor(int factor);
		ofPoint addZoom(ofPoint p);
		float addZoom(float p);
		ofPoint removeZoom(ofPoint p);

		int zoom_factor;
		float zoom_speed;
		ofPoint zoom_point, zoom_point_scaled, zoom_point_offset;
		ofPoint zoom_translation;

		bool dragging_dst;
		ofPoint last_mouse;

		ofFbo contentFbo;

};

#line 0 "../addons-all/ofxGuiExtended/src/containers/ofxGuiContainer.h"
#pragma once
/* #include "../ofxGuiElement.h" */

/* #include "../controls/ofxGuiSlider.h" */
/* #include "../controls/ofxGuiRangeSlider.h" */
/* #include "../controls/ofxGuiButton.h" */
/* #include "../controls/ofxGuiLabel.h" */
/* #include "ofParameterGroup.h" */
/* #include "ofParameter.h" */

template<class VecType>
class ofxGuiVecSlider_;

template<class VecType>
class ofxGuiColorSlider_;

template<class VecType>
class ofxGuiMenuColor_;

template<class VecType>
class ofxGuiMenuVec_;

typedef ofxGuiVecSlider_<ofVec3f> ofxGuiVec3Slider;
typedef ofxGuiVecSlider_<ofVec2f> ofxGuiVec2Slider;
typedef ofxGuiVecSlider_<ofVec4f> ofxGuiVec4Slider;
typedef ofxGuiVecSlider_<ofVec3f> ofxGuiPointSlider;

typedef ofxGuiMenuVec_<ofVec3f> ofxGuiMenuVec3;
typedef ofxGuiMenuVec_<ofVec2f> ofxGuiMenuVec2;
typedef ofxGuiMenuVec_<ofVec4f> ofxGuiMenuVec4;
typedef ofxGuiMenuVec_<ofVec3f> ofxGuiMenuPoint;

typedef ofxGuiColorSlider_<unsigned char> ofxGuiColorSlider;
typedef ofxGuiColorSlider_<unsigned short> ofxGuiShortColorSlider;
typedef ofxGuiColorSlider_<float> ofxGuiFloatColorSlider;

typedef ofxGuiMenuColor_<unsigned char> ofxGuiMenuColor;
typedef ofxGuiMenuColor_<unsigned short> ofxGuiMenuShortColor;
typedef ofxGuiMenuColor_<float> ofxGuiMenuFloatColor;

class ofxGuiRectangleSlider;
class ofxGuiMenuRectangle;
class ofxGuiCollection;
class ofxGuiPanel;
class ofxGuiTabs;
class ofxGuiMenu;
class ofxGuiFpsPlotter;


class ofxGuiContainer : public ofxGuiElement {
	public:

		ofxGuiContainer();
		ofxGuiContainer(const std::string& collectionName);
		ofxGuiContainer(const std::string& collectionName, const ofJson & config);
		ofxGuiContainer(const ofParameterGroup & parameters, const ofJson &config = ofJson());
		ofxGuiContainer(const ofParameterGroup & parameters, const std::string& _filename, float x = 10, float y = 10);
		ofxGuiContainer(const std::string& collectionName, const std::string& _filename, float x = 10, float y = 10);

		virtual ~ofxGuiContainer();

		void setup();

		using Element::add;

		template<typename T>
		typename std::enable_if<std::is_arithmetic<T>::value, ofxGuiSlider<T>*>::type add(ofParameter<T> & p, const ofJson & config = ofJson());

		ofxGuiButton* add(ofParameter <void> & parameter, const ofJson & config = ofJson());
		ofxGuiToggle* add(ofParameter <bool> & parameter, const ofJson & config = ofJson());
		ofxGuiLabel* add(ofParameter <std::string> & parameter, const ofJson & config = ofJson());
		ofxGuiVec2Slider *add(ofParameter <ofVec2f> & parameter, const ofJson & config = ofJson());
		ofxGuiVecSlider_<ofVec3f> *add(ofParameter <ofVec3f> & parameter, const ofJson & config = ofJson());
		ofxGuiVec4Slider* add(ofParameter <ofVec4f> & parameter, const ofJson & config = ofJson());
		ofxGuiColorSlider* add(ofParameter <ofColor> & parameter, const ofJson & config = ofJson());
		ofxGuiShortColorSlider* add(ofParameter <ofShortColor> & parameter, const ofJson & config = ofJson());
		ofxGuiFloatColorSlider* add(ofParameter <ofFloatColor> & parameter, const ofJson & config = ofJson());
		ofxGuiRectangleSlider *add(ofParameter <ofRectangle> & parameter, const ofJson & config = ofJson());

		void add(const std::shared_ptr<ofAbstractParameter> &p);
		void add(const ofParameterGroup& parameters);

		ofxGuiLabel* addLabel(const std::string& label, const ofJson& config = ofJson());
		ofxGuiElement* addSpacer(float width, float height);
		ofxGuiElement* addSpacer(const ofJson & config = ofJson());
		ofxGuiFpsPlotter* addFpsPlotter(const ofJson & config = ofJson());

		ofxGuiContainer* addContainer(const std::string& name="", const ofJson& config = ofJson());
		ofxGuiContainer* addContainer(const ofParameterGroup & parameters, const ofJson& config = ofJson());
		ofxGuiCollection* addGroup(const std::string& name="", const ofJson& config = ofJson());
		ofxGuiCollection* addGroup(const ofParameterGroup & parameters, const ofJson& config = ofJson());
		ofxGuiPanel* addPanel(const std::string& name="", const ofJson& config = ofJson());
		ofxGuiPanel* addPanel(const ofParameterGroup & parameters, const ofJson& config = ofJson());
		ofxGuiTabs* addTabs(const std::string& name="", const ofJson& config = ofJson());

		ofxGuiMenu* addMenu(ofParameterGroup &content, const ofJson& config = ofJson());
		void addMenuItems(ofParameterGroup *content);
		void addToMenu(const std::shared_ptr<ofAbstractParameter> &p);

		virtual void clear() override;

		/// \brief Get a list of pointers to the child elements.
		///
		/// The parent Element retains ownership.
		///
		/// \returns a list of pointers to child elements.
		virtual std::vector<ofxGuiElement*> getControls();

//		std::vector <std::string> getControlNames() const;
		std::size_t getNumControls();

		ofxGuiIntSlider* getIntSlider(const std::string& name);
		ofxGuiFloatSlider* getFloatSlider(const std::string& name);
		ofxGuiToggle* getToggle(const std::string& name);
		ofxGuiButton* getButton(const std::string& name);
		ofxGuiContainer* getGroup(const std::string& name);

		ofxGuiElement* getControl(const std::string& name);
		ofxGuiElement* getControl(std::size_t num);
		int getControlIndex(const std::string& name);
		int getControlIndex(ofxGuiElement* element);

		template <class ControlType>
		ControlType* getControlType(const std::string& name);

		template <class ControlType>
		ControlType* getControlType(const int& index);

		virtual ofAbstractParameter & getParameter() override;
		virtual std::string getName() override;
		virtual void setName(const std::string& name) override;

		bool getTogglesExclusive() const;
		void setExclusiveToggles(bool exclusive);
		bool setActiveToggle(int index);
		bool setActiveToggle(ofxGuiToggle* toggle);
		ofParameter<int>& getActiveToggleIndex();
		void deactivateAllOtherToggles(ofxGuiToggle* toggle);

		static std::string getClassType();

	protected:

		virtual std::vector<std::string> getClassTypes() override;

		ofParameterGroup parameters;

		virtual void _setConfig(const ofJson & config) override;

		void addParametersFrom(const ofParameterGroup & parameters);

		ofParameter<int> active_toggle_index;
		bool processToggles();
		void setOneToggleActive();

		ofParameter<std::string> filename;
		ofParameter<bool> exclusiveToggles;

		virtual void onChildAdded(DOM::ElementEventArgs&);
		virtual void onParentAdded(DOM::ElementEventArgs&);
		virtual void onResize(DOM::ResizeEventArgs&);

};

template <class ControlType>
ControlType* ofxGuiContainer::getControlType(const std::string& name){
	ControlType* control = dynamic_cast <ControlType *>(getControl(name));
	if(control){
		return control;
	}else{
		ofLogWarning() << "getControlType " << name << " not found, creating new";
		control = this->add<ControlType>();
		control->setName(name);
		return control;
	}
}

template <class ControlType>
ControlType* ofxGuiContainer::getControlType(const int& index){

	int counter = -1;
	for(auto &child : children()){
		if(ControlType* e = dynamic_cast<ControlType*>(child)){
			counter++;
			if(counter == index){
				return e;
			}
		}
	}

	return nullptr;

}

template<typename T>
typename std::enable_if<std::is_arithmetic<T>::value, ofxGuiSlider<T>*>::type ofxGuiContainer::add(ofParameter<T> & p, const ofJson & config){
	return add<ofxGuiSlider<T>>(p,config);
}

#line 0 "../addons-all/ofxGuiExtended/src/containers/ofxGuiCollection.h"

/* renamed from ofxGuiGroup to avoid clash with ofxxGui */

#pragma once
/* #include "ofxGuiContainer.h" */


class ofxGuiCollectionHeader : public ofxGuiElement {
	public:
		ofxGuiCollectionHeader(const ofJson &config = ofJson());

		~ofxGuiCollectionHeader();

		virtual bool mousePressed(ofMouseEventArgs & args) override;

		virtual float getMinWidth() override;
		virtual float getMinHeight() override;

		static std::string getClassType();

	protected:

		virtual std::vector<std::string> getClassTypes() override;

		virtual void generateDraw() override;
		virtual void render() override;
		ofVboMesh textMesh;

};


class ofxGuiCollection : public ofxGuiContainer {
	public:

		ofxGuiCollection();
		ofxGuiCollection(const std::string& collectionName);
		ofxGuiCollection(const std::string& collectionName, const ofJson & config);
		ofxGuiCollection(const ofParameterGroup & parameters, const ofJson &config = ofJson());
		ofxGuiCollection(const ofParameterGroup & parameters, const std::string& _filename, float x = 10, float y = 10);
		ofxGuiCollection(const std::string& collectionName, const std::string& _filename, float x = 10, float y = 10);

		virtual ~ofxGuiCollection();

		void setup();
		void setup(const std::string& collectionName);

		virtual void minimize();
		virtual void maximize();
		virtual void minimizeAll();
		virtual void maximizeAll();
		bool getMinimized();
		void toggleMinimize();

		void setShowHeader(bool show);
		ofxGuiElement* getHeader();

		virtual std::vector<ofxGuiElement*> getControls() override;

		static std::string getClassType();

	protected:

		virtual std::vector<std::string> getClassTypes() override;

		virtual void _setConfig(const ofJson & config) override;

		ofParameter<bool> minimized;
		ofParameter<bool> showHeader;
		ofxGuiElement* header;

		virtual void onHeaderVisibility(bool& showing);
		virtual void onHeaderHeight(float& height);

	private:
		float widthMaximized, heightMaximized;

};

#line 0 "../addons-all/ofxGuiExtended/src/containers/ofxGuiMenu.h"
#pragma once

/* #include "ofxGuiContainer.h" */

class ofxGuiMenuLabel : public ofxGuiLabel {
	public:
		ofxGuiMenuLabel(const std::string& labelName, const std::string & label, const ofJson & config = ofJson());
		~ofxGuiMenuLabel(){}
	protected:
		virtual void generateDraw() override;
		virtual void render() override;
		virtual float getMinWidth() override;
		ofPath icon;
};

class ofxGuiSubmenuLabel : public ofxGuiMenuLabel {
	public:
		ofxGuiSubmenuLabel(const std::string& labelName, const std::string & label, const ofJson & config = ofJson());
		~ofxGuiSubmenuLabel(){}
	protected:
		virtual void generateDraw() override;
};

class ofxGuiMenu : public ofxGuiContainer {

	public:

		ofxGuiMenu();
		ofxGuiMenu(const std::string &collectionName, const ofJson & config = ofJson());
		ofxGuiMenu(std::string collectionName, std::string filename, float x = 10, float y = 10);
		ofxGuiMenu(const ofParameterGroup & parameters, const ofJson & config = ofJson());
		ofxGuiMenu(const ofParameterGroup & parameters, const std::string& filename, float x = 10, float y = 10);
		~ofxGuiMenu();

		void setup();

		static std::string getClassType();

		ofxGuiLabel* getMenuLabel();
		ofParameter<bool>& isRootMenu();

		virtual bool mouseMoved(ofMouseEventArgs & args) override;
		virtual bool mousePressed(ofMouseEventArgs & args) override;

	protected:

		void hideOtherMenusUp(DOM::Element* parent, ofxGuiMenu* exception);
		void hideOtherMenusDown(DOM::Element *parent, ofxGuiMenu* exception);
		void hideOtherMenusUpPress(ofxGuiContainer* parent, ofxGuiMenu* exception);
		void hideOtherMenusDownPress(ofxGuiContainer *parent, ofxGuiMenu* exception);
		bool isMouseOver(ofxGuiElement *el);

		virtual std::vector<std::string> getClassTypes() override;

		virtual void generateDraw() override;

		void onAdded(DOM::ElementEventArgs& args);

		ofParameter<bool> isOpen;

		ofxGuiLabel* label;

		bool onMenuLabel;
		bool rootMenu;
		bool changeLabelColor;

};

class ofxGuiRootMenu : public ofxGuiMenu {
	public:
		ofxGuiRootMenu(const std::string &collectionName, const ofJson & config = ofJson());
		~ofxGuiRootMenu();
};


template<typename ColorType>
class ofxGuiMenuColor_: public ofxGuiMenu{

public:
	ofxGuiMenuColor_(ofParameter<ofColor_<ColorType>> &value, const ofJson & config = ofJson());
	~ofxGuiMenuColor_();

	ofAbstractParameter & getParameter();

	ofColor_<ColorType> operator=(const ofColor_<ColorType> & v);
	operator const ofColor_<ColorType> & ();
protected:
	virtual void generateDraw() override;
	void changeSlider(const void * parameter, ColorType & value);
	void changeValue(ofColor_<ColorType> & value);
	ofParameter<ofColor_<ColorType> > value;
	bool sliderChanging;
	std::vector<std::string> names;
};

template<class VecType>
class ofxGuiMenuVec_ : public ofxGuiMenu {
public:

	ofxGuiMenuVec_(ofParameter<VecType> &value, const ofJson & config = ofJson());
	~ofxGuiMenuVec_();

	void setup();

	ofAbstractParameter & getParameter();

	VecType operator=(const VecType & v);
	operator const VecType & ();
	const VecType * operator->();
protected:
	void changeSlider(const void * parameter, float & value);
	void changeValue(VecType & value);
	ofParameter<VecType> value;
	bool sliderChanging;
	std::vector<std::string> names;
};

class ofxGuiMenuRectangle : public ofxGuiMenu {
public:

	ofxGuiMenuRectangle(ofParameter<ofRectangle> &value, const ofJson & config = ofJson());
	~ofxGuiMenuRectangle();

	void setup();

	ofAbstractParameter & getParameter();

	ofRectangle operator=(const ofRectangle & v);
	operator const ofRectangle & ();
	const ofRectangle * operator->();
protected:
	void changeSlider(const void * parameter, float & value);
	void changeValue(ofRectangle & value);
	ofParameter<ofRectangle> value;
	bool sliderChanging;
	std::vector<std::string> names;
};

#line 0 "../addons-all/ofxGuiExtended/src/containers/ofxGuiPanel.h"
#pragma once

/* #include "ofxGuiCollection.h" */
/* #include "ofImage.h" */

class ofxGuiCollection;

class ofxGuiPanelHeader : public ofxGuiCollectionHeader {

	public:

		ofxGuiPanelHeader();
		ofxGuiPanelHeader(const ofJson &config);

		~ofxGuiPanelHeader(){}

		virtual float getMinWidth() override;

		virtual bool mousePressed(ofMouseEventArgs & args) override;

		ofEvent<void> loadPressedE;
		ofEvent<void> savePressedE;

		static std::string getClassType();

	protected:

		virtual std::vector<std::string> getClassTypes() override;

		virtual void generateDraw() override;
		virtual void render() override;
		virtual void loadIcons();

		ofRectangle loadBox, saveBox;
		ofImage loadIcon;
		ofImage saveIcon;

};

class ofxGuiPanel : public ofxGuiCollection {

	public:

		ofxGuiPanel(const std::string& collectionName="");
		ofxGuiPanel(const std::string& collectionName, const ofJson & config);
		ofxGuiPanel(const ofParameterGroup & parameters, const ofJson & config = ofJson());
		ofxGuiPanel(const std::string& collectionName, const std::string& filename, float x = 10, float y = 10);
		ofxGuiPanel(const ofParameterGroup & parameters, const std::string& filename, float x = 10, float y = 10);

		~ofxGuiPanel();

		void setup();
		void setup(const std::string& panelName);

		void onHeaderMove(DOM::MoveEventArgs& args);
		void onLoadPressed();
		void onSavePressed();

		static std::string getClassType();

	protected:
		virtual std::vector<std::string> getClassTypes() override;

	private:

		bool headerListenersLoaded;

};

#line 0 "../addons-all/ofxGuiExtended/src/containers/ofxGuiSliderGroup.h"
#pragma once

/* #include "ofxGuiCollection.h" */


template<class VecType>
class ofxGuiVecSlider_ : public ofxGuiCollection {
public:

	ofxGuiVecSlider_();
	ofxGuiVecSlider_(const ofJson & config);
	ofxGuiVecSlider_(ofParameter<VecType> &value, const ofJson & config = ofJson());
	ofxGuiVecSlider_(const std::string& controlName, const VecType & value, const VecType & min, const VecType & max, const ofJson & config = ofJson());

	~ofxGuiVecSlider_();

	void setup();

	ofAbstractParameter & getParameter();

	VecType operator=(const VecType & v);
	operator const VecType & ();
	const VecType * operator->();
protected:
	void changeSlider(const void * parameter, float & value);
	void changeValue(VecType & value);
	ofParameter<VecType> value;
	bool sliderChanging;
	std::vector<std::string> names;
};

class ofxGuiRectangleSlider : public ofxGuiCollection {
public:

	ofxGuiRectangleSlider();
	ofxGuiRectangleSlider(const ofJson & config);
	ofxGuiRectangleSlider(ofParameter<ofRectangle> &value, const ofJson & config = ofJson());
	ofxGuiRectangleSlider(const std::string& controlName, const ofRectangle & value, const ofRectangle & min, const ofRectangle & max, const ofJson & config = ofJson());

	~ofxGuiRectangleSlider();

	void setup();

	ofAbstractParameter & getParameter();

	ofRectangle operator=(const ofRectangle & v);
	operator const ofRectangle & ();
	const ofRectangle * operator->();
protected:
	void changeSlider(const void * parameter, float & value);
	void changeValue(ofRectangle & value);
	ofParameter<ofRectangle> value;
	bool sliderChanging;
	std::vector<std::string> names;
};

template<typename ColorType>
class ofxGuiColorSlider_: public ofxGuiCollection{

public:

	ofxGuiColorSlider_();
	ofxGuiColorSlider_(const ofJson & config);
	ofxGuiColorSlider_(ofParameter<ofColor_<ColorType>> &value, const ofJson & config = ofJson());
	ofxGuiColorSlider_(const std::string& controlName, const ofColor_<ColorType> & value, const ofColor_<ColorType> & min, const ofColor_<ColorType> & max, const ofJson & config = ofJson());

	~ofxGuiColorSlider_();

	void setup();

	ofAbstractParameter & getParameter();

	ofColor_<ColorType> operator=(const ofColor_<ColorType> & v);
	operator const ofColor_<ColorType> & ();
protected:
	void changeSlider(const void * parameter, ColorType & value);
	void changeValue(ofColor_<ColorType> & value);
	ofParameter<ofColor_<ColorType> > value;
	bool sliderChanging;
	std::vector<std::string> names;
};


#line 0 "../addons-all/ofxGuiExtended/src/containers/ofxGuiTabs.h"
#pragma once

/* #include "ofxGuiContainer.h" */

class ofxGuiTabs : public ofxGuiContainer {

	public:

		ofxGuiTabs();
		ofxGuiTabs(const std::string &collectionName, const ofJson & config = ofJson());
		ofxGuiTabs(std::string collectionName, std::string filename, float x = 10, float y = 10);
		~ofxGuiTabs();

		void setup();

		using ofxGuiContainer::add;

		template <typename GuiType>
		GuiType* add(std::unique_ptr<GuiType> element);

		virtual void clear() override;

		void setActiveTab(int index);
		ofParameter<int> &getActiveTabIndex();
		Element * getActiveTab();

		void setTabHeight(int h);
		void setTabWidth(int w);

		static std::string getClassType();

	protected:

		void _setActiveTab(int &index);

		virtual std::vector<std::string> getClassTypes() override;

		virtual void generateDraw() override;

		void onChildAdd(DOM::ElementEventArgs& args);

		ofParameter<float> tabWidth;
		ofParameter<float> tabHeight;

		ofxGuiContainer * tabs;
		std::vector<Element*> pages;
		Element * activePage;
		ofxGuiElement * activeToggle;


	private:
};

#line 0 "../addons-all/ofxGuiExtended/src/view/JsonConfigParser.h"
#pragma once

/* #include "ofMain.h" */
/* #include "../DOM/Types.h" */
/* #include "../DOM/Element.h" */

class JsonConfigParser {
	public:

		template <typename AttributeType>
		static bool parse(const ofJson &config, ofParameter<AttributeType>& attribute){
			AttributeType res = attribute.get();
			parse<AttributeType>(config, attribute.getName(), res);
			if(attribute.get() == res){
				//no changes
				return false;
			}else{
				//changes
				attribute.set(res);
				return true;

			}

		}

		template <typename AttributeType>
		static bool parse(const ofJson &config, const string& name, AttributeType& attribute){
			if(!config.is_null()){
				return _parse(config, name, attribute);
			}
			return false;
		}

		static bool parse(const ofJson &config, DOM::Element* val);

		///\brief regex helper function copied from https://github.com/openframeworks/openFrameworks/issues/1110
		static vector<std::string> getMatchedStrings(std::string contents, string regex);

	protected:


		/// \todo this method is not called for arithmetic values (don't know why)
		/// that's why I copied the content to the default _parse function at the bottom.
		/// works but should be changed someday.
		template<typename AttributeType>
		static bool _parse(const ofJson &config, const string& name,
						   typename std::enable_if<std::is_arithmetic<AttributeType>::value, AttributeType>::type& val){

			if (config.find(name) != config.end()) {
				ofJson content = config[name];
				if(content.is_number()){
					val = content;
					return true;
				}else {
					ofLogError("JsonConfigParser::parse") << "Could not parse " << config << " to arithmetic value.";
				}
			}
			return false;
		}
		static bool _parse(const ofJson &config, const string& name, bool& val);
		static bool _parse(const ofJson &config, const string& name, std::string& val);
		static bool _parse(const ofJson &config, const string& name, ofColor& val);
		static bool _parse(const ofJson &config, const string& name, ofPoint& val);
		static bool _parse(const ofJson &config, const string& name, ofRectangle& val);
		static bool _parse(const ofJson &config, const string& name, DOM::LayoutFloat& val);
		static bool _parse(const ofJson &config, const string& name, DOM::LayoutPosition& val);

		///\brief Default parse method for non implemented attribute types
		template <typename AttributeType>
		static bool _parse(const ofJson &config, const string& name, AttributeType& attribute){

			if (config.find(name) != config.end()) {
				ofJson content = config[name];
				if(content.is_number()){
					attribute = content;
					return true;
				}else {
					ofLogError("JsonConfigParser::parse") << "Could not parse " << config << " to arithmetic value.";
				}
			}

			// TODO throw error when no parsing method found?
			return false;
		}

};

#line 0 "../addons-all/ofxGuiExtended/src/view/ofxDOMBoxLayout.h"
// =============================================================================
//
// Copyright (c) 2009-2016 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once

#include <vector>
/* #include "../DOM/Types.h" */
/* #include "../DOM/Layout.h" */

class ofxDOMBoxLayout: public DOM::_Layout<ofxDOMBoxLayout>
{
public:

	/// \brief Direction options
	enum class Direction {
		/// \brief Align items horizontally from left to right (default)
		HORIZONTAL,
		/// \brief Align items vertically from top to bottom
		VERTICAL
	};

	ofxDOMBoxLayout(DOM::Element* parent);

	virtual ~ofxDOMBoxLayout();

	virtual void doLayout() override;

protected:

	static Direction getDirection(DOM::Element* e, Direction defaultVal = Direction::VERTICAL);

};


#line 0 "../addons-all/ofxGuiExtended/src/view/ofxDOMFlexBoxLayout.h"
#pragma once

/* #include "../DOM/Layout.h" */
/* #include "ofParameter.h" */
/* #include "Element.h" */

class ofxDOMFlexBoxLayout: public DOM::_Layout<ofxDOMFlexBoxLayout>
{
public:

	/// \brief Flex direction options
	enum class FlexDirection {
		/// \brief Align items horizontally from left to right (default)
		ROW,
		/// \brief Align items vertically from top to bottom
		COLUMN
	};

	/// \brief Flex wrap options
	enum class FlexWrap {
		/// \brief Set items in one single line (default)
		NOWRAP,
		/// \brief Use multiple lines to align items if needed
		WRAP
	};

	/// \brief Align items along the main axis options
	enum class JustifyContent {
		/// \brief Align items at the beginning according to flex direction (default)
		FLEX_START,
		/// \brief Align items at the end according to flex direction
		FLEX_END,
		/// \brief Align items at the center
		CENTER,
		/// \brief Distribute items with equal spacing between them, first and last items without spacing to the edges
		SPACE_BETWEEN,
		/// \brief Distribute items with equal spacing around all items
		SPACE_AROUND
	};

	/// \brief Align items along the cross axis options
	enum class AlignItems {
		/// \brief Items fill the whole height (or width)
		STRETCH,
		/// \brief Align items at the beginning (default)
		FLEX_START,
		/// \brief Align items at the end
		FLEX_END,
		/// \brief Align items at the center
		CENTER
	};

	/// \brief Alignment options for item lines when there is space in the container along the cross axis, only used if multiple rows / columns are present
	enum class AlignContent {
		/// \brief Distributed space after every item row / column
		STRETCH,
		/// \brief Items are stacked towards the beginning
		FLEX_START,
		/// \brief Items are stacked towards the end
		FLEX_END,
		/// \brief Items are stacked in the center
		CENTER,
		/// \brief Distribute item rows / columns with equal spacing between them, first and last ones without spacing to the edges
		SPACE_BETWEEN,
		/// \brief Distribute item rows / columns with equal spacing around all of them
		SPACE_AROUND
	};

	/// \brief Individual alignment options for flex items along the cross axis
	enum class AlignSelf {
		/// \brief Use AlignItems value of parent
		AUTO,
		/// \brief Item is aligned at the beginning
		FLEX_START,
		/// \brief Item is aligned at the end
		FLEX_END,
		/// \brief Item is aligned at the center
		CENTER,
		/// \brief Item is stretched
		STRETCH
	};


	/// If the Orientation::DEFAULT is chosen, the default will be set to
	/// Orientation::HORIZONTAL.
	ofxDOMFlexBoxLayout(DOM::Element* parent);

	virtual ~ofxDOMFlexBoxLayout();

	virtual void doLayout() override;

protected:

	struct FlexBoxObject {
		DOM::Element* origin;
		ofRectangle shape;
		bool sizeSet = false;
		bool flex = false;
		float flexBasis = 0;
	};

	struct FlexBoxLine {
		FlexBoxLine(float initialSpaceMainAxis){
			totalSpaceMainAxis = initialSpaceMainAxis;
		}
		std::vector<FlexBoxObject> items;
		float totalSpaceMainAxis;
		float sizeCrossAxis;
	};

	void align(FlexDirection direction);

	static bool elementFlexing(DOM::Element* e);

	static FlexDirection getFlexDirection(DOM::Element* e, FlexDirection defaultVal = FlexDirection::COLUMN);
	static FlexWrap getFlexWrap(DOM::Element* e, FlexWrap defaultVal = FlexWrap::NOWRAP);
	static JustifyContent getJustifyContent(DOM::Element* e, JustifyContent defaultVal = JustifyContent::FLEX_START);
	static AlignItems getAlignItems(DOM::Element* e, AlignItems defaultVal = AlignItems::STRETCH);
	static AlignContent getAlignContent(DOM::Element* e, AlignContent defaultVal = AlignContent::STRETCH);
	static AlignSelf getAlignSelf(DOM::Element* e, AlignSelf defaultVal = AlignSelf::AUTO);

	static float getWidthPlusMargin(DOM::Element* e);
	static float getHeightPlusMargin(DOM::Element* e);

	static void setLayoutWidthMinusMargin(DOM::Element* e, float width);
	static void setLayoutHeightMinusMargin(DOM::Element* e, float height);

};

#line 0 "../addons-all/ofxGuiExtended/src/view/ofxDOMLayoutHelper.h"
#pragma once

/* #include "../DOM/Element.h" */

class ofxDOMLayoutHelper
{
	public:
		ofxDOMLayoutHelper();

		static bool elementAbsolutePositioned(DOM::Element* e);

		static float getDesiredWidth(DOM::Element* e);
		static float getDesiredHeight(DOM::Element* e);
		static float getDesiredWidth(DOM::Element* e, float parentWidth);
		static float getDesiredHeight(DOM::Element* e, float parentHeight);
		static float getDesiredWidthStretched(DOM::Element* e, float parentWidth);
		static float getDesiredHeightStretched(DOM::Element* e, float parentHeight);
		static float getMaxWidth(DOM::Element* e, float parentWidth);
		static float getMaxHeight(DOM::Element* e, float parentHeight);

		static float getMarginHorizontal(DOM::Element* e);
		static float getMarginVertical(DOM::Element* e);
		static float getMarginLeft(DOM::Element* e);
		static float getMarginRight(DOM::Element* e);
		static float getMarginTop(DOM::Element* e);
		static float getMarginBottom(DOM::Element* e);

		static float getPaddingHorizontal(DOM::Element* e);
		static float getPaddingVertical(DOM::Element* e);
		static float getPaddingLeft(DOM::Element* e);
		static float getPaddingRight(DOM::Element* e);
		static float getPaddingTop(DOM::Element* e);
		static float getPaddingBottom(DOM::Element* e);

		static void setPosition(DOM::Element* e, ofPoint p);
};

#line 0 "../addons-all/ofxGuiExtended/src/view/ofxGuiDefaultConfig.h"
#pragma once
/* #include "ofMain.h" */
/* #include "../ofxGuiExtended.h" */

struct ofxGuiDefaultConfig{

		static ofJson get(){

			ofJson config = {

				/// settings for all elements
				{
					ofxGuiElement::getClassType(), {
						{"background-color", "rgba(0,0,0,0.2)"},
						{"fill-color", "rgba(200,200,200,0.42)"},
						{"border-width", 1},
						{"padding", 2},
						{"border-color", "rgb(255,255,255)"},
						{"margin", 4},
						{"text-color", "#ffffff"}
					}
				},

				/// settings for all toggles
				{
					ofxGuiToggle::getClassType(), {
					}
				},

				/// settings for all buttons
				{
					ofxGuiButton::getClassType(), {
					}
				},

				/// settings for all sliders
				{
					ofxGuiFloatSlider::getClassType(), {

					}
				},

				/// settings for all rangesliders
				{
					ofxGuiFloatRangeSlider::getClassType(), {

					}
				},

				/// settings for all labels
				{
					ofxGuiLabel::getClassType(), {
						{"border-width", 0},
						{"background-color", "transparent"}
					}
				},

				/// settings for all containers
				{
					ofxGuiContainer::getClassType(), {
						{"border-color", "rgba(255,255,255,0.7)"},
						{"padding", 0},
						{"border-width", 0}
					}
				},

				/// settings for all groups
				{
					ofxGuiCollection::getClassType(), {
					}
				},

				/// settings for all group headers
				{
					ofxGuiCollectionHeader::getClassType(), {
						{"width", "100%"},
						{"align-self", "stretch"},
						{"flex","none"},
						{"margin", 0},
						{"border-width", 0},
						{"padding", 0},
						{"text-color", "#ffffff"}
					}
				},

				/// settings for all panels
				{
					ofxGuiPanel::getClassType(), {
					}
				},

				/// settings for all panel headers
				{
					ofxGuiPanelHeader::getClassType(), {
					}

				},

				/// settings for all tabbed groups
				{
					ofxGuiTabs::getClassType(), {
						{"show-header",false},
						{"margin-top", 10}
					}
				},

				/// settings for all value plotters
				{
					ofxGuiValuePlotter::getClassType(), {

					}
				},

				/// settings for all input fields
				{
					ofxGuiIntInputField::getClassType(), {

					}
				}

			};
			return config;
		}

};

#line 0 "../addons-all/ofxGuiExtended/src/ofxGuiExtended.h"
#pragma once

/* #include "ofxGuiElement.h" */
/* #include "containers/ofxGuiCollection.h" */
/* #include "containers/ofxGuiSliderGroup.h" */
/* #include "containers/ofxGuiPanel.h" */
/* #include "containers/ofxGuiMenu.h" */
/* #include "containers/ofxGuiTabs.h" */
/* #include "controls/ofxGuiToggle.h" */
/* #include "controls/ofxGuiSlider.h" */
/* #include "controls/ofxGuiRangeSlider.h" */
/* #include "controls/ofxGuiButton.h" */
/* #include "controls/ofxGuiLabel.h" */
/* #include "controls/ofxGuiValuePlotter.h" */
/* #include "controls/ofxGuiFpsPlotter.h" */
/* #include "controls/ofxGuiFunctionPlotter.h" */
/* #include "controls/ofxGuiInputField.h" */
/* #include "controls/ofxGuiGraphics.h" */
/* #include "controls/ofxGuiZoomableGraphics.h" */

/* #include "DOM/ofxDOM.h" */

/* #include "view/ofxGuiDefaultConfig.h" */
/* #include "view/ofxDOMFlexBoxLayout.h" */
/* #include "view/ofxDOMBoxLayout.h" */
/* #include "view/JsonConfigParser.h" */

class ofxGui {
	public:
		ofxGui();
		~ofxGui();

		/// \brief Setup function initializing the GUI using the flexbox layout defined by ofxDOMFlexBoxLayout.
		/// This function has to be called before adding elements to the GUI.
		void setupFlexBoxLayout();

		/// \brief Template setup function initializing the GUI using the layout given by the template class.
		/// The setup function doesn't need to be called from the application if one wants to use
		/// the default ofxDOMBoxLayout, it will be executed automatically.
		/// This function has to be called before adding elements to the GUI.
		template<typename LayoutType = ofxDOMBoxLayout>
		void setup(){
			if(!setup_done){
				setup_done = true;
				document = std::make_unique<DOM::Document>();
				document->createLayout<LayoutType>(document.get());
			}else{
				ofLogError("ofxGui::setup()") << "Setup already done. This function needs to be called before getting the document or adding any elements to it.";
			}
		}

		/// \brief Get the root document of the GUI.
		/// \returns The root DOM::Document.
		DOM::Document* getDocument();

		/// \returns A parameter that determines if the gui is visible or not.
		ofParameter<bool>& getVisible();

		/// \brief Add a container to the document.
		/// A container is a collection of elements.
		/// \param name The container name.
		/// \param config The container configuration.
		/// \returns The GUI container element.
		ofxGuiContainer* addContainer(const std::string& name="", const ofJson& config = ofJson());

		/// \brief Add a container to the document.
		/// A container is a collection of elements.
		/// \param parameters A parameter group containing parameters that will be added to the container.
		/// \param config The container configuration.
		/// \returns The GUI container element.
		ofxGuiContainer* addContainer(const ofParameterGroup & parameters, const ofJson& config = ofJson());

		/// \brief Add a group to the document.
		/// A group is a container of elements with a header to minimize the group.
		/// \param name The group name.
		/// \param config The group configuration.
		/// \returns The GUI group element.
		ofxGuiCollection* addGroup(const std::string& name="", const ofJson& config = ofJson());

		/// \brief Add a group to the document.
		/// A group is a container of elements with a header to minimize the group.
		/// \param parameters A parameter group containing parameters that will be added to the group.
		/// \param config The group configuration.
		/// \returns The GUI group element.
		ofxGuiCollection* addGroup(const ofParameterGroup & parameters, const ofJson& config = ofJson());

		/// \brief Add a panel to the document.
		/// A panel is a container of elements with a header to save and load all child controls.
		/// \param name The panel name.
		/// \param config The panel configuration.
		/// \returns The GUI panel element.
		ofxGuiPanel* addPanel(const std::string& name="", const ofJson& config = ofJson());

		/// \brief Add a panel to the document.
		/// A panel is a container of elements with a header to save and load all child controls.
		/// \param parameters A parameter group containing parameters that will be added to the panel.
		/// \param config The panel configuration.
		/// \returns The GUI panel element.
		ofxGuiPanel* addPanel(const ofParameterGroup & parameters, const ofJson& config = ofJson());

		/// \brief Add a tabbed interface to the document.
		/// A tabbed interface is a container of other containers. For each added container a tab will be created.
		/// \param name The name of the tabbed interface (won't be displayed by default).
		/// \param config The tabbed interface configuration.
		/// \returns The tabbed interface element.
		ofxGuiTabs* addTabs(const std::string& name="", const ofJson& config = ofJson());

		/// \brief Set a config recursively for all elements of the GUI.
		/// \param config The configuration.
		void setConfig(const ofJson &config);

		/// \brief Add a parameter to the GUI without initializing a panel or group first.
		/// Creates a default panel if not already done.
		/// \param parameter The parameter that is going to be modifiable with the standard control type for the specific parameter type.
		template<typename T>
		void add(ofParameter<T>& parameter){
			if(!defaultPanel){
				defaultPanel = addPanel();
			}
			defaultPanel->add(parameter);
		}

		/// \brief Add parameters to the GUI without initializing a panel or group first.
		/// Creates a default panel if not already done.
		/// \param parameters The parameters that are going to be modifiable with the standard control type for each parameter type.
		template<typename T, typename... Args>
		void add(ofParameter<T>& parameter, Args... args) {
			getDocument()->blockLayout(true);
			add(parameter);
			add(args...) ;
			getDocument()->blockLayout(false);
		}

		ofxGuiContainer *addMenu(ofParameterGroup &content, const ofJson &config = ofJson());

		/// \brief Converts ofColor data type to a CSS-like rgba string.
		/// example: ofColor(255,0,0,127.5) -> "rgba(255,0,0,0.5)"
		/// \param color The color to be converted
		/// \returns The color in string rgba format.
		static std::string colorToString(const ofColor& color);

	private:
		std::unique_ptr<DOM::Document> document;

		bool setup_done;

		ofJson rootGroupConfig(const ofJson& config = ofJson());

		ofxGuiCollection* defaultPanel = nullptr;
};


#line 0 "../addons-all/ofxSortableList/src/ofxSortableList.h"
#pragma once
/* #include "ofMain.h" */
/* #include "ofxGuiExtended.h" */

struct MovingElementData {
	MovingElementData(int i1, int i2, ofxGuiElement* _widget)
		:old_index(i1),
		  new_index(i2),
		  name(_widget->getName()),
		  widget(_widget) {}
	int old_index, new_index;
	string name;
	ofxGuiElement* widget;
};

struct RemovedElementData {
	RemovedElementData(int _index, string _name):index(_index),name(_name) {}
	int index;
	string name;
};

class ofxSortableList : public ofxGuiCollection {

public:
	ofxSortableList(const string &name="", const ofJson &config = ofJson());
	~ofxSortableList();

	void clear();
	void refill();
	void shift(int start_index);

	bool mouseDragged(ofMouseEventArgs& args);
	bool mousePressed(ofMouseEventArgs& args);
	bool mouseReleased(ofMouseEventArgs& args);

	//is called after an element is dropped outside of the list.
	ofEvent <RemovedElementData> elementRemoved;

	//is called after an element is dropped and changed position.
	ofEvent <MovingElementData> elementMoved;

	//is called for every single index an element is moved. when an element is moved from 2 to 4, it is called two times (2->3, 3->4)
	ofEvent <MovingElementData> elementMovedStepByStep;

protected:

private:
	void swap(int index1, int index2);
	bool draggingElement;
	ofPoint draggedElementOldPos;
	ofVec2f mouseOffset;
	ofxGuiElement* draggedElement;
	ofxGuiElement* dummy;

};


#line 0 "../addons-all/ofxAffinetransformation/src/Eigenvalue.h"
/**
* This code change from papaya.
* Eigenvalue.h <= papaya/src/Eigenvalue.java
* If u hava any problem, please send email to dsu.kavin@gmail.com.^^
*/
/**
* papaya: A collection of utilities for Statistics and Matrix-related manipulations
* http://adilapapaya.com/papayastatistics/, 1.1.0
* Created by Adila Faruk, http://adilapapaya.com, May 2012, Last Updated April 2014
*
*
* Copyright (C) 2014 Adila Faruk http://adilapapaya.com
*
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General
* Public License along with this library; if not, write to the
* Free Software Foundation, Inc., 59 Temple Place, Suite 330,
* Boston, MA  02111-1307  USA
*/

/** Eigenvalues and eigenvectors of a real matrix.
<p>
If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is
diagonal and the eigenvector matrix V is orthogonal.
I.e. A = V.times(D.times(V.transpose())) and
V.times(V.transpose()) equals the identity matrix.
<p>
If A is not symmetric, then the eigenvalue matrix D is block diagonal
with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
columns of V represent the eigenvectors in the sense that A*V = V*D,
i.e. A.times(V) equals V.times(D).  The matrix V may be badly
conditioned, or even singular, so the validity of the equation
A = V*D*inverse(V) depends upon V.cond().
<p>
<i>Shamelessly copied (and modified) from the
<a href="http://math.nist.gov/javanumerics/jama/" target="_blank">JAMA Java
Matrix</a> package. To make things compatible with how most users use Processing, the
class take in float matrices. However, to preserve the acccuracy of the computations, the algorithm
first casts the input into a double array, prior to doing anything. All methods also return doubles; Use
{@link Cast#doubleToFloat(double[][])} if you want/need to cast everything back to floats for
further (non-high-accuracy-dependant) processing (pun intended).</i>
*/


class Eigenvalue {

public:
	/** Row and column dimension (square matrix).
	@serial matrix dimension.
	*/
	int n;

	/** Symmetry flag.
	@serial internal symmetry flag.
	*/
	bool issymmetric;

	/** Arrays for internal storage of eigenvalues.
	@serial internal storage of eigenvalues.
	*/
	double *d, *e;

	/** Array for internal storage of eigenvectors.
	@serial internal storage of eigenvectors.
	*/
	double **V;

	/** Array for internal storage of nonsymmetric Hessenberg form.
	@serial internal storage of nonsymmetric Hessenberg form.
	*/
	double **H;

	/** Working storage for nonsymmetric algorithm.
	@serial working storage for nonsymmetric algorithm.
	*/
	double *ort;

	/** Array for original matrix value.
	@serial working storage for calculate().
	*/
	double **A;

	/** Check for symmetry, then construct the eigenvalue decomposition.
	* Upon initialization, the matrices D and V, as well as the vectors containing the
	* real and imaginary eigenvalues are computed and stored.
	* @see getV()
	* @see getD()
	* @see getRealEigenvalues()
	* @see getImagEigenvalues()
	*/
	Eigenvalue() {
		n = 9;
		V = new double*[n];
		for (int i = 0; i < n; ++i)
			V[i] = new double[n];

		H = new double*[n];
		for (int i = 0; i < n; ++i)
			H[i] = new double[n];

		A = new double*[n];
		for (int i = 0; i < n; ++i)
			A[i] = new double[n];
	}
	void calculate() {

		d = new double[n];
		e = new double[n];

		issymmetric = true;
		for (int j = 0; (j < n) & issymmetric; j++) {
			for (int i = 0; (i < n) & issymmetric; i++) {
				issymmetric = (A[i][j] == A[j][i]);
			}
		}

		if (issymmetric) {
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) {
					V[i][j] = A[i][j];
				}
			}

			// Tridiagonalize.
			tred2();

			// Diagonalize.
			tql2();

		}
		else {
			//H = new double[n][n];
			ort = new double[n];

			for (int j = 0; j < n; j++) {
				for (int i = 0; i < n; i++) {
					H[i][j] = A[i][j];
				}
			}

			// Reduce to Hessenberg form.
			orthes();

			// Reduce Hessenberg to real Schur form.
			hqr2();
		}
	}

	// Symmetric Householder reduction to tridiagonal form.
	void tred2() {
		//  This is derived from the Algol procedures tred2 by
		//  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
		//  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
		//  Fortran subroutine in EISPACK.

		for (int j = 0; j < n; j++) {
			d[j] = V[n - 1][j];
		}

		// Householder reduction to tridiagonal form.

		for (int i = n - 1; i > 0; i--) {

			// Scale to avoid under/overflow.

			double scale = 0.0;
			double h = 0.0;
			for (int k = 0; k < i; k++) {
				scale = scale + abs(d[k]);
			}
			if (scale == 0.0) {
				e[i] = d[i - 1];
				for (int j = 0; j < i; j++) {
					d[j] = V[i - 1][j];
					V[i][j] = 0.0;
					V[j][i] = 0.0;
				}
			}
			else {

				// Generate Householder vector.

				for (int k = 0; k < i; k++) {
					d[k] /= scale;
					h += d[k] * d[k];
				}
				double f = d[i - 1];
				double g = sqrt(h);
				if (f > 0) {
					g = -g;
				}
				e[i] = scale * g;
				h = h - f * g;
				d[i - 1] = f - g;
				for (int j = 0; j < i; j++) {
					e[j] = 0.0;
				}

				// Apply similarity transformation to remaining columns.

				for (int j = 0; j < i; j++) {
					f = d[j];
					V[j][i] = f;
					g = e[j] + V[j][j] * f;
					for (int k = j + 1; k <= i - 1; k++) {
						g += V[k][j] * d[k];
						e[k] += V[k][j] * f;
					}
					e[j] = g;
				}
				f = 0.0;
				for (int j = 0; j < i; j++) {
					e[j] /= h;
					f += e[j] * d[j];
				}
				double hh = f / (h + h);
				for (int j = 0; j < i; j++) {
					e[j] -= hh * d[j];
				}
				for (int j = 0; j < i; j++) {
					f = d[j];
					g = e[j];
					for (int k = j; k <= i - 1; k++) {
						V[k][j] -= (f * e[k] + g * d[k]);
					}
					d[j] = V[i - 1][j];
					V[i][j] = 0.0;
				}
			}
			d[i] = h;
		}

		// Accumulate transformations.

		for (int i = 0; i < n - 1; i++) {
			V[n - 1][i] = V[i][i];
			V[i][i] = 1.0;
			double h = d[i + 1];
			if (h != 0.0) {
				for (int k = 0; k <= i; k++) {
					d[k] = V[k][i + 1] / h;
				}
				for (int j = 0; j <= i; j++) {
					double g = 0.0;
					for (int k = 0; k <= i; k++) {
						g += V[k][i + 1] * V[k][j];
					}
					for (int k = 0; k <= i; k++) {
						V[k][j] -= g * d[k];
					}
				}
			}
			for (int k = 0; k <= i; k++) {
				V[k][i + 1] = 0.0;
			}
		}
		for (int j = 0; j < n; j++) {
			d[j] = V[n - 1][j];
			V[n - 1][j] = 0.0;
		}
		V[n - 1][n - 1] = 1.0;
		e[0] = 0.0;
	}

	//hypot function code from papaya/src/SVD.java
	/** sqrt(a^2 + b^2) without under/overflow. **/
	double hypot(double a, double b) {
		double r;
		if (a*a > b*b) {
			r = b / a;
			r = abs(a)*sqrt(1 + r*r);
		}
		else if (b != 0) {
			r = a / b;
			r = abs(b)*sqrt(1 + r*r);
		}
		else {
			r = 0.0;
		}
		return r;
	}

	// Symmetric tridiagonal QL algorithm.
	void tql2() {

		//  This is derived from the Algol procedures tql2, by
		//  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
		//  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
		//  Fortran subroutine in EISPACK.

		for (int i = 1; i < n; i++) {
			e[i - 1] = e[i];
		}
		e[n - 1] = 0.0;

		double f = 0.0;
		double tst1 = 0.0;
		double eps = pow(2.0, -52.0);
		for (int l = 0; l < n; l++) {

			// Find small subdiagonal element

			tst1 = max(tst1, abs(d[l]) + abs(e[l]));
			int m = l;
			while (m < n) {
				if (abs(e[m]) <= eps*tst1) {
					break;
				}
				m++;
			}

			// If m == l, d[l] is an eigenvalue,
			// otherwise, iterate.

			if (m > l) {
				int iter = 0;
				do {
					iter = iter + 1;  // (Could check iteration count here.)

					// Compute implicit shift

					double g = d[l];
					double p = (d[l + 1] - g) / (2.0 * e[l]);
					double r = hypot(p, 1.0);
					if (p < 0) {
						r = -r;
					}
					d[l] = e[l] / (p + r);
					d[l + 1] = e[l] * (p + r);
					double dl1 = d[l + 1];
					double h = g - d[l];
					for (int i = l + 2; i < n; i++) {
						d[i] -= h;
					}
					f = f + h;

					// Implicit QL transformation.

					p = d[m];
					double c = 1.0;
					double c2 = c;
					double c3 = c;
					double el1 = e[l + 1];
					double s = 0.0;
					double s2 = 0.0;
					for (int i = m - 1; i >= l; i--) {
						c3 = c2;
						c2 = c;
						s2 = s;
						g = c * e[i];
						h = c * p;
						r = hypot(p, e[i]);
						e[i + 1] = s * r;
						s = e[i] / r;
						c = p / r;
						p = c * d[i] - s * g;
						d[i + 1] = h + s * (c * g + s * d[i]);

						// Accumulate transformation.

						for (int k = 0; k < n; k++) {
							h = V[k][i + 1];
							V[k][i + 1] = s * V[k][i] + c * h;
							V[k][i] = c * V[k][i] - s * h;
						}
					}
					p = -s * s2 * c3 * el1 * e[l] / dl1;
					e[l] = s * p;
					d[l] = c * p;

					// Check for convergence.

				} while (abs(e[l]) > eps*tst1);
			}
			d[l] = d[l] + f;
			e[l] = 0.0;
		}

		// Sort eigenvalues and corresponding vectors.

		for (int i = 0; i < n - 1; i++) {
			int k = i;
			double p = d[i];
			for (int j = i + 1; j < n; j++) {
				if (d[j] < p) {
					k = j;
					p = d[j];
				}
			}
			if (k != i) {
				d[k] = d[i];
				d[i] = p;
				for (int j = 0; j < n; j++) {
					p = V[j][i];
					V[j][i] = V[j][k];
					V[j][k] = p;
				}
			}
		}
	}

	// Nonsymmetric reduction to Hessenberg form.
	void orthes() {

		//  This is derived from the Algol procedures orthes and ortran,
		//  by Martin and Wilkinson, Handbook for Auto. Comp.,
		//  Vol.ii-Linear Algebra, and the corresponding
		//  Fortran subroutines in EISPACK.

		int low = 0;
		int high = n - 1;

		for (int m = low + 1; m <= high - 1; m++) {

			// Scale column.

			double scale = 0.0;
			for (int i = m; i <= high; i++) {
				scale = scale + abs(H[i][m - 1]);
			}
			if (scale != 0.0) {

				// Compute Householder transformation.

				double h = 0.0;
				for (int i = high; i >= m; i--) {
					ort[i] = H[i][m - 1] / scale;
					h += ort[i] * ort[i];
				}
				double g = sqrt(h);
				if (ort[m] > 0) {
					g = -g;
				}
				h = h - ort[m] * g;
				ort[m] = ort[m] - g;

				// Apply Householder similarity transformation
				// H = (I-u*u'/h)*H*(I-u*u')/h)

				for (int j = m; j < n; j++) {
					double f = 0.0;
					for (int i = high; i >= m; i--) {
						f += ort[i] * H[i][j];
					}
					f = f / h;
					for (int i = m; i <= high; i++) {
						H[i][j] -= f*ort[i];
					}
				}

				for (int i = 0; i <= high; i++) {
					double f = 0.0;
					for (int j = high; j >= m; j--) {
						f += ort[j] * H[i][j];
					}
					f = f / h;
					for (int j = m; j <= high; j++) {
						H[i][j] -= f*ort[j];
					}
				}
				ort[m] = scale*ort[m];
				H[m][m - 1] = scale*g;
			}
		}

		// Accumulate transformations (Algol's ortran).

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				V[i][j] = (i == j ? 1.0 : 0.0);
			}
		}

		for (int m = high - 1; m >= low + 1; m--) {
			if (H[m][m - 1] != 0.0) {
				for (int i = m + 1; i <= high; i++) {
					ort[i] = H[i][m - 1];
				}
				for (int j = m; j <= high; j++) {
					double g = 0.0;
					for (int i = m; i <= high; i++) {
						g += ort[i] * V[i][j];
					}
					// Double division avoids possible underflow
					g = (g / ort[m]) / H[m][m - 1];
					for (int i = m; i <= high; i++) {
						V[i][j] += g * ort[i];
					}
				}
			}
		}
	}

	// Complex scalar division.
	double cdivr, cdivi;
	void cdiv(double xr, double xi, double yr, double yi) {
		double r, d;
		if (abs(yr) > abs(yi)) {
			r = yi / yr;
			d = yr + r*yi;
			cdivr = (xr + r*xi) / d;
			cdivi = (xi - r*xr) / d;
		}
		else {
			r = yr / yi;
			d = yi + r*yr;
			cdivr = (r*xr + xi) / d;
			cdivi = (r*xi - xr) / d;
		}
	}

	// Nonsymmetric reduction from Hessenberg to real Schur form.
	void hqr2() {

		//  This is derived from the Algol procedure hqr2,
		//  by Martin and Wilkinson, Handbook for Auto. Comp.,
		//  Vol.ii-Linear Algebra, and the corresponding
		//  Fortran subroutine in EISPACK.

		// Initialize

		int nn = n;
		int n = nn - 1;
		int low = 0;
		int high = nn - 1;
		double eps = pow(2.0, -52.0);
		double exshift = 0.0;
		double p = 0, q = 0, r = 0, s = 0, z = 0, t, w, x, y;

		// Store roots isolated by balanc and compute matrix norm

		double norm = 0.0;
		for (int i = 0; i < nn; i++) {
			if (i < low | i > high) {
				d[i] = H[i][i];
				e[i] = 0.0;
			}
			for (int j = max(i - 1, 0); j < nn; j++) {
				norm = norm + abs(H[i][j]);
			}
		}

		// Outer loop over eigenvalue index

		int iter = 0;
		while (n >= low) {

			// Look for single small sub-diagonal element

			int l = n;
			while (l > low) {
				s = abs(H[l - 1][l - 1]) + abs(H[l][l]);
				if (s == 0.0) {
					s = norm;
				}
				if (abs(H[l][l - 1]) < eps * s) {
					break;
				}
				l--;
			}

			// Check for convergence
			// One root found

			if (l == n) {
				H[n][n] = H[n][n] + exshift;
				d[n] = H[n][n];
				e[n] = 0.0;
				n--;
				iter = 0;

				// Two roots found

			}
			else if (l == n - 1) {
				w = H[n][n - 1] * H[n - 1][n];
				p = (H[n - 1][n - 1] - H[n][n]) / 2.0;
				q = p * p + w;
				z = sqrt(abs(q));
				H[n][n] = H[n][n] + exshift;
				H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
				x = H[n][n];

				// Real pair

				if (q >= 0) {
					if (p >= 0) {
						z = p + z;
					}
					else {
						z = p - z;
					}
					d[n - 1] = x + z;
					d[n] = d[n - 1];
					if (z != 0.0) {
						d[n] = x - w / z;
					}
					e[n - 1] = 0.0;
					e[n] = 0.0;
					x = H[n][n - 1];
					s = abs(x) + abs(z);
					p = x / s;
					q = z / s;
					r = sqrt(p * p + q * q);
					p = p / r;
					q = q / r;

					// Row modification

					for (int j = n - 1; j < nn; j++) {
						z = H[n - 1][j];
						H[n - 1][j] = q * z + p * H[n][j];
						H[n][j] = q * H[n][j] - p * z;
					}

					// Column modification

					for (int i = 0; i <= n; i++) {
						z = H[i][n - 1];
						H[i][n - 1] = q * z + p * H[i][n];
						H[i][n] = q * H[i][n] - p * z;
					}

					// Accumulate transformations

					for (int i = low; i <= high; i++) {
						z = V[i][n - 1];
						V[i][n - 1] = q * z + p * V[i][n];
						V[i][n] = q * V[i][n] - p * z;
					}

					// Complex pair

				}
				else {
					d[n - 1] = x + p;
					d[n] = x + p;
					e[n - 1] = z;
					e[n] = -z;
				}
				n = n - 2;
				iter = 0;

				// No convergence yet

			}
			else {

				// Form shift

				x = H[n][n];
				y = 0.0;
				w = 0.0;
				if (l < n) {
					y = H[n - 1][n - 1];
					w = H[n][n - 1] * H[n - 1][n];
				}

				// Wilkinson's original ad hoc shift

				if (iter == 10) {
					exshift += x;
					for (int i = low; i <= n; i++) {
						H[i][i] -= x;
					}
					s = abs(H[n][n - 1]) + abs(H[n - 1][n - 2]);
					x = y = 0.75 * s;
					w = -0.4375 * s * s;
				}

				// MATLAB's new ad hoc shift

				if (iter == 30) {
					s = (y - x) / 2.0;
					s = s * s + w;
					if (s > 0) {
						s = sqrt(s);
						if (y < x) {
							s = -s;
						}
						s = x - w / ((y - x) / 2.0 + s);
						for (int i = low; i <= n; i++) {
							H[i][i] -= s;
						}
						exshift += s;
						x = y = w = 0.964;
					}
				}

				iter = iter + 1;   // (Could check iteration count here.)

				// Look for two consecutive small sub-diagonal elements

				int m = n - 2;
				while (m >= l) {
					z = H[m][m];
					r = x - z;
					s = y - z;
					p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
					q = H[m + 1][m + 1] - z - r - s;
					r = H[m + 2][m + 1];
					s = abs(p) + abs(q) + abs(r);
					p = p / s;
					q = q / s;
					r = r / s;
					if (m == l) {
						break;
					}
					if (abs(H[m][m - 1]) * (abs(q) + abs(r)) <
						eps * (abs(p) * (abs(H[m - 1][m - 1]) + abs(z) +
							abs(H[m + 1][m + 1])))) {
						break;
					}
					m--;
				}

				for (int i = m + 2; i <= n; i++) {
					H[i][i - 2] = 0.0;
					if (i > m + 2) {
						H[i][i - 3] = 0.0;
					}
				}

				// Double QR step involving rows l:n and columns m:n

				for (int k = m; k <= n - 1; k++) {
					bool notlast = (k != n - 1);
					if (k != m) {
						p = H[k][k - 1];
						q = H[k + 1][k - 1];
						r = (notlast ? H[k + 2][k - 1] : 0.0);
						x = abs(p) + abs(q) + abs(r);
						if (x != 0.0) {
							p = p / x;
							q = q / x;
							r = r / x;
						}
					}
					if (x == 0.0) {
						break;
					}
					s = sqrt(p * p + q * q + r * r);
					if (p < 0) {
						s = -s;
					}
					if (s != 0) {
						if (k != m) {
							H[k][k - 1] = -s * x;
						}
						else if (l != m) {
							H[k][k - 1] = -H[k][k - 1];
						}
						p = p + s;
						x = p / s;
						y = q / s;
						z = r / s;
						q = q / p;
						r = r / p;

						// Row modification

						for (int j = k; j < nn; j++) {
							p = H[k][j] + q * H[k + 1][j];
							if (notlast) {
								p = p + r * H[k + 2][j];
								H[k + 2][j] = H[k + 2][j] - p * z;
							}
							H[k][j] = H[k][j] - p * x;
							H[k + 1][j] = H[k + 1][j] - p * y;
						}

						// Column modification

						for (int i = 0; i <= min(n, k + 3); i++) {
							p = x * H[i][k] + y * H[i][k + 1];
							if (notlast) {
								p = p + z * H[i][k + 2];
								H[i][k + 2] = H[i][k + 2] - p * r;
							}
							H[i][k] = H[i][k] - p;
							H[i][k + 1] = H[i][k + 1] - p * q;
						}

						// Accumulate transformations

						for (int i = low; i <= high; i++) {
							p = x * V[i][k] + y * V[i][k + 1];
							if (notlast) {
								p = p + z * V[i][k + 2];
								V[i][k + 2] = V[i][k + 2] - p * r;
							}
							V[i][k] = V[i][k] - p;
							V[i][k + 1] = V[i][k + 1] - p * q;
						}
					}  // (s != 0)
				}  // k loop
			}  // check convergence
		}  // while (n >= low)

		// Backsubstitute to find vectors of upper triangular form

		if (norm == 0.0) {
			return;
		}

		for (n = nn - 1; n >= 0; n--) {
			p = d[n];
			q = e[n];

			// Real vector

			if (q == 0) {
				int l = n;
				H[n][n] = 1.0;
				for (int i = n - 1; i >= 0; i--) {
					w = H[i][i] - p;
					r = 0.0;
					for (int j = l; j <= n; j++) {
						r = r + H[i][j] * H[j][n];
					}
					if (e[i] < 0.0) {
						z = w;
						s = r;
					}
					else {
						l = i;
						if (e[i] == 0.0) {
							if (w != 0.0) {
								H[i][n] = -r / w;
							}
							else {
								H[i][n] = -r / (eps * norm);
							}

							// Solve real equations

						}
						else {
							x = H[i][i + 1];
							y = H[i + 1][i];
							q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
							t = (x * s - z * r) / q;
							H[i][n] = t;
							if (abs(x) > abs(z)) {
								H[i + 1][n] = (-r - w * t) / x;
							}
							else {
								H[i + 1][n] = (-s - y * t) / z;
							}
						}

						// Overflow control

						t = abs(H[i][n]);
						if ((eps * t) * t > 1) {
							for (int j = i; j <= n; j++) {
								H[j][n] = H[j][n] / t;
							}
						}
					}
				}

				// Complex vector

			}
			else if (q < 0) {
				int l = n - 1;

				// Last vector component imaginary so matrix is triangular

				if (abs(H[n][n - 1]) > abs(H[n - 1][n])) {
					H[n - 1][n - 1] = q / H[n][n - 1];
					H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
				}
				else {
					cdiv(0.0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
					H[n - 1][n - 1] = cdivr;
					H[n - 1][n] = cdivi;
				}
				H[n][n - 1] = 0.0;
				H[n][n] = 1.0;
				for (int i = n - 2; i >= 0; i--) {
					double ra, sa, vr, vi;
					ra = 0.0;
					sa = 0.0;
					for (int j = l; j <= n; j++) {
						ra = ra + H[i][j] * H[j][n - 1];
						sa = sa + H[i][j] * H[j][n];
					}
					w = H[i][i] - p;

					if (e[i] < 0.0) {
						z = w;
						r = ra;
						s = sa;
					}
					else {
						l = i;
						if (e[i] == 0) {
							cdiv(-ra, -sa, w, q);
							H[i][n - 1] = cdivr;
							H[i][n] = cdivi;
						}
						else {

							// Solve complex equations

							x = H[i][i + 1];
							y = H[i + 1][i];
							vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
							vi = (d[i] - p) * 2.0 * q;
							if (vr == 0.0 & vi == 0.0) {
								vr = eps * norm * (abs(w) + abs(q) +
									abs(x) + abs(y) + abs(z));
							}
							cdiv(x*r - z*ra + q*sa, x*s - z*sa - q*ra, vr, vi);
							H[i][n - 1] = cdivr;
							H[i][n] = cdivi;
							if (abs(x) > (abs(z) + abs(q))) {
								H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
								H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
							}
							else {
								cdiv(-r - y*H[i][n - 1], -s - y*H[i][n], z, q);
								H[i + 1][n - 1] = cdivr;
								H[i + 1][n] = cdivi;
							}
						}

						// Overflow control

						t = max(abs(H[i][n - 1]), abs(H[i][n]));
						if ((eps * t) * t > 1) {
							for (int j = i; j <= n; j++) {
								H[j][n - 1] = H[j][n - 1] / t;
								H[j][n] = H[j][n] / t;
							}
						}
					}
				}
			}
		}

		// Vectors of isolated roots

		for (int i = 0; i < nn; i++) {
			if (i < low | i > high) {
				for (int j = i; j < nn; j++) {
					V[i][j] = H[i][j];
				}
			}
		}

		// Back transformation to get eigenvectors of original matrix

		for (int j = nn - 1; j >= low; j--) {
			for (int i = low; i <= high; i++) {
				z = 0.0;
				for (int k = low; k <= min(j, high); k++) {
					z = z + V[i][k] * H[k][j];
				}
				V[i][j] = z;
			}
		}
	}

	/** Return the eigenvector matrix with each column corresponding to
	* an eigenvector of the input matrix.
	@return     V
	*/
	double** getV() {
		return V;
	}

	/** Return the real parts of the eigenvalues
	@return     real(diag(D))
	*/
	double* getRealEigenvalues() {
		return d;
	}

	/** Return the imaginary parts of the eigenvalues
	@return     imag(diag(D))
	*/
	double* getImagEigenvalues() {
		return e;
	}

	/** Return the block diagonal eigenvalue matrix
	@return     D
	*/
	double** getD() {
		double **D = new double*[n];
		for (int i = 0; i < n; ++i)
			D[i] = new double[n];

		for (int i = 0; i < n; i++) {
			D[i][i] = d[i];
			if (e[i] > 0) {
				D[i][i + 1] = e[i];
			}
			else if (e[i] < 0) {
				D[i][i - 1] = e[i];
			}
		}
		return D;
	}
};
#line 0 "../addons-all/ofxAffinetransformation/src/ofxAffineTransformation.h"
#pragma once

/* #include "ofMain.h" */
/* #include "Eigenvalue.h" */

using namespace std;

class ofxAffineTransformation {
public:
	ofxAffineTransformation();
	~ofxAffineTransformation();

	Eigenvalue EV;

	void  setCross(int m);
	void  setCross(int m, int _w, int _h);
	void  setCross(int m, int _x, int _y, int _w, int _h);
	void  setCross(vector<ofVec2f> _pnts);
	void  drawCross();
	void  checkCross();
	void  updateCross();
	void  releaseCross();
	float getFx();
	float getFy();
	float *getT();
	void  calAffineTransform(bool debug);
	void  applyAffineTransformation(int _x, int _y);
	bool  checkInside(int _x, int _y);
	ofVec2f* getPts();

private:
	int     index;		// corner index
	int     h;			// check corner distance area
	int     areaX,		// the area position.x when auto set initial corner
		    areaY,		// the area position.y when auto set initial corner
		    areaW,		// the area width when auto set initial corner
		    areaH;		// the area height when auto set initial corner
	float   fx;			// the normal x when finish calibration
	float   fy;			// the normal y when finish calibration
	float   fz;			// the normal z when finish calibration
	float   *T;			// the eigen vector when finish calibration
	ofVec2f *pts;		// four corner position
	ofVec2f *npts;		// the order of corner unit coordinate
};



#line 0 "../addons-all/ofxWaterRipple/src/GpuCompute.h"
//
// created by antoniomechas
//
// some code stolen and modified from Neil Mendoza's gpuParticleSystem
// https://github.com/neilmendoza/ofxGpuParticles
//
//

#pragma once

/* #include "ofMain.h" */

class GpuCompute
{
public:
	static const string UNIFORM_PREFIX;
    static const unsigned FLOATS_PER_TEXEL = 4;
        
    enum DataTextureIndex
    {
        DATA,
        ADD
    };
        
    GpuCompute();
        
    void init(unsigned width, unsigned height);
    void update();
    void draw();
        
    void loadDataTexture(unsigned idx, float* data,
                            unsigned x = 0, unsigned y = 0, unsigned width = 0, unsigned height = 0);
    void zeroDataTexture(unsigned idx,
                            unsigned x = 0, unsigned y = 0, unsigned width = 0, unsigned height = 0);
        
    unsigned getWidth() const { return width; }
    unsigned getHeight() const { return height; }
    unsigned getNumFloats() const { return numFloats; }
        
	ofImage imagen;
	ofTexture tex;

	float paramDamping;

private:
    void texturedQuad();
    void setUniforms(ofShader& shader);
        
    ofFbo fbos[2];
    ofVboMesh mesh;
    ofShader updateShader, drawShader, addShader;
    unsigned currentReadFbo;
    unsigned width, height, numFloats;

	ofFbo drawFbo;

};

#line 0 "../addons-all/ofxWaterRipple/src/ofxWaterRipple.h"
//
// created by antoniomechas, 2015/06/17
// 
//
// Ported to shaders from http://www.neilwallis.com/projects/java/water/index.php
//

#pragma once

/* #include "ofMain.h" */
/* #include "GpuCompute.h" */

class ofxWaterRipple {

	public:
		~ofxWaterRipple();


		void	setup(int w, int h);
		void	setupGPU();
		void	reset ();
		void	update();
		void	loadImage(const char* archivo);
		void	loadImage(ofPixelsRef img);
		void	draw(bool bUseShader);
		void	disturb(float x, float y, int radio, int profundidad);
		void	gotaPerimetro(float x, float y, int radio);
		void	tocaPunto(int x, int y, int profundidad);
		void	generaLluvia();
		void	siguienteFoto();										//Pasa a la siguiente foto de la lista

		float	pDamping;			//Factor de damping


protected:

		int SquaredDist(int sx, int sy, int dx, int dy);

		GpuCompute gpuCompute;

		int _height;
		int _width;
		
		float* data;

};
#line 0 "../addons-all/ofxGpuParticles/src/GpuParticles.h"
/*
 *  GpuParticles.h
 *
 *  Copyright (c) 2013, Neil Mendoza, http://www.neilmendoza.com
 *  All rights reserved. 
 *  
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions are met: 
 *  
 *  * Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer. 
 *  * Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *  * Neither the name of Neil Mendoza nor the names of its contributors may be used 
 *    to endorse or promote products derived from this software without 
 *    specific prior written permission. 
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 *  POSSIBILITY OF SUCH DAMAGE. 
 *
 */
#pragma once

/* #include "ofMain.h" */

namespace itg
{
    /**
     * For now, only uses RGBA and TEXTURE_RECTANGLE to make usage simpler
     */
    class GpuParticles
    {
    public:
        static const string UNIFORM_PREFIX;
        static const string UPDATE_SHADER_NAME;
        static const string DRAW_SHADER_NAME;
        static const unsigned FLOATS_PER_TEXEL = 4;
        
        // you don't have to use these but makes
        // code more readable
        enum DataTextureIndex
        {
            POSITION,
            VELOCITY
        };
        
        GpuParticles();
        
        void init(unsigned width, unsigned height,
                  ofPrimitiveMode primitive = OF_PRIMITIVE_POINTS, bool loadDefaultShaders = false, unsigned numDataTextures = 2);
        void update();
        void draw();
        
        void loadShaders(const string& updateShaderName, const string& drawShaderName);
        
        void loadDataTexture(unsigned idx, float* data,
                             unsigned x = 0, unsigned y = 0, unsigned width = 0, unsigned height = 0);
        void zeroDataTexture(unsigned idx,
                             unsigned x = 0, unsigned y = 0, unsigned width = 0, unsigned height = 0);
        
        unsigned getWidth() const { return width; }
        unsigned getHeight() const { return height; }
        unsigned getNumFloats() const { return numFloats; }
        
        void setTextureLocation(unsigned textureLocation) { this->textureLocation = textureLocation; }
        
        // listen to these events to set custom uniforms
        ofEvent<ofShader> updateEvent;
        ofEvent<ofShader> drawEvent;
        
        ofVboMesh& getMeshRef() { return mesh; }
        
        // advanced
        ofShader& getUpdateShaderRef() { return updateShader; }
        ofShader& getDrawShaderRef() { return drawShader; }
        
        void save(const string& fileName);
        void load(const string& fileName);

        // this will be called for you by ofxGpuParticles::draw()
        // you should only need to call it yourself if you are not
        // using that function (i.e. custom particle rendering)
        void setUniforms(ofShader& shader);

    private:
        ofFbo fbos[2];
        ofVboMesh mesh;
        ofVboMesh quadMesh;
        ofShader updateShader, drawShader;
        unsigned currentReadFbo;
        unsigned textureLocation;
        unsigned width, height, numFloats;
    };
}

#line 0 "../addons-all/ofxGpuParticles/src/ofxGpuParticles.h"
/*
 *  ofxGpuParticles.h
 *
 *  Copyright (c) 2013, Neil Mendoza, http://www.neilmendoza.com
 *  All rights reserved. 
 *  
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions are met: 
 *  
 *  * Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer. 
 *  * Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *  * Neither the name of Neil Mendoza nor the names of its contributors may be used 
 *    to endorse or promote products derived from this software without 
 *    specific prior written permission. 
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 *  POSSIBILITY OF SUCH DAMAGE. 
 *
 */
#pragma once

/* #include "GpuParticles.h" */

typedef itg::GpuParticles ofxGpuParticles;
#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingHelper.h"
#pragma once

/* #include "ofMain.h" */
/* #include "ofxSvg.h" */
/* #include "ofxXmlSettings.h" */

class ofx2DMappingHelper {

public:

    static ofPolyline ofPathToOfPolyline(ofPath path, bool straight_lines) {

        ofPolyline polyline;

        vector<ofPath::Command> commands;

        vector<ofPath::Command>& pathCommands = path.getCommands();
        for (unsigned int j=0; j<pathCommands.size(); j++) {
            commands.push_back(pathCommands[j]);
        }

        polyline.clear();
            int curveResolution = ofGetStyle().curveResolution;
            //maybe a better way?
            ofPath tempPath;
            int arcResolution = tempPath.getCircleResolution();

        for(unsigned int i=0; i<commands.size(); i++) {
            switch(commands[i].type) {
                case ofPath::Command::moveTo:
                    polyline.addVertex(commands[i].to);
                    break;
                case ofPath::Command::lineTo:
                    polyline.addVertex(commands[i].to);
                    break;
                case ofPath::Command::curveTo:
                    if(straight_lines)
                        polyline.addVertex(commands[i].to);
                    else
                        polyline.curveTo(commands[i].to, curveResolution);
                    break;
                case ofPath::Command::bezierTo:
                    if(straight_lines)
                        polyline.addVertex(commands[i].to);
                    else
                        polyline.bezierTo(commands[i].cp1,commands[i].cp2,commands[i].to, curveResolution);
                    break;
                case ofPath::Command::quadBezierTo:
                    if(straight_lines)
                        polyline.addVertex(commands[i].to);
                    else
                        polyline.quadBezierTo(commands[i].cp1,commands[i].cp2,commands[i].to, curveResolution);
                    break;
                case ofPath::Command::arc:
                    if(straight_lines)
                        polyline.addVertex(commands[i].to);
                    else
                        polyline.arc(commands[i].to,commands[i].radiusX,commands[i].radiusY,commands[i].angleBegin,commands[i].angleEnd, arcResolution);
                    break;
                case ofPath::Command::arcNegative:
                    if(straight_lines)
                        polyline.addVertex(commands[i].to);
                    else
                        polyline.arcNegative(commands[i].to,commands[i].radiusX,commands[i].radiusY,commands[i].angleBegin,commands[i].angleEnd, arcResolution);
                    break;
                case ofPath::Command::close:
                    polyline.close();
                    break;
                default: break;
            }
        }

        return polyline;

    }

    static void saveLineAsSvg(string path, ofPolyline line, float width, float height, ofColor strokecolor = ofColor(0)) {

        ofxXmlSettings xml;

        xml.clear();

        xml.addTag("svg");
        xml.addAttribute("svg","id","svg2",0);
        xml.addAttribute("svg","xmlns:rdf","http://www.w3.org/1999/02/22-rdf-syntax-ns#",0);
        xml.addAttribute("svg","xmlns","http://www.w3.org/2000/svg",0);
        xml.addAttribute("svg","width",width,0);
        xml.addAttribute("svg","height",height,0);
        xml.addAttribute("svg","version","1.1",0);
        xml.addAttribute("svg","xmlns:cc","http://creativecommons.org/ns#",0);
        xml.addAttribute("svg","xmlns:dc","http://purl.org/dc/elements/1.1/",0);
        xml.pushTag("svg", 0);
    //        xml.addTag("metadata");
    //        xml.addAttribute("metadata","id","metadata7");
    //        xml.pushTag("metadata");
    //        xml.popTag();
            xml.addTag("g");
            xml.addAttribute("g", "id", "layer1",0);
            xml.pushTag("g");

                int i = 0;

                xml.addTag("path");
                stringstream id_sstr;
                id_sstr << "path" << i;
                xml.addAttribute("path", "id", id_sstr.str(), i);
                stringstream path_sstr;
                path_sstr << "m";
                ofPoint last_p;
                for(unsigned int k = 0; k < line.size(); k++) {
                    ofPoint cur_p = ofPoint(line[k].x, line[k].y);
                    if(k == 0)
                        path_sstr << cur_p.x << "," << cur_p.y;
                    if(k > 0)
                        path_sstr << "," << cur_p.x-last_p.x << "," << cur_p.y-last_p.y;
                    last_p = cur_p;
                }
                //path_sstr << "z";

                xml.addAttribute("path", "d", path_sstr.str(), i);
                xml.addAttribute("path", "fill", "none", i);
                xml.addAttribute("path", "stroke", getColorAsHex(strokecolor), i);

            xml.popTag();

        xml.popTag();

        ofLogNotice("Helper: saveLineAsSvg()", "saving svg to " + path);

        xml.saveFile(path);
    }

    static string getColorAsHex(ofColor c) {
        return getColorAsHex(c.r,c.g,c.b);
    }

    static string getColorAsHex(int r, int g, int b) {
        stringstream ss;
        ss << "#" << getHexCode(r) << getHexCode(g) << getHexCode(b);
        return ss.str();
    }

    static string getHexCode(unsigned char c) {

       stringstream ss;
       ss << uppercase << setw(2) << setfill('0') << std::hex;
       ss << +c;

       return ss.str();
    }

};


#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingObject.h"
#pragma once

/* #include "ofMain.h" */
/* #include "ofx2DMappingObjectFactory.h" */
/* #include "ofxTriangle.h" */
/* #include "ofxXmlSettings.h" */
/* #include "ofx2DMappingHelper.h" */

typedef ofPtr<ofFbo> ofFbo_ptr;
typedef ofPtr<ofxXmlSettings> ofxXmlSettings_ptr;

class ofx2DMappingObject {
public:

    string  nature;

    string name;
    ofColor color;

    ofx2DMappingObject() {
        newpos = true;
        newitem = true;

        nature = "OBJECT";

        editable.set(nature, false);
    }

    ofx2DMappingObject(const ofx2DMappingObject& obj) {
        this->color = obj.color;
        this->name = obj.name;
        this->nature = obj.nature;
        this->newitem = true;
        this->editable.set(obj.name, true);
    }

    virtual ofPtr<ofx2DMappingObject> clone() const = 0;

    void setColor(ofColor color) {
        this->color = color;
    }

    virtual void loadXml(ofxXmlSettings_ptr xml) {
        color.r = xml->getAttribute("color", "r", 255, 0);
        color.g = xml->getAttribute("color", "g", 255, 0);
        color.b = xml->getAttribute("color", "b", 255, 0);

    }

    virtual void saveXml(ofxXmlSettings_ptr xml) {
        xml->addTag("color");
        xml->addAttribute("color", "r", color.r, 0);
        xml->addAttribute("color", "g", color.g, 0);
        xml->addAttribute("color", "b", color.b, 0);
    }

    virtual void draw(float w, float h) = 0;
    virtual void drawArea(float w, float h) = 0;

    virtual void update(float w, float h) = 0;

    void gaussian_elimination(float *input, int n)
    {
        // ported to c from pseudocode in
        // http://en.wikipedia.org/wiki/Gaussian_elimination

        float * A = input;
        int i = 0;
        int j = 0;
        int m = n-1;
        while (i < m && j < n)
        {
            // Find pivot in column j, starting in row i:
            int maxi = i;
            for(int k = i+1; k<m; k++)
            {
                if(fabs(A[k*n+j]) > fabs(A[maxi*n+j]))
                {
                    maxi = k;
                }
            }
            if (A[maxi*n+j] != 0)
            {
                //swap rows i and maxi, but do not change the value of i
                if(i!=maxi)
                    for(int k=0; k<n; k++)
                    {
                        float aux = A[i*n+k];
                        A[i*n+k]=A[maxi*n+k];
                        A[maxi*n+k]=aux;
                    }
                //Now A[i,j] will contain the old value of A[maxi,j].
                //divide each entry in row i by A[i,j]
                float A_ij=A[i*n+j];
                for(int k=0; k<n; k++)
                {
                    A[i*n+k]/=A_ij;
                }
                //Now A[i,j] will have the value 1.
                for(int u = i+1; u< m; u++)
                {
                    //subtract A[u,j] * row i from row u
                    float A_uj = A[u*n+j];
                    for(int k=0; k<n; k++)
                    {
                        A[u*n+k]-=A_uj*A[i*n+k];
                    }
                    //Now A[u,j] will be 0, since A[u,j] - A[i,j] * A[u,j] = A[u,j] - 1 * A[u,j] = 0.
                }

                i++;
            }
            j++;
        }

        //back substitution
        for(int i=m-2; i>=0; i--)
        {
            for(int j=i+1; j<n-1; j++)
            {
                A[i*n+m]-=A[i*n+j]*A[j*n+m];
                //A[i*n+j]=0;
            }
        }
    }

    void findHomography(ofPoint src_norm[4], ofPoint dst_norm[4], float homography[16], bool points_normalized, float w, float h)
    {

        ofPoint src[4];
        ofPoint dst[4];

        if(points_normalized) {
            for(int i = 0; i < 4; i++) {
                src[i].x=src_norm[i].x*w;
                src[i].y=src_norm[i].y*h;
                dst[i].x=dst_norm[i].x*w;
                dst[i].y=dst_norm[i].y*h;
            }
        }
        else {
            for(int i = 0; i < 4; i++) {
                src[i].x=src_norm[i].x;
                src[i].y=src_norm[i].y;
                dst[i].x=dst_norm[i].x;
                dst[i].y=dst_norm[i].y;
            }
        }

        // create the equation system to be solved
        //
        // from: Multiple View Geometry in Computer Vision 2ed
        //       Hartley R. and Zisserman A.
        //
        // x' = xH
        // where H is the homography: a 3 by 3 matrix
        // that transformed to inhomogeneous coordinates for each point
        // gives the following equations for each point:
        //
        // x' * (h31*x + h32*y + h33) = h11*x + h12*y + h13
        // y' * (h31*x + h32*y + h33) = h21*x + h22*y + h23
        //
        // as the homography is scale independent we can let h33 be 1 (indeed any of the terms)
        // so for 4 points we have 8 equations for 8 terms to solve: h11 - h32
        // after ordering the terms it gives the following matrix
        // that can be solved with gaussian elimination:

        float P[8][9]=
        {
            {-src[0].x, -src[0].y, -1,   0,   0,  0, src[0].x*dst[0].x, src[0].y*dst[0].x, -dst[0].x }, // h11
            {  0,   0,  0, -src[0].x, -src[0].y, -1, src[0].x*dst[0].y, src[0].y*dst[0].y, -dst[0].y }, // h12

            {-src[1].x, -src[1].y, -1,   0,   0,  0, src[1].x*dst[1].x, src[1].y*dst[1].x, -dst[1].x }, // h13
            {  0,   0,  0, -src[1].x, -src[1].y, -1, src[1].x*dst[1].y, src[1].y*dst[1].y, -dst[1].y }, // h21

            {-src[2].x, -src[2].y, -1,   0,   0,  0, src[2].x*dst[2].x, src[2].y*dst[2].x, -dst[2].x }, // h22
            {  0,   0,  0, -src[2].x, -src[2].y, -1, src[2].x*dst[2].y, src[2].y*dst[2].y, -dst[2].y }, // h23

            {-src[3].x, -src[3].y, -1,   0,   0,  0, src[3].x*dst[3].x, src[3].y*dst[3].x, -dst[3].x }, // h31
            {  0,   0,  0, -src[3].x, -src[3].y, -1, src[3].x*dst[3].y, src[3].y*dst[3].y, -dst[3].y }, // h32
        };

        gaussian_elimination(&P[0][0],9);

        // gaussian elimination gives the results of the equation system
        // in the last column of the original matrix.
        // opengl needs the transposed 4x4 matrix:
        float aux_H[]= { P[0][8],P[3][8],0,P[6][8], // h11  h21 0 h31
                         P[1][8],P[4][8],0,P[7][8], // h12  h22 0 h32
                         0      ,      0,0,0,       // 0    0   0 0
                         P[2][8],P[5][8],0,1
                       };      // h13  h23 0 h33

        for(int i=0; i<16; i++) homography[i] = aux_H[i];
    }

    bool        newpos;
    bool        newitem;
    ofParameter<bool> editable;

    ~ofx2DMappingObject(){}

protected:

    ofPoint getPoint(ofxXmlSettings_ptr xml) {

        ofPoint res;

        res.x = xml->getValue("x", 0.);
        res.y = xml->getValue("y", 0.);

        return res;

    }

};


#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingObjectFactory.h"
#pragma once

template <class ManufacturedType, typename ClassIDKey=std::string>
class ofx2DMappingObjectFactory
{
    typedef ofPtr<ManufacturedType> (*BaseCreateFn)();
    typedef std::map<ClassIDKey, BaseCreateFn> FnRegistry;
    FnRegistry registry;

    ofx2DMappingObjectFactory(){}

public:
    static ofx2DMappingObjectFactory &instance() {
        static ofx2DMappingObjectFactory bf;
        return bf;
    }

    void RegCreateFn(const ClassIDKey &className, BaseCreateFn fn){
        registry[className] = fn;
    }

    ofPtr<ManufacturedType> Create(const ClassIDKey &className) const {
        ofPtr<ManufacturedType> theObject(0);
        typename FnRegistry::const_iterator regEntry = registry.find(className);
        if (regEntry != registry.end())
        {
            theObject = regEntry->second();
        }
        return theObject;
    }

};

template <class AncestorType, class ManufacturedType, typename ClassIDKey=std::string>
class RegisterInFactory {

public:
    static ofPtr<AncestorType> CreateInstance() {
        return ofPtr<AncestorType>(new ManufacturedType);
    }

    RegisterInFactory(const ClassIDKey &id) {
        ofx2DMappingObjectFactory<AncestorType, ClassIDKey>::instance().RegCreateFn(id, CreateInstance);
    }
};


#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingPoint.h"
#pragma once

/* #include "ofx2DMappingObject.h" */

class ofx2DMappingPoint : public ofx2DMappingObject {

    public:

    ofPoint     pos;

    ofx2DMappingPoint() {
        this->nature = "POINT";
    }

    ofx2DMappingPoint(const ofx2DMappingPoint& obj) : ofx2DMappingObject(obj) {
        this->pos = obj.pos;
    }

    ofPtr<ofx2DMappingObject> clone() const {
        return ofPtr<ofx2DMappingObject>(new ofx2DMappingPoint(*this));
    }

    void loadXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingObject::loadXml(xml);
        pos = this->getPoint(xml);
    }

    void saveXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingObject::saveXml(xml);
        xml->addValue("x", pos.x);
        xml->addValue("y", pos.y);
    }

    void update(float w, float h){}

    void draw(float w, float h){}

    void drawArea(float w, float h){}

};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingShape.h"
#pragma once

/* #include "ofx2DMappingObject.h" */

class ofx2DMappingShape : public ofx2DMappingObject {

public:

    ofPoint     dst[4];
    ofMatrix4x4 matrix_dst_norm;
    ofxTriangle triangle;
    ofPolyline  polyline;
    ofPoint     plane[4];

    ofx2DMappingShape() {

        this->nature = "SHAPE";

        this->dst[0].x = 0;
        this->dst[0].y = 0;
        this->dst[1].x = 1;
        this->dst[1].y = this->dst[0].y;
        this->dst[2].x = this->dst[1].x;
        this->dst[2].y = 1;
        this->dst[3].x = this->dst[0].x;
        this->dst[3].y = this->dst[2].y;

        this->polyline.clear();
        this->polyline.addVertex(this->dst[0]);
        this->polyline.addVertex(this->dst[1]);
        this->polyline.addVertex(this->dst[2]);
        this->polyline.addVertex(this->dst[3]);
        this->polyline.close();

        this->plane[0] = ofPoint(0, 0, 0);
        this->plane[1] = ofPoint(1, 0, 0);
        this->plane[2] = ofPoint(1, 1, 0);
        this->plane[3] = ofPoint(0, 1, 0);

        this->matrix_dst_norm.makeIdentityMatrix();
    }

    ofx2DMappingShape(const ofx2DMappingShape& obj) : ofx2DMappingObject(obj) {
        for(int i = 0; i < 4; i++) {
            this->dst[i] = obj.dst[i];
            this->plane[i] = obj.plane[i];
        }
        this->polyline = obj.polyline;
        this->triangle = obj.triangle;
        this->matrix_dst_norm = obj.matrix_dst_norm;
    }

    ofPtr<ofx2DMappingObject> clone() const {
        return ofPtr<ofx2DMappingObject>(new ofx2DMappingShape(*this));
    }

    void loadXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingObject::loadXml(xml);
        xml->pushTag("dst", 0);
            setRectangle(xml, dst);
        xml->popTag();
        xml->pushTag("polyline");
            polyline = getPolyline(xml);
        xml->popTag();
    }

    void saveXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingObject::saveXml(xml);
        xml->addTag("dst");
        xml->pushTag("dst", 0);
            xml->addTag("lefttop");
            xml->pushTag("lefttop", 0);
                xml->addValue("x", dst[0].x);
                xml->addValue("y", dst[0].y);
            xml->popTag();
            xml->addTag("righttop");
            xml->pushTag("righttop", 0);
                xml->addValue("x", dst[1].x);
                xml->addValue("y", dst[1].y);
            xml->popTag();
            xml->addTag("rightbottom");
            xml->pushTag("rightbottom", 0);
                xml->addValue("x", dst[2].x);
                xml->addValue("y", dst[2].y);
            xml->popTag();
            xml->addTag("leftbottom");
            xml->pushTag("leftbottom", 0);
                xml->addValue("x", dst[3].x);
                xml->addValue("y", dst[3].y);
            xml->popTag();
        xml->popTag();

        xml->addTag("polyline");
        xml->pushTag("polyline",0);

            for(unsigned int k = 0; k < polyline.size(); k++) {
                xml->addTag("point");
                xml->pushTag("point",k);
                    xml->addValue("x", polyline[k].x);
                    xml->addValue("y", polyline[k].y);
                xml->popTag();
            }

        xml->popTag();
    }

    void draw(float w, float h){}

    void drawArea(float w, float h) {

        ofSetColor(this->color);

        ofFill();

        ofBeginShape();
        for (unsigned int j = 0; j < this->polyline.size(); j++){
            ofVertex(this->polyline[j].x*w, this->polyline[j].y*h);
        }

        ofEndShape(true);

    }

    void update(float w, float h) {
        this->findHomography(this->plane, this->dst, (GLfloat*) this->matrix_dst_norm.getPtr(), true, w, h);
        this->triangle.clear();
        this->triangle.triangulate(this->polyline.getVertices());
    }

protected:

    void setRectangle(ofxXmlSettings_ptr xml, ofPoint *rectangle) {

        xml->pushTag("lefttop", 0);
            rectangle[0] = getPoint(xml);
        xml->popTag();
        xml->pushTag("righttop", 0);
            rectangle[1] = getPoint(xml);
        xml->popTag();
        xml->pushTag("rightbottom", 0);
            rectangle[2] = getPoint(xml);
        xml->popTag();
        xml->pushTag("leftbottom", 0);
            rectangle[3] = getPoint(xml);
        xml->popTag();

    }

    ofPolyline getPolyline(ofxXmlSettings_ptr xml) {

        ofPolyline res;

        int point_count = xml->getNumTags("point");

        for(int k = 0; k < point_count; k++) {
            xml->pushTag("point",k);
                ofPoint point(xml->getValue("x", 0.), xml->getValue("y", 0.));
                res.addVertex(point);
            xml->popTag();
        }

        res.close();

        return res;

    }

};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingColorShape.h"
#pragma once

/* #include "ofx2DMappingShape.h" */

class ofx2DMappingColorShape : public ofx2DMappingShape {

    public:

    ofx2DMappingColorShape() {
        this->nature = "COLOR_SHAPE";
    }

    ofx2DMappingColorShape(const ofx2DMappingColorShape& obj) : ofx2DMappingShape(obj) {
    }

    ofPtr<ofx2DMappingObject> clone() const {
        return ofPtr<ofx2DMappingObject>(new ofx2DMappingColorShape(*this));
    }

    void draw(float w, float h) {
        ofFill();
        ofSetColor(this->color);
        ofBeginShape();
            for (unsigned int j = 0; j < this->polyline.size(); j++){
            ofVertex(this->polyline[j].x*w, this->polyline[j].y*h);
        }
        ofEndShape(true);
    }
};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingContentShape.h"
#pragma once

/* #include "ofx2DMappingShape.h" */

class ofx2DMappingContentShape : public ofx2DMappingShape {

    public:

    ofPoint     src[4];
    float       src_width;
    float       src_height;
    ofMatrix4x4 matrix_src_dst;

    ofTexture* texture;

    ofx2DMappingContentShape() {

        this->nature = "CONTENT_SHAPE";

        this->src[0].x = 0;
        this->src[0].y = 0;
        this->src[1].x = 1;
        this->src[1].y = this->src[0].y;
        this->src[2].x = this->src[1].x;
        this->src[2].y = 1;
        this->src[3].x = this->src[0].x;
        this->src[3].y = this->src[2].y;

        this->matrix_src_dst.makeIdentityMatrix();
    }

    ofx2DMappingContentShape(const ofx2DMappingContentShape& obj) : ofx2DMappingShape(obj) {
        for(int i = 0; i < 4; i++) {
            this->src[i] = obj.src[i];
        }
        this->src_width = obj.src_width;
        this->src_height = obj.src_height;
        this->matrix_src_dst = obj.matrix_src_dst;
        this->texture = obj.texture;
    }

    ofPtr<ofx2DMappingObject> clone() const {
        return ofPtr<ofx2DMappingObject>(new ofx2DMappingContentShape(*this));
    }

    void loadXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingShape::loadXml(xml);
        xml->pushTag("src", 0);
            setRectangle(xml, src);
        xml->popTag();
    }

    void saveXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingShape::saveXml(xml);
        xml->addTag("src");
        xml->pushTag("src", 0);
            xml->addTag("lefttop");
            xml->pushTag("lefttop", 0);
                xml->addValue("x", src[0].x);
                xml->addValue("y", src[0].y);
            xml->popTag();
            xml->addTag("righttop");
            xml->pushTag("righttop", 0);
                xml->addValue("x", src[1].x);
                xml->addValue("y", src[1].y);
            xml->popTag();
            xml->addTag("rightbottom");
            xml->pushTag("rightbottom", 0);
                xml->addValue("x", src[2].x);
                xml->addValue("y", src[2].y);
            xml->popTag();
            xml->addTag("leftbottom");
            xml->pushTag("leftbottom", 0);
                xml->addValue("x", src[3].x);
                xml->addValue("y", src[3].y);
            xml->popTag();
        xml->popTag();
    }

    void update(float w, float h) {
        ofx2DMappingShape::update(w, h);
        this->findHomography(this->dst, this->src, (GLfloat*) this->matrix_src_dst.getPtr(), true, w, h);
    }

    void setTexture(ofTexture* texture) {
        this->texture = texture;
        if(texture) {
            src_width = texture->getWidth();
            src_height = texture->getHeight();
        }
    }

    void draw(float w, float h) {

        ofPushMatrix();

            glMultMatrixf(this->matrix_dst_norm.getPtr());

            if(this->texture) {

                ofSetColor(255);

                texture->bind();

                if(this->polyline.size()!= 4) {

                    glBegin(GL_TRIANGLES);
                    for (int i = 0; i < this->triangle.nTriangles; i++){

                        float cx = (((this->triangle.triangles[i].a.x - this->dst[0].x) / (this->dst[1].x-this->dst[0].x) * (this->src[1].x-this->src[0].x))+ this->src[0].x)* src_width;
                        float cy = (((this->triangle.triangles[i].a.y - this->dst[0].y) / (this->dst[2].y-this->dst[0].y) * (this->src[2].y-this->src[0].y))+ this->src[0].y) * src_height;
                        float ox = (this->triangle.triangles[i].a.x - this->dst[0].x) / (float)(this->dst[1].x-this->dst[0].x) * w;
                        float oy = (this->triangle.triangles[i].a.y - this->dst[0].y) / (float)(this->dst[2].y-this->dst[0].y) * h;
                        glTexCoord2f(cx, cy);
                        glVertex2f(ox, oy);

                        cx = (((this->triangle.triangles[i].b.x - this->dst[0].x) / (this->dst[1].x-this->dst[0].x) * (this->src[1].x-this->src[0].x))+ this->src[0].x)* src_width;
                        cy = (((this->triangle.triangles[i].b.y - this->dst[0].y) / (this->dst[2].y-this->dst[0].y) * (this->src[2].y-this->src[0].y))+ this->src[0].y) * src_height;
                        ox = (this->triangle.triangles[i].b.x - this->dst[0].x)/(float)(this->dst[1].x-this->dst[0].x)*w;
                        oy = (this->triangle.triangles[i].b.y - this->dst[0].y)/(float)(this->dst[2].y-this->dst[0].y)*h;
                        glTexCoord2f(cx, cy);
                        glVertex2f(ox, oy);

                        cx = (((this->triangle.triangles[i].c.x - this->dst[0].x) / (this->dst[1].x-this->dst[0].x) * (this->src[1].x-this->src[0].x))+ this->src[0].x)* src_width;
                        cy = (((this->triangle.triangles[i].c.y - this->dst[0].y) / (this->dst[2].y-this->dst[0].y) * (this->src[2].y-this->src[0].y))+ this->src[0].y) * src_height;
                        ox = (this->triangle.triangles[i].c.x - this->dst[0].x)/(float)(this->dst[1].x-this->dst[0].x)*w;
                        oy = (this->triangle.triangles[i].c.y - this->dst[0].y)/(float)(this->dst[2].y-this->dst[0].y)*h;
                        glTexCoord2f(cx, cy);
                        glVertex2f(ox, oy);

                    }
                    glEnd();
                }
                else {

                    glBegin(GL_QUADS);

                    glTexCoord2f(this->src[0].x*src_width, this->src[0].y*src_height);		glVertex3f(0, 0, 0);
                    glTexCoord2f(this->src[1].x*src_width, this->src[1].y*src_height);		glVertex3f(w, 0, 0);
                    glTexCoord2f(this->src[2].x*src_width, this->src[2].y*src_height);		glVertex3f(w, h, 0);
                    glTexCoord2f(this->src[3].x*src_width, this->src[3].y*src_height);		glVertex3f(0, h, 0);

                   glEnd();
                }

                texture->unbind();

            }

        ofPopMatrix();

    }

    ofTexture* getTexture() {
        return texture;
    }

};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingImage.h"
#pragma once

/* #include "ofx2DMappingContentShape.h" */

class ofx2DMappingImage : public ofx2DMappingContentShape {

    public:

    ofImage     image;
    string      img_src;

    ofx2DMappingImage() {
        this->image.clear();
        this->img_src = "";
        this->nature = "IMAGE";
    }

    ofx2DMappingImage(const ofx2DMappingImage& obj) : ofx2DMappingContentShape(obj) {
        this->image = obj.image;
        this->img_src = obj.img_src;
    }

    ofPtr<ofx2DMappingObject> clone() const {
        return ofPtr<ofx2DMappingObject>(new ofx2DMappingImage(*this));
    }

    void loadXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingContentShape::loadXml(xml);
        string url = xml->getValue("url", "images/notfound.png");
        loadImage(url);
    }

    virtual void saveXml(ofxXmlSettings_ptr xml) {
        ofx2DMappingContentShape::saveXml(xml);
        xml->addValue("url", img_src);
    }

//    void draw(float w, float h) {

//        if(this->image.isAllocated()) {
//            ofPushMatrix();
//            glMultMatrixf(this->matrix_dst_norm.getPtr());

//            ofSetColor(255);
//            ofFill();

//            this->image.bind();

//                glBegin(GL_QUADS);

//                glTexCoord2f(this->src[0].x*this->image.getWidth(), this->src[0].y*this->image.getHeight());	glVertex3f(0, 0, 0);
//                glTexCoord2f(this->src[1].x*this->image.getWidth(), this->src[1].y*this->image.getHeight());	glVertex3f(w, 0, 0);
//                glTexCoord2f(this->src[2].x*this->image.getWidth(), this->src[2].y*this->image.getHeight());	glVertex3f(w, h, 0);
//                glTexCoord2f(this->src[3].x*this->image.getWidth(), this->src[3].y*this->image.getHeight());	glVertex3f(0, h, 0);

//                glEnd();

//            this->image.unbind();
//            glPopMatrix();
//        }

//    }

    void loadImage(string url) {
        image.clear();
        if(image.load(url)) {
            img_src = url;
            src_width = image.getWidth();
            src_height = image.getHeight();
            setTexture(&image.getTexture());
        }
        else {
            ofLogError("MappingImage::loadImage()", "Could not load " + url + ".");
        }
    }

};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingFbo.h"
#pragma once

/* #include "ofx2DMappingContentShape.h" */

class ofx2DMappingFbo : public ofx2DMappingContentShape {

    public:

    ofFbo_ptr fbo;

    ofx2DMappingFbo() {
        this->nature = "FBO";
    }

    ofx2DMappingFbo(const ofx2DMappingFbo& obj) : ofx2DMappingContentShape(obj) {
        this->fbo = obj.fbo;
    }

    ofPtr<ofx2DMappingObject> clone() const {
        return ofPtr<ofx2DMappingObject>(new ofx2DMappingFbo(*this));
    }

    void setFbo(ofFbo_ptr &fbo) {
        this->fbo = fbo;
        if(fbo) {
            src_width = fbo->getWidth();
            src_height = fbo->getHeight();
            setTexture(&fbo->getTexture());
        }
    }

};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingProjector.h"
#pragma once

/* #include "ofx2DMappingObject.h" */
/* #include "ofx2DMappingContentShape.h" */
/* #include "ofx2DMappingFbo.h" */
/* #include "ofx2DMappingColorShape.h" */
/* #include "ofx2DMappingShape.h" */
/* #include "ofx2DMappingImage.h" */
/* #include "ofx2DMappingPoint.h" */
/* #include "ofxSvg.h" */

typedef ofPtr< vector<ofPolyline> > ofPolylines_ptr;
typedef ofPtr< vector<ofPtr<ofPath>> > ofPaths_ptr;

class ofx2DMappingProjector {

public:

    ofx2DMappingProjector(float w, float h);

    ~ofx2DMappingProjector();

    void update();
    void                        updateOutlines();
    void                        updateOutline(int shape_id);

    ofPoint relative(ofPoint orig);

    ofPtr<ofx2DMappingObject> addShape(ofPtr<ofx2DMappingObject> obj, bool swap = false);
    ofPtr<ofx2DMappingObject> addShape(string type, string name, bool swap = false);
    ofPtr<ofx2DMappingObject> copyShape(ofPtr<ofx2DMappingObject> obj, bool swap = false);

    bool removeShape(int id);
    void removeAllShapes();

    bool swapShapes(int index1, int index2);

    ofPtr<ofx2DMappingObject> getMappingObject(int id);

    unsigned int shapeCount();

    ofPtr<ofx2DMappingObject> getFirstImageShape();

    template <class T>
    vector<ofPtr<T>> getShapesByClass() {
        vector<ofPtr<T>> res;
        res.clear();
        ofPtr<T> mo;
        for(unsigned int i = 0; i < shapeCount(); i++) {
            mo = dynamic_pointer_cast<T>(getMappingObject(i));
            if(mo) {
                res.push_back(mo);
            }
        }
        return res;
    }

    ofMatrix4x4 getMatrixOfImageAtPoint(ofPoint p);

    bool pointVisibleInShape(ofPoint p, ofPtr<ofx2DMappingContentShape> mq);

    bool isLeft(ofPoint a, ofPoint b, ofPoint c);

    ofPoint getStartPoint();

    void setStartPoint(ofPoint p);

    void                        exportSvg(string path);

    ofPtr<ofxSVG>                  svg();
    ofPolylines_ptr             outlines();
    ofPolylines_ptr             outlinesRaw();
    ofPaths_ptr                 paths();

    bool reloadSvg(string file);
    void                        importSvg(string file);
    void                        reloadLinesFromRaw();

    ofParameter<float>			outputWidth();
    ofParameter<float>			outputHeight();

private:

    float                       output_w, output_h;

    ofPtr<ofxSVG>                  _svg;
    ofPaths_ptr                 _paths;
    ofPolylines_ptr             _outlines;
    ofPolylines_ptr             _outlines_raw;

    vector<ofPtr<ofx2DMappingObject>> shapes;
    ofPoint                 start_point;
    ofPoint                 plane[4];

    ofFbo_ptr               input_fbo;

};



#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingController.h"
#pragma once

/* #include "ofMain.h" */
/* #include "ofx2DMappingProjector.h" */
/* #include "ofxXmlSettings.h" */

typedef ofPtr<ofxXmlSettings> ofxXmlSettings_ptr;
typedef ofPtr<ofFbo> ofFbo_ptr;
typedef ofPtr<ofImage> ofImage_ptr;
typedef ofPtr<ofTexture> ofTexture_ptr;

class ofx2DMappingController {

	public:

		ofx2DMappingController();
		~ofx2DMappingController() {
			projectors.clear();
		}

		void						setup(string xml_path);
		void						update();
		void                        updateFbo(int projector_id);
		void                        updateAreaFbo(int projector_id);

		void						setupMapping();
		void						reloadMapping(ofxXmlSettings_ptr xml);
		void                        setRectangle(ofxXmlSettings_ptr xml, ofPoint* rectangle);
		ofPoint                     getPoint(ofxXmlSettings_ptr xml);
		ofPolyline                  getPolyline(ofxXmlSettings_ptr xml);

		void                        drawCalibration(ofx2DMappingProjector *p);

		void						addProjector(float w, float h);
		ofx2DMappingProjector*                  getProjector(int id);

		ofPoint                     getPointInMappedArea(ofPoint last_p,ofPoint next_p);
		ofPoint                     intersectionPointPolyline(ofPoint last_p, ofPoint next_p, ofPolyline polyline);

		ofPoint                     getIntersection(ofPoint p1, ofPoint p2, ofPoint p3, ofPoint p4);
		bool                        isLeft(ofPoint p1, ofPoint p2, ofPoint p_test);
		bool                        isOnLine(ofPoint p1, ofPoint p2, ofPoint p_test);

		ofParameter<bool>           &getCalibrating();

		ofParameter<float>          &getCalBorder();
		ofParameter<int>            &getCalGrey();

		float						controlWidth();
		float						controlHeight();

		void						setControlWidth(float val);
		void						setControlHeight(float val);

		ofFbo_ptr &getOutput();
		ofFbo_ptr					getArea();

		ofPoint                     controlpoint;

		void keyPressed  (ofKeyEventArgs &args);
		void keyReleased(ofKeyEventArgs &args);

		void saveOutputImage();

		void                        saveMapping(string path, string path_svg, string path_png);
		void                        saveMappingDefault();
		void                        saveMappingAsPng(string path);
		void                        saveMappingAsPng();
		void                        saveMappingAsSvg();
		void                        importSvg();

		void addTemplate(ofPtr<ofx2DMappingObject> obj);
		template <class T>
		ofPtr<T> addTemplate(string name) {
			ofPtr<T> obj  = ofPtr<T>(new T());
			addTemplate(obj);
			obj->name = name;
			return obj;
		}

		vector<ofPtr<ofx2DMappingObject>> getOptions();

		ofRectangle                 getOutputRectangle();
		void                        setOutputRectangle(ofRectangle r);

	private:

		ofPtr<ofx2DMappingObject> createShape(ofx2DMappingProjector* projector, string type, string name);

		bool use_mapping;

		string xml_mapping, svg_mapping, png_mapping;

		float control_w, control_h;

		vector<ofx2DMappingProjector>			projectors;
		GLfloat						matrix[16];
		ofPoint						plane[4];

		ofParameter<bool>           is_cal;
		ofParameter<float>          cal_border;
		ofParameter<int>            cal_grey;

		ofFbo_ptr           		mapped_content_fbo;
		ofFbo_ptr                   mapped_area_fbo;

		void                        mappedContentToFbo(ofx2DMappingProjector *p);
		void                        mappedAreaToFbo(ofx2DMappingProjector *p);

		vector<ofPtr<ofx2DMappingObject>>   available_shapes;

		ofRectangle                 output_rectangle;

};



#line 0 "../addons-all/ofx2DMapping/src/ofx2DFormMapping.h"
#pragma once

/* #include "ofMain.h" */
/* #include "ofxPanel.h" */
/* #include "ofx2DMappingProjector.h" */
/* #include "ofxSortableList.h" */

struct draggableVertex : public ofPoint {

    bool 	bBeingDragged;
    bool 	bOver;
    float 	radius;

};

struct mappableShape {

    vector <draggableVertex> polyline, src;
    vector<ofPoint> dst;
    ofColor color;

};


class ofx2DFormMapping : public ofxPanel {

public:
    ofx2DFormMapping();

    bool mouseMoved(ofMouseEventArgs &args);
    bool mouseDragged(ofMouseEventArgs &args);
    bool mousePressed(ofMouseEventArgs &args);
    bool mouseReleased(ofMouseEventArgs &args);
    bool mouseScrolled(ofMouseEventArgs &args);

    void setup(string title, ofx2DMappingProjector* parent_projector, ofxSortableList* parent_list, float w, float h);

    void rebuild();
    void updateForms();

    void update();
    void draw(bool show_source);

    void setMappingBackground(ofFbo_ptr &fbo);
    void setOutputForm(ofRectangle rect);
    void setOutputForm(float x, float y, float w, float h);

    void setEditMode(bool direct_edit);

    void setSize(float w, float h);



private:

    void setMappingRects();
    void updateSourceBackground();

    void setZoomFactor(int factor);
    ofPoint addZoom(ofPoint p);
    float addZoom(float p);
    ofPoint removeZoom(ofPoint p);
    ofPoint addZoomRelativeOfDstRect(ofPoint p);
    ofPoint removeZoomRelativeOfDstRect(ofPoint p);

    bool direct_edit;

    ofFbo_ptr mapping_bg;
    ofFbo mapping_front;
    ofTexture* source_bg;

    vector<mappableShape> shapes;
    ofRectangle control_rect, control_rect_backup;
    ofRectangle mapping_rect_dst, mapping_rect_src, mapping_rect_output;

    ofParameter<string> explanation;

    ofx2DMappingProjector* parent_projector;
    ofxSortableList* parent_list;

    int zoom_factor;
    float zoom_speed;
    ofPoint zoom_point, zoom_point_scaled, zoom_point_offset;
    ofPoint translation_dst;

    bool dragging_dst;
    ofPoint last_mouse;

    int mapping_margin;

};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMappingView.h"
#pragma once
/* #include "ofMain.h" */
/* #include "ofx2DMappingController.h" */
/* #include "ofxSortableList.h" */
/* #include "ofx2DFormMapping.h" */

class ofx2DMappingView {

public:
    ofx2DMappingView();
    void setup(float x, float y, float w, float h);
    void update();
    void draw();
    void draw(ofPoint pos);
    void setMappingBackground(ofFbo_ptr fbo);
    void showSource(bool show);
    void setEditMode(bool &direct_edit);

    void setControl(ofx2DMappingController* ctrl);

    void importSvg();

    ofx2DFormMapping* getFormMapping();

    void setShape(ofRectangle shape);
    ofRectangle getShape();

private:

    ofx2DMappingController* ctrl;

    void setSubpanelPositions();
    void updateObjectList();
    void selectAllObjects();
    void deselectAllObjects();
    void removeAllObjects();

    bool show_source, direct_edit;

    ofRectangle control_rect;

    ofxSortableList *object_list;

    ofPoint pos_main_options, pos_calibration_options, pos_add_buttons, pos_shape_list;

    ofParameterGroup add_buttons_panel;
    ofx2DFormMapping mapping_forms;
    ofxGuiPanel *main_panel, *list_panel;
    ofParameterGroup calibration_options, list_options;

    void removeForm(RemovedElementData& data);
    void reorderForm(MovingElementData& data);

    ofParameter<void> save_btn, import_btn, select_all_btn, deselect_all_btn, delete_all_btn;
    ofParameter<bool> edit_mode_btn;
    vector<ofParameter<bool>> add_button_params;

	ofxGui gui;

    float zoom;
    ofPoint zoom_pos;


};

#line 0 "../addons-all/ofx2DMapping/src/ofx2DMapping.h"
#pragma once
/* #include "ofMain.h" */
/* #include "ofx2DMappingController.h" */
/* #include "ofx2DMappingView.h" */

class ofx2DMapping {

public:
    ofx2DMapping();
    ~ofx2DMapping();

    void setup();
    void setup(string mapping_path);
    void update();
    void draw();

    void showControls(bool show);

    ofx2DMappingController* getControl();
    ofx2DMappingView* getControlView();

    void setOutputShape(float x, float y, float width, float height);
    void setControlShape(float x, float y, float width, float height);

    //void setDirectEditMode(bool direct);

    template <class T>
    ofPtr<T> addTemplate(string name) {
        return ctrl.addTemplate<T>(name);
    }

    ofPtr<ofx2DMappingImage> addImageTemplate(string name, string path);
    ofPtr<ofx2DMappingFbo> addFboTemplate(string name, ofPtr<ofFbo> fbo);
    ofPtr<ofx2DMappingColorShape> addColorTemplate(string name, ofColor color);

private:

    ofx2DMappingController ctrl;
    ofx2DMappingView view;

    bool show_controls;

};

#line 0 "../addons-all/ofxLight2D/src/Shape2D.h"
// =============================================================================
//
// Copyright (c) 2014 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


/* #include "ofVec2f.h" */
/* #include "ofColor.h" */
/* #include "ofMesh.h" */
/* #include "ofPolyline.h" */


namespace ofx {


class Shape2D
{
public:
    typedef std::shared_ptr<Shape2D> SharedPtr;
    typedef std::vector<SharedPtr> List;

    Shape2D();
    virtual ~Shape2D();

    void update();
    void draw();

    void setShape(const ofPolyline& shape);
    const ofPolyline& getShape() const;

    ofVec3f getCenter() const;

    void setColor(const ofFloatColor& color);
    ofFloatColor getColor() const;

protected:
    ofVec3f _position;

    ofFloatColor _color;

    ofPolyline _shape;

    void createMesh() const;
    mutable bool _isMeshDirty;

    mutable ofMesh _mesh;

};


} // namespace ofx

#line 0 "../addons-all/ofxLight2D/src/Light2D.h"
// =============================================================================
//
// Copyright (c) 2014 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


/* #include "ofVec2f.h" */
/* #include "ofColor.h" */
/* #include "ofMesh.h" */
/* #include "ofShader.h" */


namespace ofx {


class Light2D
{
public:
	typedef std::shared_ptr<Light2D> SharedPtr;
	typedef std::vector<SharedPtr> List;

    Light2D();
    virtual ~Light2D();

    virtual void update();
    virtual void draw();

    void setPosition(const ofVec3f& position);
    const ofVec3f& getPosition() const;

    void setAngle(float angle);
    float getAngle() const;

    void setViewAngle(float viewAngle);
    float getViewAngle() const;

    void setRadius(float radius);
    float getRadius() const;

    void setColor(const ofFloatColor& color);
    ofFloatColor getColor() const;

    float getBleed() const;
    void setBleed(float bleed);

    float getLinearizeFactor() const;
    void setLinearizeFactor(float linearizeFactor);

    static const float DEFAULT_RADIUS;
    static const float DEFAULT_RANGE;
    static const std::string DEFAULT_LIGHT_SHADER_FRAGMENT_SRC;

    static ofShader DEFAULT_LIGHT_SHADER;

protected:
    ofVec3f _position;
    float _angle;

    float _radius;

    float _viewAngle;
    ofFloatColor _color;
    float _bleed;
    float _linearizeFactor;

    void createMesh() const;
    mutable bool _isMeshDirty;
    mutable ofMesh _mesh;
};


} // namespace ofx

#line 0 "../addons-all/ofxLight2D/src/LightSystem2D.h"
// =============================================================================
//
// Copyright (c) 2014 Christopher Baker <http://christopherbaker.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// =============================================================================


#pragma once


/* #include "Light2D.h" */
/* #include "Shape2D.h" */
/* #include "ofTexture.h" */
/* #include "ofShader.h" */
/* #include "ofFbo.h" */


namespace ofx {


class LightSystem2D
{
public:
    LightSystem2D();
    virtual ~LightSystem2D();

    void setup(ofEventArgs& args);
    void update(ofEventArgs& args);
    void draw(ofEventArgs& args);

    void add(Light2D::SharedPtr light);
    void add(Shape2D::SharedPtr shape);

    void add(const Light2D::List& light);
    void add(const Shape2D::List& shape);

    void remove(Light2D::SharedPtr light);
    void remove(Shape2D::SharedPtr shape);

    void remove(const Light2D::List& lights);
    void remove(const Shape2D::List& shapes);

    void clearLights();
    void clearShapes();

    void windowResized(ofResizeEventArgs& resize);

protected:
    Light2D::List _lights;
    Shape2D::List _shapes;

    ofFbo _lightComp;
    ofFbo _sceneComp;

    static void makeMask(Light2D::SharedPtr light,
                         Shape2D::SharedPtr shape,
                         ofMesh& mask);

};


} // namespace ofx

#line 0 "../addons-all/ofxRay/src/ofxRay/Base.h"
#pragma once
//
//  Base.h
//  ofxRay
//
//  Elliot Woods (C) 2012, MIT license
//	http://www.kimchiandchips.com
//

/* #include "ofMain.h" */

#if OF_VERSION_MINOR < 9	
	#define ofDrawLine ofLine
	#define OFXRAY_GET_TEXTURE getTextureReference()
#else
	#define OFXRAY_GET_TEXTURE getTexture()
#endif

namespace ofxRay {
	class Base;
}
ostream& operator<<(ostream & os, const ofxRay::Base &);
istream& operator>>(istream & is, ofxRay::Base &);

namespace ofxRay {
	class Base {
	public:
		Base();
		Base(ofColor color);
	
		void randomiseColor();
		void randomise(float amplitude=1.0f);
	
		virtual void draw() const = 0;	
		virtual void randomiseVectors(float amplitude=1.0f) = 0;

		friend ostream & (::operator<<) (ostream &, const Base &);
		friend istream & (::operator>>) (istream &, Base &);

		ofColor color;
	};
}
#line 0 "../addons-all/ofxRay/src/ofxRay/Ray.h"
#pragma once
//
//  Ray.h
//  ofxRay
//
//  Elliot Woods (C) 2012, MIT license
//	http://www.kimchiandchips.com
//

/* #include "Base.h" */

namespace ofxRay {
	class Ray;
}
ostream& operator<<(ostream & os, const ofxRay::Ray &);
istream& operator>>(istream & is, ofxRay::Ray &);

namespace ofxRay {
	class Ray : public Base {
	public:
		Ray();
		Ray(ofVec3f s, ofVec3f t, bool infinite=true);
		Ray(ofVec3f s, ofVec3f t, ofColor color, bool infinite=true);
	
		//-
		//ofGeometric
		void draw() const override;
		void randomiseVectors(float amplitude = 1.0f) override;
		//-
		
		///NOTE : does not account for non-infinite lines
		Ray intersect(const Ray &other) const;
	
		float distanceTo(const ofVec3f& point) const;
		ofVec3f closestPointOnRayTo(const ofVec3f& point) const;
	
		Ray& operator*=(const ofMatrix4x4 &m);
		Ray operator*(const ofMatrix4x4 &m) const;
	
		ofVec3f	getMidpoint() const;
		float	getLength() const;
		float	getLengthSquared() const;
	
		void setStart(const ofVec3f &);
		void setEnd(const ofVec3f &);
		void setTranmissionVector(const ofVec3f &);

		const ofVec3f & getStart() const;
		ofVec3f getEnd() const;
		const ofVec3f & getTransmissionVector() const;

		Ray operator*(float other) const;
		ofVec3f operator()(float other) const;

		friend ostream& (::operator<<) (ostream&, const Ray &);
		friend istream& (::operator>>) (istream&, Ray &);
	
		//vectors
		ofVec3f	s, t;
		bool	infinite;
		bool	defined;
	
		//draw styles
		float	width;
	};
}
#line 0 "../addons-all/ofxRay/src/ofxRay/Plane.h"
#pragma once
//
//  Plane.h
//  ofxRay
//
//  Elliot Woods (C) 2012, MIT license
//	http://www.kimchiandchips.com
//

/* #include "Base.h" */
/* #include "Ray.h" */

namespace ofxRay {
	class Plane : public Base {
	public:
		Plane();
		Plane(float a, float b, float c, float d);
		Plane(ofVec3f center, ofVec3f normal);
		Plane(ofVec3f center, ofVec3f normal, ofVec3f up, ofVec2f scale);
	
		//-
		//ofGeometric
		void draw() const;
		void randomiseVectors(float amplitude=1.0f);
		//-
	
		bool intersect(const Ray &ray) const;
		bool intersect(const Ray &ray, ofVec3f &position) const;
	
		const ofVec3f& getCenter() const;
		const ofVec3f& getNormal() const;
		const ofVec3f& getUp() const;
		const ofVec2f& getScale() const;
		ofVec4f getABCD() const; ///< http://mathworld.wolfram.com/Point-PlaneDistance.html
		bool getInfinite() const;
	
		void setCenter(const ofVec3f& center);
		void setNormal(const ofVec3f& normal);
		void setUp(const ofVec3f& up);
		void setScale(const ofVec2f& scale);
		void setInfinite(const bool b);
		void setFrom(ofPlanePrimitive &);
	
		///fills rays{0..3} with rays starting from corners and going to target
		void getCornerRaysTo(const ofVec3f &target, Ray* rays) const;
		///fills rays{0..3} with rays starting from source and going to corners
		void getCornerRaysFrom(const ofVec3f &source, Ray* rays) const;
	
		float getDistanceTo(const ofVec3f &) const;
		bool fitToPoints(const vector<ofVec3f> &, float & residual);

		ofVec3f getRight() const;
	
		Ray getUpRay() const;
		Ray getRightRay() const;
	protected:	
		ofVec3f center;
		ofVec3f normal;
	
		bool infinite;
		ofVec3f up;
		ofVec2f scale;
	
		static ofMesh & getViewGrid();
		static ofMesh & getViewPlane();
	};
}

ostream& operator<<(ostream & os, const ofxRay::Plane &);
istream& operator >> (istream & is, ofxRay::Plane &);
#line 0 "../addons-all/ofxRay/src/ofxRay/Projector.h"
#pragma once
//
//  Projector.h
//  ofxRay
//
//  Elliot Woods (C) 2012, MIT license
//	http://www.kimchiandchips.com
//
/* #include "Ray.h" */
/* #include "Base.h" */

namespace ofxRay {
	class Projector;
}
ostream& operator<<(ostream &, const ofxRay::Projector &);
istream& operator>>(istream & is, ofxRay::Projector &);

namespace ofxRay {
    
    class Plane;
    
	///A class to generate rays given parameters for a projector or camera
	///NB: ofProjector inherits from ofNode, and therefore ofNode stores its view matrix
	class Projector : public Base, public ofNode {
	public:
		Projector(int width=1024, int height=768);
		Projector(float throwRatio, const ofVec2f& lensOffset, int width, int height);
		Projector(const ofMatrix4x4 & projection, int width, int height);
		Projector(const ofMatrix4x4 & view, const ofMatrix4x4 & projection, int width, int height);

		//--
		//ofGeometric
		//--
		//
		void draw() const;
		void randomiseVectors(float amplitude=1.0f);
		//
		//--
		
		///Choose a random pose, for the projector with scale factor
		void randomisePose(float scale=1.0f);
	
		ofVec2f pixelToCoordinate(const ofVec2f & xy) const;

		///Undistort the given coordinate (pass through for Projector)
		virtual ofVec2f undistortCoordinate(const ofVec2f & xy) const { return xy;}
		
		///Generate a ray for the given pixel coordinates x,y within the projector's image
		Ray castPixel(int x, int y) const;
		Ray castPixel(const ofVec2f& xy) const;
		void castPixels(const vector<ofVec2f>& xy, vector<Ray>& rays) const;

		///Generate a ray for the given normalised coordinate x,y where {-1.0f<x,y<1.0f}
		Ray castCoordinate(const ofVec2f& xy) const;
		void castCoordinates(const vector<ofVec2f>& xy, vector<Ray>& rays) const;

        // Generate a ray for the projection center
        Ray getProjectionCenterRay() const;
        
        // Generate a ray for the projector itself (differs from the above if we have lens offset)
        Ray getProjectorRay(float distance) const;
        
        // returns a plane, perpendicular to the projector ray, at the specified distance
        Plane getProjectionPlaneAt(float distance, bool infinite = false) const;
        
        // convert world coordinates, to signed normalized (-1...1) coordinates
        ofVec3f getNormalizedSCoordinateOfWorldPosition(ofVec3f pointWorld) const;
        
        // convert world coordinates, to unsigned normalized (0...1) coordinates
        ofVec3f getNormalizedUCoordinateOfWorldPosition(ofVec3f pointWorld) const;

        // convert world coordinates to screen pixel coordinates
        ofVec3f getScreenCoordinateOfWorldPosition(ofVec3f pointWorld) const;
        
        // convert signed normalized (-1...1) coordiantes to world coordinates (pointNorm.z contains distance to projector plane)
        ofVec3f getWorldPositionOfNormalizedSCoordinate(ofVec3f pointNormS) const;
        
        // convert unsigned normalized (0...1) coordiantes to world coordinates (pointNorm.z contains distance to projector plane)
        ofVec3f getWorldPositionOfNormalizedUCoordinate(ofVec3f pointNormU) const;
        
        // convert screen pixel coordinates to world coordinates (pointScreen.z contains distance to projector plane)
        ofVec3f getWorldPositionOfScreenCoordinate(ofVec3f pointScreen) const;
        

        void setProjection(float throwRatio, const ofVec2f& lensOffset);
		void setProjection(const ofMatrix4x4& projection);

		///Set width of projector. Warning: we will forget our throwRatio and lensOffset
		void setWidth(int width);
		///Set height of projector. Warning: we will forget our throwRatio and lensOffset
		void setHeight(int height);
		int getWidth() const;
		int getHeight() const;

        float getThrowRatio() const;
        ofVec2f getLensOffset() const;

		ofMatrix4x4 getViewMatrix() const;
		ofMatrix4x4 getProjectionMatrix() const;

		bool isProjectionMatrixInfinite() const;
		ofMatrix4x4 getClippedProjectionMatrix() const; ///<If projection matrix is infinite, we enforce a (0.01...10.0) clipping
		
		void drawOnNearPlane(ofBaseHasTexture &, bool nearPlaneFlipped = false) const;
		void drawOnNearPlane(ofTexture &, bool nearPlaneFlipped = false) const;
		
		void beginAsCamera(bool flipY = false) const;
		void endAsCamera() const;
		
		ofVec2f getCoordinateFromIndex(const uint32_t index) const;
		ofVec2f getCoordinateFromIndex(const uint32_t x, const uint32_t y) const;

		ofVec2f getIndexFromCoordinate(const ofVec2f&) const;
		
		void setNearClip(float near = 0.5);
		void setFarClip(float far = 20.0f);

		friend ostream & (::operator<<) (ostream &, const Projector &);
		friend istream & (::operator>>) (istream &, Projector &);
	protected:
		int width;
		int height;
        
		ofMatrix4x4 projection;
		static ofMesh* drawBox;

		float nearClip = 0.5f;
		float farClip = 20.0f;
	private:
		static void makeBox();

        float throwRatio;
        ofVec2f lensOffset;
	};
}


#line 0 "../addons-all/ofxRay/src/ofxRay/Camera.h"
#pragma once
//
//  Camera.h
//  ofxRay
//
//  Elliot Woods (C) 2012, MIT license
//	http://www.kimchiandchips.com
//
/* #include "Ray.h" */
/* #include "Projector.h" */

namespace ofxRay {
	class Camera;
}
ostream& operator<<(ostream &, const ofxRay::Camera &);
istream& operator>>(istream & is, ofxRay::Camera &);

namespace ofxRay {
	class Camera : public Projector {
	public:
		Camera();
		Camera(const ofVec2f & focalLength, const ofVec2f & center, float w, float h);
		
		ofVec2f undistortCoordinate(const ofVec2f & xy) const;
		vector<float> distortion;

		friend ostream & (::operator<<) (ostream &, const Camera &);
		friend istream & (::operator>>) (istream &, Camera &);
	};
}

#line 0 "../addons-all/ofxRay/src/ofxRay.h"
#pragma once
//
//  ofxRay.h
//  ofxRay
//
//  Elliot Woods (C) 2012, MIT license
//	http://www.kimchiandchips.com
//

//include me in your project
//and i'll include everything else

/* #include "ofMain.h" */

/* #include "ofxRay/Ray.h" */
/* #include "ofxRay/Plane.h" */
/* #include "ofxRay/Projector.h" */
/* #include "ofxRay/Camera.h" */

typedef ofxRay::Ray ofRay;
typedef ofxRay::Plane ofPlane;
typedef ofxRay::Projector ofProjector;
#line 0 "../addons-all/ofxShadertoy/src/ofxShadertoy.h"
//
//  ofxShadertoy.h
//  Addon for loading and displaying www.shadertoy.com shaders
//
//  Created by @tiagosr on 6/26/15.
//
//

#pragma once
/* #include "ofMain.h" */

class ofxShadertoy: public ofBaseDraws {
protected:
    ofShader shader;
    ofTexture channel0, channel1, channel2, channel3;
    bool useMouse, advanceTime;
    ofVec2f mousepos;
    ofVec2f dimensions;
    ofCamera *camera;
    double globalTime;
public:
    ofxShadertoy();
    virtual ~ofxShadertoy();
    bool load(string shaderfilename,
              bool chan0cube = false,
              bool chan1cube = false,
              bool chan2cube = false,
              bool chan3cube = false);
    virtual void begin() const;
    virtual void end() const;
    virtual void update(ofEventArgs&);
    virtual void setUseMouse(bool);
    virtual void setAdvanceTime(bool);
    virtual void setCamera(ofCamera*);
    virtual void draw(float x, float y) const { draw(x, y, 0, dimensions.x, dimensions.y); }
    virtual void draw(float x, float y, float w, float h) const { draw(x, y, 0, w, h); }
    virtual void draw(float x, float y, float z, float w, float h) const;
    virtual float getWidth() const { return dimensions.x; }
    virtual float getHeight() const { return dimensions.y; }
    virtual void setWidth(float w) { dimensions.x = w; }
    virtual void setHeight(float h) { dimensions.y = h; }
    virtual void setTexture(int index, const ofTexture& tex);
};

#line 0 "../addons-all/ofxBlender/src/zstr.h"
//---------------------------------------------------------
// Copyright 2015 Ontario Institute for Cancer Research
// Written by Matei David (matei@cs.toronto.edu)
//---------------------------------------------------------

// Reference:
// http://stackoverflow.com/questions/14086417/how-to-write-custom-input-stream-in-c

#ifndef __ZSTR_H
#define __ZSTR_H

#include <cstring>
#include <string>
#include <cassert>
#include <fstream>
#include <sstream>
#include <zlib.h>


/**
 * This namespace defines wrappers for std::ifstream, std::ofstream, and
 * std::fstream objects. The wrappers perform the following steps:
 * - check the open modes make sense
 * - check that the call to open() is successful
 * - (for input streams) check that the opened file is peek-able
 * - turn on the badbit in the exception mask
 */
namespace strict_fstream
{

/// Overload of error-reporting function, to enable use with VS.
/// Ref: http://stackoverflow.com/a/901316/717706
static std::string strerror()
{
    std::string buff(80, '\0');
#ifdef _WIN32
    if (strerror_s(&buff[0], buff.size(), errno) != 0)
    {
        buff = "Unknown error";
    }
#elif __APPLE__ || (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE
// XSI-compliant strerror_r()
    if (strerror_r(errno, &buff[0], buff.size()) != 0)
    {
        buff = "Unknown error";
    }
#else
// GNU-specific strerror_r()
    auto p = strerror_r(errno, &buff[0], buff.size());
    std::string tmp(p, std::strlen(p));
    std::swap(buff, tmp);
#endif
    buff.resize(buff.find('\0'));
    return buff;
}

/// Exception class thrown by failed operations.
class Exception
    : public std::exception
{
public:
    Exception(const std::string& msg) : _msg(msg) {}
    const char * what() const noexcept { return _msg.c_str(); }
private:
    std::string _msg;
}; // class Exception

namespace detail
{

struct static_method_holder
{
    static std::string mode_to_string(std::ios_base::openmode mode)
    {
        static const int n_modes = 6;
        static const std::ios_base::openmode mode_val_v[n_modes] =
            {
                std::ios_base::in,
                std::ios_base::out,
                std::ios_base::app,
                std::ios_base::ate,
                std::ios_base::trunc,
                std::ios_base::binary
            };

        static const char * mode_name_v[n_modes] =
            {
                "in",
                "out",
                "app",
                "ate",
                "trunc",
                "binary"
            };
        std::string res;
        for (int i = 0; i < n_modes; ++i)
        {
            if (mode & mode_val_v[i])
            {
                res += (! res.empty()? "|" : "");
                res += mode_name_v[i];
            }
        }
        if (res.empty()) res = "none";
        return res;
    }
    static void check_mode(const std::string& filename, std::ios_base::openmode mode)
    {
        if ((mode & std::ios_base::trunc) && ! (mode & std::ios_base::out))
        {
            throw Exception(std::string("strict_fstream: open('") + filename + "'): mode error: trunc and not out");
        }
        else if ((mode & std::ios_base::app) && ! (mode & std::ios_base::out))
        {
            throw Exception(std::string("strict_fstream: open('") + filename + "'): mode error: app and not out");
        }
        else if ((mode & std::ios_base::trunc) && (mode & std::ios_base::app))
        {
            throw Exception(std::string("strict_fstream: open('") + filename + "'): mode error: trunc and app");
        }
     }
    static void check_open(std::ios * s_p, const std::string& filename, std::ios_base::openmode mode)
    {
        if (s_p->fail())
        {
            throw Exception(std::string("strict_fstream: open('")
                            + filename + "'," + mode_to_string(mode) + "): open failed: "
                            + strerror());
        }
    }
    static void check_peek(std::istream * is_p, const std::string& filename, std::ios_base::openmode mode)
    {
        bool peek_failed = true;
        try
        {
            is_p->peek();
            peek_failed = is_p->fail();
        }
        catch (std::ios_base::failure e) {}
        if (peek_failed)
        {
            throw Exception(std::string("strict_fstream: open('")
                            + filename + "'," + mode_to_string(mode) + "): peek failed: "
                            + strerror());
        }
        is_p->clear();
    }
}; // struct static_method_holder

} // namespace detail

class ifstream
    : public std::ifstream
{
public:
    ifstream() = default;
    ifstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
    {
        open(filename, mode);
    }
    void open(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
    {
        mode |= std::ios_base::in;
        exceptions(std::ios_base::badbit);
        detail::static_method_holder::check_mode(filename, mode);
        std::ifstream::open(filename, mode);
        detail::static_method_holder::check_open(this, filename, mode);
        detail::static_method_holder::check_peek(this, filename, mode);
    }
}; // class ifstream

class ofstream
    : public std::ofstream
{
public:
    ofstream() = default;
    ofstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::out)
    {
        open(filename, mode);
    }
    void open(const std::string& filename, std::ios_base::openmode mode = std::ios_base::out)
    {
        mode |= std::ios_base::out;
        exceptions(std::ios_base::badbit);
        detail::static_method_holder::check_mode(filename, mode);
        std::ofstream::open(filename, mode);
        detail::static_method_holder::check_open(this, filename, mode);
    }
}; // class ofstream

class fstream
    : public std::fstream
{
public:
    fstream() = default;
    fstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
    {
        open(filename, mode);
    }
    void open(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
    {
        if (! (mode & std::ios_base::out)) mode |= std::ios_base::in;
        exceptions(std::ios_base::badbit);
        detail::static_method_holder::check_mode(filename, mode);
        std::fstream::open(filename, mode);
        detail::static_method_holder::check_open(this, filename, mode);
        detail::static_method_holder::check_peek(this, filename, mode);
    }
}; // class fstream

} // namespace strict_fstream



namespace zstr
{

/// Exception class thrown by failed zlib operations.
class Exception
    : public std::exception
{
public:
    Exception(z_stream * zstrm_p, int ret)
        : _msg("zlib: ")
    {
        switch (ret)
        {
        case Z_STREAM_ERROR:
            _msg += "Z_STREAM_ERROR: ";
            break;
        case Z_DATA_ERROR:
            _msg += "Z_DATA_ERROR: ";
            break;
        case Z_MEM_ERROR:
            _msg += "Z_MEM_ERROR: ";
            break;
        case Z_VERSION_ERROR:
            _msg += "Z_VERSION_ERROR: ";
            break;
        case Z_BUF_ERROR:
            _msg += "Z_BUF_ERROR: ";
            break;
        default:
            std::ostringstream oss;
            oss << ret;
            _msg += "[" + oss.str() + "]: ";
            break;
        }
        _msg += zstrm_p->msg;
    }
    Exception(const std::string msg) : _msg(msg) {}
    const char * what() const noexcept { return _msg.c_str(); }
private:
    std::string _msg;
}; // class Exception

namespace detail
{

class z_stream_wrapper
    : public z_stream
{
public:
    z_stream_wrapper(bool _is_input = true, int _level = Z_DEFAULT_COMPRESSION)
        : is_input(_is_input)
    {
        this->zalloc = Z_NULL;
        this->zfree = Z_NULL;
        this->opaque = Z_NULL;
        int ret;
        if (is_input)
        {
            this->avail_in = 0;
            this->next_in = Z_NULL;
            ret = inflateInit2(this, 15+32);
        }
        else
        {
            ret = deflateInit2(this, _level, Z_DEFLATED, 15+16, 8, Z_DEFAULT_STRATEGY);
        }
        if (ret != Z_OK) throw Exception(this, ret);
    }
    ~z_stream_wrapper()
    {
        if (is_input)
        {
            inflateEnd(this);
        }
        else
        {
            deflateEnd(this);
        }
    }
private:
    bool is_input;
}; // class z_stream_wrapper

} // namespace detail

class istreambuf
    : public std::streambuf
{
public:
    istreambuf(std::streambuf * _sbuf_p,
               std::size_t _buff_size = default_buff_size, bool _auto_detect = true)
        : sbuf_p(_sbuf_p),
          zstrm_p(nullptr),
          buff_size(_buff_size),
          auto_detect(_auto_detect),
          auto_detect_run(false),
          is_text(false)
    {
        assert(sbuf_p);
        in_buff = new char [buff_size];
        in_buff_start = in_buff;
        in_buff_end = in_buff;
        out_buff = new char [buff_size];
        setg(out_buff, out_buff, out_buff);
    }

    istreambuf(const istreambuf &) = delete;
    istreambuf(istreambuf &&) = default;
    istreambuf & operator = (const istreambuf &) = delete;
    istreambuf & operator = (istreambuf &&) = default;

    virtual ~istreambuf()
    {
        delete [] in_buff;
        delete [] out_buff;
        if (zstrm_p) delete zstrm_p;
    }

    virtual std::streambuf::int_type underflow()
    {
        if (this->gptr() == this->egptr())
        {
            // pointers for free region in output buffer
            char * out_buff_free_start = out_buff;
            do
            {
                // read more input if none available
                if (in_buff_start == in_buff_end)
                {
                    // empty input buffer: refill from the start
                    in_buff_start = in_buff;
                    std::streamsize sz = sbuf_p->sgetn(in_buff, buff_size);
                    in_buff_end = in_buff + sz;
                    if (in_buff_end == in_buff_start) break; // end of input
                }
                // auto detect if the stream contains text or deflate data
                if (auto_detect && ! auto_detect_run)
                {
                    auto_detect_run = true;
                    unsigned char b0 = *reinterpret_cast< unsigned char * >(in_buff_start);
                    unsigned char b1 = *reinterpret_cast< unsigned char * >(in_buff_start + 1);
                    // Ref:
                    // http://en.wikipedia.org/wiki/Gzip
                    // http://stackoverflow.com/questions/9050260/what-does-a-zlib-header-look-like
                    is_text = ! (in_buff_start + 2 <= in_buff_end
                                 && ((b0 == 0x1F && b1 == 0x8B)         // gzip header
                                     || (b0 == 0x78 && (b1 == 0x01      // zlib header
                                                        || b1 == 0x9C
                                                        || b1 == 0xDA))));
                }
                if (is_text)
                {
                    // simply swap in_buff and out_buff, and adjust pointers
                    assert(in_buff_start == in_buff);
                    std::swap(in_buff, out_buff);
                    out_buff_free_start = in_buff_end;
                    in_buff_start = in_buff;
                    in_buff_end = in_buff;
                }
                else
                {
                    // run inflate() on input
                    if (! zstrm_p) zstrm_p = new detail::z_stream_wrapper(true);
                    zstrm_p->next_in = reinterpret_cast< decltype(zstrm_p->next_in) >(in_buff_start);
                    zstrm_p->avail_in = in_buff_end - in_buff_start;
                    zstrm_p->next_out = reinterpret_cast< decltype(zstrm_p->next_out) >(out_buff_free_start);
                    zstrm_p->avail_out = (out_buff + buff_size) - out_buff_free_start;
                    int ret = inflate(zstrm_p, Z_NO_FLUSH);
                    // process return code
                    if (ret != Z_OK && ret != Z_STREAM_END) throw Exception(zstrm_p, ret);
                    // update in&out pointers following inflate()
                    in_buff_start = reinterpret_cast< decltype(in_buff_start) >(zstrm_p->next_in);
                    in_buff_end = in_buff_start + zstrm_p->avail_in;
                    out_buff_free_start = reinterpret_cast< decltype(out_buff_free_start) >(zstrm_p->next_out);
                    assert(out_buff_free_start + zstrm_p->avail_out == out_buff + buff_size);
                    // if stream ended, deallocate inflator
                    if (ret == Z_STREAM_END)
                    {
                        delete zstrm_p;
                        zstrm_p = nullptr;
                    }
                }
            } while (out_buff_free_start == out_buff);
            // 2 exit conditions:
            // - end of input: there might or might not be output available
            // - out_buff_free_start != out_buff: output available
            this->setg(out_buff, out_buff, out_buff_free_start);
        }
        return this->gptr() == this->egptr()
            ? traits_type::eof()
            : traits_type::to_int_type(*this->gptr());
    }
private:
    std::streambuf * sbuf_p;
    char * in_buff;
    char * in_buff_start;
    char * in_buff_end;
    char * out_buff;
    detail::z_stream_wrapper * zstrm_p;
    std::size_t buff_size;
    bool auto_detect;
    bool auto_detect_run;
    bool is_text;

    static const std::size_t default_buff_size = (std::size_t)1 << 20;
}; // class istreambuf

class ostreambuf
    : public std::streambuf
{
public:
    ostreambuf(std::streambuf * _sbuf_p,
               std::size_t _buff_size = default_buff_size, int _level = Z_DEFAULT_COMPRESSION)
        : sbuf_p(_sbuf_p),
          zstrm_p(new detail::z_stream_wrapper(false, _level)),
          buff_size(_buff_size)
    {
        assert(sbuf_p);
        in_buff = new char [buff_size];
        out_buff = new char [buff_size];
        setp(in_buff, in_buff + buff_size);
    }

    ostreambuf(const ostreambuf &) = delete;
    ostreambuf(ostreambuf &&) = default;
    ostreambuf & operator = (const ostreambuf &) = delete;
    ostreambuf & operator = (ostreambuf &&) = default;

    int deflate_loop(int flush)
    {
        while (true)
        {
            zstrm_p->next_out = reinterpret_cast< decltype(zstrm_p->next_out) >(out_buff);
            zstrm_p->avail_out = buff_size;
            int ret = deflate(zstrm_p, flush);
            if (ret != Z_OK && ret != Z_STREAM_END && ret != Z_BUF_ERROR) throw Exception(zstrm_p, ret);
            std::streamsize sz = sbuf_p->sputn(out_buff, reinterpret_cast< decltype(out_buff) >(zstrm_p->next_out) - out_buff);
            if (sz != reinterpret_cast< decltype(out_buff) >(zstrm_p->next_out) - out_buff)
            {
                // there was an error in the sink stream
                return -1;
            }
            if (ret == Z_STREAM_END || ret == Z_BUF_ERROR || sz == 0)
            {
                break;
            }
        }
        return 0;
    }

    virtual ~ostreambuf()
    {
        // flush the zlib stream
        //
        // NOTE: Errors here (sync() return value not 0) are ignored, because we
        // cannot throw in a destructor. This mirrors the behaviour of
        // std::basic_filebuf::~basic_filebuf(). To see an exception on error,
        // close the ofstream with an explicit call to close(), and do not rely
        // on the implicit call in the destructor.
        //
        sync();
        delete [] in_buff;
        delete [] out_buff;
        delete zstrm_p;
    }
    virtual std::streambuf::int_type overflow(std::streambuf::int_type c = traits_type::eof())
    {
        zstrm_p->next_in = reinterpret_cast< decltype(zstrm_p->next_in) >(pbase());
        zstrm_p->avail_in = pptr() - pbase();
        while (zstrm_p->avail_in > 0)
        {
            int r = deflate_loop(Z_NO_FLUSH);
            if (r != 0)
            {
                setp(nullptr, nullptr);
                return traits_type::eof();
            }
        }
        setp(in_buff, in_buff + buff_size);
        return traits_type::eq_int_type(c, traits_type::eof()) ? traits_type::eof() : sputc(c);
    }
    virtual int sync()
    {
        // first, call overflow to clear in_buff
        overflow();
        if (! pptr()) return -1;
        // then, call deflate asking to finish the zlib stream
        zstrm_p->next_in = nullptr;
        zstrm_p->avail_in = 0;
        if (deflate_loop(Z_FINISH) != 0) return -1;
        deflateReset(zstrm_p);
        return 0;
    }
private:
    std::streambuf * sbuf_p;
    char * in_buff;
    char * out_buff;
    detail::z_stream_wrapper * zstrm_p;
    std::size_t buff_size;

    static const std::size_t default_buff_size = (std::size_t)1 << 20;
}; // class ostreambuf

class istream
    : public std::istream
{
public:
    istream(std::istream & is)
        : std::istream(new istreambuf(is.rdbuf()))
    {
        exceptions(std::ios_base::badbit);
    }
    explicit istream(std::streambuf * sbuf_p)
        : std::istream(new istreambuf(sbuf_p))
    {
        exceptions(std::ios_base::badbit);
    }
    virtual ~istream()
    {
        delete rdbuf();
    }
}; // class istream

class ostream
    : public std::ostream
{
public:
    ostream(std::ostream & os)
        : std::ostream(new ostreambuf(os.rdbuf()))
    {
        exceptions(std::ios_base::badbit);
    }
    explicit ostream(std::streambuf * sbuf_p)
        : std::ostream(new ostreambuf(sbuf_p))
    {
        exceptions(std::ios_base::badbit);
    }
    virtual ~ostream()
    {
        delete rdbuf();
    }
}; // class ostream

namespace detail
{

template < typename FStream_Type >
struct strict_fstream_holder
{
    strict_fstream_holder(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
        : _fs(filename, mode)
    {}
    FStream_Type _fs;
}; // class strict_fstream_holder

} // namespace detail

class ifstream
    : private detail::strict_fstream_holder< strict_fstream::ifstream >,
      public std::istream
{
public:
    explicit ifstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
        : detail::strict_fstream_holder< strict_fstream::ifstream >(filename, mode),
          std::istream(new istreambuf(_fs.rdbuf()))
    {
        exceptions(std::ios_base::badbit);
    }
    virtual ~ifstream()
    {
        if (rdbuf()) delete rdbuf();
    }
}; // class ifstream

class ofstream
    : private detail::strict_fstream_holder< strict_fstream::ofstream >,
      public std::ostream
{
public:
    explicit ofstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::out)
        : detail::strict_fstream_holder< strict_fstream::ofstream >(filename, mode | std::ios_base::binary),
          std::ostream(new ostreambuf(_fs.rdbuf()))
    {
        exceptions(std::ios_base::badbit);
    }
    virtual ~ofstream()
    {
        if (rdbuf()) delete rdbuf();
    }
}; // class ofstream

} // namespace zstr

#endif // __ZSTR_H

#line 0 "../addons-all/ofxBlender/src/Utils.h"
#ifndef BLENDER_UTILS_H
#define BLENDER_UTILS_H

/* #include "ofMain.h" */

#define OFX_BLENDER "ofxBlender"

namespace ofx {
namespace blender {

	std::string &trim(std::string &s);

}
}
#endif // LOADER_H

#line 0 "../addons-all/ofxBlender/src/Interpolation.h"
#ifndef INTERPOLATION_H
#define INTERPOLATION_H

/* #include "Utils.h" */

namespace ofx {

namespace blender {

enum InterpolationType {
    LINEAR,
    BEZIER,
    CONSTANT
};

class Interpolation {
public:

	//taken from http://devmag.org.za/2011/04/05/bzier-curves-a-tutorial/
	template<typename Type>
	static Type bezier(float t, ofVec2f p0, ofVec2f p1, ofVec2f p2, ofVec2f p3) {
		ofLogWarning(OFX_BLENDER) << "unsupported type passed to bezier, works only with float";
		return Type();
	}


	template<typename Type>
	static Type linear(float interpol, Type a, Type b) {
		return a + (b - a) * interpol;
	}

//};
};

template<>
float Interpolation::bezier<float>(float t, ofVec2f p0, ofVec2f p1, ofVec2f p2, ofVec2f p3);

}
}

#endif // INTERPOLATION_H

#line 0 "../addons-all/ofxBlender/src/Animation.h"
#ifndef ANIMATION_H
#define ANIMATION_H

/* #include "Utils.h" */
#include <typeindex>
/* #include "Interpolation.h" */

namespace ofx {

namespace blender {

class Timeline;

class Animation_ {
public:

	// little helper class to have templated default handlers for timeline events
	class DefaultHandler_ {
	public:
		virtual std::type_index getType()=0;
	};

	template<typename Type>
	class DefaultHandler: public DefaultHandler_ {
	public:
		typedef std::function<void(Type&, string, int)> Listener;
		DefaultHandler(Listener _listener) {
			listener = _listener;
		}

		void call(Type t, string address, int channel) {
			listener(t, address, channel);
		}

		std::type_index getType() {
			return type_index(typeid(Type));
		}

		Listener listener;
	};

	class DefaultHandlerContainer {
	public:
		template<typename Type>
		void call(Type value, string address, int channel) {
			std::type_index type(typeid(Type));
			if(handlers.find(type) != handlers.end()) {
				DefaultHandler<Type>* handler = static_cast<DefaultHandler<Type>*>(handlers[type]);
				handler->call(value, address, channel);
			}
		}

		template<typename Type>
		void add(std::function<void(Type&, string, int)> listener) {
			DefaultHandler<Type>* handler = new DefaultHandler<Type>(listener);
			handlers[handler->getType()] = handler;
		}

		std::map<std::type_index, DefaultHandler_*> handlers;
	};
	/////////////////////////////////////////////////////////////////////

	Animation_(string address_, int channel_): type(typeid(void)) {
		isLoop = false;
		internalTime = 0;
		timeOffset = 0;
		timeLast = timeOffset;
		channel = channel_;
		address = address_;
		defaultHandler = NULL;
	}

	void step(unsigned long long timeNow) {
		timeNow -= timeOffset;
		onStep(timeNow, timeLast);
		timeLast = timeNow;
	};

	template<typename Type>
	bool isType() {
		return std::type_index(typeid(Type)) == type;
	}

	void clear() {
		keyframes.clear();
	}

	virtual void reset() {};

	bool isRunning() {
		return getKeyframeAfter(timeLast) != NULL;
	}

	int channel;
	string address;
	bool isLoop;
	unsigned long long timeOffset;
	unsigned long long timeLast;
	std::type_index type;

protected:
	class Keyframe {
	public:
		Keyframe(unsigned long long _time) {
			time = _time;
		}
		unsigned long long time;
	};
	virtual void onStep(unsigned long long timeNow, unsigned long long timeLast) = 0;
	struct keyFrameSort {
		inline bool operator() (const Keyframe* k1, const Keyframe* k2) {
			return (k1->time < k2->time);
		}
	};

	void addKeyframe(Keyframe* keyframe) {
		keyframes.push_back(keyframe);
		std::sort(keyframes.begin(), keyframes.end(), keyFrameSort());
	}

	Keyframe* getKeyframeBefore(unsigned long long time) {
		Keyframe* lastKey = NULL;
		for(Keyframe* key: keyframes) {
			if(key->time >= time)
				return lastKey;
			lastKey = key;
		}
		return lastKey;
	}

	Keyframe* getKeyframeAfter(unsigned long long time) {
		for(Keyframe* key: keyframes) {
			if(key->time >= time)
				return key;
		}
		return NULL;
	}

	std::vector<Keyframe*> keyframes;
	unsigned long long internalTime;
	DefaultHandlerContainer* defaultHandler;

	friend class Timeline;
};

template<typename Type>
class Animation:public Animation_ {
public:

	class Keyframe: public Animation_::Keyframe {
	public:
		Keyframe(unsigned long long _time, Type v, ofVec2f p, ofVec2f h1, ofVec2f h2):Animation_::Keyframe(_time) {
			point = p;
			handle1 = h1;
			handle2 = h2;
			interpolation = BEZIER;
			value = v;
		}

		Keyframe(unsigned long long _time, Type v, InterpolationType type):Animation_::Keyframe(_time) {
			interpolation = type;
			value = v;
		}

		ofVec2f point;
		ofVec2f handle1;
		ofVec2f handle2;
		Type value;
		InterpolationType interpolation;
	};

	Animation(string address, int channel):Animation_(address, channel) {
		oldValueSet = false;
		type = std::type_index(typeid(Type));
	};

	void onStep(unsigned long long timeNow, unsigned long long timeLast) {
		
		
				
		Keyframe* key1 = static_cast<Keyframe*>(Animation_::getKeyframeBefore(timeNow));
		Keyframe* key2 = static_cast<Keyframe*>(Animation_::getKeyframeAfter(timeNow));
		
		//check if we have a key1, otherwise I don't know how to calculate this

		if(!key1 && !key2) {
			return;
		}

		if(key1 == key2) {
			key2 = NULL;
		}

		if(!key1 && key2) {
			key1 = key2;
			key2 = NULL;
		}

		//if there is no key in the future, then the value has to be key1
		if(!key2 || key1->interpolation == CONSTANT) {
			Animation<Type>::triggerListeners(key1->value);
			return;
		}

		//both keys are around, let's tween
		double step = key2->time - key1->time;
		double stepRel = (timeNow - key1->time) / step;
		
		/*
		if(channel == 2  && address == "rotation_euler"){
			cout << stepRel << ": " <<  key1->value << " - " << key2->value << " " << timeNow << " - " << key1->time << " - " << key2->time << endl;
		}
		*/
		/*
		if(stepRel < .002) {
			Animation<Type>::triggerListeners(key1->value);
			return;
		}else if(stepRel > .998) {
			Animation<Type>::triggerListeners(key2->value);
			return;
		}
		*/

		switch(key1->interpolation) {
		case LINEAR:
			Animation<Type>::triggerListeners(Interpolation::linear<Type>(stepRel, key1->value, key2->value));
			break;
		case BEZIER:
			Animation<Type>::triggerListeners(Interpolation::bezier<Type>(stepRel, key1->point, key1->handle2, key2->handle1, key2->point));
			break;
		case CONSTANT:
			Animation<Type>::triggerListeners(key1->value);
		}
	}

	void addKeyframe(double time, Type value, ofVec2f p, ofVec2f h1, ofVec2f h2) {
		Keyframe* key = new Keyframe(time, value, p, h1, h2);
		Animation_::addKeyframe(key);
	}

	void addKeyframe(double time, Type value, InterpolationType type = LINEAR) {
		Keyframe* key = new Keyframe(time, value, type);
		Animation_::addKeyframe(key);
	}

	typedef std::function<void(Type&, string, int)> Listener;
	void addListener(Listener listener) {
		listeners.push_back(listener);
	}

	void triggerListeners(Type value) {

		//don't do unnecessary triggers
		if(oldValueSet && oldValue == value) {
			return;
		}

		//call teh default handler
		if(defaultHandler)
			defaultHandler->call<Type>(value, address, channel);

		for(Listener listener: listeners) {
			listener(value, address, channel);
		}
		oldValue = value;
		oldValueSet = true;
	}

	void reset() {
		oldValueSet = false;
	}

private:
	std::vector<Listener> listeners;
	Type oldValue;
	bool oldValueSet;
};

//////////////////////////////////////////////////// MARKER

class Marker {
public:
	Marker(unsigned long long t, string n) {
		time = t;
		name = n;
	}

	unsigned long long time;
	string name;
};

/////////////////////////////////////////////////// TIMELINE

class Timeline {
public:
	Timeline();
	~Timeline();

	template<typename Type>
	void setDefaultHandler(std::function<void(Type&, string, int)> listener) {
		defaultHandler.add<Type>(listener);
	}

	void add(Timeline* timeline);
	void add(Animation_* animation);
	void addMarker(float time, string name);

	template<typename Type>
	Animation<Type>* getAnimation(string address, int channel=0) {
		for(Animation_* anim: animations) {
			//
			if(anim->channel == channel && anim->address == address) {
				if(anim->isType<Type>()) {
					return static_cast<Animation<Type>* >(anim);
				}
			}
		}
		Animation<Type>* newAnim = new Animation<Type>(address, channel);
		add(newAnim);
		return newAnim;
	}

	void play();
	void playBackwards();
	void pause();
	void step();
	void stop();
	void replay();
	//void pause();

	void setDuration(double duration);
	void setLoop(bool loopState);
	void setEndless(bool endlessState);
	void clear();

	bool isPlaying();
	bool isPaused();

	bool isAnimating();
	bool hasAnimation(string key);
	bool hasAnimation(string key, int channel);
	bool hasAnimations();

	template<typename Type>
	void animateTo(Type from, Type to, float duration, string address, int channel=0, InterpolationType interpolation=LINEAR) {
		if(!bIsEndless) {
			ofLogWarning(OFX_BLENDER) << "animateTo: timeline is not endless, this might result in abrupt repeats or stops";
		}

		//cout << "Animate from " << getTime() << " to " << (getTime() + duration * 1000) << endl;

		Animation<Type>* anim = getAnimation<Type>(address, channel);
		anim->clear();
		anim->addKeyframe(getTime(), from);
		anim->addKeyframe(getTime() + duration * 1000, to);
	}

	std::vector<Marker*> getMarkers();
	Marker* getNextMarker();
	Marker* getPrevMarker();
	Marker* getMarkerBefore(Marker* marker);

	void jumpToMarker(Marker* marker);
	void jumpToMarker(std::string markerName);
	void jumpToNextMarker();
	void jumpToPrevMarker();

	void jumpToTime(unsigned long long time);
	unsigned long long getTime();
	unsigned long long getDuration();


	ofEvent<Timeline*> started;
	ofEvent<Timeline*> ended;
	ofEvent<Timeline*> preFrame;
	ofEvent<Timeline*> postFrame;
	ofEvent<std::string> markerTriggered;

private:
	Animation_::DefaultHandlerContainer defaultHandler;
	void setTime(unsigned long long time);
	std::vector<Animation_*> animations;
	std::vector<Timeline*> children;
	std::vector<Marker*> markers;
	void triggerMarker(Marker* marker);
	Marker* lastMarker;
	//TODO: fix marker queue
	std::vector<Marker*> markerQueue;
	unsigned long long time;
	unsigned long long timeOld;
	unsigned long long duration;
	unsigned long long timeOffset;
	bool isLoop;
	bool bIsPlaying;
	bool bIsEndless;
	bool bIsPaused;
	bool bPlayBackwards;
};

}
}

#endif // ANIMATION_H

#line 0 "../addons-all/ofxBlender/src/Constraint.h"
#ifndef CONSTRAINT_H
#define CONSTRAINT_H

/* #include "ofMain.h" */

namespace ofx {

namespace blender {

class Object;
struct ObjectEventArgs;

class Constraint {
public:
	Constraint();
	~Constraint();

	void setup(Object* obj);

	virtual void onSetup() {};
	virtual void onUpdate() {};
	virtual void onOrientationChanged() {};
	virtual void onPositionChanged() {
		cout << "BLAH" << endl;
	};
	virtual void onScaleChanged() {};

	Object* object;
	string name;
};

class TrackToConstraint: public Constraint {
public:
	TrackToConstraint(Object* target, ofVec3f up = ofVec3f(0, 1, 0));

	void onPositionChanged();
	void onTargetPositionChanged(ofx::blender::ObjectEventArgs& obj);

	void updateLookAt();

	Object* target;
	ofVec3f up;
};

//some people might like this name more
typedef TrackToConstraint LookAtConstraint;

}

}

#endif // CONSTRAINT_H

#line 0 "../addons-all/ofxBlender/src/Object.h"
#ifndef BLENDER_OBJECT_H
#define BLENDER_OBJECT_H

/* #include "Utils.h" */
/* #include "ofMain.h" */
/* #include "Animation.h" */
/* #include "Constraint.h" */

namespace ofx {
namespace blender {

enum ObjectType {
    EMPTY,
    MESH,
    LIGHT,
    CAMERA,
    TEXT
};

class Scene;
class Layer;

struct VecDouble {
	double x;
	double y;
	double z;
};

struct ObjectEventArgs {
	Object* obj;
};

class Object: public ofNode {
public:

	Object();
	~Object();

	void update();
	void draw(Scene* scene=NULL, bool drawChildren=true);

	virtual void preDraw() {};
	virtual void customDraw();
	virtual void postDraw() {};

	void addChild(Object* child, bool keepGlobalTransform=false);
	void removeChild(Object* child);
	bool hasChild(Object* obj);

	std::vector<Object*> getChildren();
	Object* getParent();
	bool hasParent();
	bool isVisible();
	void setVisible(bool state);
	void show();
	void hide();
	void toggleVisibility();

	void addConstraint(Constraint* constraint);

	void interpolateTo(Object* obj,  float t);
	void animateTo(Object* obj, float time, InterpolationType interpolation=LINEAR);
	void animatePositionTo(glm::vec3 pos, float time, InterpolationType interpolation=LINEAR);
	void animateRotationTo(glm::vec3 rot, float time, InterpolationType interpolation=LINEAR);
	void animateRotationTo(glm::quat rot, float time, InterpolationType interpolation=LINEAR);
	void animateScaleTo(glm::vec3 scale, float time, InterpolationType interpolation=LINEAR);

	ofVec2f getPositionOnScreen(ofRectangle viewport = ofGetCurrentViewport());

	string name;
	ObjectType type;
	Timeline timeline;
	Scene* scene;
	Layer* layer;

	ofEvent<ObjectEventArgs> positionChanged;
	ofEvent<ObjectEventArgs> orientationChanged;
	ofEvent<ObjectEventArgs> scaleChanged;
	ofEvent<ObjectEventArgs> onHide;
	ofEvent<ObjectEventArgs> onShow;

protected:
	virtual void onAnimationDataFloat(float value, string address, int channel);
	virtual void onAnimationDataBool(bool value, string address, int channel);
	virtual void onAnimationDataVec3f(ofVec3f vec, string address, int channel);
	virtual void onAnimationDataQuat(ofQuaternion quat, string address, int channel);

	void onOrientationChanged();
	void onPositionChanged();
	void onScaleChanged();

	void onTimelinePreFrame(Timeline*&);
	void onTimelinePostFrame(Timeline*&);

private:
	ofVec3f originalRotation;
	Object* lookAtTarget;
	ofVec3f lookAtUp;
	bool visible;
	Object* parent;
	std::vector<Object*> children;
	std::vector<Constraint*> constraints;

	//helpers for euler rotation
	bool animIsEuler;
	bool isEulerRotSet;
	/*
	struct DoubleVec{
		double x;
		double y;
		double z;
	};
	*/
	ofVec3f eulerRot;
};

}
}

#endif // OBJECT_H

#line 0 "../addons-all/ofxBlender/src/Billboard.h"
#ifndef BILLBOARD_H
#define BILLBOARD_H

/* #include "Object.h" */

namespace ofx {

namespace blender {

class Billboard: public Object {
public:
	Billboard();
	~Billboard();

	virtual void preDraw();

	void setUpVector(float x, float y, float z);
	void setUpVector(ofVec3f upVec);

private:
	bool bCustomUp;
	ofVec3f customUp;
};

}

}

#endif // BILLBOARD_H

#line 0 "../addons-all/ofxBlender/src/Camera.h"
#ifndef CAMERA_H
#define CAMERA_H

/* #include "Object.h" */

namespace ofx {
namespace blender {

class Camera: public ofx::blender::Object {
public:
	Camera();
	~Camera();
	
	void customDraw();
	void onPositionChanged();
	void onOrientationChanged();
	void setLens(float lens);
	float getLens();
	void updateLens();
	void updateCamPos();
	void animateLensTo(float targetLens, float duration, InterpolationType interpolation=LINEAR);
	void interpolateLensTo(Camera* cam, float t);
	void interpolateTo(Camera* cam, float t);
	ofCamera camera;
private:
	void preDraw();
	void onAnimationDataFloat(float value, string address, int channel);
	
	ofMesh debugMesh;
	float lens;
};

}
}

#endif // CAMERA_H

#line 0 "../addons-all/ofxBlender/src/File.h"
#ifndef FILE_H
#define FILE_H


/* #include "Utils.h" */
/* #include "Scene.h" */
/* #include "Object.h" */
/* #include "zstr.h" */
#include <functional>

namespace ofx
{
namespace blender
{

//all the names of the blender object types
#define BL_SCENE "Scene"
#define BL_OBJECT "Object"
#define BL_MESH "Mesh"
#define BL_CAMERA "Camera"
#define BL_MATERIAL "Material"
#define BL_TEXTURE "MTex"

/////////////////////////////////////////////////////////////////////////////////////////////////////// DNA
class DNAName
{
public:
	DNAName(string n) {
		name=n;

		//strip the name
		nameClean = name;
		ofStringReplace(nameClean, "*", "");
		nameClean = ofSplitString(nameClean, "[")[0];
	}

	std::string name;
	std::string nameClean;
};

class DNAType
{
public:
	DNAType(string n, unsigned int i) {
		id = i;
		name = n;
	};
	string name;
	unsigned short size;
	unsigned int id;
};

class DNAField
{
public:
	DNAField(DNAType* t, DNAName* n, unsigned int off) {
		name=n;
		type=t;
		offset=off;

		isPointer = false;
		isArray = false;
		arrayDimensions = 0;

		//now analyze the name
		unsigned int len = name->name.size();
		if(name->name[0] == '*')
			isPointer = true;
		if(len > 2 && name->name[1] == '*') {
			isArray = true;
			arrayDimensions = 1;
		}

		unsigned int numSquareBracks = ofStringTimesInString(name->name, "[");
		if(numSquareBracks != 0) {
			isArray = true;
			if(numSquareBracks == 1) {
				arrayDimensions = 1;
			} else if(numSquareBracks == 2) {
				arrayDimensions = 2;
			}

			//now extract array sizes from brackets
			if(arrayDimensions > 0) {
				std::vector<std::string> parts = ofSplitString(name->name, "[");
				arraySizes.push_back(ofToInt(ofSplitString(parts[1], "]")[0]));
				if(arrayDimensions > 1)
					arraySizes.push_back(ofToInt(ofSplitString(parts[2], "]")[0]));
			}
		}

		//check if arraySizes is filled up properly
		if(isArray && arrayDimensions != arraySizes.size()) {
			for(unsigned int i=arraySizes.size(); i<arrayDimensions; i++) {
				arraySizes.push_back(0);
			}
		}
	};

	DNAName* name;
	DNAType* type;
	unsigned int offset;

	bool isPointer;
	bool isArray;
	unsigned int arrayDimensions;
	std::vector<unsigned int> arraySizes;
};

class DNAStructure
{
public:
	DNAStructure(DNAType* t) {
		type = t;
	}

	bool hasField(string fieldName) {
		for(DNAField& field: fields) {
			if(field.name->nameClean == fieldName)
				return true;
		}
		return false;
	}

	DNAField& getField(string fieldName) {
		for(DNAField& field: fields) {
			if(field.name->nameClean == fieldName)
				return field;
		}
		return fields[0];
	}

	DNAType* type;
	std::vector<DNAField> fields;
};

class DNACatalog
{
public:
	vector<DNAName> names;
	vector<DNAType> types;
	vector<DNAStructure> structures;

	bool hasStructure(std::string name) {
		for(vector<DNAStructure>::iterator it = structures.begin(); it<structures.end(); it++) {
			if((*it).type->name == name)
				return true;
		}
		return false;
	}

	DNAStructure* getStructure(std::string name) {
		for(vector<DNAStructure>::iterator it = structures.begin(); it<structures.end(); it++) {
			if((*it).type->name == name)
				return &(*it);
		}
		ofLogWarning(OFX_BLENDER) << "Structure " << name << " not found in DNA Catalog";
		return NULL;
	}
};

////////////////////////////////////////////////////////////////////////////////////////// FILE
class DNAStructureReader;

class File
{
public:

	File();
	~File();

	bool load(string path);
	void exportStructure(string path="structure.html");
	unsigned int getNumberOfScenes();
	Scene* getScene(unsigned int index);
	Scene* getScene(string sceneName);
	unsigned int getNumberOfObjects();
	Object* getObject(unsigned int index);
	
	bool skipTextures;
	
private:
	class Block
	{
	public:
		Block(File* f) {
			file = f;
		}
		File* file;
		string code;
		unsigned int size;
		unsigned long address;
		unsigned int SDNAIndex;
		unsigned int count;
		streampos offset;
		DNAStructure* structure;
	};

	//templated read function
	template<typename Type>
	Type read() {
		Type ret;
		file().read((char*)&ret, sizeof(Type));
		return ret;
	}

	template<typename Type>
	Type* readMany(unsigned int howMany) {
		Type* ret = new Type[howMany];
		for(unsigned int i=0; i<howMany; i++) {
			ret[i] = read<Type>();
		}
		return ret;
	}

	char* readChar(streamsize length);
	std::string readString(streamsize length=0);
	void readHeader(File::Block& block);
	void seek(streamoff to);
	void* parseFileBlock(Block* block);
	void* parseFileBlock(unsigned long adress);

	unsigned int getNumberOfTypes(string typeName);
	std::vector<Block*> getBlocksByType(string typeName);
	Block* getBlocksByType(string typeName, unsigned int pos);
	Block* getBlockByAddress(unsigned long address);
	Object* getObjectByAddress(unsigned long address);
	bool doesAddressExist(unsigned long address);

	//function that retreives the pointer type
	std::function<unsigned long()> readPointer;
	unsigned int pointerSize;
	string version;
	std::vector<Block> blocks;
	std::map<unsigned long, void*> parsedBlocks;
	DNACatalog catalog;
	zstr::ifstream *zfile;
	std::istream &file() { return *zfile; };
	float scale;
		
	//packed files
	//std::map<string, ofPixels> packedImages;

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////// ALL ABOUT PARSING //////////////////////////////////////////////////////

	friend class DNAStructureReader;
	friend class DNALinkedListReader;
	friend class Parser;

};

}
}

#endif // FILE_H

#line 0 "../addons-all/ofxBlender/src/Layer.h"
#ifndef LAYER_H
#define LAYER_H

/* #include "Object.h" */

namespace ofx {
namespace blender {

class Layer {
public:
	Layer();
	~Layer();
	
	void add(Object* obj);
	bool isVisible();
	void show();
	void hide();
	void toggleVisibility();
private:
	bool visible;
	std::vector<Object*> objects;
};

}
}

#endif // LAYER_H

#line 0 "../addons-all/ofxBlender/src/Light.h"
#ifndef LIGHT_H
#define LIGHT_H

/* #include "Object.h" */

namespace ofx
{

namespace blender
{

class Light: public ofx::blender::Object
{
public:
	Light();
	~Light();
	void begin();
	void end();
	void customDraw();
	ofLight light;
	//float constantAtt;
	//float linearAtt;
	//float quadraticAtt;
};

}

}

#endif // LIGHT_H

#line 0 "../addons-all/ofxBlender/src/Material.h"
#ifndef MATERIAL_H
#define MATERIAL_H

/* #include "Utils.h" */
/* #include "Light.h" */

namespace ofx {
namespace blender {

class Texture {
public:
	Texture():isEnabled(true) {}
	Texture(string imgPath):isEnabled(true) {img.loadImage(imgPath);}
	string name;
	ofImage img;
	string uvLayerName;
	bool isEnabled;
};

class Scene;
class Mesh;
class Material {
public:
	Material();
	Material(string imagePath);
	~Material();

	void begin();
	void end();
	
	bool hasTransparency();
	
	void addShader(ofShader* shader);
	
	ofMaterial material;
	std::vector<Texture*> textures;
	string name;
	bool useShader;
	
	std::vector<ofShader*> shaders;
	
private:
	friend class Scene;
	friend class Mesh;
		
	std::vector<Light*> lights;
	bool isLightningEnabled;
	bool isTwoSided;
};

}
}

#endif // MATERIAL_H

#line 0 "../addons-all/ofxBlender/src/Mesh.h"
#ifndef MESH_H
#define MESH_H

/* #include "Object.h" */
/* #include "Material.h" */

namespace ofx {
namespace blender {

enum Shading {
    FLAT,
    SMOOTH
};

class Scene;

class Mesh: public ofx::blender::Object {
public:
	class TriangleUVs {
	public:
		TriangleUVs(ofVec2f a_, ofVec2f b_, ofVec2f c_) {
			a = a_;
			b = b_;
			c = c_;
		}

		ofVec2f a;
		ofVec2f b;
		ofVec2f c;
	};

	class Triangle {
	public:
		Triangle(unsigned int a_, unsigned int b_, unsigned int c_) {
			a = a_;
			b = b_;
			c = c_;
		}

		Triangle(unsigned int a_, unsigned int b_, unsigned int c_, ofVec2f uv1, ofVec2f uv2, ofVec2f uv3) {
			Triangle(a_, b_, c_);
			addUVs(uv1, uv2, uv3);
		}

		void addUVs(ofVec2f a, ofVec2f b, ofVec2f c) {
			uvs.push_back(TriangleUVs(a, b, c));
		}

		unsigned int a;
		unsigned int b;
		unsigned int c;
		Material* material;
		Shading shading;
		std::vector<TriangleUVs> uvs;
	};

	class Part {
	public:
		Part(Material* mat, Shading shade, bool hasUvs_) {
			material = mat;
			shading = shade;
			hasTriangles = false;
			hasUvs = hasUvs_;
			primitive.setUseVbo(true);
		}

		void draw();

		of3dPrimitive primitive;
		Material* material;
		Shading shading;
		std::vector<Triangle> polys;
		bool hasTriangles;
		bool hasUvs;
	};

	///////////////////////////////////////////////////////////////
	Mesh();
	~Mesh();

	void pushMaterial(Material* material);
	void pushShading(Shading shading);

	void addVertex(ofVec3f pos, ofVec3f norm=ofVec3f());
	void addTriangle(Triangle triangle);
	void addMesh(ofMesh& mesh);

	ofVec3f& getVertex(unsigned int index);
	ofVec3f& getNormal(unsigned int index);
	Triangle& getTriangle(unsigned int index);

	void exportUVs(int w=1024, int h=1024, unsigned int layer=0, string path="");

	std::vector<Part>& getParts();

	void clear();

	void build();

	void customDraw();
	void drawNormals(float length=1);

	string meshName;

	bool isTwoSided;
	bool isTransparent;

	ofVec3f boundsMin;
	ofVec3f boundsMax;

private:
	friend class Scene;

	Part& getPart(Material* mat, Shading shading, bool hasUvs);
		
	Material* curMaterial;
	Shading curShading;
	std::vector<ofVec3f> vertices;
	std::vector<ofVec3f> normals;
	std::vector<Triangle> triangles;
	std::vector<Part> parts;
	std::vector<Material*> materials;
};

}
}

#endif // MESH_H

#line 0 "../addons-all/ofxBlender/src/Scene.h"
#ifndef BLENDER_SCENE_H
#define BLENDER_SCENE_H

/* #include "Object.h" */
/* #include "Animation.h" */
/* #include "Mesh.h" */
/* #include "Camera.h" */
/* #include "Light.h" */
/* #include "Layer.h" */

namespace ofx {
namespace blender {

class Scene: public ofNode{
public:
    Scene();
    ~Scene();

	void setDebug(bool state);
	void toggleDebug();
	bool isDebugEnabled();

    void customDraw();
    void update();
    void addObject(Object* obj);
	bool hasObject(Object* obj);
	Object* getObject(unsigned int index);
	Object* getObject(string name);
	Mesh* getMesh(unsigned int index);
	Mesh* getMesh(string name);
	std::vector<Mesh*> getMeshes();
	Camera* getCamera(string name);
	Camera* getCamera(unsigned int index);
	Light* getLight(string name);
	Light* getLight(unsigned int index);
	void setLightningEnabled(bool state);
	
	//will try to draw non alpha objects before alpha
	void enableAlphaOrdering();
	
	Camera* getActiveCamera();
	ofCamera* getDebugCamera();
	void setActiveCamera(Camera* cam);
	void disableCamera();
	
	void setViewport(float x, float y, float w, float h);
	ofRectangle& getViewport();
	bool hasViewport();
	
	ofFloatColor bgColor;

    Timeline timeline;
	string name;
	std::map<int, Layer> layers;
	ofEasyCam debugCam;
	
private:
	void onWindowResize(ofResizeEventArgs& args);
	
	Camera* activeCamera;
    std::vector<Object*> objects;
    std::vector<Mesh*> meshes;
	std::vector<Camera*> cameras;
	std::vector<Light*> lights;
	std::vector<Material*> materials;
	bool bHasViewport;
	ofRectangle viewport;
	bool doDebug;
	bool doLightning;
	bool isFirstDebugEnable;
};

}
}

#endif // OBJECT_H

#line 0 "../addons-all/ofxBlender/src/Parser.h"
#ifndef FILEPARSERS_H
#define FILEPARSERS_H

//all of the code is in the header file. this file should only be included once and that is by the file.cpp

/* #include "Scene.h" */
/* #include "Object.h" */
/* #include "File.h" */
/* #include "Mesh.h" */
/* #include "Material.h" */

enum BLENDER_TYPES {
    BL_EMPTY_ID = 0,
    BL_MESH_ID = 1,
    BL_TEXT_ID = 4,
    BL_LIGHT_ID = 10,
    BL_CAM_ID = 11
};

/* texflag */
#define MTEX_RGBTOINT       1
#define MTEX_STENCIL        2
#define MTEX_NEGATIVE       4
#define MTEX_ALPHAMIX       8
#define MTEX_VIEWSPACE      16
#define MTEX_DUPLI_MAPTO    32
#define MTEX_OB_DUPLI_ORIG  64
#define MTEX_COMPAT_BUMP    128
#define MTEX_3TAP_BUMP      256
#define MTEX_5TAP_BUMP      512
#define MTEX_BUMP_OBJECTSPACE   1024
#define MTEX_BUMP_TEXTURESPACE  2048
/* #define MTEX_BUMP_FLIPPED    4096 */ /* UNUSED */
#define MTEX_BICUBIC_BUMP       8192

namespace ofx {

namespace blender {

//helper class to read structures
class DNAStructureReader {
public:

	DNAStructureReader(File::Block* b) {
		file = b->file;
		block = b;
		reset();
	};

	string getType() {
		return structure->type->name;
	}

	void reset() {
		curBlock = 0;
		nextBlock();
	}

	unsigned int count() {
		return block->count;
	}

	//multiple structures can be integrated into one block, move ahead in the file
	void nextBlock() {
		setStructure(block->structure, block->offset + streampos(structure->type->size * curBlock));
		curBlock++;
	}

	//jump to a specific block
	void blockAt(unsigned int pos) {
		if(pos>count()) {
			ofLogWarning(OFX_BLENDER) << "DNAStructureReader::blockAt " << pos << " not that many blocks in " << block->structure->type->name << endl;
		}
		curBlock = pos;
		nextBlock();
	}

	DNAStructureReader& setStructureType(string structureName) {
		if(!file->catalog.hasStructure(structureName)) {
			ofLogWarning(OFX_BLENDER) << "Structure \"" << structureName << "\" not found in file";
			return *this;
		}
		setStructure(file->catalog.getStructure(structureName), block->offset + streampos(structure->type->size * curBlock));
		return *this;
	}

	DNAStructureReader& setStructure(DNAStructure* s, streamoff offset) {
		structure = s;
		currentOffset = offset;
		return *this;
	}

	//set another structure according to the provided field name
	DNAStructureReader& setStructure(string structureName) {
		if(!structure->hasField(structureName)) {
			ofLogWarning(OFX_BLENDER) << "Property \"" << structureName << "\" not found in " << structure->type->name;
			return *this;
		}
		DNAField& field = structure->getField(structureName);
		DNAStructure* s = file->catalog.getStructure(field.type->name);
		if(!s)
			return *this;
		setStructure(s, currentOffset + std::streampos(field.offset));
		return *this;
	}

	DNAField* setField(string fieldName) {
		if(!structure->hasField(fieldName)) {
			ofLogWarning(OFX_BLENDER) << "Property \"" << fieldName << "\" not found in " << structure->type->name;
			return NULL;
		}
		DNAField& field = structure->getField(fieldName);
		file->seek(currentOffset + std::streampos(field.offset));
		return &field;
	}

	template<typename Type>
	std::vector<Type> readVector(string fieldName) {
		std::vector<Type> ret;
		DNAField* field = setField(fieldName);
		if(!field) {
			return ret;
		}
		if(!field->isArray) {
			ofLogWarning(OFX_BLENDER) << "Property \"" << fieldName << "\" is not an array type";
			return ret;
		}

		if(field->arrayDimensions > 1) {
			ofLogWarning(OFX_BLENDER) << "Property \"" << fieldName << "\" has more than one array dimension, use readMultArray";
		}

		if(field->arraySizes[0] != 0) {
			for(unsigned int i=0; i < field->arraySizes[0]; i++) {
				ret.push_back(file->read<Type>());
			}
		}

		return ret;
	}

	std::vector<unsigned long> readAddressArray(string fieldName) {
		std::vector<unsigned long> ret;
		DNAField* field = setField(fieldName);
		if(!field) {
			return ret;
		}

		//cout << field->arraySizes[0] << endl;

		if(!field->isArray) {
			ofLogWarning(OFX_BLENDER) << "Property \"" << fieldName << "\" is not an array type";
			return ret;
		}

		if(field->arraySizes[0] > 0) {
			for(unsigned int i=0; i < field->arraySizes[0]; i++) {
				unsigned long ptr = file->readPointer();
				if(ptr != 0)
					ret.push_back(ptr);
			}
		} else {
			while(true) {
				unsigned long addr = file->readPointer();
				if(addr == 0)
					break;
				else
					ret.push_back(addr);
			}
		}
		return ret;
	}

	std::vector<DNAStructureReader> readStructureArray(string fieldName) {
		std::vector<unsigned long> addresses = readAddressArray(fieldName);
		std::vector<DNAStructureReader> ret;
		for(unsigned long& address: addresses) {
			File::Block* block = file->getBlockByAddress(address);
			if(block != NULL) {
				ret.push_back(DNAStructureReader(block));
			}
		}
		return ret;
	};

	template<typename Type>
	std::vector<std::vector<Type> > readMultArray(string fieldName) {
		std::vector<std::vector<Type> > ret;
		DNAField* field = setField(fieldName);
		if(!field) {
			return ret;
		}
		if(!field->isArray) {
			ofLogWarning(OFX_BLENDER) << "Property \"" << fieldName << "\" is not an array type";
			return ret;
		}

		if(field->arrayDimensions <= 1)
			ofLogWarning(OFX_BLENDER) << "Property \"" << fieldName << "\" has only one array dimension, use readArray";

		for(unsigned int i=0; i < field->arraySizes[0]; i++) {
			std::vector<Type> temp;
			for(unsigned int j=0; j<field->arraySizes[1]; j++) {
				temp.push_back(file->read<Type>());
			}
			ret.push_back(temp);
		}


		return ret;
	}

	template<typename Type>
	Type read(string fieldName) {

		//check for specials functions
		if(std::is_same<Type, std::string>::value) {
			ofLogWarning(OFX_BLENDER) << "DNAStructureReader::read string types should be read with readString";
			//return Type();
		}

		bool isPointer = std::is_pointer<Type>::value;

		DNAField* field = setField(fieldName);
		if(!field) {
			return Type();
		}

		if(field->isArray) {
			ofLogWarning(OFX_BLENDER) << "DNAStructureReader::read field is an array and should be read with readArray";
			//return Type();
		}

		//read the file contents
		return file->read<Type>();
	}

	string readString(string fieldName) {
		DNAField* field = setField(fieldName);
		if(!field) {
			return "undefined";
		}

		//sometimes strings are stored as pointers to a string structure, make a shortcut for convenience
		if(field->isPointer && field->type->name == "char") {
			//pointers to char are actually pointers to Link objects
			DNAStructureReader link = readStructure(fieldName);
			return link.readString("next");
		}

		if(field->isArray || field->isPointer) {
			string ret = file->readString();
			//strings are usually object names or paths, objects names have the object type prepending, check and remove
			if(ret.size() >= block->code.size() && block->code == ret.substr(0, block->code.size())) {
				ret = ret.substr(block->code.size());
			}
			return ret;
		}
		ofLogWarning(OFX_BLENDER) << "Could not read string, not a char* " << fieldName;
		return "undefined";
	}

//get a vec2
	template<typename Type>
	ofVec2f readVec2(string fieldName) {
		ofVec2f ret;
		std::vector<Type> vals = readVector<Type>(fieldName);
		if(vals.size() >= 2) {
			ret.set(vals[0], vals[1]);
		}
		return ret;
	}
	ofVec2f readVec2f(string fieldName) {
		return readVec2<float>(fieldName);
	}

//get a vec3
	template<typename Type>
	ofVec3f readVec3(string fieldName) {
		ofVec3f ret;
		std::vector<Type> vals = readVector<Type>(fieldName);
		if(vals.size() >= 3) {
			ret.set(vals[0], vals[1], vals[2]);
		}
		return ret;
	}
	ofVec3f readVec3f(string fieldName) {
		return readVec3<float>(fieldName);
	}

	template<typename Type>
	std::vector<ofVec3f> readVec3Array(string fieldName, unsigned int len=0) {
		std::vector<ofVec3f> ret;
		DNAField* field = setField(fieldName);
		if(!field) {
			return ret;
		}

		if(len == 0) {
			if(field->arrayDimensions > 1)
				len = field->arraySizes[0];
		}

		for(unsigned int i=0; i<len; i++) {
			Type x = file->read<Type>();
			Type y = file->read<Type>();
			Type z = file->read<Type>();
			ret.push_back(ofVec3f(x, y, z));
		}

		return ret;
	}
	std::vector<ofVec3f> readVec3fArray(string fieldName, unsigned int len=0) {
		return readVec3Array<float>(fieldName, len);
	}

	//get an array
	template<typename Type>
	Type* readArray(string fieldName, unsigned int amount) {
		DNAField* field = setField(fieldName);
		if(!field) {
			return new Type[0];
		}
		return file->readMany<Type>(amount);
	}

//get a pointer address
	unsigned long readAddress(string fieldName) {
		DNAField* field = setField(fieldName);
		if(!field) {
			return 0;
		}
		return file->readPointer();
	}

	char* readChar(string fieldName, unsigned int length) {
		setField(fieldName);
		return file->readChar(length);
	}

//a linked list is basically an array of different structures
	std::vector<DNAStructureReader> readLinkedList(string fieldName) {
		std::vector<DNAStructureReader> ret;
		unsigned long address = readAddress(fieldName);
		if(address == 0)
			return ret;

		/*DNAStructureReader linkReader(block->file->getBlockByAddress(address));
		unsigned long first = linkReader.readAddress("first");
		if(first == 0){
			return ret;
		}*/

		//Get the first structure
		ret.push_back(DNAStructureReader(block->file->getBlockByAddress(address)));
		while(ret.back().readAddress("next")) {
			//and the next one
			ret.push_back(DNAStructureReader(block->file->getBlockByAddress(ret.back().readAddress("next"))));
		}

		return ret;
	}

	std::vector<DNAStructureReader> readLinkAsList(string fieldName) {
		//TODO: I don't really get how these Links work, doublecheck

		std::vector<DNAStructureReader> ret;
		unsigned long address = readAddress(fieldName);
		if(address == 0)
			return ret;


		//go back to the first structure
		DNAStructureReader link = readStructure(fieldName);

		if(file->doesAddressExist(link.readAddress("next"))) {
			ret.push_back(link.readStructure("next"));
		}

		if(file->doesAddressExist(link.readAddress("prev"))) {
			DNAStructureReader first = link.readStructure("prev");
			while(first.hasPrev()) {
				first = first.getPrev();
			}

			ret.push_back(first);

			while(first.hasNext()) {
				first = first.getNext();
				ret.push_back(first);
			}
		}

		return ret;
	}

	//get a reader for sturcture at address
	DNAStructureReader readStructure(string fieldName) {
		unsigned long address = readAddress(fieldName);
		if(address == 0) {
			ofLogWarning(OFX_BLENDER) << "DNAStructureReader::readStructure could not read structure \"" << fieldName << "\" in \"" << getType() << "\" returning self";
			return *this;
		}
		File::Block* block = file->getBlockByAddress(address);
		if(block == NULL) {
			ofLogWarning(OFX_BLENDER) << "DNAStructureReader::readStructure could not read structure \"" << fieldName << "\" in \"" << getType() << "\" returning self";
			return *this;
		}
		return DNAStructureReader(block);
	}
	/*
	DNAStructureReader readStructure(string fieldName, string fieldType) {
		unsigned long address = readAddress(fieldName);
		if(address == 0) {
			ofLogWarning(OFX_BLENDER) << "DNAStructureReader::readStructure could not read structure \"" << fieldName << "\" in \"" << getType() << "\" returning self";
			return *this;
		}
		file->getBlockByAddress(address);

	}
	*/

	bool hasNext() {
		if(!structure->hasField("id"))
			return false;
		setStructure("id");
		unsigned long addr = readAddress("next");
		if(addr!=0 && !file->doesAddressExist(addr)) {
			addr = 0;
		}
		reset();
		return  addr != 0;
	}

	DNAStructureReader getNext() {
		setStructure("id");
		DNAStructureReader ret = readStructure("next");
		//if(ret.getType() == "ID")
		//	ret.reset();
		reset();
		return ret;
	}

	bool hasPrev() {
		if(!structure->hasField("id"))
			return false;
		setStructure("id");
		unsigned long addr = readAddress("prev");
		if(addr!=0 && !file->doesAddressExist(addr)) {
			addr = 0;
		}
		reset();
		return  addr != 0;
	}

	DNAStructureReader getPrev() {
		setStructure("id");
		DNAStructureReader ret = readStructure("prev");
		//if(ret.getType() == "ID")
		//	ret.reset();
		reset();
		return ret;
	}

	void* parse() {
		return file->parseFileBlock(block);
	}

	File* file;

private:
	DNAStructure* structure;
	File::Block* block;
	streamoff currentOffset;
	unsigned int curBlock;
};

//////////////////////////////////////////////////////////////////////////////////////// PARSER
class Parser {
public:

	//handler wrapers to automate the process of updating / creating new types
	class Handler_ {
	public:
		virtual void* call(DNAStructureReader&) = 0;
		virtual void* call(DNAStructureReader&, void*) = 0;
		virtual void* create() {
			return NULL;
		}
	};

	template<typename Type>
	class Handler: public Handler_ {
	public:
		typedef std::function<void(DNAStructureReader&, Type*)> funcType;
		Handler(funcType f) {
			function = f;
		}
		void* call(DNAStructureReader& reader) {
			return call(reader, new Type());
		}
		void* call(DNAStructureReader&  reader, void* obj) {
			Type* t = static_cast<Type*>(obj);
			function(reader, t);
			return obj;
		}

		void* create() {
			return new Type();
		}

		funcType function;
	};

	//ObjectHandlers are special because they have to check what kind of object it is first and then call the right parser
	class ObjectHandler: public Handler_ {
	public:
		typedef std::function<void(DNAStructureReader&, Object*)> ObjFunction;
		ObjectHandler(ObjFunction func) {
			objFunction = func;
		}

		void* call(DNAStructureReader& reader) {
			Handler_* handler = getHandlerFor(getTypeId(reader));
			//cout << getTypeId(reader) << endl;

			if(!handler)
				return NULL;
			return call(reader, handler->create());
		}

		void* call(DNAStructureReader&  reader, void* obj) {
			//check if we have a handler for the type
			Handler_* handler = getHandlerFor(getTypeId(reader));
			if(!handler)
				return NULL;
			Object* t = static_cast<Object*>(obj);
			//parse all object parameters first
			objFunction(reader, t);
			//and then load the right data block and call the object
			File::Block* dataBlock = reader.file->getBlockByAddress(reader.readAddress("data"));
			if(dataBlock) {
				DNAStructureReader dataReader(dataBlock);
				handler->call(dataReader, t);
			} else {
				ofLogWarning(OFX_BLENDER) << "ObjectHandler could not read datablock at pointer " << reader.readAddress("data");
			}
			return obj;
		}

		template<typename Type>
		void addHandler(int typeId, std::function<void(DNAStructureReader&, Type*)> func) {
			handlers[typeId] = new Handler<Type>(func);
		}

	private:

		int getTypeId(DNAStructureReader& reader) {
			return reader.read<short>("type");
		}

		Handler_* getHandlerFor(int type) {
			if(handlers.find(type) != handlers.end()) {
				return handlers[type];
			}
			return NULL;
		}
		std::map<int, Handler_*> handlers;
		ObjFunction objFunction;
	};


	//now handle all the parsing
	static void init() {
		if(isInit)
			return;

		Parser::handlers[BL_SCENE] = new Handler<Scene>(Parser::parseScene);
		Parser::handlers[BL_MATERIAL] = new Handler<Material>(Parser::parseMaterial);
		Parser::handlers[BL_TEXTURE] = new Handler<Texture>(Parser::parseTexture);

		//Types based on objects like Mesh, Camera, Light are special and need to be registered with the ObjectHandler
		ObjectHandler* objHandler = new ObjectHandler(Parser::parseObject);
		objHandler->addHandler<Mesh>(BL_MESH_ID, Parser::parseMesh);
		objHandler->addHandler<Camera>(BL_CAM_ID, Parser::parseCamera);
		objHandler->addHandler<Light>(BL_LIGHT_ID, Parser::parseLight);
		objHandler->addHandler<Object>(BL_EMPTY_ID, Parser::parseEmpty);
		Parser::handlers[BL_OBJECT] = objHandler;

		isInit = true;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void parseScene(DNAStructureReader& reader, Scene* scene) {
		reader.setStructure("id");
		scene->name = reader.readString("name");
		reader.reset();

		ofLogNotice(OFX_BLENDER) << "Loading Scene \"" << scene->name << "\"";

		//read render settings
		reader.setStructure("r");
		short fps = reader.read<short>("frs_sec");
		scene->timeline.setLoop(true);
		double duration = 1.f/(float)fps * (float)reader.read<int>("efra");
		scene->timeline.setDuration(duration);
		reader.reset();

		//Timeline infos
		//cout << "LENGTH " << reader.readStructure("fps_info").getType() << endl;

		//loop through all objects and add them to the scene
		DNAStructureReader next = reader.readStructure("base");
		do {
			//Parser::parseFileBlock(getBlockByType(BL_OBJECT, index))
			DNAStructureReader objReader = next.readStructure("object");
			Object* object = static_cast<Object*>(objReader.parse());
			if(object != NULL) {
				scene->addObject(object);

				//set the scene layer to the object
				int layer = objReader.read<int>("lay");
				if(layer >= 0) {
					object->layer = &scene->layers[layer];
				}

				//check if the object is a light
				if(object->type == LIGHT) {
					scene->setLightningEnabled(true);
				}
			}

			//cout << next.readStructure("object").setStructure("id").readString("name") << endl;
			if(next.readAddress("next") == 0) {
				break;
			}
			next = next.readStructure("next");
		} while(true);

		//set active camera
		if(reader.readAddress("camera") != 0) {
			scene->setActiveCamera(static_cast<Camera*>(reader.file->getObjectByAddress(reader.readAddress("camera"))));
		}

		//WORLD INFOS
		DNAStructureReader worldReader = reader.readStructure("world");
		scene->bgColor = ofFloatColor(worldReader.read<float>("horr"), worldReader.read<float>("horg"), worldReader.read<float>("horb"));
		//cout << "COLOR MODEL " << worldReader.read<short>("colormodel") << endl;
		//cout << reader.readStructure("base").readStructure("object").setStructure("id").readString("name") << endl;


		//MARKERS
		for(DNAStructureReader& markerReader: reader.readLinkedList("markers")) {
			scene->timeline.addMarker(1.f/(float)fps * (float)markerReader.read<int>("frame"), markerReader.readString("name"));
		}
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct TempKeyFrame {
		unsigned long long time;
		short ipo;
		std::vector<ofVec3f> points;
	};

	static std::vector<TempKeyFrame> parseKeyframes(DNAStructureReader curve) {
		std::vector<TempKeyFrame> ret;
		int numPoints = curve.read<int>("totvert");
		DNAStructureReader bezier = curve.readStructure("bezt");
		for(int i=0; i<numPoints; i++) {
			TempKeyFrame key;
			key.points = bezier.readVec3fArray("vec");

			key.ipo = bezier.read<short>("ipo");
			if(key.ipo > 4)
				key.ipo = bezier.read<char>("ipo");

			//TODO: read proper frame rate
			double fps = 24; //default blender frame rate

			double time = 1./fps * key.points[1][0];
			key.time = time * 1000;

			ret.push_back(key);
			bezier.nextBlock();
		}
		return ret;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void parseAnimationData(DNAStructureReader reader, Timeline* timeline) {
		unsigned long animDataAddress = reader.readAddress("adt");
		if(animDataAddress == 0)
			return;

		DNAStructureReader animReader(reader.file->getBlockByAddress(animDataAddress));
		if(animReader.readAddress("action") == 0)
			return;
		
		//load all curves
		vector<DNAStructureReader> curves = animReader.readStructure("action").readLinkedList("curves");
		for(DNAStructureReader& curve: curves) {
			string rnaPath = curve.readString("rna_path");
			int arrayIndex = curve.read<int>("array_index");
			string address = rnaPath;
			int channel = arrayIndex;

			//cout << address << endl;

			//if the channel is rotation, scale or translate, add an X
			std::vector<TempKeyFrame> keyframes = parseKeyframes(curve);
			
			//float type animations
			if(address == "location" || address == "rotation" || address == "scale" || address=="rotation_euler" || address=="lens") {

				//create the animation, arrayIndex
				Animation<float>* anim = new Animation<float>(address, arrayIndex);
				for(TempKeyFrame& key: keyframes) {
					if(key.ipo == 1)
						anim->addKeyframe(key.time, key.points[1][1]);
					else if(key.ipo == 2)
						anim->addKeyframe(key.time, key.points[1][1], key.points[1], key.points[0], key.points[2]);
					else if(key.ipo == 0)
						anim->addKeyframe(key.time, key.points[1][1], CONSTANT);
					else
						ofLogWarning(OFX_BLENDER) << "Parser:: addKeyframe (unknown ipo type: " << key.ipo << ")";
				}
				timeline->add(anim);

			} else if(address == "hide_render") {

				Animation<bool>* anim = new Animation<bool>(address, arrayIndex);

				for(TempKeyFrame& key: keyframes) {

					bool value = false;
					if(key.points[1][1] > 0)
						value = true;

					anim->addKeyframe(key.time, value, CONSTANT);
				}
				timeline->add(anim);
			} else {
				ofLogNotice(OFX_BLENDER) << "Unknown rna address path " << rnaPath;
			}
		}
	}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void parseObject(DNAStructureReader& reader, Object* object) {
		reader.setStructure("id");
		object->name = reader.readString("name");
		reader.reset();

		ofLogNotice(OFX_BLENDER) << "Loading Object \"" << object->name << "\"";

		//get transformation
#if 0
		vector<vector<float> > matArray = reader.readMultArray<float>("obmat");
		ofMatrix4x4 mat(matArray[0][0], matArray[0][1], matArray[0][2], matArray[0][3],
		                matArray[1][0], matArray[1][1], matArray[1][2], matArray[1][3],
		                matArray[2][0], matArray[2][1], matArray[2][2], matArray[2][3],
		                matArray[3][0], matArray[3][1], matArray[3][2], matArray[3][3]);

		object->setTransformMatrix(mat);
#else
        vector<float> loc = reader.readVector<float>("loc");
        vector<float> rot = reader.readVector<float>("rot"); // euler rot
        vector<float> quat = reader.readVector<float>("quat"); // quat rot
        vector<float> scale = reader.readVector<float>("scale");
#endif
		//flags
		//cout << reader.read<short>("flag") << endl;

		//check for parent
		unsigned long parentAddress = reader.readAddress("parent");
		if(parentAddress != 0) {
			DNAStructureReader parentReader = reader.readStructure("parent");
			Object* parent = static_cast<Object*>(parentReader.parse());
			if(parent != NULL) {
#if 0
				object->setTransformMatrix(mat * ofMatrix4x4::getInverseOf(parent->getGlobalTransformMatrix()));
#else
#endif
				parent->addChild(object, false);
			}
		}

		//check for constraints
		for(DNAStructureReader& constraintReader: reader.readLinkedList("constraints")) {
			string name = constraintReader.readString("name");

			DNAStructureReader data = constraintReader.readStructure("data");
			if(data.getType() == "bTrackToConstraint") {

				Object* target = static_cast<Object*>(data.readStructure("tar").parse());

				if(target) {
					ofLogNotice(OFX_BLENDER) << "Creating Track To Constraint " << object->name << " -> " << target->name;

					TrackToConstraint* constraint = new TrackToConstraint(target, ofVec3f(0, 0, 1));
					object->addConstraint(constraint);
				}
			}
		}

		/*
		for(DNAStructureReader& constraintReader: reader.readLinkedList("constraintChannels")) {
			//cout << constraintReader.getType() << endl;
		}
		*/

		//parse the anim data
		parseAnimationData(reader, &object->timeline);
	}

	static void parseEmpty(DNAStructureReader& reader, Object* empty) {
		//pass
	}

#define ME_SMOOTH 1

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void parseMesh(DNAStructureReader& reader, Mesh* mesh) {
		reader.setStructure("id");
		mesh->meshName = reader.readString("name");
		reader.reset();

		ofLogNotice(OFX_BLENDER) << "Loading Mesh \"" << mesh->name << "\"";

		/*
		enum DrawFlag {
		    DRAW_FLAT = 67,
		    DRAW_SMOOTH = 75
		};
		*/

		//two sided
		//TODO: check how flags actually work, this will only be right when flag is exactly 4
		//TODO: there is somewhere a flag defined in blender source code, called ME_SMOOTH, GEMAT_BACKCULL
		/*
		if(reader.read<short>("flag") == 4) {
			mesh->isTwoSided = true;
		} else {
			mesh->isTwoSided = false;
		}
		*/



		//get address of the polygon blocks
		DNAStructureReader polyReader = reader.readStructure("mpoly");

		//get address of the loops blocks
		DNAStructureReader loopReader = reader.readStructure("mloop");

		//get address of the vertices blocks
		DNAStructureReader vertReader = reader.readStructure("mvert");

		//get address of the edge blocks
		//DNAStructureReader edgeReader = reader.readStructure("medge");
		//get address of the material blocks
		//DNAStructureReader mtPolyReader = reader.readStructure("mtpoly");

		//read all vertices and add to the mesh
		mesh->clear();
		unsigned int totalVertices = reader.read<int>("totvert");
		for(unsigned int i=0; i<totalVertices; i++) {
			mesh->addVertex(vertReader.readVec3f("co"), vertReader.readVec3<short>("no").getNormalized());
			vertReader.nextBlock();
		}

		//read all Materials
		std::vector<Material*> materials;
		std::vector<DNAStructureReader> materialStructs = reader.readLinkAsList("mat");
		for(DNAStructureReader& matReader: materialStructs) {
			materials.push_back(static_cast<Material*>(matReader.parse()));
		}

		//try to read uv coordinates
		bool hasUV = false;
		std::vector<ofVec2f> defaultUvs;
		if(reader.readAddress("mloopuv") != 0) {
			DNAStructureReader uvReader = reader.readStructure("mloopuv");
			for(unsigned int j=0; j<uvReader.count(); j++) {
				defaultUvs.push_back(uvReader.readVec2f("uv"));
				defaultUvs.back().y = 1 - defaultUvs.back().y;
				uvReader.nextBlock();
			}
			hasUV = true;
		}

		std::map<string, std::vector<ofVec2f> > uvLayers;

		//read the layers
		if(reader.readAddress("ldata") != 0) {
			reader.setStructure("ldata");
			int numLayers = reader.read<int>("totlayer");
			DNAStructureReader layerReader = reader.readStructure("layers");
			for(int i=0; i<numLayers; i++) {
				DNAStructureReader layerData = layerReader.readStructure("data");

				//only interested in CD_MLOOPUV types (could also be CD_MPOLY)
				if(layerData.getType() == "MLoopUV") {
					string layerName = layerReader.readString("name");
					for(unsigned int j=0; j<layerData.count(); j++) {
						uvLayers[layerName].push_back(layerData.readVec2f("uv"));
						uvLayers[layerName].back().y = 1 - uvLayers[layerName].back().y;
						layerData.nextBlock();
					}
				}
				layerReader.nextBlock();
			}
			reader.reset();
		}

		//get the total number of polygons
		int totalPolys = reader.read<int>("totpoly");

		ofVec3f e0, e1;

		///
		bool vertCountTooBig = false;
		bool vertCountTooSmall = false;

		//build triangles
		for(int i=0; i<totalPolys; i++) {
			unsigned int vertCount = polyReader.read<int>("totloop");
			if (vertCount<3) {
				vertCountTooSmall = true;
				continue;
			}
			if (vertCount>4) {
				vertCountTooBig = true;
				continue;
			}

			//check the shading
			Shading shading = FLAT;
			//if(((int)polyReader.read<char>("flag")) == 3) {
			if(polyReader.read<char>("flag") & ME_SMOOTH) {
				shading = SMOOTH;
			}

			mesh->pushShading(shading);

			//pick the material
			unsigned int materialNumber = polyReader.read<short>("mat_nr");
			Material* material = NULL;
			if(materialNumber < materials.size()) {
				material = materials[materialNumber];
				mesh->pushMaterial(material);
			}

			//pick the uv layer
			std::vector<ofVec2f>* uvLayer = NULL;
			if(material) {
				if(material->textures.size() > 0) {
					if(material->textures[0]->uvLayerName != "")
						uvLayer = &uvLayers[material->textures[0]->uvLayerName];
				}
			}

			if(!uvLayer && hasUV)
				uvLayer = &defaultUvs;

			//write triangles
			int loopStart = polyReader.read<int>("loopstart");

			if(vertCount == 4) {
				loopReader.blockAt(loopStart);
				unsigned int index0 = loopReader.read<int>("v");
				loopReader.nextBlock();
				unsigned int index1 = loopReader.read<int>("v");
				loopReader.nextBlock();
				unsigned int index2 = loopReader.read<int>("v");
				loopReader.nextBlock();
				unsigned int index3 = loopReader.read<int>("v");
				//loopReader.nextBlock();

				e0 = mesh->getVertex(index0) - mesh->getVertex(index1);
				e1 = mesh->getVertex(index2) - mesh->getVertex(index3);

				if(e0.lengthSquared() < e1.lengthSquared()) {

					Mesh::Triangle tri1(index0, index1, index2);
					if(uvLayer && uvLayer->size() > loopStart+2) {
						tri1.addUVs(uvLayer->at(loopStart), uvLayer->at(loopStart+1), uvLayer->at(loopStart+2));
					}
					mesh->addTriangle(tri1);

					Mesh::Triangle tri2(index2, index3, index0);
					if(uvLayer && uvLayer->size() > loopStart+3) {
						tri2.addUVs(uvLayer->at(loopStart+2), uvLayer->at(loopStart+3), uvLayer->at(loopStart));
					}

					mesh->addTriangle(tri2);

				} else {
					//mesh->addTriangle(index1, index2, index4);
					//mesh->addTriangle(index4, index2, index3);

					Mesh::Triangle tri1(index0, index1, index3);
					if(uvLayer && uvLayer->size() > loopStart+3) {
						tri1.addUVs(uvLayer->at(loopStart), uvLayer->at(loopStart+1), uvLayer->at(loopStart+3));
					}
					mesh->addTriangle(tri1);

					Mesh::Triangle tri2(index3, index1, index2);
					if(uvLayer && uvLayer->size() > loopStart+3) {
						tri2.addUVs(uvLayer->at(loopStart+3), uvLayer->at(loopStart+1), uvLayer->at(loopStart+2));
					}

					mesh->addTriangle(tri2);
				}

			} else {
				loopReader.blockAt(loopStart);
				unsigned int index0 = loopReader.read<int>("v");
				loopReader.nextBlock();
				unsigned int index1 = loopReader.read<int>("v");
				loopReader.nextBlock();
				unsigned int index2 = loopReader.read<int>("v");

				//mesh->addTriangle(index1, index2, index3);
				Mesh::Triangle tri1(index0, index1, index2);
				if(uvLayer && uvLayer->size() > loopStart+2) {
					tri1.addUVs(uvLayer->at(loopStart), uvLayer->at(loopStart+1), uvLayer->at(loopStart+2));
				}
				mesh->addTriangle(tri1);
			}

			//done, let's advance to the next polygon
			polyReader.nextBlock();
		}

		//warnings
		if(vertCountTooBig)
			ofLogWarning(OFX_BLENDER) << "can't convert polygon with more than 4 vertices";
		if(vertCountTooSmall)
			ofLogWarning(OFX_BLENDER) << "can't convert polygon with only 2 or less vertices";

		//export uv layers
		//for(unsigned int i=0; i<mesh->getNumUVLayers(); i++) {
		//cout << "EXPORT" << endl;
		//mesh->exportUVLayer(i);
		//}
		mesh->build();
		//mesh->exportUVs();
	}

#define TF_INVISIBLE 1024
#define TF_TWOSIDE 512

	static void parseMaterial(DNAStructureReader& reader, Material* material) {
		reader.setStructure("id");
		material->name = reader.readString("name");
		reader.reset();

		/*
		MA_LIGHTINGENABLED  = (1 << 1),
		MA_WIREFRAME        = (1 << 2),
		*/

		ofLogNotice(OFX_BLENDER) << "Loading Material \"" << material->name << "\"";

		material->material.setShininess(reader.read<float>("spec"));


		//TODO: why are those colors flipped?
		material->material.setDiffuseColor(ofFloatColor(reader.read<float>("r"), reader.read<float>("g"), reader.read<float>("b")));
		material->material.setAmbientColor(ofFloatColor(reader.read<float>("r"), reader.read<float>("g"), reader.read<float>("b")));
		material->material.setSpecularColor(ofFloatColor(reader.read<float>("specr"), reader.read<float>("specg"), reader.read<float>("specb")));

		//load textures
		if(!reader.file->skipTextures) {
			std::vector<DNAStructureReader> textures = reader.readStructureArray("mtex");
			for(DNAStructureReader& texReader: textures) {
				Texture* texture = static_cast<Texture*>(texReader.parse());
				if(texture->isEnabled && texture->img.isAllocated())
					material->textures.push_back(texture);
			}
			if(material->textures.size() > 1) {
				ofLogNotice(OFX_BLENDER) << "Material \"" << material->name << "\" has more than 1 Texture, only the first one will be used";
			}
		}
	}

	static void parseTexture(DNAStructureReader& reader, Texture* texture) {
		DNAStructureReader texReader = reader.readStructure("tex");
		texReader.setStructure("id");
		texture->name = texReader.readString("name");
		texReader.reset();

		ofLogNotice(OFX_BLENDER) << "Loading Texture \"" << texture->name << "\"";

		//cout << "FLAG " << (reader.read<short>("texflag") & 2) << endl;

		texture->uvLayerName = reader.readString("uvname");
		//reader.readString("uvname") << endl;

		//there are many more types
		enum texTypes {
		    BLEND = 1,
		    WOOD = 2,
		    VOXEL = 15,
		    IMAGE = 8
		};

		if(texReader.read<short>("type") != IMAGE) {
			ofLogWarning(OFX_BLENDER) << "CAN ONLY READ TEXTURES OF TYPE IMAGE \"" << texture->name << "\"";
			return;
		}

		DNAStructureReader imgReader = texReader.readStructure("ima");

		//check if file is packed or has to be loaded
		if(imgReader.readAddress("packedfile")) {
			DNAStructureReader packedFile = imgReader.readStructure("packedfile");
			unsigned int size = packedFile.read<int>("size");
			DNAStructureReader dataBlock = packedFile.readStructure("data");

			char* pixels = dataBlock.readChar("next", size);
			ofBuffer buffer(pixels, size);
			texture->img.loadImage(buffer);
			//texture->img.saveImage(texture->name+".png");
		} else {
			string path = imgReader.readString("name");
			ofStringReplace(path, "//", "");
			texture->img.loadImage(path);
		}
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static void parseCamera(DNAStructureReader& reader, Camera* cam) {
		ofCamera* camera = &cam->camera;

		cam->setLens(reader.read<float>("lens"));

		camera->setNearClip(reader.read<float>("clipsta"));
		camera->setFarClip(reader.read<float>("clipend"));

		parseAnimationData(reader, &cam->timeline);

		//camera->setupPerspective(true, fov, 0, 1000000);
	}

	static void parseLight(DNAStructureReader& reader, Light* light) {
		//http://en.wikibooks.org/wiki/GLSL_Programming/Blender/Diffuse_Reflection
		enum LightType {
		    BL_POINT = 0,
		    BL_SUN = 1,
		    BL_SPOT = 2,
		    BL_HEMI = 3,
		    BL_AREA = 4
		};

		//TODO: the lights get kind of parsed, but there is lots to do, best would be to use blenders shaders

		unsigned int type = reader.read<short>("type");
		if(type == BL_POINT) {
			light->light.setPointLight();
			float energy = reader.read<float>("energy");
			if(energy == 0)
				energy = .00001;
			float distance = 1.f / reader.read<float>("dist");
			light->light.setAttenuation(1.f / energy, reader.read<float>("att1") * distance, reader.read<float>("att2") * distance);
		} else if(type == BL_SUN) {
			light->light.setDirectional();
			light->light.tilt(180);
		} else if(type == BL_SPOT) {
			light->light.setSpotlight(ofRadToDeg(reader.read<float>("spotsize"))*.5, (1-reader.read<float>("spotblend"))*128);
		} else if(type == BL_HEMI) {
		} else {
			ofLogWarning(OFX_BLENDER) << "Light \"" << light->name << "\" has an unsupported type";
		}

		light->light.setDiffuseColor(ofFloatColor(reader.read<float>("r"), reader.read<float>("g"), reader.read<float>("b")));
	}

	static void* parseFileBlock(File::Block* block) {
		return parseFileBlock(block, NULL);
	}

	static void* parseFileBlock(File::Block* block, void* obj) {
		if(handlers.find(block->structure->type->name) != handlers.end()) {
			DNAStructureReader reader = DNAStructureReader(block);
			if(obj == NULL)
				return handlers[block->structure->type->name]->call(reader);
			else
				return handlers[block->structure->type->name]->call(reader, obj);
		}
		ofLogWarning(OFX_BLENDER) << "No Parser for Object Type \"" << block->structure->type->name << "\" found";
		return NULL;
	}

private:
	typedef std::map<std::string, Handler_*> HandlerList;
	static HandlerList handlers;
	static bool isInit;
};

}

}

#endif // FILEPARSERS_H

#line 0 "../addons-all/ofxBlender/src/ofxBlender.h"
/* #include "File.h" */

#line 0 "../addons-all/ofxFatLines/src/sincosineLut.h"
#pragma once
/* #include "ofMain.h" */
#define DEFAULT_RES 16

class sinCosineLut{

public:
    static vector<float>sinLut;
    static vector<float>cosLut;
    static inline void changeResolution(int res){
        resolution = res;
    }
    static int getResolution(){return resolution;}
private:
    static int resolution;    

    static inline vector<float>initSin(){
        vector<float> temp;
        for (int i = 0; i<resolution; i++) {
            sinLut.push_back(sin((float(i)/resolution)*TWO_PI));
        }
        return temp;
    }

    static inline vector<float>initCos(){
        vector<float> temp;
        for (int i = 0; i<resolution; i++) {
            cosLut.push_back(cos((float(i)/resolution)*TWO_PI));
        }
        return temp;
    }
};
#line 0 "../addons-all/ofxFatLines/src/ofxFatLine.h"
#pragma once
/* #include "ofMain.h" */
/* #include "sincosineLut.h" */

//#include "vector_operations.h"
//#include "vertex_array_holder.h"
//--------------------------------------------------------------
inline bool lineSegmentsIntersect(const ofVec2f & l1a, const ofVec2f & l1b, const ofVec2f & l2a, const ofVec2f & l2b){
	if(l1a == l2a || l1a == l2b || l1b == l2a || l1b == l2b){
		return true;
	}

	float m1, m2;//slopes
	bool infM1 = false, infM2 = false;
	bool equalSlope = false;
	if (l1a.x == l1b.x) {
		infM1 =true;
	}
	if (l2a.x == l2b.x) { //the slope is equal to infinite, or a division by 0 is created. 
		infM2 =true;
	}
	if (infM1 && infM2) {
		equalSlope = true;
	}else{
		if(!infM1){//check so we dont divide by 0
			m1 = (l1b.y - l1a.y)/(l1b.x - l1a.x);//slope line 1
		}
		if (!infM2) {
			m2 = (l2b.y - l2a.y)/(l2b.x - l2a.x);//slope line 2		
		}
		
		if (!infM1 && !infM2) {
			if (m1 == m2) {
				equalSlope = true;
			}
		}
	}
	if(equalSlope){
		if(!infM1){
			if((MAX(l1a.x, l1b.x) > MIN(l2a.x,l2b.x)) ||  (MAX(l2a.x, l2b.x) > MIN(l1a.x,l1b.x))){
				
			}
		}else{
		}
	}else{
	
	}
	
}
//--------------------------------------------------------------
inline double sideOfLine(const ofVec2f& v, const ofVec2f& a, const ofVec2f& b){
    ofVec2f dir = (b-a).normalized().perpendiculared();
    return v.normalized().dot(dir);
}
//--------------------------------------------------------------
static inline bool sameSideOfLine( const ofVec2f& V, const ofVec2f& ref, const ofVec2f& a, const ofVec2f& b){
	double sign1 = sideOfLine(V*100, a, b);
    double sign2 = sideOfLine(ref*100, a, b);
    return !( (sign1>=0) ^ (sign2>=0));
    
}
//--------------------------------------------------------------
static inline ofVec3f getMidVector(ofVec3f &a, ofVec3f &b){
    return(a.normalized() + b.normalized()).normalized();
    /*
     ofVec3f perp = (a - pivot).cross(b - pivot);
     float  angle = (a - pivot).angle(b - pivot);
     return a.getRotated(angle/2,pivot, perp);//*/
}

enum ofxFatLineJointType{
    OFX_FATLINE_JOINT_MITER,
    OFX_FATLINE_JOINT_BEVEL,
    OFX_FATLINE_JOINT_ROUND
};
enum ofxFatLineCapType{
    OFX_FATLINE_CAP_BUTT,
    OFX_FATLINE_CAP_ROUND,
    OFX_FATLINE_CAP_SQUARE,
    OFX_FATLINE_CAP_RECT
};

class ofxFatLine : public ofPolyline{
public:
    ofxFatLine();
    ofxFatLine(const vector<glm::vec3> &P,const vector<ofFloatColor> &C, const vector<double> &W, bool triangulation = false );

    void add(const glm::vec3 &thePoint, const ofFloatColor &theColor, const double &theWeight);
    void add(const vector<glm::vec3> &thePoints, const vector<ofFloatColor> &theColors, const vector<double> &theWeights);
	
	void setFromPolyline(ofPolyline & poly);
    
    void enableFeathering(bool e = true){bFeather = e;}
    void toggleFeathering(){enableFeathering(!bFeather);}
    
    void setFeather(double f){feathering = f; update();}
    double getFeather(){return feathering;}
    
    void setJointType(ofxFatLineJointType j){joint = j;}
    ofxFatLineJointType getJointType(){return joint;}
    
    void setCapType(ofxFatLineCapType c ){cap = c;}
    ofxFatLineCapType getCapType(){return cap;}
    
    void enableTriangulation(bool e = true){bTriangulation = e; }
    void toggleTriangulation(){enableTriangulation(!bTriangulation);}

    void enableFeatherAtCore(bool e = true){bFeatherAtCore =e; }
    void toggleFeatherAtCore(){enableFeatherAtCore(!bFeatherAtCore);}

    void enableFeatherAtCap(bool e = true){bFeatherAtCap =e; }
    void toggleFeatherAtCap(){enableFeatherAtCap(!bFeatherAtCap);}    
    
	void setGlobalColor(ofColor col);
	void setGlobalColor(ofFloatColor col);
	
	void setGlobalWidth(float w);
	
    void draw();
    void update();
    void updatePoint(int index, ofVec3f p);
    void updateWeight(int index, float w);
    float getWeight(int index);
    void updateColor(int index, ofFloatColor& c);
    ofColor getColor(int index);
    ofMesh &getMesh(){return mesh;}
    void drawDebug();
    void printDebug();

protected:
    void addColor(const ofFloatColor &c);
    void addColors(const vector<ofFloatColor> &c);
    void addWeight(const double &w);
    void addWeights(const vector<double> &w);

    void pushQuadIndices(int index);
    void pushQuadIndices(int i1, int i2, int i3, int i4);
    void pushNewVertex(ofVec3f v, ofVec3f p, ofVec3f r1, ofVec3f r2, float maxLength, int index, float cos, bool bFlipped = false);    
    void pushNewAnchors(ofVec3f v, ofVec3f dir, ofFloatColor color, float l1, float l2, bool bInv);
    void pushNewAnchor(ofVec3f a, ofFloatColor c);
    void pushTriangleIndices(int i1, int i2, int i3);
    void updateCap(ofVec3f p1, ofVec3f p2, int index);
    void updateMesh();
    void updateMeshIndices();
    void updateJoint(int index, bool bFlip);
    void updateVertex(int index);

    ofMesh mesh, capJointMesh;
    
    vector<ofFloatColor> colors;
    vector<double> weights;
    vector<ofVec3f> midVectors;
    vector<ofVec3f> flippepMidVectors;
    vector<ofVec3f> crossedVectors;
    vector<glm::vec3> meshVertices;
    vector<ofIndexType>meshIndices;
    vector<ofFloatColor> meshColors;
    vector<ofVec3f>jointMeshVertices;
    vector<ofIndexType>jointMeshIndices;
    vector<ofFloatColor>jointMeshColors;
	
	ofFloatColor globalColor;
	float globalWidth;
	bool bUseGlobalColor;
	bool bUseGlobalWidth;
    bool bTriangulation;
	ofxFatLineJointType joint;
	ofxFatLineCapType cap;
	bool bFeather;
    double feathering;
	bool bFeatherAtCap;
	bool bFeatherAtCore;
    
    

};

#line 0 "../addons-all/ofxHistoryPlot/src/ofxHistoryPlot.h"
/*
 *  ofxHistoryPlot.h
 *  emptyExample
 *
 *  Created by Oriol Ferrer Mesi on 28/01/11.
 *  Copyright 2011 uri.cat. All rights reserved.
 *
 */

#ifndef OFX_HISTORY_PLOT_DEFINED
#define OFX_HISTORY_PLOT_DEFINED

/* #include "ofMain.h" */
#include <limits>

#define DEFAULT_WIDTH	160.0f
#define DEFAULT_HEIGHT	120.0f

class ofxHistoryPlot{

	public :

		ofxHistoryPlot(float * val, std::string varName, float maxHistory, bool autoUpdate_ = true);
		
		void update( float val = numeric_limits<float>::quiet_NaN() );	//adds in the plot current value of the specified var, 
											//usually you would call this once per frame if not autoUpdate_ == false for the graph to update
										
		void draw(float x, float y , float w = DEFAULT_WIDTH, float h = DEFAULT_HEIGHT);	//draws a box
		void draw(float x, float y );	//draws a box
		void draw(int x, int y );
		void setRange(float low, float high);	//range is manual
		void setLowerRange(float low);	//low is fixed, high is auto
		void setRangeAuto();

		void addHorizontalGuide(float yval, ofColor c);
		void clearHorizontalGuides();
		void setDrawGuideValues(bool doIt){drawGuideValues = doIt;}

		void setMaxHistory(int max);
		void setPrecision(int prec){ precision = ofClamp(prec, 0, 15); }	//number of decimals to show
		float getHeight(){ return DEFAULT_HEIGHT;}
		float getWidth(){ return DEFAULT_WIDTH;}

		void setColor(ofColor c){ lineColor = c;}
		ofColor getColor(){return lineColor;}

		void setBackgroundColor(ofColor c){ bgColor = c;}
		void setGridColor(ofColor c){ gridColor = c;}
		void setShowNumericalInfo(bool show){ showNumericalInfo = show;}	
		void setRespectBorders(bool respect){respectBorders = respect;}
		void setDrawSkipVal(int skip){ drawSkip = skip; if (drawSkip <1) drawSkip = 1;} //draw evey n samples, might speed up drawing 
		void setLineWidth(float w){ lineWidth = w;}
		void setDrawBackground(bool d) { drawBackground = d;}
		void setDrawTitle(bool doit){drawTitle = doit;}
		void setDrawGrid(bool d) { drawGrid = d;}
		void setGridUnit(float g){gridUnit = g;} //pixels
		void setAutoRangeShrinksBack(bool shrink){shrinkBackInAutoRange = shrink;};
		void setDrawFromRight(bool val); //begin drawing graph from right instead of left
		void reset();
		float getLowerRange();
		float getHigerRange();
		float getLowestValue();
		float getHigestValue();

		void setShowSmoothedCurve(bool show){showSmoothedPlot = show;}
		void setSmoothFilter(float filter){smoothFactor = filter;};
		void setCropToRect(bool s){scissor = s;}

		std::deque<float>& getValues(){ return values; }
    
        std::string getVariableName();

	private:

		enum RangeMode{
			RANGE_MANUAL,
			RANGE_LOWER_FIXED,
			RANGE_AUTOMATIC
		};

		void refillGridMesh(float x, float y , float w, float h);
		void refillPlotMesh(ofVboMesh& mesh, deque<float> & vals, float x, float y , float w, float h);

		std::string			varName;
		float *			valf;
	
		std::deque<float>	values;
		std::deque<float>	smoothValues;

		std::vector<float>	horizontalGuides;
		bool			drawGuideValues;
		std::vector<ofColor>	horizontalGuideColors;

		float			lowest, highest;
		float			manualLowest, manualHighest;

		RangeMode		rangeMode;

		bool			drawBackground;

		bool			autoUpdate;
		bool			showNumericalInfo;
		bool			respectBorders;
		bool			drawGrid;
		bool			shrinkBackInAutoRange;
		bool			drawFromRight; //begin drawing graph from right instead of left
		bool			drawTitle;
		bool			scissor;

		int				MAX_HISTORY;
		int				index;
		int				addedCounter;
		
		int				precision;
	
		unsigned int	count;
	
		ofColor			lineColor;
		ofColor			bgColor;
		ofColor			gridColor;
			
		int				drawSkip;
		float			lineWidth;
		float			gridUnit;

		bool			showSmoothedPlot;
		float			smoothValue; //average of the last plotted vals
		float			smoothFactor; //(0 1.0] >> 1.0 means no smoothing

		bool plotNeedsRefresh;

		ofVboMesh gridMesh;
		ofVboMesh plotMesh;
		ofVboMesh smoothPlotMesh;

		ofRectangle prevRect;
};

#endif

#line 0 "../addons-all/ofxBillboard/src/ofxBillboard.h"
//
//  ofxBillboard.h
//  ofxBillboard
//
//  Created by Elie Zananiri on 2013-08-26.
//  Adapted from the Lighthouse 3D Billboarding Tutorial by Antnio Ramires Fernandes.
//  http://www.lighthouse3d.com/opengl/billboarding/
//

#pragma once

/* #include "ofMain.h" */

void ofxBillboardBeginCylindrical(const ofVec3f& camPos, const ofVec3f& objPos);
void ofxBillboardBeginSpherical(const ofVec3f& camPos, const ofVec3f& objPos);
void ofxBillboardBeginCylindricalCheat(const ofVec3f& objPos);
void ofxBillboardBeginSphericalCheat(const ofVec3f& objPos);
void ofxBillboardBeginSphericalObvious(const ofVec3f& camPos, const ofVec3f& objPos);
void ofxBillboardEnd();

#line 0 "../addons-all/ofx2dFluid/src/ofx2dFluidConstants.h"
/*
 *  ofx2dFluidConstants.h
 *  openFrameworks
 *
 *  Created by Alain Ramos a.k.a. ding
 *  Copyright 2008 Alain Ramos.
 *
 *
 For Free you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 */



#ifndef OF_X_2D_FLUID_CONSTANTS_H
#define OF_X_2D_FLUID_CONSTANTS_H

//color data structure
//	----------------------------------------------------------------------------------------------------
typedef struct rgbFloat {
	float r, g, b;
};

//The Fluid Object Class
//	----------------------------------------------------------------------------------------------------
class ofxFluidObject {
	
public:	
	int ID; // object id
	ofPoint position, delta;//position and delta variables/**should not mess with these use set_position**/
	rgbFloat cf; //color info
	bool color_set;// true if color data is set in cf
	bool update_color; //color was updated
	bool updated; //object updated
	
	//constructor
	ofxFluidObject() {
		ID				= -1;
		color_set		= false;
		update_color	= false;
		updated			= false;
		position.set(-100, -100);
		randomize_color();
	}
	
	//operator overloading
	void operator=(ofxFluidObject & _object) {
		ID = _object.ID;
		position.set(_object.position.x, _object.position.y);
		delta.set(_object.delta.x, _object.delta.y);
		cf.r = _object.cf.r;
		cf.g = _object.cf.g;
		cf.b = _object.cf.b;
		color_set = _object.color_set;
		update_color = _object.update_color;
		updated = _object.updated;
	}
	
	//sets random color data
	void randomize_color(bool _update = false) {
		float div = 1.0 / (RAND_MAX);
		cf.r = (float) rand() * div;
		cf.g = (float) rand() * div;
		cf.b = (float) rand() * div;
		color_set = true;
		update_color = _update;
	}
	
	//from 0 - 255
	void set_color(int _r, int _g, int _b, bool _update = false) {
		cf.r = (float)_r / 255.0f; cf.r = MAX(0,MIN(cf.r,1.0f));
		cf.g = (float)_g / 255.0f; cf.g = MAX(0,MIN(cf.g,1.0f));
		cf.b = (float)_b / 255.0f; cf.b = MAX(0,MIN(cf.b,1.0f));
		color_set = true;
		update_color = _update;
	}
	
	//get color data
	rgbFloat get_color() {
		return cf;
	}
	
	//sets the object id
	void set_id( int _id) {
		ID = _id;
	}
	
	//sets position & delta using x,y coordinates
	void set_position(float _x, float _y, bool _updateDelta = false) {
		if (_updateDelta) {
			delta.set(position.x, position.y);
		}
		position.set(_x, _y);		
	}
	
	//sets position & delta using ofPoint
	void set_position(ofPoint _pos, bool _updateDelta = false) {
		if (_updateDelta) {
			delta.set(position.x, position.y);
		}
		position.set(_pos.x, _pos.y);
	}
	
	//get current position
	ofPoint get_position() {
		return position;
	}
	
	//update position and color data
	void update( ofxFluidObject& object ) {
		set_position(object.get_position(), true);
		if (!object.update_color) update_color = false;
		else {
			cf.r					= object.cf.r;
			cf.g					= object.cf.g;
			cf.b					= object.cf.b;
			update_color			= true;
			object.update_color		= false;
		}
		updated = true;
	}
	
};


//The Force Object Class
//	----------------------------------------------------------------------------------------------------
class ofxForceObject {
	
public:	
	int ID; // object id
	ofPoint position, delta;//position and delta variables
	float force;//force influence
	bool updated, forceSet; //object updated
	
	//constructor
	ofxForceObject() {
		ID				= -1;
		updated			= false;
		force			= 0.5f;
		position.set(-1, -1);
	}
		
	//sets position & delta using x,y coordinates
	void set_position(float _x, float _y, bool _updateDelta = false) {
		if (_updateDelta) {
			delta.set(position.x, position.y);
		}
		position.set(_x, _y);		
	}
	
	//sets position & delta using ofPoint
	void set_position(ofPoint _pos, bool _updateDelta = false) {
		if (_updateDelta) {
			delta.set(position.x, position.y);
		}
		position.set(_pos.x, _pos.y);
	}
	
	//get current position
	ofPoint get_position() {
		return position;
	}
	
	void set_force(bool _set, float _force) {
		forceSet	= _set;
		force		= _force;
	}
	
	//sets the object id
	void set_id( int _id) {
		ID = _id;
	}
	
	//update position and color data
	void update( ofxForceObject& object ) {
		set_position(object.get_position(), true);
		updated = true;
	}
};

#endif
#line 0 "../addons-all/ofx2dFluid/src/ofx2dSolver.h"
/*
 *  ofx2dSolver.h
 *  openFrameworks
 *
 *  Created by Alain Ramos a.k.a. ding
 *  Copyright 2008 Alain Ramos.
 *
 *
 For Free you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 */
//	----------------------------------------------------------------------------------------------------

#ifndef OF_2D_SOLVER_H
#define OF_2D_SOLVER_H


#include <math.h>

#define IX(i,j) ((i)+(N+2)*(j))
#define SWAP(x0,x) {float * tmp=x0;x0=x;x=tmp;}
#define SWAP_RGB(i0,i,j0,j,k0,k) {float * tmp; tmp=i0;i0=i;i=tmp; tmp=j0;j0=j;j=tmp; tmp=k0;k0=k;k=tmp;}
#define FOR_EACH_CELL for ( i=1 ; i<=N ; i++ ) { for ( j=1 ; j<=N ; j++ ) {
#define END_FOR }}


class ofx2dSolver {
		
	public:
	
		//////////
		// Constructors
		ofx2dSolver() {
						
			epsilon = 5; //curl
			smallf = 0.0000001f;
			
			N = 100; //grid
			dt = 0.2f; //timestep
			diff = 0.0005f; //diffuse
			visc = 0.0001f; //viscocity

			
			size = (N+2)*(N+2);
			
			r			= new float [size];
			g			= new float [size];
			b			= new float [size];
			r0			= new float [size];
			g0			= new float [size];
			b0			= new float [size];	
			u			= new float [size];
			v			= new float [size];
			u_prev		= new float [size];
			v_prev		= new float [size];
			dens		= new float [size];	
			dens_prev	= new float [size];
			blocked		= new bool	[size];
			
			for ( int i = 0 ; i < size ; i++ ) {
				u[i] = v[i] = u_prev[i] = v_prev[i] = dens[i] = dens_prev[i] = 0.0f;
				r[i] = r0[i] = g[i] = g0[i] = b[i] = b0[i] = 0.0f;
				blocked[i] = false;
			}
			
		}
	
		//constructor that sets the grid size
		ofx2dSolver(int _n) {
		
			epsilon = 5; //curl
			smallf = 0.0000001f;
		
			N = _n; //grid
			dt = 0.2f; //timestep
			diff = 0.0005f; //diffuse
			visc = 0.0001f; //viscocity
		
		
			size = (N+2)*(N+2);
		
			r			= new float [size];
			g			= new float [size];
			b			= new float [size];
			r0			= new float [size];
			g0			= new float [size];
			b0			= new float [size];	
			u			= new float [size];
			v			= new float [size];
			u_prev		= new float [size];
			v_prev		= new float [size];
			dens		= new float [size];	
			dens_prev	= new float [size];
			blocked		= new bool	[size];
		
			for ( int i = 0 ; i < size ; i++ ) {
				u[i] = v[i] = u_prev[i] = v_prev[i] = dens[i] = dens_prev[i] = 0.0f;
				r[i] = r0[i] = g[i] = g0[i] = b[i] = b0[i] = 0.0f;
				blocked[i] = false;
			}
		
		}
	
		//////////
		// Destructor
		 ~ofx2dSolver() {
		 	delete[] r;
			delete[] g;
			delete[] b;
			delete[] r0;
			delete[] g0;
			delete[] b0;
			delete[] u;
			delete[] v;
			delete[] u_prev;
			delete[] v_prev;
			delete[] dens;
			delete[] dens_prev;
			delete[] blocked;
		}
		
		
		//////////
		// The Variables
		bool * blocked;
	
		//color density variables
		float * r, * g, * b;
		float * r0, * g0, * b0;
		//gray scale density variables
		float * dens, * dens_prev;
		//velocities
		float * u, * v, * u_prev, * v_prev;
	
		int size;
		int N;
		float dt, diff, visc;
		float epsilon;
		float smallf;
	
		
	//////////
	// the solver
	
	//add source single color
	void add_source (float * x, float * s) {
		for ( int i=0 ; i<size ; i++ ) x[i] += dt*s[i];
	}
	
	void add_source_rgb (float * _r, float * _r0, float * _g, float * _g0, float * _b, float * _b0) {
		for ( int i=0 ; i<size ; i++ ) {
			_r[i] += dt*_r0[i];
			_g[i] += dt*_g0[i];
			_b[i] += dt*_b0[i];
		}
	}
	
	//set boundries for single color
	void set_bnd ( int b, float * x ) {
		int i,j;
		for ( i=1 ; i<=N ; i++ ) {
			x[IX(0  ,i)] = b==1 ? 0 : x[IX(1,i)];
			x[IX(N+1,i)] = b==1 ? 0 : x[IX(N,i)];
			x[IX(i,0  )] = b==2 ? 0 : x[IX(i,1)];
			x[IX(i,N+1)] = b==2 ? 0 : x[IX(i,N)];
		}
		
		FOR_EACH_CELL
		if(!blocked[IX(i,j)]) continue;
		if( (b==1) || (b==2) ) {
			x[IX(i,j)]=0;
		}
		else {
			int count  =0;
			float total=0;
			if(!blocked[IX(i+1,j)]) { count++; total+=x[IX(i+1,j)]; }
			if(!blocked[IX(i-1,j)]) { count++; total+=x[IX(i-1,j)]; }		
			if(!blocked[IX(i,j+1)]) { count++; total+=x[IX(i,j+1)]; }
			if(!blocked[IX(i,j-1)]) { count++; total+=x[IX(i,j-1)]; }
			if(count) total/=count;
			x[IX(i,j)]=total;
		}
		END_FOR
	}
	
	//set boundries for r g b
	void set_bnd_rgb ( int b, float * _r, float * _g, float * _b ) {
		int i,j;
		for ( i=1 ; i<=N ; i++ ) {
			_r[IX(0  ,i)] = b==1 ? 0 : _r[IX(1,i)];
			_r[IX(N+1,i)] = b==1 ? 0 : _r[IX(N,i)];
			_r[IX(i,0  )] = b==2 ? 0 : _r[IX(i,1)];
			_r[IX(i,N+1)] = b==2 ? 0 : _r[IX(i,N)];
			
			_g[IX(0  ,i)] = b==1 ? 0 : _g[IX(1,i)];
			_g[IX(N+1,i)] = b==1 ? 0 : _g[IX(N,i)];
			_g[IX(i,0  )] = b==2 ? 0 : _g[IX(i,1)];
			_g[IX(i,N+1)] = b==2 ? 0 : _g[IX(i,N)];
			
			_b[IX(0  ,i)] = b==1 ? 0 : _b[IX(1,i)];
			_b[IX(N+1,i)] = b==1 ? 0 : _b[IX(N,i)];
			_b[IX(i,0  )] = b==2 ? 0 : _b[IX(i,1)];
			_b[IX(i,N+1)] = b==2 ? 0 : _b[IX(i,N)];
		}
		
		FOR_EACH_CELL
		if(!blocked[IX(i,j)]) continue;
		if( (b==1) || (b==2) ) {
			_r[IX(i,j)]=0;
			_g[IX(i,j)]=0;
			_b[IX(i,j)]=0;
		}
		else {
			int count  =0;
			float total_r=0;
			float total_g=0;
			float total_b=0;
			if(!blocked[IX(i+1,j)]) { count++; total_r+=_r[IX(i+1,j)]; total_g+=_g[IX(i+1,j)]; total_b+=_b[IX(i+1,j)];}
			if(!blocked[IX(i-1,j)]) { count++; total_r+=_r[IX(i-1,j)]; total_g+=_g[IX(i-1,j)]; total_b+=_b[IX(i-1,j)];}		
			if(!blocked[IX(i,j+1)]) { count++; total_r+=_r[IX(i,j+1)]; total_g+=_g[IX(i,j+1)]; total_b+=_b[IX(i,j+1)];}
			if(!blocked[IX(i,j-1)]) { count++; total_r+=_r[IX(i,j-1)]; total_g+=_g[IX(i,j-1)]; total_b+=_b[IX(i,j-1)];}
			if(count){
				total_r/=count;
				total_g/=count;
				total_b/=count;
			}
			_r[IX(i,j)]=total_r;
			_g[IX(i,j)]=total_g;
			_b[IX(i,j)]=total_b;
		}
		END_FOR
	}
	
	//linear solver for single color//
	void lin_solve ( int b, float * x, float * x0, float a, float c ) {
		int i, j;
		
		for ( int k=0 ; k<20 ; k++ ) {
			FOR_EACH_CELL
			x[IX(i,j)] = (x0[IX(i,j)] + a*(x[IX(i-1,j)]+x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)]))/c;
			END_FOR
			
			set_bnd ( b, x );
		}
		
	}
	
	//linear solver for r g b
	void lin_solve_rgb ( int b, float * _r, float * _r0,
								float * _g, float * _g0,
								float * _b, float * _b0,
								float a, float c ) {
		int i, j;
		
		for ( int k=0 ; k<20 ; k++ ) {
			FOR_EACH_CELL
			_r[IX(i,j)] = (_r0[IX(i,j)] + a*(_r[IX(i-1,j)]+_r[IX(i+1,j)]+_r[IX(i,j-1)]+_r[IX(i,j+1)]))/c;
			_g[IX(i,j)] = (_g0[IX(i,j)] + a*(_g[IX(i-1,j)]+_g[IX(i+1,j)]+_g[IX(i,j-1)]+_g[IX(i,j+1)]))/c;
			_b[IX(i,j)] = (_b0[IX(i,j)] + a*(_b[IX(i-1,j)]+_b[IX(i+1,j)]+_b[IX(i,j-1)]+_b[IX(i,j+1)]))/c;
			END_FOR
			
			set_bnd_rgb ( b, _r, _g, _b );
		}
		
	}
	
	//diffuse single color
	void diffuse ( int N, int b, float * x, float * x0, float diff, float dt ) {
		float a=dt*diff*N*N;
		lin_solve ( b, x, x0, a, 1+4*a );
	}
	
	//diffuse r g b
	void diffuse_rgb ( int b, float * _r, float * _r0,
							  float * _g, float * _g0,
							  float * _b, float * _b0,
							  float diff, float dt ) {
		float a=dt*diff*N*N;
		lin_solve_rgb ( b, _r, _r0, _g, _g0, _b, _b0, a, 1+4*a );
	}
		
	//advect single color	
	void advect ( int N, int b, float * d, float * d0, float * u, float * v, float dt ) {
		int i, j, i0, j0, i1, j1;
		float x, y, s0, t0, s1, t1, dt0, vx, vy, tleft,t,tnext,distx,disty;
		
		dt0 = dt*N;
		
		
		FOR_EACH_CELL
		
		if(blocked[IX(i,j)]) continue;
		
		tleft=dt0;
		x=i;y=j;		
		
		while(tleft>smallf) {
			
			//enforce boundry contraints
			if (x<0.5f) x=0.5f; if (x>N+0.5f) x=N+0.5f; 
			if (y<0.5f) y=0.5f; if (y>N+0.5f) y=N+0.5f; 
			
			
			i0=(int)x; i1=i0+1;
			j0=(int)y; j1=j0+1;
			s1 = x-i0; s0 = 1-s1; t1 = y-j0; t0 = 1-t1;
			
			vx = -(s0*(t0*u[IX(i0,j0)]+t1*u[IX(i0,j1)])+
				   s1*(t0*u[IX(i1,j0)]+t1*u[IX(i1,j1)]));
			
			vy = -(s0*(t0*v[IX(i0,j0)]+t1*v[IX(i0,j1)])+
				   s1*(t0*v[IX(i1,j0)]+t1*v[IX(i1,j1)]));
			
			
			float speed2=vx*vx+vy*vy; 
			if(speed2>smallf) tnext=.5/sqrt(speed2);
			else tnext=tleft;
			
			t=tnext > tleft ? tleft : tnext;
			tleft-=t;
			
			
			x+=t*vx;
			y+=t*vy;
		}
		
		
		if (x<0.5f) x=0.5f; if (x>N+0.5f) x=N+0.5f; 
		if (y<0.5f) y=0.5f; if (y>N+0.5f) y=N+0.5f; 
		
		
		i0=(int)x; i1=i0+1;
		j0=(int)y; j1=j0+1;
		s1 = x-i0; s0 = 1-s1; t1 = y-j0; t0 = 1-t1;
		
		d[IX(i,j)] = s0*(t0*d0[IX(i0,j0)]+t1*d0[IX(i0,j1)])+
		s1*(t0*d0[IX(i1,j0)]+t1*d0[IX(i1,j1)]);
		END_FOR
		set_bnd ( b, d );
	}
	
	
	void advect_rgb (int b, float * _r, float * _r0,
							float * _g, float * _g0,
							float * _b, float * _b0,
							float * _u, float * _v, float dt ) {
		int i, j, i0, j0, i1, j1;
		float x, y, s0, t0, s1, t1, dt0, vx, vy, tleft,t,tnext,distx,disty;
		
		dt0 = dt*N;
		
		
		FOR_EACH_CELL
		
		if(blocked[IX(i,j)]) continue;
		
		tleft=dt0;
		x=i;y=j;		
		
		while(tleft>smallf) {
			
			//enforce boundry contraints
			if (x<0.5f) x=0.5f; if (x>N+0.5f) x=N+0.5f; 
			if (y<0.5f) y=0.5f; if (y>N+0.5f) y=N+0.5f; 
			
			
			i0=(int)x; i1=i0+1;
			j0=(int)y; j1=j0+1;
			s1 = x-i0; s0 = 1-s1; t1 = y-j0; t0 = 1-t1;
			
			vx = -(s0*(t0*u[IX(i0,j0)]+t1*u[IX(i0,j1)])+
				   s1*(t0*u[IX(i1,j0)]+t1*u[IX(i1,j1)]));
			
			vy = -(s0*(t0*v[IX(i0,j0)]+t1*v[IX(i0,j1)])+
				   s1*(t0*v[IX(i1,j0)]+t1*v[IX(i1,j1)]));
			
			
			float speed2=vx*vx+vy*vy; 
			if(speed2>smallf) tnext=.5/sqrt(speed2);
			else tnext=tleft;
			
			t=tnext > tleft ? tleft : tnext;
			tleft-=t;
			
			
			x+=t*vx;
			y+=t*vy;
		}
		
		
		if (x<0.5f) x=0.5f; if (x>N+0.5f) x=N+0.5f; 
		if (y<0.5f) y=0.5f; if (y>N+0.5f) y=N+0.5f; 
		
		
		i0=(int)x; i1=i0+1;
		j0=(int)y; j1=j0+1;
		s1 = x-i0; s0 = 1-s1; t1 = y-j0; t0 = 1-t1;
		
		_r[IX(i,j)] = s0*(t0*_r0[IX(i0,j0)]+t1*_r0[IX(i0,j1)])+s1*(t0*_r0[IX(i1,j0)]+t1*_r0[IX(i1,j1)]);
		_g[IX(i,j)] = s0*(t0*_g0[IX(i0,j0)]+t1*_g0[IX(i0,j1)])+s1*(t0*_g0[IX(i1,j0)]+t1*_g0[IX(i1,j1)]);
		_b[IX(i,j)] = s0*(t0*_b0[IX(i0,j0)]+t1*_b0[IX(i0,j1)])+s1*(t0*_b0[IX(i1,j0)]+t1*_b0[IX(i1,j1)]);
		END_FOR
		set_bnd_rgb ( b, _r, _g, _b );
	}
							  
	
	//prject velocities
	void project ( int N, float * u, float * v, float * p, float * div ) {
		int i, j;
		
		FOR_EACH_CELL
		div[IX(i,j)] = -0.5f*(u[IX(i+1,j)]-u[IX(i-1,j)]+v[IX(i,j+1)]-v[IX(i,j-1)])/N;
		p[IX(i,j)] = 0;
		END_FOR	
		set_bnd ( 0, div ); set_bnd ( 0, p );
		
		lin_solve ( 0, p, div, 1, 4 );
		
		FOR_EACH_CELL
		u[IX(i,j)] -= 0.5f*N*(p[IX(i+1,j)]-p[IX(i-1,j)]);
		v[IX(i,j)] -= 0.5f*N*(p[IX(i,j+1)]-p[IX(i,j-1)]);
		END_FOR
		set_bnd ( 1, u ); set_bnd ( 2, v );
	}
	
	
	//adds curl
	void add_vorocity(int N, float * u, float * v, float dt) {
		
		//vort is just the curl of the velocity field
#define vort(i,j) (( -0.5*( v[IX(i+1,j)]-v[IX(i-1,j)] + u[IX(i,j-1)]-u[IX(i,j+1)] )*N ))
		
		int i, j;
		
		int size = (N+2)*(N+2);
		
		float *fx	=	new float [size];
		float *fy	=	new float [size];
		
		FOR_EACH_CELL
		if(i==1 || j==1 || i==N || j==N) continue;
		
		float dvx = 0.5*(vort(i+1,j)-vort(i-1,j));
		float dvy = 0.5*(vort(i,j+1)-vort(i,j-1));
		
		float mag=sqrt(dvx*dvx+dvy*dvy);
		
		//apply a force equal to epsilon * cross(N,vor)
		fx[IX(i,j)]=mag > smallf ? epsilon*dt*dvy*vort(i,j)/(mag*N) : 0;
		fy[IX(i,j)]=mag > smallf ? epsilon*dt*dvx*vort(i,j)/(mag*N) : 0;
		END_FOR
		
		set_bnd ( 0, fx ); set_bnd ( 0, fy );
		
		
		FOR_EACH_CELL
		if(i==1 || j==1 || i==N || j==N) continue;
		
		if(u[IX(i,j)]) u[IX(i,j)]+=fx[IX(i,j)];
		if(v[IX(i,j)]) v[IX(i,j)]-=fy[IX(i,j)];
		END_FOR
		
		set_bnd ( 1, u ); set_bnd ( 2, v );
		
		delete[] fx;
		delete[] fy;
		
#undef vort
		
	}
	
	void dens_step ( int N, float * x, float * x0, float * u, float * v, float diff, float dt ) {
		add_source ( x, x0 );
		SWAP ( x0, x ); diffuse ( N, 0, x, x0, diff, dt );
		SWAP ( x0, x ); advect ( N, 0, x, x0, u, v, dt );
	}
	
	void dens_step_rgb (float * _r, float * _r0,
						float * _g, float * _g0,
						float * _b, float * _b0,
						float * _u, float * _v,
						float diff, float dt ) {
		add_source_rgb ( _r, _r0, _g, _g0, _b, _b0 );
		SWAP_RGB ( _r0, _r, _g0, _g, _b0, _b );
		diffuse_rgb ( 0, _r, _r0, _g, _g0, _b, _b0, diff, dt );
		SWAP_RGB ( _r0, _r, _g0, _g, _b0, _b );
		advect_rgb ( 0, _r, _r0, _g, _g0, _b, _b0, u, v, dt );
	}
	
	void vel_step ( int N, float * u, float * v, float * u0, float * v0, float visc, float dt ) {
		add_source ( u, u0 ); add_source ( v, v0 );
		SWAP ( u0, u ); diffuse ( N, 1, u, u0, visc, dt );
		SWAP ( v0, v ); diffuse ( N, 2, v, v0, visc, dt );
		project ( N, u, v, u0, v0 );
		SWAP ( u0, u ); SWAP ( v0, v );
		advect ( N, 1, u, u0, u0, v0, dt ); advect ( N, 2, v, v0, u0, v0, dt );
		project ( N, u, v, u0, v0 );
	}
	
};

#endif
#line 0 "../addons-all/ofx2dFluid/src/ofx2dFluid.h"
/*
 *  ofx2dFluid.h
 *  openFrameworks
 *
 *  Created by Alain Ramos a.k.a. ding
 *  Copyright 2008 Alain Ramos.
 *
 *
 For Free you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 */
//	----------------------------------------------------------------------------------------------------


#ifndef OF_X_2D_FLUID_H
#define OF_X_2D_FLUID_H

#include <list>
/* #include "ofMain.h" */
/* #include "ofx2dSolver.h" */
/* #include "ofx2dFluidConstants.h" */


//The Fluid Class
//	----------------------------------------------------------------------------------------------------
class ofx2dFluid : public ofx2dSolver {
	
	public:
	
		//constructors
		//this constructor has a default grid size of 100
		ofx2dFluid ();
		//this constructor can set the grid size 
		ofx2dFluid (int _gridSize);
	
		//destructor
		~ofx2dFluid ();
	
		//draw variables
		bool	wireframe, //draw wireframe
				drawvelocities, //draw velocities
				drawcircle, //draw circles 
				drawbounds, //draw bounds
				drawAlpha;
	
		//general variables
		float height, width;//with and height of fluid
	
		//force and source values
		float	force, source; //amount of influence of force and source points
	
		//influence values
		float gravity, wind, fade; //self explanatory
	
		//influences
		bool	fadeOut,
				addWind,
				addGravity;
	
		//**still working on this-----------------//
		rgbFloat bound_color;//bound color//	 //
		//--------------------------------------//
	
		//fluid objects
		list <ofxFluidObject> fluid_objects;
	
		//force position data
		list <ofxForceObject> force_objects;
	
		// main fluid functions//
		void update(); //updates the fluid
		void draw(); //draws the fluid
		void add_object ( ofxFluidObject & _object ); //adds object to the fluid
		void add_force ( ofxForceObject & _object ); // adds forces only to the fluid
		//THE GETTERS
		ofPoint get_velocity ( float _x, float _y, int _influence = 100);// gets velocity of fluid at x,y position
		float get_dencity (float _x, float _y); //gets dencity of fluid at x,y position
		ofxFluidObject * get_fluid(int _id);//returns fluid object with specified id
		ofxForceObject * get_force(int _id);//returns force object with specified id
		//THE SETTERS
		void set_size (float _w, float _h); // sets sizes of fluid
		void set_curl ( float _curl); //sets curl of fluid
		void set_viscocity ( float _visc); //set viscocity of fluid
		void set_Influences ( float _source, float _force = 0.5f);//sets the amount of influence of force and source points
		void set_fade ( bool _set, float _fade = 1.0f);//sets the fade value
		void set_wind ( bool _set, float _wind = 1.5f);//sets the wind value
		void set_gravity ( bool _set, float _gravity = 5.0);//sets the gravity value
		void set_alpha ( bool _set); //true to turn on alpha **off by default for speeds sake
	
		//**still working on this part----------------------------------------------------------//
		void add_bound (float _x, float _y);//adds blocked pixels where there is no fluid		//
		void remove_bound ( float _x, float _y);// removes blocked pixels						//
		void set_bnd_color ( float _r, float _g, float _b);//sets boundry color					//
		//**------------------------------------------------------------------------------------//
	
	private:
		//position variables
		int omx, omy, mx, my;
		int fx, fy, ofx, ofy;
		//update
		void object_update( float * d, float * r, float * g, float * b, float * u, float * v ); //updates object densities
		void update_force(); //updates forces only
};

#endif

#line 0 "../addons-all/ofx2dFluid/src/ofx2dFluidMain.h"
/*
 *  ofxFidMain.h
 *  openFrameworks
 *
 *  Created by Alain Ramos a.k.a. ding
 *  Copyright 2008 Alain Ramos.
 *
 *
 For Free you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 */
//	----------------------------------------------------------------------------------------------------

#ifndef OF_X_2DFLUIDMAIN_H
#define OF_X_2DFLUIDMAIN_H


/* #include "ofx2dFluidConstants.h" */

/* #include "ofx2dFluid.h" */

/* #include "ofx2dSolver.h" */

#endif
#line 0 "../addons-all/ofxMPMFluid/src/ofxMPMObstacle.h"
/**
 * ofxMPMFluid.cpp
 * The MIT License (MIT)
 * Copyright (c) 2010 respective contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *  
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 *****************************************
 * MPM FLuid Simulation Demo
 * OpenFrameworks version by Golan Levin
 * http://www.flong.com
 *
 * ofxAddon created by James George (@obviousjm)
 * http://www.jamesgeorge.org
 *
 * Original Java version:
 * http://grantkot.com/MPM/Liquid.html
 *
 * Flash version:
 * Copyright iunpin ( http://wonderfl.net/user/iunpin )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://wonderfl.net/c/6eu4
 *
 * Javascript version:
 * Copyright Stephen Sinclair (radarsat1) ( http://www.music.mcgill.ca/~sinclair )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://www.music.mcgill.ca/~sinclair/blog 
 */

//============================================================================
class ofxMPMObstacle {

	public:
	
	float cx;
	float cy;
	float radius;
	float radius2;
	
	ofxMPMObstacle ( float inx, float iny, float inr);
};
	
#line 0 "../addons-all/ofxMPMFluid/src/ofxMPMParticle.h"
/**
 * ofxMPMFluid.cpp
 * The MIT License (MIT)
 * Copyright (c) 2010 respective contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *  
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 *****************************************
 * MPM FLuid Simulation Demo
 * OpenFrameworks version by Golan Levin
 * http://www.flong.com
 *
 * ofxAddon created by James George (@obviousjm)
 * http://www.jamesgeorge.org
 *
 * Original Java version:
 * http://grantkot.com/MPM/Liquid.html
 *
 * Flash version:
 * Copyright iunpin ( http://wonderfl.net/user/iunpin )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://wonderfl.net/c/6eu4
 *
 * Javascript version:
 * Copyright Stephen Sinclair (radarsat1) ( http://www.music.mcgill.ca/~sinclair )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://www.music.mcgill.ca/~sinclair/blog 
 */

#pragma once

//============================================================================
class ofxMPMParticle {

	public:
	
	float x;
	float y;
	float u;
	float v;
	float pu; 
	float pv;
	float d;

	int   cx;
	int   cy;

	float gu;
	float gv;
	float T00;
	float T01;
	float T11;

	float px[3];
	float py[3];
	float gx[3];
	float gy[3];
	
	ofxMPMParticle ( float inx, float iny, float inu, float inv);

};
	
#line 0 "../addons-all/ofxMPMFluid/src/ofxMPMNode.h"
/**
 * ofxMPMFluid.cpp
 * The MIT License (MIT)
 * Copyright (c) 2010 respective contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *  
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 *****************************************
 * MPM FLuid Simulation Demo
 * OpenFrameworks version by Golan Levin
 * http://www.flong.com
 *
 * ofxAddon created by James George (@obviousjm)
 * http://www.jamesgeorge.org
 *
 * Original Java version:
 * http://grantkot.com/MPM/Liquid.html
 *
 * Flash version:
 * Copyright iunpin ( http://wonderfl.net/user/iunpin )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://wonderfl.net/c/6eu4
 *
 * Javascript version:
 * Copyright Stephen Sinclair (radarsat1) ( http://www.music.mcgill.ca/~sinclair )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://www.music.mcgill.ca/~sinclair/blog 
 */

#pragma once

//============================================================================
class ofxMPMNode {

public:
	float m;
	float d;
	float gx;
	float gy;
	float u;
	float v;
	float ax;
	float ay;
	bool active;
	
	void clear();
	ofxMPMNode();

};
#line 0 "../addons-all/ofxMPMFluid/src/ofxMPMFluid.h"
/**
 * ofxMPMFluid.cpp
 * The MIT License (MIT)
 * Copyright (c) 2010 respective contributors
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *  
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 *****************************************
 * MPM FLuid Simulation Demo
 * OpenFrameworks version by Golan Levin
 * http://www.flong.com
 *
 * ofxAddon created by James George (@obviousjm)
 * http://www.jamesgeorge.org
 *
 * Original Java version:
 * http://grantkot.com/MPM/Liquid.html
 *
 * Flash version:
 * Copyright iunpin ( http://wonderfl.net/user/iunpin )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://wonderfl.net/c/6eu4
 *
 * Javascript version:
 * Copyright Stephen Sinclair (radarsat1) ( http://www.music.mcgill.ca/~sinclair )
 * MIT License ( http://www.opensource.org/licenses/mit-license.php )
 * Downloaded from: http://www.music.mcgill.ca/~sinclair/blog 
 */

#pragma once
/* #include "ofMain.h" */
/* #include "ofxMPMParticle.h" */
/* #include "ofxMPMNode.h" */
/* #include "ofxMPMObstacle.h" */

class ofxMPMFluid {
  public:
	ofxMPMFluid();

	void setup(int maxParticles, int w=160, int h=120);
	void update(float mouseX = ofGetMouseX(), float mouseY = ofGetMouseY());
	void draw();
    void addTouch(int userID, ofVec2f pos);
    void addTouch(ofVec2f pos);
    void updateTouch(int userID, ofVec2f pos);
    void removeTouch(int userID);
    
    int gridSizeX, gridSizeY;
    ofVec2f translate;
    
    
    void addObstacle(ofxMPMObstacle *ob);
    void removeObstacle(ofxMPMObstacle *ob);
	
	int getGridSizeX();
	int getGridSizeY();
	
	float scaleFactor;	
	int numParticles;
	float densitySetting;
	float stiffness;     
	float bulkViscosity; 
	float elasticity;    
	float viscosity;     
	float yieldRate;     
	bool  bGradient;	
	float gravity;
	bool  bDoObstacles;
	float smoothing;
    
    bool bDoMouse;
    float mouseForce;
	
	vector<ofxMPMParticle*>& getParticles();
	
  protected:
	float elapsed;

    map<int , vector<ofVec2f> > userPos;
	vector<ofxMPMParticle*> particles;
	int maxNumParticles;
	vector< vector<ofxMPMNode*> > grid;
	vector< ofxMPMNode*> activeNodes;	
	int numActiveNodes;
	
	vector<ofxMPMObstacle*> obstacles;
	float previousMouseX;
	float previousMouseY;
};
